{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftvertechnik\u00e1k (2024-t\u0151l)","text":"<p>Gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAB00 Szoftvertechnik\u00e1k c. t\u00e1rgyhoz, 2024 \u00e9vt\u0151l kezd\u0151d\u0151en. A kor\u00e1bbi \u00e9vek anyag\u00e1nak megtekint\u00e9s\u00e9hez az oldal fejl\u00e9c\u00e9ben tal\u00e1lhat\u00f3 leny\u00edl\u00f3 mez\u0151ben a megfelel\u0151 \u00e9vet kell kiv\u00e1lasztani (pl. \"2023-ig\").</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAB00 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) enged\u00e9ly\u00e9vel \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/","title":"Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3d\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-osztaly","title":"Absztrakt oszt\u00e1ly","text":"<p>A fogalmak kor\u00e1bbi t\u00e1rgyak keret\u00e9ben m\u00e1r ismertet\u00e9sre ker\u00fcltek, \u00edgy most csak a legfontosabbakat foglaljuk \u00f6ssze, illetve a C# vonatkoz\u00e1s\u00e1ra t\u00e9r\u00fcnk ki. Absztrakt oszt\u00e1ly Olyan oszt\u00e1ly, mely nem p\u00e9ld\u00e1nyos\u00edthat\u00f3. C# nyelven az oszt\u00e1lydefin\u00edci\u00f3ban az abstract kulcssz\u00f3t kell ki\u00edrni, pl.:</p> <pre><code>abstract class Shape { \u2026 }\n</code></pre> <p>Absztrakt oszt\u00e1lyoknak lehetnek absztrakt met\u00f3dusaik, melyeknek nem adjuk meg a t\u00f6rzs\u00e9t, ezekn\u00e9l is az abstract kulcssz\u00f3t kell haszn\u00e1lni:</p> <pre><code>\u2026\nabstract void Draw();\n\u2026\n</code></pre> <p>Absztrakt oszt\u00e1lyok haszn\u00e1lat\u00e1nak k\u00e9t c\u00e9lja lehet:</p> <ul> <li>Egy oszt\u00e1lyhierarchi\u00e1ban a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot fel tudjuk vinni egy absztrakt k\u00f6z\u00f6s \u0151sbe, \u00edgy elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t.</li> <li>Egys\u00e9gesen tudjuk absztrakt \u0151sk\u00e9nt hivatkozva a lesz\u00e1rmazottakat kezelni (pl. heterog\u00e9n kollekci\u00f3k).</li> </ul> <p>.NET k\u00f6rnyezetben, csak\u00fagy, mint Java nyelven, egy oszt\u00e1lynak csak egy \u0151soszt\u00e1lya lehet.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/#interfesz","title":"Interf\u00e9sz","text":"<p>Az interf\u00e9sz nem m\u00e1s, mint egy m\u0171velethalmaz. Tulajdonk\u00e9ppen egy olyan absztrakt oszt\u00e1lynak felel meg, melynek minden m\u0171velete absztrakt.</p> <p>C# nyelven az <code>interface</code> kulcssz\u00f3val tudunk interf\u00e9szt defini\u00e1lni:</p> <pre><code>public interface ISerializable \n{\n   void WriteToStream(Stream s);\n   void LoadFromStream(Stream s);\n}\n\npublic interface IComparable \n{\n   int CompareTo(Object obj);\n}\n</code></pre> <p>M\u00edg egy oszt\u00e1lynak csak egy \u0151se lehet, ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n    \u2026\n}\n</code></pre> <p>Ebben a p\u00e9ld\u00e1ban Rect oszt\u00e1ly a Shape oszt\u00e1lyb\u00f3l sz\u00e1rmazik, valamint az <code>ISerializable</code> \u00e9s <code>IComparable</code> interf\u00e9szeket implement\u00e1lja (k\u00f6telez\u0151en az \u0151soszt\u00e1lyt kell el\u0151sz\u00f6r megadni). Az interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban annak valamennyi m\u0171velet\u00e9t meg kell val\u00f3s\u00edtani, vagyis meg kell \u00edrni a t\u00f6rzs\u00e9t (kiv\u00e9ve azt a ritka esetet, amikor absztrakt m\u0171velettel val\u00f3s\u00edtjuk meg). Interf\u00e9szek haszn\u00e1lat\u00e1nak egy f\u0151 c\u00e9lja van. Interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk az interf\u00e9szt implement\u00e1l\u00f3 valamennyi oszt\u00e1lyt kezelni (pl. heterog\u00e9n kollekci\u00f3). Ennek egy k\u00f6vetkezm\u00e9nye: az interf\u00e9szek lehet\u0151v\u00e9 teszik sz\u00e9les k\u00f6rben haszn\u00e1lhat\u00f3 oszt\u00e1lyok \u00e9s f\u00fcggv\u00e9nyek meg\u00edr\u00e1s\u00e1t. Pl. tudunk \u00edrni egy univerz\u00e1lis Sort sorrendez\u0151 f\u00fcggv\u00e9nyt, mely b\u00e1rmilyen oszt\u00e1llyal haszn\u00e1lhat\u00f3, mely implement\u00e1lja az IComparable interf\u00e9szt.</p> <p>Az interf\u00e9sz alkalmaz\u00e1s\u00e1nak el\u0151nyei m\u00e9g:</p> <ul> <li>A kliensnek el\u00e9g a kiszolg\u00e1l\u00f3 objektum interf\u00e9sz\u00e9t ismernie, \u00edgy egyszer\u0171en tudja a kiszolg\u00e1l\u00f3t haszn\u00e1lni.</li> <li>Ha a kliens csak az interf\u00e9szen kereszt\u00fcl haszn\u00e1lja a kiszolg\u00e1l\u00f3t, \u00edgy a kiszolg\u00e1l\u00f3 bels\u0151 implement\u00e1ci\u00f3ja megv\u00e1ltozhat, a klienst nem kell m\u00f3dos\u00edtani (\u00fajra sem kell ford\u00edtani). Ennek megfelel\u0151en az interf\u00e9sz egy szerz\u0151d\u00e9s is a kiszolg\u00e1l\u00f3 \u00e9s a kliens k\u00f6z\u00f6tt: am\u00edg a kiszolg\u00e1l\u00f3 garant\u00e1lja az interf\u00e9sz t\u00e1mogat\u00e1s\u00e1t, a klienst nem kell v\u00e1ltoztatni.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/#absztrakt-os-es-interfesz-osszehasonlitasa","title":"Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa","text":"<p>Az absztrakt \u0151s el\u0151nye az interf\u00e9sszel szemben, hogy adhatunk meg a m\u0171veletekre vonatkoz\u00f3an alap\u00e9rtelmezett implement\u00e1ci\u00f3t, illetve vehet\u00fcnk fel tagv\u00e1ltoz\u00f3kat.</p> <p>Az interf\u00e9szek el\u0151nye az absztrakt \u0151ssel szemben, hogy egy oszt\u00e1ly ak\u00e1rh\u00e1ny interf\u00e9szt implement\u00e1lhat, m\u00edg \u0151se maximum egy lehet.</p> <p>Az interf\u00e9szek haszn\u00e1lat\u00e1nak van m\u00e9g egy k\u00f6vetkezm\u00e9nye, ami bizonyos esetben kellemetlens\u00e9geket okozhat. Amikor az interf\u00e9szbe \u00faj m\u0171veletet vesz\u00fcnk fel, akkor valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt szint\u00e9n b\u0151v\u00edteni kell, k\u00fcl\u00f6nben a k\u00f3d nem fordul. Absztrakt \u0151s b\u0151v\u00edt\u00e9se eset\u00e9n ez nincs \u00edgy: amennyiben \u00faj m\u0171veletet vesz\u00fcnk fel, lehet\u0151s\u00e9g\u00fcnk van azt virtu\u00e1lis f\u00fcggv\u00e9nyk\u00e9nt felvenni, \u00e9s \u00edgy az \u0151sben alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni r\u00e1. Ez esetben az lesz\u00e1rmazottak ig\u00e9ny szerint tudj\u00e1k ezt fel\u00fcldefini\u00e1lni, erre nincsenek r\u00e1k\u00e9nyszer\u00edtve. Az interf\u00e9szek ezen tulajdons\u00e1ga k\u00fcl\u00f6n\u00f6sen oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek eset\u00e9n lehet kellemetlen. Tegy\u00fck fel, hogy a .NET \u00faj verzi\u00f3j\u00e1nak kiad\u00e1skor a keretrendszer egyik interf\u00e9sz\u00e9be \u00faj m\u0171veletet vesznek fel. Ekkor valamennyi alkalmaz\u00e1sban valamennyi implement\u00e1l\u00f3 oszt\u00e1lyt m\u00f3dos\u00edtani kell, k\u00fcl\u00f6nben nem fordul a k\u00f3d. Ezt k\u00e9tf\u00e9lek\u00e9ppen lehet elker\u00fclni. Vagy \u0151soszt\u00e1ly haszn\u00e1lat\u00e1val, vagy ha m\u00e9gis interf\u00e9szt kellene b\u0151v\u00edteni, akkor ink\u00e1bb \u00faj interf\u00e9szt bevezet\u00e9s\u00e9vel, amely m\u00e1r az \u00faj m\u0171veletet is tartalmazza. B\u00e1r itt az els\u0151 megk\u00f6zel\u00edt\u00e9s (\u0151soszt\u00e1ly alkalmaz\u00e1sa) t\u0171nik els\u0151 \u00e9rz\u00e9sre vonz\u00f3bbnak, ennek is van h\u00e1tr\u00e1nya: ha az alkalmaz\u00e1s fejleszt\u00e9sekor egy keretrendszerbeli \u0151sb\u0151l sz\u00e1rmaztatunk, akkor oszt\u00e1lyunknak m\u00e1r nem lehet m\u00e1s \u0151se, \u00e9s ez bizony sok esetben f\u00e1jdalmas megk\u00f6t\u00e9st jelent.</p> <p>\u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja. B\u0151vebben inform\u00e1ci\u00f3 itt:  default interface methods.</p> <p>Mivel mind az interf\u00e9szek, mind az absztrakt \u0151soszt\u00e1lyok alkalmaz\u00e1sa j\u00e1rhat negat\u00edv k\u00f6vetkezm\u00e9nyekkel is, sz\u00e1mos esetben a kett\u0151 egy\u00fcttes haszn\u00e1lat\u00e1val tudjuk kihozni megold\u00e1sunkb\u00f3l a maximumot (vagyis lesz a k\u00f3dunk k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00fagy, hogy nem, vagy csak minim\u00e1lis m\u00e9rt\u00e9kben tartalmaz k\u00f3dduplik\u00e1ci\u00f3t).</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/","title":"Interface and abstract (base) class","text":"<p>Last modified date: 2022.10.15 Edited by Zolt\u00e1n Benedek</p> <p>The chapter does not contain an exercise, it introduces the related theory to students.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#abstract-class","title":"Abstract class","text":"<p>The concepts have been covered in previous topics, so for now we will just summarize the most important ones and focus on the C# aspect. Abstract class A class that cannot be instantiated. In C#, in the class definition, the abstract keyword must be written out, e.g.:</p> <pre><code>abstract class Shape { ... }\n</code></pre> <p>Abstract classes may have abstract methods that do not have a root, and for these abstract methods the abstract keyword should be used:</p> <pre><code>...\nabstract void Draw();\n...\n</code></pre> <p>There are two purposes for using abstract classes:</p> <ul> <li>In a class hierarchy, we can map code common to descendants into an abstract common base class, thus avoiding code duplication.</li> <li>We can uniformly refer to descendants as abstract base classes (e.g. heterogeneous collections).</li> </ul> <p>in .NET, as in Java, a class can have only one base class class.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#interface","title":"Interface","text":"<p>An interface is nothing more than a set of operations. In fact, it corresponds to an abstract class whose all operations are abstract.</p> <p>In C# you can define an interface with the <code>interface</code> keyword:</p> <pre><code>public interface ISerializable \n{\n   void WriteToStream(Stream s);\n   void LoadFromStream(Stream s);\n}\n\npublic interface IComparable \n{\n   int CompareTo(Object obj);\n}\n</code></pre> <p>While a class can have only one base class, it can implement any number of interfaces:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n    ...\n}\n</code></pre> <p>In this example, the Rect class is derived from the Shape class and implements the <code>ISerializable</code> and <code>IComparable</code> interfaces (mandatory to specify the base class first). In a class implementing an interface, all its operations must be implemented, i.e., its trunk must be written (except in the rare case where it is implemented by an abstract operation). There is one main purpose for using interfaces. Referenced as an interface, we can uniformly manage all the classes that implement the interface (e.g., a heterogeneous collection). One consequence of this is that interfaces allow us to write classes and functions that can be used in a wide variety of ways. For example, we can write a universal Sort ordering function that can be used with any class that implements the IComparable interface.</p> <p>Other benefits of using the interface include:</p> <ul> <li>The client only needs to know the interface of the server object to be able to use the server easily.</li> <li>If the client only uses the server through the interface, so the internal implementation of the server may change, the client does not need to be modified (nor recompiled). Accordingly, the interface is also a contract between the server and the client: as long as the server guarantees support for the interface, the client does not need to change.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_eng/#comparison-of-abstract-base-class-and-interface","title":"Comparison of abstract base class and interface","text":"<p>The advantage of the abstract base class over the interface is that you can specify a default implementation for the operations and include member variables.</p> <p>The advantage of interfaces over abstract ancestors is that a class can implement any number of interfaces, while its base class can implement at most one.</p> <p>There is another consequence of using interfaces, which can cause inconvenience in some cases. When a new operation is added to the interface, all implementing classes must also be extended, otherwise the code will not compile. This is not the case when extending an abstract base class: if you add a new operation, you have the option to add it as a virtual function, and thus give it a default implementation in the ancestor. In this case, the descendants can redefine this as they wish, they are not forced to do so. This feature of interfaces can be particularly inconvenient for class libraries/framework systems. Suppose a new version of .NET is released and a new operation is added to one of the interfaces of the framework. All implementing classes in all applications must then be modified, otherwise the code will not compile. There are two ways to avoid this. Either by using a legacy class, or, if an interface should be extended, by introducing a new interface that already contains the new operation. Although the first approach (using an base class class) seems more attractive at first sight, it also has a drawback: if you derive from an ancestor in the framework when developing your application, your class can have no other ancestor, and this is a painful constraint in many cases.</p> <p>It's worth knowing that starting from C# 8 (or .NET or .NET Core runtime, not supported under .NET Framework), interface operations can be given a default implementation (default interface methods), so no abstract class is needed to solve the above problem, but an interface can no longer have a member variable. More information here: default interface methods.</p> <p>Since using both interfaces and abstract classes can have negative consequences, in many cases we can get the most out of our solution by using both (i.e., our code can be easily extended with no or minimal code duplication).</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_ger/","title":"Schnittstelle und abstrakte (angestammte) Klasse","text":"<p>Letztes \u00c4nderungsdatum: 2022.10.15 Er hat trainiert: Zolt\u00e1n Benedek</p> <p>Das Kapitel enth\u00e4lt keine \u00dcbung, sondern bietet den Studierenden eine Einf\u00fchrung in die entsprechende Theorie.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_ger/#abstrakte-klasse","title":"Abstrakte Klasse","text":"<p>Die Konzepte wurden bereits in fr\u00fcheren Themen behandelt, so dass wir jetzt nur die wichtigsten zusammenfassen und uns auf den C#-Aspekt konzentrieren werden. Abstrakte Klasse Eine Klasse, die nicht instanziiert werden kann. In C# sollte in der Klassendefinition das abstrakte Schl\u00fcsselwort geschrieben werden, z.B.:</p> <pre><code>abstract class Shape { ... }\n</code></pre> <p>Abstrakte Klassen k\u00f6nnen abstrakte Methoden haben, die keine Wurzel haben, und f\u00fcr diese abstrakten Methoden sollte das Schl\u00fcsselwort abstract verwendet werden:</p> <pre><code>..\nabstract void Draw();\n..\n</code></pre> <p>Es gibt zwei Gr\u00fcnde f\u00fcr die Verwendung abstrakter Klassen:</p> <ul> <li>In einer Klassenhierarchie k\u00f6nnen wir Code, der allen Nachkommen gemeinsam ist, auf einen abstrakten gemeinsamen Vorfahren abbilden und so Code-Duplikation vermeiden.</li> <li>Wir k\u00f6nnen uns einheitlich auf Nachkommen als abstrakte Vorfahren beziehen (z. B. heterogene Sammlungen).</li> </ul> <p>in .NET, wie auch in Java, kann eine Klasse nur eine Vorg\u00e4ngerklasse haben.</p>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_ger/#schnittstelle","title":"Schnittstelle","text":"<p>Eine Schnittstelle ist nichts anderes als eine Reihe von Operationen. Sie entspricht in der Tat einer abstrakten Klasse, deren s\u00e4mtliche Operationen abstrakt sind.</p> <p>In C# k\u00f6nnen Sie eine Schnittstelle mit dem Schl\u00fcsselwort <code>interface</code> definieren:</p> <pre><code>public interface ISerializable \n{\n   void WriteToStream(Stream s);\n   void LoadFromStream(Stream s);\n}\n\npublic interface IComparable \n{\n   int CompareTo(Object obj);\n}\n</code></pre> <p>W\u00e4hrend eine Klasse nur einen Vorfahren haben kann, kann sie eine beliebige Anzahl von Schnittstellen implementieren:</p> <pre><code>public class Rect : Shape, ISerializable, IComparable\n{\n    ..\n}\n</code></pre> <p>In diesem Beispiel ist die Klasse Rect von der Klasse Shape abgeleitet und implementiert die Schnittstellen <code>ISerializable</code> und <code>IComparable</code> (die Vorg\u00e4ngerklasse muss zuerst angegeben werden). In der Klasse, die die Schnittstelle implementiert, m\u00fcssen alle ihre Operationen implementiert werden, d. h. ihr Stamm muss geschrieben werden (au\u00dfer in dem seltenen Fall, dass sie durch eine abstrakte Operation implementiert wird). Die Verwendung von Schnittstellen hat vor allem einen Zweck. Als Schnittstelle referenziert, k\u00f6nnen wir alle Klassen, die die Schnittstelle implementieren, einheitlich verwalten (z. B. heterogene Sammlung). Eine Folge davon ist, dass Schnittstellen es Ihnen erm\u00f6glichen, Klassen und Funktionen zu schreiben, die auf vielf\u00e4ltige Weise verwendet werden k\u00f6nnen. Wir k\u00f6nnen zum Beispiel eine universelle Sortierfunktion schreiben, die mit jeder Klasse verwendet werden kann, die die Schnittstelle IComparable implementiert.</p> <p>Weitere Vorteile der Nutzung der Schnittstelle sind:</p> <ul> <li>Der Client muss nur die Schnittstelle des Serverobjekts kennen, um den Server problemlos nutzen zu k\u00f6nnen.</li> <li>Wenn der Client den Server nur \u00fcber die Schnittstelle nutzt, so dass sich die interne Implementierung des Servers \u00e4ndern kann, muss der Client nicht ge\u00e4ndert (und auch nicht neu kompiliert) werden. Dementsprechend ist die Schnittstelle auch ein Vertrag zwischen dem Server und dem Client: Solange der Server die Unterst\u00fctzung f\u00fcr die Schnittstelle garantiert, braucht der Client nicht zu wechseln.</li> </ul>"},{"location":"egyeb/interfesz-es-absztrakt-os/index_ger/#vergleich-von-abstraktem-vorfahren-und-schnittstelle","title":"Vergleich von abstraktem Vorfahren und Schnittstelle","text":"<p>Der Vorteil des abstrakten Vorg\u00e4ngers gegen\u00fcber der Schnittstelle besteht darin, dass Sie eine Standardimplementierung f\u00fcr die Operationen angeben und Membervariablen einschlie\u00dfen k\u00f6nnen.</p> <p>Der Vorteil von Schnittstellen gegen\u00fcber abstrakten Vorfahren besteht darin, dass eine Klasse eine beliebige Anzahl von Schnittstellen implementieren kann, w\u00e4hrend ihr Vorfahre h\u00f6chstens eine implementieren kann.</p> <p>Die Verwendung von Schnittstellen hat noch eine weitere Konsequenz, die in einigen F\u00e4llen zu Unannehmlichkeiten f\u00fchren kann. Wenn eine neue Operation zur Schnittstelle hinzugef\u00fcgt wird, m\u00fcssen alle implementierenden Klassen ebenfalls erweitert werden, sonst l\u00e4sst sich der Code nicht kompilieren. Dies ist bei der Erweiterung eines abstrakten Vorg\u00e4ngers nicht der Fall: Wenn Sie eine neue Operation hinzuf\u00fcgen, haben Sie die M\u00f6glichkeit, sie als virtuelle Funktion hinzuzuf\u00fcgen und ihr somit eine Standardimplementierung im Vorg\u00e4nger zu geben. In diesem Fall k\u00f6nnen die Nachkommen dies nach Belieben umdefinieren, sie sind nicht dazu gezwungen. Diese Eigenschaft von Schnittstellen kann f\u00fcr Klassenbibliotheken/Framework-Systeme besonders unangenehm sein. Angenommen, eine neue Version von .NET wird ver\u00f6ffentlicht und eine neue Operation wird zu einer der Schnittstellen des Frameworks hinzugef\u00fcgt. Alle implementierenden Klassen in allen Anwendungen m\u00fcssen dann ge\u00e4ndert werden, da der Code sonst nicht kompiliert werden kann. Es gibt zwei M\u00f6glichkeiten, dies zu vermeiden. Entweder durch Verwendung einer Legacy-Klasse oder, wenn eine Schnittstelle erweitert werden soll, durch Einf\u00fchrung einer neuen Schnittstelle, die die neue Operation bereits enth\u00e4lt. Obwohl der erste Ansatz (Verwendung einer Vorg\u00e4ngerklasse) auf den ersten Blick attraktiver erscheint, hat er auch einen Nachteil: Wenn Sie bei der Entwicklung Ihrer Anwendung von einem Vorg\u00e4nger im Framework ableiten, kann Ihre Klasse keinen weiteren Vorg\u00e4nger haben, und das ist in vielen F\u00e4llen eine schmerzhafte Einschr\u00e4nkung.</p> <p>Es ist wichtig zu wissen, dass ab C# 8 (oder .NET oder .NET Core Runtime, nicht unterst\u00fctzt unter .NET Framework), Schnittstellenoperationen eine Standardimplementierung (Standardschnittstellenmethoden) gegeben werden kann, so dass keine abstrakte Klasse ben\u00f6tigt wird, um das obige Problem zu l\u00f6sen, aber eine Schnittstelle kann nicht mehr eine Mitgliedsvariable haben. Weitere Informationen finden Sie hier: Standardschnittstellenmethoden.</p> <p>Da sowohl die Verwendung von Schnittstellen als auch von abstrakten Klassen negative Folgen haben kann, k\u00f6nnen wir in vielen F\u00e4llen das meiste aus unserer L\u00f6sung herausholen, wenn wir beides verwenden (d. h. unser Code kann ohne oder mit nur minimaler Code-Duplizierung leicht erweitert werden).</p>"},{"location":"egyeb/uml-kod-kapcsolata/","title":"Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete","text":"<p>Utols\u00f3 m\u00f3dos\u00edt\u00e1s ideje: 2022.10.15 Kidolgozta: Benedek Zolt\u00e1n</p> <p>A fejezet nem tartalmaz feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismerteti a kapcsol\u00f3d\u00f3 elm\u00e9letet.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#bevezeto","title":"Bevezet\u0151","text":"<p>A fejezet egy r\u00f6vid, v\u00e1zlatos \u00e1ttekint\u00e9st ad az UML oszt\u00e1lydiagram \u00e9s a forr\u00e1sk\u00f3d k\u00f6z\u00f6tti lek\u00e9pez\u00e9s alapjair\u00f3l, a megel\u0151z\u0151 f\u00e9l\u00e9vben Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultak ism\u00e9tl\u00e9sek\u00e9nt.</p> <p>Napjainkban sz\u00e1mos szoftverfejleszt\u00e9si m\u00f3dszertan l\u00e9tezik. Ezek k\u00fcl\u00f6nb\u00f6z\u0151 m\u00e9rt\u00e9kben \u00e9p\u00edtenek arra, illetve k\u00f6vetelik meg, hogy a szoftver elk\u00e9sz\u00edt\u00e9se sor\u00e1n modellez\u00e9st alkalmazzunk. Az azonban k\u00e9ts\u00e9gtelen, hogy m\u00e9g a legagilisabb, legink\u00e1bb \u201ek\u00f3dcentrikus\u201d szeml\u00e9letm\u00f3dok k\u00f6vet\u0151i is hasznosnak \u00edt\u00e9lik a szoftver fontosabb/komplexebb komponenseinek \u00e9s szerkezeti elemeinek vizu\u00e1lis modellez\u00e9s\u00e9t annak grafikus volt\u00e1b\u00f3l ad\u00f3d\u00f3 nagyobb kifejez\u0151 ereje miatt.</p> <p>Tegy\u00fck fel, hogy feladatunk egy alkalmaz\u00e1s, vagy annak adott modulj\u00e1nak elk\u00e9sz\u00edt\u00e9se. A v\u00e1lasztott m\u00f3dszertanunkat k\u00f6vetve \u2013 j\u00f3 es\u00e9llyel t\u00f6bb iter\u00e1ci\u00f3ban \u2013 a k\u00f6vetelm\u00e9ny elemz\u00e9s, anal\u00edzis, tervez\u00e9s, implement\u00e1ci\u00f3 \u00e9s tesztel\u00e9s l\u00e9p\u00e9seit fogjuk \u00e9rinteni. Koncentr\u00e1ljunk most a tervez\u00e9si f\u00e1zisra. Ennek sor\u00e1n elk\u00e9sz\u00fcl a rendszer (legal\u00e1bbis bizonyos r\u00e9szeinek) r\u00e9szletes terve, mely kimenete a r\u00e9szletes/ implement\u00e1ci\u00f3s terv, illetve modell. Ezen a szinten a modellben szerepl\u0151 bizonyos elemek (pl. oszt\u00e1lyok) egy\u00e9rtelm\u0171en lek\u00e9pezhet\u0151k az adott alrendszer implement\u00e1ci\u00f3j\u00e1ul v\u00e1lasztott programoz\u00e1si nyelv elemeire. Ha j\u00f3 a fejleszt\u0151/modellez\u0151 eszk\u00f6z\u00fcnk, akkor az le tudja gener\u00e1lni az oszt\u00e1lyok v\u00e1z\u00e1t (pl. C++, Java, C# oszt\u00e1lyok). A feladatunk ezt k\u00f6vet\u0151en a gener\u00e1lt k\u00f3dban szerepl\u0151 a met\u00f3dusok t\u00f6rzs\u00e9nek kit\u00f6lt\u00e9se.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#fogalmak","title":"Fogalmak","text":"<ul> <li>Forward engineering: modellb\u0151l k\u00f3d gener\u00e1l\u00e1sa. A r\u00e9szletes tervb\u0151l a modellez\u0151 eszk\u00f6z le tudja gener\u00e1lni a programv\u00e1zat. El\u0151nye, hogy kevesebbet kell k\u00f3dolni.</li> <li>Reverse engineering: k\u00f3db\u00f3l modell gener\u00e1l\u00e1sa. A m\u00e1r k\u00e9sz k\u00f3d meg\u00e9rt\u00e9s\u00e9t seg\u00edti.</li> <li>Round-trip engineering: az el\u0151z\u0151 kett\u0151 egy\u00fcttes alkalmaz\u00e1sa. A l\u00e9nyeg: a modell \u00e9s a k\u00f3d v\u00e9gig szinkronban van. Ha a k\u00f3dban v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a modellben, ha a modellben v\u00e1ltoztatunk, a v\u00e1ltoz\u00e1s megjelenik a k\u00f3dban.</li> </ul> <p>Ahhoz, hogy a k\u00f3dgener\u00e1l\u00e1s el\u0151nyeivel \u00e9lni tudjunk, a k\u00f6vetkez\u0151kkel kell tiszt\u00e1ban legy\u00fcnk: ismern\u00fcnk kell, hogy az adott modellez\u0151 eszk\u00f6z az egyes modell elemeket hogyan k\u00e9pezi le az adott programoz\u00e1si nyelv elemeire. A lek\u00e9pez\u00e9s f\u00fcgg a nyelvt\u0151l \u00e9s a modellez\u0151 eszk\u00f6zt\u0151l is, nincs r\u00e1 univerz\u00e1lis szabv\u00e1ny. A lek\u00e9pez\u00e9sek \u00e1ltal\u00e1ban magukt\u00f3l \u00e9rtet\u0151d\u0151ek, t\u00fal nagy elt\u00e9r\u00e9s nem szokott lenni.</p> <p>A k\u00f6vetkez\u0151kben azt tekintj\u00fck \u00e1t, hogy az UML oszt\u00e1lydiagram egyes modellelemei hogyan k\u00e9pz\u0151dnek le forr\u00e1sk\u00f3dra, \u00e9s viszont.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#osztalyok-lekepezese","title":"Oszt\u00e1lyok lek\u00e9pez\u00e9se","text":"<p>Mondhatni trivi\u00e1lisan egyszer\u0171:</p> <ul> <li>UML oszt\u00e1ly -&gt; oszt\u00e1ly</li> <li>UML attrib\u00fatum -&gt; tagv\u00e1ltoz\u00f3</li> <li>UML m\u0171velet -&gt; m\u0171velet/met\u00f3dus</li> </ul> <p>Egy p\u00e9lda:</p> <p></p> <p>, mely a k\u00f6vetkez\u0151 k\u00f3dnak felel meg C# nyelven:</p> <pre><code>public abstract class Shape\n{\n    private int x;\n    private int y;\n    public Shape(int x, int y) { this.x = x; this.y = y; }\n    public abstract void Draw(Graphics gr);\n}\n</code></pre> <p>A l\u00e1that\u00f3s\u00e1g kapcs\u00e1n a lek\u00e9pez\u00e9s:</p> <ul> <li>+: public</li> <li>-: private</li> <li>#: protected</li> </ul> <p>Enn\u00e9l izgalmasabb k\u00e9rd\u00e9sk\u00f6r, hogy milyen m\u00f3don t\u00f6rt\u00e9nik az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatok lek\u00e9pez\u00e9se, ezt a k\u00f6vetkez\u0151 fejezetek ismertetik.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#i-altalanositas-specializacio-kapcsolat","title":"I. \u00c1ltal\u00e1nos\u00edt\u00e1s, specializ\u00e1ci\u00f3 kapcsolat","text":"<p>C# lek\u00e9pez\u00e9s:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#ii-asszociacio","title":"II. Asszoci\u00e1ci\u00f3","text":"<p>Ez a kapcsolatt\u00edpus mindig kommunik\u00e1ci\u00f3t jelent az oszt\u00e1lyok objektumai k\u00f6z\u00f6tt. Egy adott oszt\u00e1ly ig\u00e9nybe veszi egy m\u00e1sik oszt\u00e1ly szolg\u00e1ltat\u00e1sait.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#a-lekepezes-01-multiplicitasu-asszociacios-kapcsolat-eseten","title":"A) Lek\u00e9pez\u00e9s 0..1 multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy pointert vagy referenci\u00e1t tartalmaz a kliens oszt\u00e1ly, melyen kereszt\u00fcl ig\u00e9nybe tudja venni a c\u00e9loszt\u00e1ly szolg\u00e1ltat\u00e1sait (meg tudja h\u00edvni annak m\u0171veleteit). P\u00e9lda:</p> <p></p> <p>C++ lek\u00e9pez\u00e9s:</p> <pre><code>class Application\n{\n   WindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C# lek\u00e9pez\u00e9s (nincsenek pointerek, csak referenci\u00e1k):</p> <pre><code>class Application\n{\n   WindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>Mink\u00e9t esetben azt l\u00e1tjuk, hogy a kliens oszt\u00e1lyba felvesz\u00fcnk egy pointer vagy referencia tagv\u00e1ltoz\u00f3t, melynek t\u00edpusa megegyezik az asszoci\u00e1ci\u00f3ban hivatkozott c\u00e9loszt\u00e1ly t\u00edpus\u00e1val, illetve a tagv\u00e1ltoz\u00f3 neve az asszoci\u00e1ci\u00f3s kapcsolatra a c\u00e9loszt\u00e1lyra megadott szereppel (role), mely a p\u00e9ld\u00e1ban a <code>windowManager</code>. A lek\u00e9pez\u00e9s logikus, hiszen a kliens ezen pointeren/referenci\u00e1n kereszt\u00fcl tudja a c\u00e9lobjektumot b\u00e1rmely m\u0171velet\u00e9b\u0151l el\u00e9rni \u00e9s met\u00f3dusait megh\u00edvni.</p> <p>Megjegyz\u00e9s. El\u0151fordulhat, hogy az asszoci\u00e1ci\u00f3 k\u00e9tir\u00e1ny\u00fa, mindk\u00e9t oszt\u00e1ly ig\u00e9nybe veszi a m\u00e1sik szolg\u00e1ltat\u00e1sait. Ilyenkor sokszor nem tessz\u00fck ki az asszoci\u00e1ci\u00f3 mindk\u00e9t v\u00e9g\u00e9re a nyilat, hanem mindk\u00e9t v\u00e9g\u00e9r\u0151l elhagyjuk azt. Ilyen k\u00e9tir\u00e1ny\u00fa kapcsolat eset\u00e9n a szerepet (role) a kapcsolat mindk\u00e9t v\u00e9g\u00e9n meg kell adni. A lek\u00e9pez\u00e9s sor\u00e1n mindk\u00e9t oszt\u00e1lyba felvesz\u00fcnk egy pointert/referenci\u00e1t a m\u00e1sikra.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#b-lekepezes-0n-multiplicitasu-asszociacios-kapcsolat-eseten","title":"B) Lek\u00e9pez\u00e9s 0..n multiplicit\u00e1s\u00fa asszoci\u00e1ci\u00f3s kapcsolat eset\u00e9n","text":"<p>Ebben az esetben egy kliensoldali objektum t\u00f6bb c\u00e9loldali objektummal van kapcsolatban. P\u00e9lda:</p> <p></p> <p>Egy <code>WindowManager</code> objektum t\u00f6bb <code>Window</code> objektumot menedzsel. A lek\u00e9pez\u00e9s sor\u00e1n a kliens oszt\u00e1lyba a c\u00e9loszt\u00e1lybeli objektumok valamilyen gy\u0171jtem\u00e9ny\u00e9t vessz\u00fck fel. Ez lehet t\u00f6mb, lista stb., ami a c\u00e9lunknak az adott helyzetben legink\u00e1bb megfelel.</p> <p>Egy lek\u00e9pz\u00e9si lehet\u0151s\u00e9g a fenti p\u00e9ld\u00e1ra C++ nyelven:</p> <pre><code>class WindowManager\n{\n  vector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Illetve C# nyelven:</p> <pre><code>class WindowManager\n{\n  List&lt;Window&gt; windows; \n};\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/#iii-aggregacio-tartalmazas-resz-egesz-viszony","title":"III. Aggreg\u00e1ci\u00f3 (tartalmaz\u00e1s, r\u00e9sz-eg\u00e9sz viszony)","text":"<p>\u00c1ltal\u00e1ban a lek\u00e9pez\u00e9se pontosan \u00fagy t\u00f6rt\u00e9nik, mint az asszoci\u00e1ci\u00f3 eset\u00e9ben.</p>"},{"location":"egyeb/uml-kod-kapcsolata/#iv-fuggoseg-dependency","title":"IV. F\u00fcgg\u0151s\u00e9g (dependency)","text":"<p>A leglaz\u00e1bb kapcsolatot jelenti oszt\u00e1lyok k\u00f6z\u00f6tt. P\u00e9lda:</p> <p></p> <p>A jelent\u00e9se: a <code>Window</code> oszt\u00e1ly f\u00fcgg a <code>Graphics</code> oszt\u00e1lyt\u00f3l. Vagyis, ha a <code>Graphics</code> oszt\u00e1ly megv\u00e1ltozik, akkor lehet, hogy a Window oszt\u00e1lyt is meg kell v\u00e1ltoztatni. Ezt a kapcsolatt\u00edpust akkor szoktuk haszn\u00e1lni, ha a f\u00fcgg\u0151s\u00e9gi kapcsolat elej\u00e9n lev\u0151 oszt\u00e1ly met\u00f3dusai param\u00e9terlist\u00e1j\u00e1ban/visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben szerepel a kapcsolat v\u00e9g\u00e9n lev\u0151 oszt\u00e1ly. A p\u00e9ld\u00e1ban a <code>Window</code> oszt\u00e1ly <code>onDraw</code> m\u0171velete param\u00e9terk\u00e9nt megkapja a <code>Graphics</code> oszt\u00e1ly egy objektum\u00e1t, \u00edgy f\u00fcgg t\u0151le, hiszen a met\u00f3dus t\u00f6rzs\u00e9ben \u00edgy meg tudja h\u00edvni a <code>Graphics</code> oszt\u00e1ly met\u00f3dusait. Ha pl. a <code>Graphics</code> oszt\u00e1ly <code>FillRect</code> met\u00f3dus\u00e1nak nev\u00e9t megv\u00e1ltoztatjuk, akkor ezt a v\u00e1ltoz\u00e1st \u00e1t kell vezetni a h\u00edv\u00e1sok hely\u00e9n, vagyis a <code>Window</code> oszt\u00e1ly onDraw met\u00f3dus\u00e1nak t\u00f6rzs\u00e9ben is.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/","title":"Theory of the relationship between the UML class diagram and code","text":"<p>Last modified date: 2022.10.15 Edited by Zolt\u00e1n Benedek</p> <p>The chapter does not contain an exercise, it introduces the related theory to students.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#introduction","title":"Introduction","text":"<p>The chapter gives a brief, sketchy overview of the basics of mapping between the UML class diagram and the source code, as a review of what has already been learned in Software Engineering in the previous semester.</p> <p>Today, there are many software development methodologies. They rely on, or require, modelling to varying degrees in the construction of the software. However, there is no doubt that even the most agile, \"code-centric\" followers of the most \"code-centric\" approaches find it useful to visually model the more important/complex components and structural elements of software, because of the greater expressive power of the graphical nature of the software.</p> <p>Let's say you have to build an application or a specific module of an application. Following our chosen methodology, we will cover the steps of requirements analysis, analysis, design, implementation and testing, probably in several iterations. Let's now focus on the design phase. This will result in a detailed design of the system (at least parts of it), resulting in a detailed/implementation plan or model. At this level, certain elements of the model (e.g. classes) can be explicitly mapped to elements of the programming language chosen to implement the subsystem. If you have a good development/modeling tool, it can generate the class skeleton (e.g. C++, Java, C# classes). Our task is then to fill in the root of the methods in the generated code.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#concepts","title":"Concepts","text":"<ul> <li>Forward engineering: generating code from a model. From the detailed plan, the modelling tool can generate the program framework. The advantage is that less coding is needed.</li> <li>Reverse engineering: generating a model from code. It helps you understand the code you already have.</li> <li>Round-trip engineering: a combination of the previous two. The point is: the model and the code are in sync all the time. If you change the code, the change appears in the model, if you change the model, the change appears in the code.</li> </ul> <p>In order to take advantage of code generation, you need to be aware of the following: you need to know how a given modelling tool maps each model element to elements of a given programming language. The mapping depends on the language and the modelling tool, there is no universal standard. The mappings are usually self-explanatory, there is not usually too much variation.</p> <p>In the following we will look at how each model element of the UML class diagram is mapped to source code, and vice versa.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#mapping-of-classes","title":"Mapping of classes","text":"<p>It's trivially simple:</p> <ul> <li>UML class -&gt; class</li> <li>UML attribute -&gt; member variable</li> <li>UML operation -&gt; operation/method</li> </ul> <p>An example:</p> <p>Shape class</p> <p>, which corresponds to the following code in C#:</p> <pre><code>public abstract class Shape\n{\n    private int x;\n    private int y;\n    public Shape(int x, int y) { this.x = x; this.y = y; }\n    public abstract void Draw(Graphics gr);\n}\n</code></pre> <p>In the context of visibility, mapping:</p> <ul> <li>+: public</li> <li>-: private</li> <li>#: protected</li> </ul> <p>A more exciting question is how the relationships between classes are mapped, and this is discussed in the following chapters.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#i-generalisation-specialisation-link","title":"I. Generalisation, specialisation link","text":"<p>Generalisation, specialisation</p> <p>C# mapping:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#ii-association","title":"II. Association","text":"<p>This relationship type always implies communication between objects of classes. A department uses the services of another department.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#a-building-a-01-multiplicity-association-relation","title":"A) Building a 0..1 multiplicity association relation","text":"<p>In this case, the client class contains a pointer or reference through which it can use the services of the target class (call its operations). Example:</p> <p>Generalisation, specialisation, single contact</p> <p>C++ mapping:</p> <pre><code>class Application\n{\n   WindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C# mapping (no pointers, only references):</p> <pre><code>class Application\n{\n   WindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>In both cases, we see that a pointer or reference member variable is added to the client class, whose type is the same as the type of the target class referenced in the association, and the name of the member variable is the role given to the target class for the association relationship, which in the example is . The mapping is logical, since the client can access the target object from any of its operations and call its methods through this pointer/reference.</p> <p>Comment. Sometimes the association is two-way, with each class using the services of the other. Often, instead of putting an arrow at both ends of the association, we leave it at both ends. In such a two-way relationship, the role must be specified at both ends of the relationship. During the mapping, we add a pointer/reference to each class to the other.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#b-derivation-for-an-association-relation-with-multiplicity-0n","title":"B) Derivation for an association relation with multiplicity 0..n","text":"<p>In this case, a client-side object is related to several target-side objects. Example:</p> <p>Generalisation, specialisation, multiple links</p> <p>One <code>WindowManager</code> object manages several <code>Window</code> objects. The mapping takes some collection of objects in the target class into the client class. This can be an array, list, etc., whichever best suits our purpose in the situation.</p> <p>A mapping to the above example in C++:</p> <pre><code>class WindowManager\n{\n  vector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Or in C#:</p> <pre><code>class WindowManager\n{\n  List&lt;Window&gt; windows; \n};\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#iii-aggregation-inclusion-part-part-relationship","title":"III. Aggregation (inclusion, part-part relationship)","text":"<p>In general, the mapping is exactly the same as for association.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_eng/#iv-dependency-dependency","title":"IV. Dependency (dependency)","text":"<p>It represents the loosest link between departments. Example:</p> <p>Dependency</p> <p>Meaning: the <code>Window</code> class depends on the <code>Graphics</code> class. That is, if the <code>Graphics</code> class is changed, the Window class may also need to be changed. This connection type is used when the parameter list/return value of the methods of the class at the beginning of the dependency connection contains the class at the end of the connection. In the example, the <code>onDraw</code> operation of the <code>Window</code> class receives an object of the <code>Graphics</code> class as a parameter, and thus depends on it, since it can call the methods of the <code>Graphics</code> class in the method's trunk. If, for example, the name of the <code>FillRect</code> method of the <code>Graphics</code> class is changed, this change must be reflected in the call location, i.e., in the trunk of the <code>onDraw</code> method of the Window class.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/","title":"Theorie der Beziehung zwischen dem UML-Klassendiagramm und dem Code","text":"<p>Letztes \u00c4nderungsdatum: 2022.10.15 Ausgearbeitet von: Zolt\u00e1n Benedek</p> <p>Das Kapitel enth\u00e4lt keine \u00dcbung, sondern bietet den Studierenden eine Einf\u00fchrung in die entsprechende Theorie.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Das Kapitel gibt einen kurzen \u00dcberblick \u00fcber die Grundlagen des Mappings zwischen dem UML-Klassendiagramm und dem Quellcode, als Wiederholung dessen, was bereits im vorherigen Semester in Softwarechnologien gelernt wurde.</p> <p>Heutzutage gibt es viele Softwareentwicklungsmethoden. Sie st\u00fctzen sich bei der Erstellung der Software in unterschiedlichem Ma\u00dfe auf die Modellierung bzw. erfordern diese. Es besteht jedoch kein Zweifel daran, dass selbst die Anh\u00e4nger der agilsten, \"code-zentrierten\" Ans\u00e4tze es f\u00fcr n\u00fctzlich halten, die wichtigeren/komplexeren Komponenten und Strukturelemente der Software visuell zu modellieren, da deren grafische Natur eine gr\u00f6\u00dfere Ausdruckskraft hat.</p> <p>Nehmen wir an, man muss eine Anwendung oder ein bestimmtes Modul einer Anwendung erstellen. Nach der von sich gew\u00e4hlten Methodik wird man die Schritte Anforderungsanalyse, Analyse, Entwurf, Implementierung und Test durchf\u00fchren, wahrscheinlich in mehreren Iterationen. Konzentrieren wir uns nun auf die Entwurfsphase. Das Ergebnis ist ein detaillierter Entwurf des Systems (zumindest von Teilen davon), der in einen detaillierten Plan oder ein Modell f\u00fcr die Umsetzung m\u00fcndet. Auf dieser Ebene k\u00f6nnen bestimmte Elemente des Modells (z. B. Klassen) explizit auf Elemente der f\u00fcr die Implementierung des Teilsystems gew\u00e4hlten Programmiersprache abgebildet werden. Wenn man \u00fcber ein gutes Entwicklungs-/Modellierungswerkzeug verf\u00fcgt, kann dieses das Klassenskelett (z. B. C++, Java-, C#-Klassen) generieren. Unsere Aufgabe besteht nun darin, die Wurzel der Methoden in den generierten Code einzutragen.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#konzepte","title":"Konzepte","text":"<ul> <li>Forward Engineering: Generierung von Code aus einem Modell. Aus dem detaillierten Plan kann das Modellierungswerkzeug das Programmger\u00fcst erstellen. Der Vorteil ist, dass weniger Kodierung erforderlich ist.</li> <li>Reverse Engineering: Generierung eines Modells aus Code. Es hilft Ihnen, den bereits vorhandenen Code zu verstehen.</li> <li>Round-Trip-Engineering: eine Kombination der beiden vorgenannten Verfahren. Der springende Punkt ist, dass das Modell und der Code st\u00e4ndig synchronisiert sind. Wenn Sie den Code \u00e4ndern, erscheint die \u00c4nderung im Modell, wenn Sie das Modell \u00e4ndern, erscheint die \u00c4nderung im Code.</li> </ul> <p>Um die Vorteile der Codegenerierung nutzen zu k\u00f6nnen, muss man Folgendes wissen: man muss wissen, wie ein bestimmtes Modellierungswerkzeug jedes Modellelement auf Elemente einer bestimmten Programmiersprache abbildet. Das Mapping h\u00e4ngt von der Sprache und dem Modellierungswerkzeug ab, es gibt keinen universellen Standard. Die Zuordnungen sind in der Regel selbsterkl\u00e4rend, es gibt in der Regel nicht allzu viele Variationen.</p> <p>Im Folgenden werden wir uns ansehen, wie jedes Modellelement des UML-Klassendiagramms auf den Quellcode abgebildet wird und umgekehrt.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#zuordnung-von-klassen","title":"Zuordnung von Klassen","text":"<p>Es ist trivial einfach:</p> <ul> <li>UML-Klasse -&gt; Klasse</li> <li>UML-Attribut -&gt; Mitgliedsvariable</li> <li>UML-Operation -&gt; Funktion/Method</li> </ul> <p>Ein Beispiel:</p> <p></p> <p>, was folgendem Code in C# entspricht:</p> <pre><code>public abstract class Shape\n{\n    private int x;\n    private int y;\n    public Shape(int x, int y) { this.x = x; this.y = y; }\n    public abstract void Draw(Graphics gr);\n}\n</code></pre> <p>Im Zusammenhang mit der Sichtbarkeit, Kartierung:</p> <ul> <li>+: public</li> <li>-: private</li> <li># : protected</li> </ul> <p>Eine spannendere Frage ist, wie die Beziehungen zwischen den Klassen abgebildet werden, und dies wird in den folgenden Kapiteln diskutiert.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#i-generalisierung-und-spezialisierung","title":"I. Generalisierung und Spezialisierung","text":"<p>C#-Zuordnung:</p> <pre><code>public class Base\n{ };\npublic class Derived : Base\n{ };\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#ii-assoziation","title":"II. Assoziation","text":"<p>Dieser Beziehungstyp impliziert immer eine Kommunikation zwischen Objekten von Klassen. Eine Abteilung nimmt die Dienste einer anderen Abteilung in Anspruch.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#a-aufbau-einer-01-multiplizitats-assoziationsbeziehung","title":"A) Aufbau einer 0..1-Multiplizit\u00e4ts-Assoziationsbeziehung","text":"<p>In diesem Fall enth\u00e4lt die Client-Klasse einen Zeiger oder Verweis, \u00fcber den sie die Dienste der Zielklasse nutzen (ihre Operationen aufrufen) kann. Beispiel:</p> <p></p> <p>C++-Zuordnung:</p> <pre><code>klasse Bewerbung\n{\n   WindowManager* windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>C#-Zuordnung (keine Zeiger, nur Referenzen):</p> <pre><code>class Application\n{\n   WindowManager windowManager;\n};\n\nclass WindowManager\n{\n};\n</code></pre> <p>In beiden F\u00e4llen sehen wir, dass wir der Client-Klasse eine Zeiger- oder Referenz-Member-Variable hinzuf\u00fcgen, die vom gleichen Typ ist wie die Zielklasse, auf die in der Assoziation verwiesen wird, und der Name der Member-Variable ist die Rolle, die der Zielklasse f\u00fcr die Assoziationsbeziehung gegeben wurde, die in diesem Beispiel <code>windowManager</code>ist. Die Zuordnung ist logisch, da der Client auf das Zielobjekt aus jeder seiner Operationen zugreifen und seine Methoden \u00fcber diesen Zeiger/Verweis aufrufen kann.</p> <p>Kommentar. Manchmal ist die Assoziation in beide Richtungen, wobei jede Klasse die Dienste der anderen nutzt. Anstatt einen Pfeil an beiden Enden der Assoziation anzubringen, lassen wir ihn oft an beiden Enden stehen. In einer solchen wechselseitigen Beziehung muss die Rolle an beiden Enden der Beziehung angegeben werden. W\u00e4hrend des Mappings f\u00fcgen wir einen Zeiger/Referenz auf jede Klasse der anderen hinzu.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#b-ableitung-fur-eine-assoziationsbeziehung-mit-der-multiplizitat-0n","title":"B) Ableitung f\u00fcr eine Assoziationsbeziehung mit der Multiplizit\u00e4t 0..n","text":"<p>In diesem Fall ist ein Objekt auf der Client-Seite mit mehreren Objekten auf der Zielseite verbunden. Beispiel:</p> <p></p> <p>Ein <code>WindowManager</code> Objekt verwaltet mehrere <code>Window</code> Objekte. Das Mapping \u00fcbernimmt eine Sammlung von Objekten der Zielklasse in die Client-Klasse. Dabei kann es sich um ein Array, eine Liste usw. handeln, je nachdem, was f\u00fcr unsere Zwecke in der jeweiligen Situation am besten geeignet ist.</p> <p>Eine Abbildung des obigen Beispiels in C++:</p> <pre><code>class WindowManager\n{\n  vector&lt;Window*&gt; windows;\n};\n</code></pre> <p>Oder in C#:</p> <pre><code>class WindowManager\n{\n  List&lt;Window&gt; windows; \n};\n</code></pre>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#iii-aggregation-einbeziehung-teil-ganzes-beziehung","title":"III. Aggregation (Einbeziehung, Teil-Ganzes-Beziehung)","text":"<p>Im Allgemeinen ist die Zuordnung genau die gleiche wie bei der Assoziation.</p>"},{"location":"egyeb/uml-kod-kapcsolata/index_ger/#iv-abhangigkeit-dependenz","title":"IV. Abh\u00e4ngigkeit (Dependenz)","text":"<p>Sie stellt die lockerste Verbindung zwischen den Abteilungen dar. Beispiel:</p> <p></p> <p>Das bedeutet: Die Klasse <code>Window</code> h\u00e4ngt von der Klasse <code>Graphics</code> ab. Das hei\u00dft, wenn die Klasse <code>Graphics</code> ge\u00e4ndert wird, muss m\u00f6glicherweise auch die Klasse Window ge\u00e4ndert werden. Diese Art der Beziehung wird verwendet, wenn die Parameterliste/R\u00fcckgabewerte der Methoden der Klasse am Anfang der Abh\u00e4ngigkeitsbeziehung die Klasse am Ende der Beziehung enth\u00e4lt. Im Beispiel erh\u00e4lt die Operation <code>onDraw</code> der Klasse <code>Window</code> ein Objekt der Klasse <code>Graphics</code> als Parameter und ist somit von dieser abh\u00e4ngig, da sie die Methoden der Klasse <code>Graphics</code> im Stamm der Methode aufrufen kann. Wird z.B. der Name der Methode <code>FillRect</code> der Klasse <code>Graphics</code> ge\u00e4ndert, muss sich diese \u00c4nderung in der Aufrufstelle, d.h. im Stamm der Methode onDraw der Klasse <code>Window</code> widerspiegeln.</p>"},{"location":"hazi/","title":"\u00d6n\u00e1ll\u00f3/h\u00e1zi feladatok","text":"<p>Valamennyi h\u00e1zi feladat elk\u00e9sz\u00edt\u00e9se k\u00f6telez\u0151. A megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik (b\u0151vebben itt). Az \u00f6n\u00e1ll\u00f3/h\u00e1zi feladatokra vonatkoz\u00f3 pontos k\u00f6vetelm\u00e9nyek Moodle-ben, a T\u00e1rgyk\u00f6vetelm\u00e9nyek alatt olvashat\u00f3k (\"\u00d6n\u00e1ll\u00f3/h\u00e1zi feladatok\" fejezet).</p>"},{"location":"hazi/#a-feladatok","title":"A feladatok","text":"<ul> <li>1. HF - A modell \u00e9s a k\u00f3d kapcsolata</li> <li>2. HF - Nyelvi eszk\u00f6z\u00f6k</li> <li>3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa</li> <li>4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se</li> <li>5. HF - MVVM</li> <li>6. HF - Tervez\u00e9si mint\u00e1k</li> <li>IMSc HF - Liftrendszer: </li> </ul>"},{"location":"hazi/#a-feladatok-beadasa","title":"A feladatok bead\u00e1sa","text":"<p>Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt. K\u00e9r\u00fcnk, alaposan olvasd v\u00e9gig a le\u00edr\u00e1st!</p> <p>FONTOS</p> <p>A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zi feladatokat nem \u00e9rt\u00e9kelj\u00fck.</p> <p>Bizonyos h\u00e1zi feladatokhoz automata el\u0151ellen\u0151rz\u0151 is tartozik, err\u0151l itt olvashatsz b\u0151vebben.</p>"},{"location":"hazi/#kepernyokepek","title":"K\u00e9perny\u0151k\u00e9pek","text":"<p>Bizonyos h\u00e1zi feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi.</p> <p>A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, \u00edgy felker\u00fclnek a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</p>"},{"location":"hazi/#szukseges-eszkozok","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k","text":"<p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezet alapvet\u0151en a Visual Studio 2022, err\u0151l itt tal\u00e1lhat\u00f3 b\u0151vebb le\u00edr\u00e1s.</p>"},{"location":"hazi/VisualStudio/","title":"Visual Studio &amp; .NET SDK telep\u00edt\u00e9se","text":"<p>COMING SOON</p>"},{"location":"hazi/meghirdetes-elott/","title":"H\u00e1zi feladat","text":"<p>Ez a h\u00e1zi feladat ebben a f\u00e9l\u00e9vben m\u00e9g nem ker\u00fclt meghirdet\u00e9sre, \u00edgy a le\u00edr\u00e1sa k\u00e9s\u0151bb lesz el\u00e9rhet\u0151 a f\u00e9l\u00e9v folyam\u00e1n.</p>"},{"location":"hazi/meghirdetes-elott_ger/","title":"Hausaufgaben","text":"<p>Diese Hausarbeit wurde in diesem Semester noch nicht angek\u00fcndigt, so dass die Beschreibung erst im Laufe des Semesters verf\u00fcgbar sein wird.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/","title":"1. HF - A modell \u00e9s a k\u00f3d kapcsolata","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A feladathoz nem kapcsol\u00f3dik el\u0151ad\u00e1s.  A feladatok elm\u00e9leti \u00e9s gyakorlati h\u00e1tter\u00e9\u00fcl az  \"1. A modell \u00e9s a k\u00f3d kapcsolata\" vezetett laborgyakorlat szolg\u00e1l:</p> <ul> <li>Ezt a laborgyakorlatot a hallgat\u00f3k a gyakorlatvezet\u0151 \u00fatmutat\u00e1s\u00e1val, a gyakorlatvezet\u0151vel k\u00f6z\u00f6sen vezetett m\u00f3don v\u00e9gzik/v\u00e9gezt\u00e9k el.</li> <li>A laborgyakorlathoz \u00fatmutat\u00f3 tartozik, mely r\u00e9szletekbe men\u0151en bemutatja az elm\u00e9leti h\u00e1tteret, valamint l\u00e9p\u00e9senk\u00e9nt ismerteti a megold\u00e1s elk\u00e9sz\u00edt\u00e9s\u00e9t: 1. A modell \u00e9s a k\u00f3d kapcsolata</li> </ul> <p>Erre \u00e9p\u00edtve jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Egy egyszer\u0171 .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok gyakorl\u00e1sa</li> <li>Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se</li> <li>Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1j\u00e1nak gyakorl\u00e1sa</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p> <p>C# 12-es (\u00e9s \u00fajabb) nyelvi elemek haszn\u00e1lata</p> <p>A h\u00e1zi feladat megold\u00e1sa sor\u00e1n C# 12-es, \u00e9s ann\u00e1l \u00fajabb nyelvi elemek, (pl. primary constructor) nem haszn\u00e1lhat\u00f3k, ugyanis a GitHub-on fut\u00f3 ellen\u0151rz\u0151 ezeket m\u00e9g nem t\u00e1mogatja.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-kiindulasi-keret-letoltese-az-elkeszult-megoldas-feltoltese","title":"A kiindul\u00e1si keret let\u00f6lt\u00e9se, az elk\u00e9sz\u00fclt megold\u00e1s felt\u00f6lt\u00e9se","text":"<p>A h\u00e1zi feladat kiindul\u00e1si k\u00f6rnyezet\u00e9nek publik\u00e1l\u00e1sa, valamint a megold\u00e1s bead\u00e1sa Git, GitHub \u00e9s GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. F\u0151bb l\u00e9p\u00e9sek:</p> <ol> <li>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3).</li> <li>Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t.</li> <li>A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> </ol> <p>Ezekhez itt tal\u00e1lhat\u00f3 r\u00e9szletesebb le\u00edr\u00e1s:</p> <ul> <li>Git, GitHub, GitHub Classroom</li> <li>H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata</li> </ul>"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-hazi-feladat-eloellenorzese-es-hivatalos-ertekelese","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se","text":"<p>Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut a felt\u00f6lt\u00f6tt k\u00f3d (el\u0151)ellen\u0151rz\u00e9se, \u00e9s meg lehet n\u00e9zni a kimenet\u00e9t! Err\u0151l b\u0151vebb inform\u00e1ci\u00f3 itt tal\u00e1lhat\u00f3 (mindenk\u00e9ppen olvasd el): A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#feladat-1-egy-egyszeru-net-konzol-alkalmazas-elkeszitese","title":"Feladat 1 \u2013 Egy egyszer\u0171 .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/#kiindulo-projekt","title":"Kiindul\u00f3 projekt","text":"<p>A kiindul\u00e1si k\u00f6rnyezet a <code>Feladat1</code> mapp\u00e1ban tal\u00e1lhat\u00f3, az ebben lev\u0151 <code>MusicApp.sln</code> f\u00e1jlt nyissuk meg Visual Studioban \u00e9s ebben a solutionben dolgozzunk.</p> <p>Figyelem!</p> <p>\u00daj solution \u00e9s/vagy projektf\u00e1jl l\u00e9trehoz\u00e1sa, vagy a projekt m\u00e1s/\u00fajabb .NET verzi\u00f3kra targetel\u00e9se tilos.</p> <p>A <code>Feladat1\\Input</code> mapp\u00e1ban tal\u00e1lhat\u00f3 egy <code>music.txt</code> f\u00e1jl, mely a feladat bemenetek\u00e9nt haszn\u00e1land\u00f3.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#feladat","title":"Feladat","text":"<p>Egy sz\u00f6vegf\u00e1ljban zeneszerz\u0151k/el\u0151ad\u00f3k/egy\u00fcttesek sz\u00e1mainak c\u00edmeit t\u00e1roljuk a k\u00f6vetkez\u0151 form\u00e1tumban.</p> <ul> <li>Minden szerz\u0151h\u00f6z k\u00fcl\u00f6n sor tartozik.</li> <li>Minden sorban el\u0151sz\u00f6r a szerz\u0151 neve szerepel, majd <code>;</code>-t k\u00f6vetve <code>;</code>-vel elv\u00e1lasztva sz\u00e1mok c\u00edmei.</li> <li>A f\u00e1jl tartalma \u00e9rv\u00e9nyesnek tekintend\u0151, ha \u00fcres, vagy csak whitespace (space, tab) karaktereket tartalmaz\u00f3 sorok is vannak.</li> </ul> <p>A mell\u00e9kelt music.txt f\u00e1jl tartalma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3:</p> <pre><code>Adele; Hello; Rolling in the Deep; Skyfall\nEnnio Morricone;    A Fistful Of Dollars; Man with a Harmonica\nAC/DC; Thunderstruck; T.N.T\n</code></pre> <p>Olvassuk be a f\u00e1jlt <code>Song</code> oszt\u00e1lybeli objektumok list\u00e1j\u00e1ba. Egy <code>Song</code> objektum egy dal adatait t\u00e1rolja (szerz\u0151 \u00e9s c\u00edm). A beolvas\u00e1st k\u00f6vet\u0151en \u00edrjuk ki form\u00e1zott m\u00f3don az objektumok adatait a szabv\u00e1nyos kimenetre az al\u00e1bbi form\u00e1ban:</p> <pre><code>szerz\u01511: szerz\u01511_dalc\u00edm1\nszerz\u01511: szerz\u01511_dalc\u00edm2\n...\nszerz\u01512: szerz\u01512_dalc\u00edm1\n...\nstb.\n</code></pre> <p>A mintaf\u00e1jlunk eset\u00e9ben a k\u00f6vetkez\u0151 (a f\u00e1jl tartalm\u00e1nak f\u00fcggv\u00e9ny\u00e9ben lehet elt\u00e9r\u00e9s) kimenetet szeretn\u00e9nk l\u00e1tni:</p> <p></p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#a-megvalositas-lepesei","title":"A megval\u00f3s\u00edt\u00e1s l\u00e9p\u00e9sei","text":"<p>Vegy\u00fcnk fel egy <code>Song</code> nev\u0171 oszt\u00e1lyt a projektbe (jobb katt a Solution Explorerben a projekten, a men\u00fcben Add / Class).</p> <p>Vegy\u00fck fel a sz\u00fcks\u00e9ges tagokat \u00e9s egy ezekhez passzol\u00f3 konstruktort:</p> <pre><code>public class Song\n{\n    public readonly string Artist;\n    public readonly string Title;\n\n    public Song(string artist, string title)\n    {\n        Artist = artist;\n        Title = title;\n    }\n}\n</code></pre> <p>Property</p> <p>A tagv\u00e1ltoz\u00f3kat <code>readonly</code>-k\u00e9nt vett\u00fck fel, mert nem akartuk, hogy ezek ut\u00f3lag, a konstruktor lefut\u00e1s\u00e1t k\u00f6vet\u0151en megv\u00e1ltoztathat\u00f3k legyenek. Alternat\u00edva lehetne a csak olvashat\u00f3 tulajdons\u00e1g (property) alkalmaz\u00e1sa a readonly tagv\u00e1ltoz\u00f3k helyett (ez k\u00e9s\u0151bbi tanagyag).</p> <p>A k\u00f6vetkez\u0151kben a <code>Song</code> oszt\u00e1lyunkban defini\u00e1ljuk fel\u00fcl az implicit <code>System.Object</code> \u0151sb\u0151l \u00f6r\u00f6k\u00f6lt <code>ToString</code> m\u0171veletet, hogy az az el\u0151\u00edrt form\u00e1ban adja vissza objektum adatait. A megold\u00e1sban sztring interpol\u00e1ci\u00f3t haszn\u00e1ljunk (ezt m\u00e1r alkalmaztuk az els\u0151 labor keret\u00e9ben):</p> <pre><code>public override string ToString()\n{\n    return $\"{Artist}: {Title}\";\n}\n</code></pre> <p>Sz\u00f6vegf\u00e1jl feldolgoz\u00e1s\u00e1ra legk\u00e9nyelmesebben a <code>System.IO</code> n\u00e9vt\u00e9rben lev\u0151 <code>StreamReader</code> oszt\u00e1lyt tudjuk haszn\u00e1lni.</p> <p>A <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben olvassuk fel soronk\u00e9nt a f\u00e1jlt, hozzuk l\u00e9tre a <code>Song</code> objektumokat, \u00e9s tegy\u00fck be egy <code>List&lt;Song&gt;</code> dinamikusan ny\u00fajt\u00f3zkod\u00f3 t\u00f6mbbe. Figyelj\u00fcnk arra, hogy a f\u00e1jlban a <code>;</code>-vel elv\u00e1lasztott elemek el\u0151tt/ut\u00e1n whitespace karakterek (space, tab) lehetnek, ezekt\u0151l szabaduljunk meg!</p> <p>A k\u00f6vetkez\u0151 k\u00f3d egy lehets\u00e9ges megold\u00e1st mutat, a megold\u00e1s r\u00e9szleteit a k\u00f3dkommentek magyar\u00e1zz\u00e1k. A f\u00e9l\u00e9v sor\u00e1n ez az els\u0151 \u00f6n\u00e1ll\u00f3 feladat, valamint a hallgat\u00f3k t\u00f6bbs\u00e9g\u00e9nek ez els\u0151 .NET/C# alkalmaz\u00e1sa, \u00edgy itt m\u00e9g adunk mintamegold\u00e1st, de a rutinosabb hallgat\u00f3k \u00f6n\u00e1ll\u00f3an is pr\u00f3b\u00e1lkozhatnak.</p> Megold\u00e1s <pre><code>namespace MusicApp;\n\npublic class Program\n{\n    // A Main f\u00fcggv\u00e9ny a Program oszt\u00e1lyon bel\u00fcl tal\u00e1lhat\u00f3, ezt itt nem jel\u00fclj\u00fck\n    public static void Main(string[] args)\n    {\n        // Ebben t\u00e1roljuk a dal objektumokat\n        List&lt;Song&gt; songs = new List&lt;Song&gt;();\n\n        // F\u00e1jl beolvas\u00e1sa soronk\u00e9nt, songs lista felt\u00f6lt\u00e9se\n        StreamReader sr = null;\n        try\n        {\n            // A @ jelent\u00e9se a string konstans el\u0151tt:\n            // kikapcsolja a string escape-el\u00e9st,\n            // \u00edgy nem kell a '\\' helyett '\\\\'-t \u00edrni.\n            sr = new StreamReader(@\"C:\\temp\\music.txt\");\n            string line;\n            while ((line = sr.ReadLine()) != null)\n            {\n                // Ha \u00fcres volt a sor\n                if (string.IsNullOrWhiteSpace(line))\n                    continue;\n\n                // A line v\u00e1ltoz\u00f3ban benne van az eg\u00e9sz sor,\n                // a Split-tel a ;-k ment\u00e9n feldaraboljuk\n                string[] lineItems = line.Split(';');\n\n                // Els\u0151 elem, amiben az szerz\u0151 nev\u00e9t v\u00e1rjuk\n                // A Trim elt\u00e1vol\u00edtja a vezet\u0151 \u00e9s z\u00e1r\u00f3 whitespace karaktereket\n                string artist = lineItems[0].Trim();\n\n                // Menj\u00fcnk v\u00e9gig a dalokon, \u00e9s vegy\u00fck fel a list\u00e1ba\n                for (int i = 1; i &lt; lineItems.Length; i++)\n                {\n                    Song song = new Song(artist, lineItems[i].Trim());\n                    songs.Add(song);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(\"A f\u00e1jl feldolgoz\u00e1sa sikertelen.\");\n            // Az e.Message csak a kiv\u00e9tel sz\u00f6veg\u00e9t tartalmazza. \n            // Ha minden kiv\u00e9tel inform\u00e1ci\u00f3t ki szeretn\u00e9nk \u00edrni (pl. stack trace), \n            // akkor az e.ToString()-et \u00edrjuk ki.\n            Console.WriteLine(e.Message);\n        }\n        finally\n        {\n            // L\u00e9nyeges, hogy finally blokkban z\u00e1rjuk le a f\u00e1jlt, \n            // hogy egy esetleges kiv\u00e9tel eset\u00e9n se maradjon m\u00f6g\u00f6tt\u00fcnk lez\u00e1ratlan \u00e1llom\u00e1ny.\n            // try-finally helyett haszn\u00e1lhattunk volna using blokkot,\n            // azt egyel\u0151re nem kell tudni (a f\u00e9l\u00e9v derek\u00e1n tanuljuk).\n            if (sr != null)\n                sr.Close();\n        }\n\n        // A songs lista elemeinek ki\u00edr\u00e1sa a konzolra\n        foreach (Song song in songs)\n            Console.WriteLine(song.ToString());\n    }\n}\n</code></pre> <p>A <code>c:\\temp</code> mapp\u00e1ba m\u00e1soljuk ki a <code>music.txt</code> f\u00e1jlt, \u00e9s futtassuk az alkalmaz\u00e1st. A megval\u00f3s\u00edt\u00e1s sor\u00e1n az egyszer\u0171s\u00e9gre t\u00f6rekedve mindent bele\u00f6nt\u00f6tt\u00fcnk a <code>main</code> f\u00fcggv\u00e9nybe, \u201e\u00e9les\u201d k\u00f6rnyezetben mindenk\u00e9pp c\u00e9lszer\u0171 a k\u00f3dot egy k\u00fcl\u00f6n feldolgoz\u00f3 oszt\u00e1lyba kiszervezni.</p> <p>A fenti p\u00e9ld\u00e1ban j\u00f3p\u00e1r .NET/C# alaptechnika bemutat\u00e1sra ker\u00fcl, mindenk\u00e9pen \u00e9rdemes a fenti k\u00f3dba sz\u00fart megjegyz\u00e9sek alapj\u00e1n ezeket \u00e9rtelmezni \u00e9s megtanulni, a f\u00e9l\u00e9v sor\u00e1n ezekre \u00e9p\u00edteni fogunk.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#feladat-2-az-uml-es-a-kod-kapcsolata-interfesz-es-absztrakt-os-alkalmazastechnikaja","title":"Feladat 2 - Az UML \u00e9s a k\u00f3d kapcsolata, interf\u00e9sz \u00e9s absztrakt \u0151s alkalmaz\u00e1stechnik\u00e1ja","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/#kiindulo-kornyezet","title":"Kiindul\u00f3 k\u00f6rnyezet","text":"<p>A kiindul\u00e1si k\u00f6rnyezet a <code>Feladat2</code> mapp\u00e1ban tal\u00e1lhat\u00f3, az ebben lev\u0151 <code>Shapes.sln</code> f\u00e1jlt nyissuk meg Visual Studioban, \u00e9s ebben a solutionben dolgozzunk.</p> <p>Figyelem!</p> <p>\u00daj solution \u00e9s/vagy projektf\u00e1jl l\u00e9trehoz\u00e1sa, vagy a projekt m\u00e1s/\u00fajabb .NET verzi\u00f3kra targetel\u00e9se tilos.</p> <p>A <code>Feladat2\\Shapes</code> mapp\u00e1ban tal\u00e1lhat\u00f3 egy <code>Controls.dll</code> f\u00e1jl, ezt a feladat megold\u00e1sa sor\u00e1n kell majd felhaszn\u00e1lni.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#beadando-a-forraskodon-tulmenoen","title":"Beadand\u00f3 (a forr\u00e1sk\u00f3don t\u00falmen\u0151en)","text":"<p>K\u00e9t-h\u00e1rom bekezd\u00e9sben a Feladat 2 megold\u00e1sa sor\u00e1n hozott tervez\u0151i d\u00f6nt\u00e9sek, a megold\u00e1s legfontosabb alapelveinek r\u00f6vid sz\u00f6veges \u00f6sszefoglal\u00e1sa, indokl\u00e1sa. Ezt a kiindul\u00f3 keret <code>Feladat2</code> mapp\u00e1j\u00e1ban m\u00e1r megtal\u00e1lhat\u00f3 <code>readme.md</code> sz\u00f6vegf\u00e1jlba kell bele\u00edrni tetsz\u0151leges markdown form\u00e1tumban, vagy egyszer\u0171 nyers sz\u00f6vegk\u00e9nt. Fontos, hogy a <code>Feladat2</code> mapp\u00e1ban lev\u0151 f\u00e1jlba dolgozz (akkor is, ha esetleg a gy\u00f6k\u00e9rmapp\u00e1ban is van egy azonos nev\u0171 f\u00e1jl).</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#feladat_1","title":"Feladat","text":"<p>Egy s\u00edkbeli vektorgrafikus alakzatokat kezelni k\u00e9pes CAD tervez\u0151alkalmaz\u00e1s els\u0151 v\u00e1ltozat\u00e1nak kifejleszt\u00e9s\u00e9vel b\u00edznak meg benn\u00fcnket. B\u0151vebben:</p> <ul> <li> <p>K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alakzatokat kell tudni kezelni. Kezdetben a <code>Square</code> (n\u00e9gyzet), <code>Circle</code> (k\u00f6r) \u00e9s <code>TextArea</code> t\u00edpus\u00fa alakzatokat kell t\u00e1mogatni, de a k\u00f3d legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal. A <code>TextArea</code> egy szerkeszthet\u0151 sz\u00f6vegdoboz.</p> <p>Elnevez\u00e9sek</p> <p>Az oszt\u00e1lyokat mindenk\u00e9ppen a fentieknek megfelel\u0151en nevezz\u00fck el!</p> </li> <li> <p>Az alakzatokhoz tartoz\u00f3 adatok: x \u00e9s y koordin\u00e1ta, valamint olyan adatok, melyek a megjelen\u00edt\u00e9shez \u00e9s az alakzatok ter\u00fclet\u00e9nek kisz\u00e1m\u00edt\u00e1s\u00e1hoz sz\u00fcks\u00e9gesek. Pl. n\u00e9gyzet eset\u00e9ben oldalhossz\u00fas\u00e1g, <code>TextArea</code> eset\u00e9ben sz\u00e9less\u00e9g \u00e9s magass\u00e1g, k\u00f6r eset\u00e9ben a sug\u00e1r.</p> </li> <li> <p>Minden alakzatnak biztos\u00edtania kell m\u0171veleteket t\u00edpus\u00e1nak, koordin\u00e1t\u00e1i \u00e9s ter\u00fclet\u00e9nek lek\u00e9rdez\u00e9s\u00e9hez. A t\u00edpus lek\u00e9rdez\u0151 m\u0171velet <code>string</code>-gel t\u00e9rjen vissza, illetve a be\u00e9p\u00edtett <code>Type</code> oszt\u00e1ly <code>GetType</code> m\u0171velete nem haszn\u00e1lhat\u00f3 a megval\u00f3s\u00edt\u00e1s sor\u00e1n.</p> </li> <li> <p>List\u00e1zni kell tudni a mem\u00f3ri\u00e1ban nyilv\u00e1ntartott alakzatokat a szabv\u00e1nyos kimenetre (konzolra). Ennek sor\u00e1n a k\u00f6vetkez\u0151 adatokat \u00edrjuk ki: alakzat t\u00edpusa (pl. n\u00e9gyzet eset\u00e9n <code>Square</code> stb.), a k\u00e9t koordin\u00e1ta, alakzat ter\u00fclete. A be\u00e9p\u00edtett <code>Type</code> oszt\u00e1ly <code>GetType</code> m\u0171velete nem haszn\u00e1lhat\u00f3 a t\u00edpus ki\u00edr\u00e1s sor\u00e1n.</p> </li> <li> <p>A <code>TextArea</code> oszt\u00e1lynak k\u00f6telez\u0151en a jelen feladathoz tartoz\u00f3 <code>Controls.dll</code> oszt\u00e1lyk\u00f6nyvt\u00e1r <code>Textbox</code> oszt\u00e1ly\u00e1b\u00f3l kell sz\u00e1rmaznia. A <code>Controls.dll</code> egy .NET szerelv\u00e9ny, leford\u00edtott form\u00e1ban tartalmaz oszt\u00e1lyokat.</p> <p>Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3</p> <p>B\u00e1r C# 8-t\u00f3l t\u00e1mogatott .NET interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa. Ez sokszor hasznos technika, de a megold\u00e1sban nem alkalmazhat\u00f3, enn\u00e9l \"klasszikusabb\" megk\u00f6zel\u00edt\u00e9st kell v\u00e1lasztani.</p> </li> <li> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n t\u00f6rekedjen egys\u00e9gbez\u00e1r\u00e1sra: pl. az alakzatok menedzsel\u00e9se legyen egy erre dedik\u00e1lt oszt\u00e1ly feladata.</p> <p>Failure</p> <p>Az nem elfogadhat\u00f3, ha a <code>Main</code> f\u00fcggv\u00e9nyben egy helyben l\u00e9trehozott egyszer\u0171 list\u00e1ba ker\u00fclnek az alakzatok t\u00e1rol\u00e1sra! Ezen fel\u00fcl a menedzsel\u00e9s\u00e9rt felel\u0151s oszt\u00e1ly NE sz\u00e1rmazzon a be\u00e9p\u00edtett <code>List</code> vagy hasonl\u00f3 oszt\u00e1lyb\u00f3l, hanem tartalmazza azt. Az adatok szabv\u00e1nyos kimentre t\u00f6rt\u00e9n\u0151 list\u00e1z\u00e1s\u00e1\u00e9rt ez az oszt\u00e1ly legyen a felel\u0151s.</p> </li> <li> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n t\u00f6rekedjen a k\u00f6nny\u0171 b\u0151v\u00edthet\u0151s\u00e9gre, karbantarthat\u00f3s\u00e1gra, ker\u00fclje el a k\u00f3dduplik\u00e1ci\u00f3t (tagv\u00e1ltoz\u00f3k, m\u0171veletek, konstruktorok eset\u00e9ben egyar\u00e1nt). A megold\u00e1s elfogad\u00e1s\u00e1nak ezek kiemelt szempontjai!</p> </li> <li> <p>A <code>Main</code> f\u00fcggv\u00e9nyben mutasson p\u00e9ld\u00e1t az oszt\u00e1lyok haszn\u00e1lat\u00e1ra.</p> </li> <li> <p>Legk\u00e9s\u0151bb a megval\u00f3s\u00edt\u00e1s v\u00e9g\u00e9re k\u00e9sz\u00edtsen a Visual Studio solutionben egy oszt\u00e1lydiagramot, melyen a solution oszt\u00e1lyait j\u00f3l \u00e1ttekinthet\u0151 form\u00e1ban rendezze el. Az asszoci\u00e1ci\u00f3s kapcsolatokat asszoci\u00e1ci\u00f3 form\u00e1j\u00e1ban jelen\u00edtse meg, ne tagv\u00e1ltoz\u00f3k\u00e9nt (Show as Association ill. Show as Collection Association, l\u00e1sd 1. labor \u00fatmutat\u00f3ja).</p> <p>Class Diagram komponens</p> <p>A Visual Studio 2022 nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add / New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni. Err\u0151l b\u0151vebben jelen \u00fatmutat\u00f3 Fejleszt\u0151k\u00f6rnyezet oldal\u00e1n lehet olvasni.</p> </li> </ul> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk:</p> <ul> <li>Az alakzatok kirajzol\u00e1s\u00e1t nem val\u00f3s\u00edtjuk meg (az ehhez sz\u00fcks\u00e9ges ismeretek a f\u00e9l\u00e9v sor\u00e1n k\u00e9s\u0151bb szerepelnek).</li> <li>Az alakzatokat csak a mem\u00f3ri\u00e1ban kell nyilv\u00e1ntartani.</li> </ul>"},{"location":"hazi/1-model-es-kod-kapcsolata/#osztalykonyvtarak-hasznalata","title":"Oszt\u00e1lyk\u00f6nyvt\u00e1rak haszn\u00e1lata","text":"<p>A megold\u00e1s az 1. A modell \u00e9s a k\u00f3d kapcsolata laborgyakorlat mint\u00e1j\u00e1ra kidolgozhat\u00f3. Jelen feladat egy l\u00e9nyeges r\u00e9szlet\u00e9ben k\u00fcl\u00f6nb\u00f6zik t\u0151le: m\u00edg abban csak sz\u00f3ban k\u00f6t\u00f6tt\u00fck ki, hogy a <code>DisplayBase</code> \u0151soszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztat\u00f3, jelen esetben a <code>Textbox</code> \u0151soszt\u00e1lyunk eset\u00e9ben ez adott, hiszen csak egy leford\u00edtott dll form\u00e1j\u00e1ban \u00e1ll rendelkez\u00e9sre.</p> <p>Note</p> <p>T\u00f6bbkomponens\u0171 alkalmaz\u00e1sok fejleszt\u00e9s\u00e9r\u0151l, szerelv\u00e9ny \u00e9s projekt referencia alkalmaz\u00e1s\u00e1r\u00f3l az els\u0151 el\u0151ad\u00e1son volt sz\u00f3, ha nem eml\u00e9kszel erre a t\u00e9mak\u00f6rre, c\u00e9lszer\u0171 \u00e1tism\u00e9telni.</p> <p>A k\u00f6vetkez\u0151kben n\u00e9zz\u00fck meg, milyen l\u00e9p\u00e9sekben lehet egy ilyen dll-ben lev\u0151 oszt\u00e1lyokat a k\u00f3dunkban felhaszn\u00e1lni:</p> <ol> <li>A Visual Studio Solution Explorer ablak\u00e1ban jobb gombbal kattintsunk a Dependencies elemen, \u00e9s v\u00e1lasszuk az Add Reference-t vagy Add Project Reference-t (amelyik l\u00e9tezik).</li> <li>A megjelen\u0151 ablak bal oldal\u00e1n v\u00e1lasszuk ki a Browse elemet,</li> <li>Ha az ablak k\u00f6zep\u00e9n a list\u00e1ban megjelenik a <code>Controls.dll</code>, pip\u00e1ljuk ki az elemet.</li> <li>Ha nem jelenik meg, akkor kattintsunk az ablakunk jobb als\u00f3 r\u00e9sz\u00e9ben lev\u0151 Browse... gombon.         1. A megjelen\u0151 f\u00e1jlb\u00f6ng\u00e9sz\u0151 ablakban navig\u00e1ljunk el a <code>Controls.dll</code> f\u00e1jlhoz, \u00e9s kattintsunk rajta  dupl\u00e1n, ami bez\u00e1rja az ablakot.         2. A Reference Manager ablakunk k\u00f6z\u00e9ps\u0151 r\u00e9sz\u00e9n a <code>Controls.dll</code> l\u00e1that\u00f3 kipip\u00e1lva, az OK gombbal z\u00e1rjuk be az ablakot.</li> <li>Az OK gombbal z\u00e1rjuk be az ablakot.</li> </ol> Ha esetleg 'Reference is invalid or unsupported' hiba\u00fczenetet kapsz <p>Nagyon ritk\u00e1n, de el\u0151fordulhat, hogy a fenti l\u00e9p\u00e9sek sor\u00e1n a Visual Studio a \"Reference is invalid or unsupported\" hiba\u00fczenetet jelzi. Ilyenkor az esetek t\u00f6bbs\u00e9g\u00e9ben a Visual Studio \u00fajratelep\u00edt\u00e9se seg\u00edt.</p> <p>Ezzel a projekt\u00fcnkben felvett\u00fcnk egy referenci\u00e1t a <code>Controls.dll</code>-re, \u00edgy a benne lev\u0151 oszt\u00e1lyok haszn\u00e1lhat\u00f3k (pl. lehet p\u00e9ld\u00e1nyos\u00edtani \u0151ket, vagy lehet bel\u0151l\u00fck sz\u00e1rmaztatni). A Solution Explorer-ben a Dependencies majd Assemblies csom\u00f3pontot lenyitva a Controls megjelenik:</p> <p></p> <p>A <code>Textbox</code> oszt\u00e1ly, melyb\u0151l a <code>TextArea</code> oszt\u00e1lyunkat sz\u00e1rmaztatni kell, a <code>Controls</code> n\u00e9vt\u00e9rben tal\u00e1lhat\u00f3. A <code>TextBox</code> oszt\u00e1lynak egy konstruktora van, melynek n\u00e9gy param\u00e9tere van, az x \u00e9s y koordin\u00e1t\u00e1k, valamint a sz\u00e9less\u00e9g \u00e9s a magass\u00e1g. Amennyiben sz\u00fcks\u00e9g lenne r\u00e1, a t\u00f6bbi m\u0171velet felder\u00edt\u00e9s\u00e9ben az Object Browser seg\u00edt. Az Object Browser a View men\u00fcb\u0151l az Object Browser men\u00fc kiv\u00e1laszt\u00e1s\u00e1val nyithat\u00f3 meg. Az Object Browser egy \u00faj tabf\u00fcl\u00f6n jelenik meg.</p> <p>Ha \u00fcres az Object Browser n\u00e9zet</p> <p>A Visual Studio 2022 hajlamos arra, hogy mindaddig, am\u00edg nincs egy forr\u00e1sf\u00e1jl megnyitva, az Object Browserben nem jelen\u00edt meg semmit (csak egy \"No information\" kezdet\u0171 sz\u00f6veg l\u00e1tszik). Ha azt tapasztaljuk, hogy \u00fcres az Object Browser n\u00e9zet, csak nyissuk meg a Program.cs f\u00e1jl a Solution Explorerben, majd v\u00e1ltsunk vissza az Object Browser tabf\u00fclre, ahol \u00edgy m\u00e1r megjelennek a komponensek. </p> <p>Az Object Browserben a <code>Controls</code> komponenst lenyitogatva az egyes csom\u00f3pontokat kiv\u00e1lasztva (n\u00e9vt\u00e9r, oszt\u00e1ly) az adott csom\u00f3pont jellemz\u0151i jelennek meg: pl. az oszt\u00e1ly nev\u00e9n \u00e1llva az oszt\u00e1ly tagjait l\u00e1tjuk.</p> <p></p> <p>Most m\u00e1r minden inform\u00e1ci\u00f3 rendelkez\u00e9s\u00fcnkre \u00e1ll a feladat megval\u00f3s\u00edt\u00e1s\u00e1hoz.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/#beadas","title":"Bead\u00e1s","text":"<p>Ellen\u0151rz\u0151lista ism\u00e9tl\u00e9sk\u00e9ppen:</p> <ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li> <p>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</p> </li> <li> <p>A 2. feladat sor\u00e1n ne felejtsd el a <code>readme.md</code>-ben a megold\u00e1sod bemutatni.</p> </li> </ul>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/","title":"1. HF - Beziehung zwischen Modell und Code","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Die \u00dcbung ist nicht mit einer Pr\u00e4sentation verbunden.  Den theoretischen und praktischen Hintergrund f\u00fcr die \u00dcbungen liefert das Kapitel \"1. Die Beziehung zwischen Modell und Code\" wird als angeleitete Labor\u00fcbung dienen:</p> <ul> <li>Diese Labor\u00fcbung wird von den Studierenden unter Anleitung des Tutors gemeinsam durchgef\u00fchrt.</li> <li>Die Labor\u00fcbung wird von einem Leitfaden begleitet, der einen detaillierten theoretischen Hintergrund und eine Schritt-f\u00fcr-Schritt-Anleitung f\u00fcr die Herstellung einer L\u00f6sung enth\u00e4lt: 1. Beziehung zwischen dem Modell und dem Code</li> </ul> <p>Darauf aufbauend k\u00f6nnen die Aufgaben dieser Selbst\u00fcbung mit Hilfe der k\u00fcrzeren Leitf\u00e4den, die der Aufgabenbeschreibung folgen, durchgef\u00fchrt werden.</p> <p>Das Ziel der unabh\u00e4ngigen \u00dcbung:</p> <ul> <li>Erstellen einer einfachen .NET-Anwendung, \u00dcben der C#-Grundlagen</li> <li>Veranschaulichung der Beziehung zwischen UML und Code</li> <li>Praktische Anwendung der Schnittstelle und der abstrakten primitiven Klasse</li> </ul> <p>Die erforderliche Entwicklungsumgebung wird hier beschrieben.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#laden-sie-den-ausgangsrahmen-herunter-laden-sie-die-fertige-losung-hoch","title":"Laden Sie den Ausgangsrahmen herunter, laden Sie die fertige L\u00f6sung hoch","text":"<p>Die urspr\u00fcngliche Hausaufgabenumgebung wird ver\u00f6ffentlicht und die L\u00f6sung wird \u00fcber Git, GitHub und GitHub Classroom eingereicht. Die wichtigsten Schritte:</p> <ol> <li>Erstellen Sie mit GitHub Classroom ein Repository f\u00fcr sich selbst. Sie finden die Einladungs-URL in Moodle (Sie k\u00f6nnen sie sehen, indem Sie auf den Link*\"GitHub classroom links for homework*\" auf der Startseite des Fachs klicken).</li> <li>Klonen Sie das resultierende Repository. Dazu geh\u00f6rt auch die erwartete Struktur der L\u00f6sung.</li> <li>Nachdem Sie die Aufgaben erledigt haben, \u00fcbergeben Sie Ihre L\u00f6sung alt und dr\u00fccken Sie sie alt.</li> </ol> <p>Diese werden hier ausf\u00fchrlicher beschrieben:</p> <ul> <li>Git, GitHub, GitHub Classroom</li> <li>Arbeitsablauf bei Hausaufgaben und Verwendung von Git/GitHub</li> </ul>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#vorabkontrolle-und-formale-bewertung-der-hausaufgaben","title":"Vorabkontrolle und formale Bewertung der Hausaufgaben","text":"<p>Jedes Mal, wenn Sie Code auf GitHub hochladen, f\u00fchrt GitHub automatisch eine (Vor-)Pr\u00fcfung des hochgeladenen Codes durch und Sie k\u00f6nnen das Ergebnis sehen! Weitere Informationen dazu finden Sie hier (lesen Sie sie unbedingt): Vorabkontrolle und formale Bewertung der Hausaufgaben.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#aufgabe-1-erstellen-einer-einfachen-net-konsolenanwendung","title":"Aufgabe 1 - Erstellen einer einfachen .NET-Konsolenanwendung","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#ursprungliches-projekt","title":"Urspr\u00fcngliches Projekt","text":"<p>Die anf\u00e4ngliche Umgebung befindet sich im Ordner <code>Feladat1</code>, \u00f6ffnen Sie die Datei <code>MusicApp.sln</code> in Visual Studio und arbeiten Sie in dieser L\u00f6sung.</p> <p>Achtung!</p> <p>Das Erstellen einer neuen Projektmappe und/oder Projektdatei oder die Ausrichtung des Projekts auf andere/neuere .NET-Versionen ist verboten.</p> <p>Im Ordner <code>Feladat1\\Input</code> befindet sich eine Datei <code>music.txt</code>, die als Eingabe f\u00fcr die Aufgabe verwendet werden soll.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#verfasst-am","title":"Verfasst am","text":"<p>In einem Textstring speichern wir die Titel der Lieder von Komponisten/Interpreten/Ensembles im folgenden Format.</p> <ul> <li>Jeder Autor hat eine eigene Zeile.</li> <li>Jede Zeile beginnt mit dem Namen des Autors, gefolgt von <code>;</code>, gefolgt von den Titeln der Nummern, getrennt durch <code>;</code>.</li> <li>Der Inhalt der Datei wird als g\u00fcltig angesehen, wenn Leerzeilen oder Zeilen, die nur Leerzeichen (Leerzeichen, Tabulator) enthalten, vorhanden sind.</li> </ul> <p>Der Inhalt der beigef\u00fcgten Datei music.txt ist \u00e4hnlich wie der folgende:</p> <pre><code>Adele; Hello; Rolling in the Deep; Skyfall\nEnnio Morricone;    A Fistful Of Dollars; Mann mit der Mundharmonika\nAC/DC; Thunderstruck; T.N.T\n</code></pre> <p>Lesen Sie die Datei in die Liste der Klassenobjekte <code>Song</code>.  Ein Objekt <code>Song</code> speichert die Daten (Autor und Titel) eines Liedes. Nach dem Scannen schreiben Sie die formatierten Daten der Objekte in folgendem Format auf die Standardausgabe:</p> <pre><code>autor1: Autor1_Titel1\nautor1: Autor1_Titel2\n...\nautor2: Autor2_Songtitel1\n...\nusw.\n</code></pre> <p>F\u00fcr unsere Beispieldatei m\u00f6chten wir die folgende Ausgabe sehen (die je nach Inhalt der Datei variieren kann):</p> <p></p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#schritte-der-umsetzung","title":"Schritte der Umsetzung","text":"<p>F\u00fcgen Sie dem Projekt eine Klasse mit dem Namen <code>Song</code> hinzu (Rechtsklick auf das Projekt im Solution Explorer, Men\u00fc Hinzuf\u00fcgen / Klasse).</p> <p>F\u00fcgen Sie die erforderlichen Mitglieder und einen passenden Konstruktor ein:</p> <pre><code>public class Song\n{\n    public readonly string Artist;\n    public readonly string Title;\n\n    public Song(string artist, string title)\n    {\n        Artist = artist;\n        Title = title;\n    }\n}\n</code></pre> <p>Property</p> <p>Die Mitgliedsvariablen wurden als <code>readonly</code>eingef\u00fcgt, weil wir nicht wollten, dass sie nach Ausf\u00fchrung des Konstruktors ge\u00e4ndert werden k\u00f6nnen. Eine Alternative w\u00e4re die Verwendung von schreibgesch\u00fctzten Eigenschaften anstelle von schreibgesch\u00fctzten Mitgliedsvariablen (dies ist ein sp\u00e4terer Kern).</p> <p>Im Folgenden werden wir die Operation <code>ToString</code>, die vom impliziten Vorfahren <code>System.Object</code> geerbt wurde, in unserer Klasse <code>Song</code> umdefinieren, um Objektdaten in der gew\u00fcnschten Form zur\u00fcckzugeben. Verwenden Sie die String-Interpolation in der L\u00f6sung (wir haben dies bereits in der ersten \u00dcbung verwendet):</p> <pre><code>public override string ToString()\n{\n    return $\"{Artist}: {Title}\";\n}\n</code></pre> <p>Die geeignetste Klasse zur Verarbeitung einer Textdatei ist <code>StreamReader</code> im Namensraum <code>System.IO</code>. </p> <p>In unserer Funktion <code>Main</code> lesen wir die Datei Zeile f\u00fcr Zeile ein, erstellen die <code>Song</code> Objekte und legen sie in ein <code>List&lt;Song&gt;</code> dynamisch dehnbares Array. Bitte beachten Sie, dass in der Datei vor/nach den durch <code>;</code>getrennten Elementen Leerzeichen (Space, Tab) stehen k\u00f6nnen, entfernen Sie diese!</p> <p>Der folgende Code zeigt eine m\u00f6gliche L\u00f6sung, deren Einzelheiten in den Codekommentaren erl\u00e4utert werden. Dies ist die erste eigenst\u00e4ndige Aufgabe des Semesters und f\u00fcr die meisten Studenten die erste Anwendung von .NET/C#, daher geben wir Ihnen eine Musterl\u00f6sung, aber erfahrenere Studenten k\u00f6nnen es auch selbst versuchen.</p> L\u00f6sung <pre><code>namespace MusicApp;\n\npublic class Program\n{\n    // Die Funktion Main befindet sich innerhalb der Klasse Program, die hier nicht gezeigt wird\n    public static void Main(string[] args)\n    {\n        // Hier werden die Liedobjekte gespeichert\n        Liste&lt;Song&gt; songs = new List&lt;Song&gt;();\n\n        // Datei zeilenweise durchsuchen, Liederliste hochladen\n        StreamReader sr = null;\n        try\n        {\n            // @ steht f\u00fcr @ vor der Zeichenkettenkonstante:\n            // Deaktiviert String Escape,\n            // damit Sie nicht '\\\\' statt '\\\\' schreiben m\u00fcssen.\n            sr = new StreamReader(@\"C:\\temp\\music.txt\");\n            string line;\n            while ((line = sr.ReadLine()) != null)\n            {\n                // Wenn die Warteschlange leer war\n                if (string.IsNullOrWhiteSpace(line))\n                    continue;\n\n                // Die Zeilenvariable enth\u00e4lt die gesamte Zeile,\n                // geteilt entlang der ;- mit Split\n                string[] lineItems = line.Split(';');\n\n                // Erstes Element, in dem wir den Namen des Autors erwarten\n                // Trim entfernt f\u00fchrende und nachfolgende Wei\u00dfraumzeichen\n                string artist = lineItems[0].Trim();\n\n                // Gehen Sie die Lieder durch und f\u00fcgen Sie sie der Liste hinzu\n                for (int i = 1; i &lt; lineItems.Length; i++)\n                {\n                    Song song = new Song(artist, lineItems[i].Trim());\n                    songs.Add(song);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(\"Die Datei konnte nicht verarbeitet werden.\");\n            // e.Message enth\u00e4lt nur den Text der Ausnahme. \n            // Wenn Sie alle Ausnahmeinformationen (z.B. Stacktrace) ausgeben m\u00f6chten, \n            // dann wird e.ToString() gedruckt.\n            Console.WriteLine(e.Message);\n        }\n        finally\n        {\n            // Es ist wichtig, dass die Datei abschlie\u00dfend in einem Block geschlossen wird, \n            // um sicherzustellen, dass wir im Falle einer Ausnahme keine offene Datei haben.\n            // Wir h\u00e4tten einen using-Block anstelle von try-finally verwenden k\u00f6nnen,\n            // Das brauchen Sie noch nicht zu wissen (wir werden es in der Mitte des Semesters lernen).\n            if (sr != null)\n                sr.Close();\n        }\n\n        // Ausgabe der Lieder in der Liste auf der Konsole\n        foreach (Song song in songs)\n            Console.WriteLine(song.ToString());\n    }\n}\n</code></pre> <p>Kopieren Sie die Datei \"music.txt\" in den Ordner \"c:\\temp\" und starten Sie die Anwendung. Der Einfachheit halber haben wir alles in die Funktion <code>main</code> aufgenommen, aber in einer \"Live\"-Umgebung ist es ratsam, den Code in eine separate Verarbeitungsklasse auszulagern.</p> <p>Im obigen Beispiel werden eine Reihe grundlegender .NET/C#-Techniken vorgestellt. Es lohnt sich auf jeden Fall, sie zu interpretieren und aus den Notizen im obigen Code zu lernen, und wir werden im Laufe des Semesters auf ihnen aufbauen.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#aufgabe-2-beziehung-zwischen-uml-und-code-schnittstellen-und-abstrakten-anwendungstechniken","title":"Aufgabe 2 - Beziehung zwischen UML und Code, Schnittstellen und abstrakten Anwendungstechniken","text":""},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#ursprungliche-umgebung","title":"Urspr\u00fcngliche Umgebung","text":"<p>Die anf\u00e4ngliche Umgebung befindet sich im Ordner <code>Feladat2</code>, \u00f6ffnen Sie die Datei <code>Shapes.sln</code> in Visual Studio und arbeiten Sie in dieser L\u00f6sung.</p> <p>Achtung!</p> <p>Das Erstellen einer neuen Projektmappe und/oder Projektdatei oder die Ausrichtung des Projekts auf andere/neuere .NET-Versionen ist verboten.</p> <p>Es gibt eine Datei <code>Controls.dll</code> im Ordner <code>Feladat2\\Shapes</code>, die Sie zur L\u00f6sung des Problems verwenden m\u00fcssen.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#einzureichen-zusatzlich-zum-quellcode","title":"Einzureichen (zus\u00e4tzlich zum Quellcode)","text":"<p>In zwei bis drei Abs\u00e4tzen eine kurze textliche Zusammenfassung der bei der L\u00f6sung von Aufgabe 2 getroffenen Entwurfsentscheidungen, der wichtigsten Grunds\u00e4tze der L\u00f6sung und der Begr\u00fcndung daf\u00fcr. Dies sollte in die Textdatei <code>readme.md</code> geschrieben werden, die sich bereits im Ordner <code>Feladat2</code> des urspr\u00fcnglichen Frames befindet, in einem beliebigen Markdown-Format oder als einfacher Text. Es ist wichtig, in der Datei im Ordner <code>Feladat2</code> zu arbeiten (auch wenn es eine Datei mit demselben Namen im Stammordner gibt).</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#verfasst-am_1","title":"Verfasst am","text":"<p>Wir haben die Aufgabe, die erste Version einer CAD-Anwendung zu entwickeln, die fl\u00e4chige Vektorgrafiken verarbeiten kann. Lesen Sie mehr:</p> <ul> <li> <p>Sie m\u00fcssen in der Lage sein, verschiedene Arten von Formen zu bearbeiten. Zun\u00e4chst sollten <code>Square</code> (Quadrat), <code>Circle</code> (Kreis) und <code>TextArea</code> unterst\u00fctzt werden, aber der Code sollte leicht um neue Typen erweiterbar sein.  <code>TextArea</code> ist ein editierbares Textfeld.</p> <p>Namen</p> <p>Achten Sie darauf, dass Sie die Klassen entsprechend den obigen Angaben benennen!</p> </li> <li> <p>Die mit den Formen verbundenen Daten: x- und y-Koordinaten sowie Daten, die f\u00fcr die Visualisierung und die Berechnung des Fl\u00e4cheninhalts der Formen erforderlich sind. Zum Beispiel Seitenl\u00e4nge f\u00fcr ein Quadrat, Breite und H\u00f6he f\u00fcr <code>TextArea</code>, Radius f\u00fcr einen Kreis.</p> </li> <li> <p>Jede Form muss Operationen zur Abfrage ihres Typs, ihrer Koordinaten und ihrer Fl\u00e4che bieten. Die Typabfrageoperation sollte <code>string</code>zur\u00fcckgeben, und die Operation <code>GetType</code> der eingebauten Klasse <code>Type</code> sollte in der Implementierung nicht verwendet werden.</p> </li> <li> <p>Sie m\u00fcssen in der Lage sein, die im Speicher abgelegten Formen auf der Standardausgabe (Konsole) aufzulisten. Die folgenden Daten werden geschrieben: Art der Form (z. B. f\u00fcr ein Quadrat <code>Square</code> usw.), die beiden Koordinaten, Fl\u00e4che der Form. Die Operation <code>GetType</code> der eingebauten Klasse <code>Type</code> kann nicht in der Typdeklaration verwendet werden.</p> </li> <li> <p>Die Klasse <code>TextArea</code> muss aus der Klasse <code>Textbox</code> der Klassenbibliothek <code>Controls.dll</code> f\u00fcr diese Aufgabe stammen.  <code>Controls.dll</code> ist eine .NET-Assembly, die kompiliert wurde, um Klassen zu enthalten.</p> <p>Standardimplementierung in Schnittstelle</p> <p>Geben Sie die Standardimplementierung in der .NET-Schnittstelle an, die in C# 8 und h\u00f6her unterst\u00fctzt wird. Dies ist oft eine n\u00fctzliche Technik, die aber bei der L\u00f6sung nicht anwendbar ist; es sollte ein eher \"klassischer\" Ansatz gew\u00e4hlt werden.</p> </li> <li> <p>Bei der Umsetzung ist eine Vereinheitlichung anzustreben: z.B. sollte die Verwaltung der Formen in die Zust\u00e4ndigkeit einer eigenen Abteilung fallen.</p> <p>Failure</p> <p>Es ist nicht zul\u00e4ssig, Formen in einer lokal erzeugten einfachen Liste in der Funktion <code>Main</code> zu speichern! Au\u00dferdem sollte die Klasse, die f\u00fcr die Verwaltung zust\u00e4ndig ist, NICHT von der eingebauten Klasse <code>List</code> oder einer \u00e4hnlichen Klasse abgeleitet werden, sondern sie sollte diese enthalten. Diese Abteilung sollte f\u00fcr die Auflistung der Daten in einer Standardausgabe zust\u00e4ndig sein.</p> </li> <li> <p>Streben Sie bei der Implementierung nach einfacher Erweiterbarkeit, Wartbarkeit und Vermeidung von doppeltem Code (f\u00fcr Mitgliedsvariablen, Operationen, Konstruktoren). Dies sind die wichtigsten Kriterien f\u00fcr die Annahme der L\u00f6sung!</p> </li> <li> <p>Zeigen Sie ein Beispiel f\u00fcr die Verwendung von Klassen in der Funktion <code>Main</code>. </p> </li> <li> <p>Sp\u00e4testens am Ende der Implementierung erstellen Sie in Visual Studio Solution ein Klassendiagramm, in dem Sie die Klassen der L\u00f6sung \u00fcbersichtlich anordnen k\u00f6nnen. Zeigen Sie Assoziationsbeziehungen als Assoziation, nicht als Mitgliedsvariable*(Als Assoziation anzeigen* oder*Als Assoziation* anzeigen). Als Sammlungsverband anzeigen, siehe Laboranleitung 1).</p> <p>Klassendiagrammkomponente</p> <p>Visual Studio 2022 f\u00fcgt die Klassendesignerkomponente bei der Installation nicht immer hinzu. Wenn es nicht m\u00f6glich ist, ein Klassendiagramm zum Visual Studio-Projekt hinzuzuf\u00fcgen (weil das Klassendiagramm nicht in der Liste des Fensters aufgef\u00fchrt ist, das w\u00e4hrend des Befehls Hinzuf\u00fcgen / Neues Element erscheint), muss die Komponente Klassendiagramm nachtr\u00e4glich installiert werden. Weitere Informationen hierzu finden Sie auf der Seite Entwicklungsumgebung in diesem Handbuch.</p> </li> </ul> <p>Wir nehmen erhebliche Vereinfachungen bei der Umsetzung vor:</p> <ul> <li>Formen werden nicht gezeichnet (die notwendigen F\u00e4higkeiten werden sp\u00e4ter im Semester behandelt).</li> <li>Die Formen sollten nur im Speicher aufgezeichnet werden.</li> </ul>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#verwendung-von-klassenbibliotheken","title":"Verwendung von Klassenbibliotheken","text":"<p>Die L\u00f6sung ist 1. Die Beziehung zwischen dem Modell und dem Code kann auf der Grundlage einer Labor\u00fcbung entwickelt werden. Die vorliegende Aufgabe unterscheidet sich in einem wichtigen Detail: W\u00e4hrend wir nur verbal feststellten, dass der Quellcode der Vorfahrenklasse <code>DisplayBase</code> nicht ver\u00e4nderbar ist, ist dies im Fall unserer Vorfahrenklasse <code>Textbox</code> eine Selbstverst\u00e4ndlichkeit, da sie nur als kompilierte DLL verf\u00fcgbar ist.</p> <p>Note</p> <p>Die Entwicklung von Mehrkomponentenanwendungen, die Zusammenstellung und die Projektreferenz wurden in der ersten Vorlesung behandelt; wenn Sie sich nicht an dieses Thema erinnern, lohnt es sich, es zu wiederholen.</p> <p>Im Folgenden werden wir uns die Schritte zur Verwendung der Klassen in einer solchen DLL in unserem Code ansehen:</p> <ol> <li>Klicken Sie im Fenster Visual Studio Solution Explorer mit der rechten Maustaste auf Abh\u00e4ngigkeiten und w\u00e4hlen Sie Verweis hinzuf\u00fcgen oder Projektverweis hinzuf\u00fcgen(je nachdem, was vorhanden ist).</li> <li>W\u00e4hlen Sie auf der linken Seite des angezeigten Fensters Browse,</li> <li>Wenn <code>Controls.dll</code> in der Liste in der Mitte des Fensters erscheint, deaktivieren Sie das Kontrollk\u00e4stchen.</li> <li>Wenn sie nicht angezeigt wird, klicken Sie auf die Schaltfl\u00e4che Durchsuchen... unten rechts im Fenster.         1. Navigieren Sie im angezeigten Dateibrowser-Fenster zur Datei <code>Controls.dll</code> und doppelklicken Sie darauf, um das Fenster zu schlie\u00dfen.         2. In der Mitte des Referenzmanager-Fensters sehen Sie das H\u00e4kchen bei <code>Controls.dll</code>. Klicken Sie auf OK, um das Fenster zu schlie\u00dfen.</li> <li>Klicken Sie auf OK, um das Fenster zu schlie\u00dfen.</li> </ol> Sehr selten, aber es kann vorkommen, dass Visual Studio eine Fehlermeldung <p>Referenz ist ung\u00fcltig oder wird nicht unterst\u00fctzt\" anzeigt, wenn Sie die oben genannten Schritte ausf\u00fchren. In den meisten F\u00e4llen hilft eine Neuinstallation von Visual Studio.</p> <p>Damit haben wir in unserem Projekt einen Verweis auf <code>Controls.dll</code>hinzugef\u00fcgt, so dass die darin enthaltenen Klassen verwendet werden k\u00f6nnen (z. B. k\u00f6nnen sie instanziiert oder von ihnen abgeleitet werden). Wenn Sie im Projektmappen-Explorer auf Abh\u00e4ngigkeiten und dann auf Baugruppen klicken, werden Steuerelemente angezeigt:</p> <p></p> <p>Die Klasse <code>Textbox</code>, von der unsere Klasse <code>TextArea</code> abgeleitet werden soll, befindet sich im Namespace <code>Controls</code>.  Die Klasse <code>TextBox</code> hat einen Konstruktor mit vier Parametern, den x- und y-Koordinaten sowie der Breite und H\u00f6he. Bei Bedarf kann der Object Browser *Ihnen helfen, andere Operationen zu entdecken. Der *Object Browser *kann durch Auswahl des Men\u00fcs *Object Browser *aus dem Men\u00fc *Ansicht ge\u00f6ffnet werden. Der *Object Browser *wird in einer neuen Registerkarte angezeigt.</p> <p>Wenn die Objektbrowser-Ansicht leer ist</p> <p>Visual Studio 2022 zeigt im Objektbrowser nichts an (nur den Text \"Keine Informationen\"), solange keine Quelldatei ge\u00f6ffnet ist. Wenn Sie feststellen, dass die Object Browser-Ansicht leer ist, \u00f6ffnen Sie einfach die Datei Program.cs im Projektmappen-Explorer und wechseln Sie zur\u00fcck zur Registerkarte Object Browser, wo die Komponenten nun angezeigt werden. </p> <p>Wenn Sie im *Object Browser *auf die Komponente <code>Controls</code> klicken und jeden Knoten (Namensraum, Klasse) ausw\u00e4hlen, werden die Attribute dieses Knotens angezeigt: Wenn Sie z. B. auf den Klassennamen klicken, werden die Mitglieder der Klasse angezeigt.</p> <p></p> <p>Wir haben nun alle Informationen, die wir zur Erf\u00fcllung der Aufgabe ben\u00f6tigen.</p>"},{"location":"hazi/1-model-es-kod-kapcsolata/index_ger/#vorlegen-bei","title":"Vorlegen bei","text":"<p>Checkliste f\u00fcr Wiederholungen:</p> <ul> <li>Geben Sie in der Datei neptun.txt im Stammverzeichnis des Repositorys Ihren Neptun-Code in Gro\u00dfbuchstaben ein. Die Datei sollte nur diese sechs Zeichen enthalten und nichts anderes.</li> <li>Sie sollten in den urspr\u00fcnglichen L\u00f6sungen/Projekten arbeiten, die Sie von GitHub heruntergeladen haben, und nicht in neu erstellten Projekten.</li> <li>Solange Sie nicht mit Visual Studio Git vertraut sind, sollten Sie nach dem Push (sp\u00e4testens wenn die Hausarbeit als eingereicht gilt) \u00fcberpr\u00fcfen, ob Sie alle \u00c4nderungen hochgeladen haben, indem Sie sich die Dateien im Repository auf der GitHub-Weboberfl\u00e4che ansehen.</li> <li>\u00dcberpr\u00fcfen Sie in der GitHub-Schnittstelle nach dem Push, ob der GitHub Action-basierte Pre-Validator fehlerfrei gelaufen ist.</li> <li>Es ist wichtig, dass Aufgaben nur angenommen werden, wenn sie vollst\u00e4ndig abgeschlossen sind und den Anforderungen in jeder Hinsicht entsprechen. Nicht rotierenden Codes oder Teill\u00f6sungen sollte man nicht trauen.</li> <li> <p>Nat\u00fcrlich m\u00fcssen Sie Ihre eigene Arbeit einreichen (da sie bewertet wird).</p> </li> <li> <p>Vergessen Sie bei Aufgabe 2 nicht, Ihre L\u00f6sung unter <code>readme.md</code>einzureichen.</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/","title":"2. HF - Nyelvi eszk\u00f6z\u00f6k","text":""},{"location":"hazi/2-nyelvi-eszkozok/#bevezetes","title":"Bevezet\u00e9s","text":"<p>Az \u00f6n\u00e1ll\u00f3 feladat a 2. el\u0151ad\u00e1son \u00e9s a 3. el\u0151ad\u00e1s els\u0151 fel\u00e9ben elhangzottakra \u00e9p\u00edt (ezek a \"El\u0151ad\u00e1s 02 - Nyelvi eszk\u00f6z\u00f6k\" el\u0151ad\u00e1sanyagban szerepelnek). Gyakorlati h\u00e1tter\u00e9\u00fcl a 2. labor - Nyelvi eszk\u00f6z\u00f6k laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Tulajdons\u00e1gok (property) haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Deleg\u00e1tok (delegate) \u00e9s esem\u00e9nyek (event) alkalmaz\u00e1sa</li> <li>.NET attrib\u00fatumok haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Alapvet\u0151 gy\u0171jtem\u00e9nyt\u00edpusok haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Lambda kifejez\u00e9sek gyakorl\u00e1sa</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p> <p>C# 12-es (\u00e9s \u00fajabb) nyelvi elemek haszn\u00e1lata</p> <p>A h\u00e1zi feladat megold\u00e1sa sor\u00e1n C# 12-es, \u00e9s ann\u00e1l \u00fajabb nyelvi elemek, (pl. primary constructor) nem haszn\u00e1lhat\u00f3k, ugyanis a GitHub-on fut\u00f3 ellen\u0151rz\u0151 ezeket m\u00e9g nem t\u00e1mogatja.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#beadas-menete-eloellenorzo","title":"Bead\u00e1s menete, el\u0151ellen\u0151rz\u0151","text":"<p>A bead\u00e1s menete megegyezik az els\u0151 h\u00e1zi feladat\u00e9val (r\u00e9szletes le\u00edr\u00e1s a szok\u00e1sos helyen, l\u00e1sd H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata):</p> <ol> <li>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik).</li> <li>Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t.</li> <li>A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> </ol> <p>Az el\u0151ellen\u0151rz\u0151 is a szok\u00e1sos m\u00f3don m\u0171k\u00f6dik. R\u00e9szletes le\u00edr\u00e1s: A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-1-baljos-arnyak","title":"Feladat 1 \u2013 Balj\u00f3s \u00e1rnyak","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat","title":"Feladat","text":"<p>Amint az k\u00f6zismert, a jedi lovagok erej\u00e9t a sejtjeikben \u00e9l\u0151 kis \u00e9letform\u00e1k, a midi-chlorianok adj\u00e1k. Az eddigi legmagasabb midi-chlorian szintet (20.000 f\u00f6l\u00f6tti \u00e9rt\u00e9ket) Anakin Skywalkern\u00e9l m\u00e9rt\u00e9k.</p> <p>K\u00e9sz\u00edts egy oszt\u00e1lyt <code>Jedi</code> n\u00e9ven mely egy <code>string</code> t\u00edpus\u00fa <code>Name</code> \u00e9s egy <code>int</code> t\u00edpus\u00fa <code>MidiChlorianCount</code> tulajdons\u00e1ggal rendelkezik. Ut\u00f3bbi eset\u00e9ben figyelj r\u00e1, hogy a <code>MidiChlorianCount</code> \u00e9rt\u00e9k\u00e9t ne lehessen 35-re, vagy ann\u00e1l kisebb \u00e9rt\u00e9kre \u00e1ll\u00edtani, ha ezzel pr\u00f3b\u00e1lkozik valaki, az oszt\u00e1lynak kiv\u00e9telt kell dobnia. A valid\u00e1ci\u00f3 sor\u00e1n a lehet\u0151 legegyszer\u0171bb, legletisztultabb megold\u00e1st v\u00e1laszd: a property setterben egyszer\u0171 <code>if</code>-et haszn\u00e1lj \u00e9s dobj kiv\u00e9telt, ne legyen az <code>if</code>-nek <code>else</code> \u00e1ga, valamint nincs sz\u00fcks\u00e9g a <code>return</code> haszn\u00e1lat\u00e1ra sem.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor 1. feladat\u00e1val anal\u00f3g m\u00f3don k\u00e9sz\u00edthet\u0151 el. A <code>MidiChlorianCount</code> tulajdons\u00e1g setter\u00e9ben \u00e9rv\u00e9nytelen \u00e9rt\u00e9k eset\u00e9n dobj kiv\u00e9telt. Ezt p\u00e9ld\u00e1ul a k\u00f6vetkez\u0151 utas\u00edt\u00e1ssal tehet\u0151 meg:</p> <pre><code>throw new ArgumentException(\"You are not a true jedi!\");\n</code></pre>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-2-a-klonok-tamadasa","title":"Feladat 2 \u2013 A kl\u00f3nok t\u00e1mad\u00e1sa","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_1","title":"Feladat","text":"<p>Eg\u00e9sz\u00edtsd ki az 1. feladatban elk\u00e9sz\u00edtett oszt\u00e1lyt attrib\u00fatumokkal \u00fagy, hogy amennyiben az <code>XmlSerializer</code> oszt\u00e1ly seg\u00edts\u00e9g\u00e9vel, XML form\u00e1tum\u00fa adatf\u00e1jlba \u00edrunk/soros\u00edtunk ki egy <code>Jedi</code> objektumot, a tulajdons\u00e1gai egy-egy XML attrib\u00fatum form\u00e1j\u00e1ban, magyarul jelenjenek meg! Ezt k\u00f6vet\u0151en \u00edrj egy f\u00fcggv\u00e9nyt, mely a <code>Jedi</code> oszt\u00e1ly egy p\u00e9ld\u00e1ny\u00e1t egy sz\u00f6vegf\u00e1jlba soros\u00edtja, majd onnan visszaolvassa egy \u00faj objektumba (ezzel tulajdonk\u00e9ppen kl\u00f3nozva az eredeti objektumot).</p> <p>XML soros\u00edt\u00f3 attrib\u00fatumai</p> <p>Az XML soros\u00edt\u00e1st szab\u00e1lyoz\u00f3 attrib\u00fatumokat ne tagv\u00e1ltoz\u00f3k, hanem a property-k felett helyezd el!</p> <p>A Jedi oszt\u00e1ly legyen publikus</p> <p>Az XML soros\u00edt\u00f3 csak publikus oszt\u00e1lyokon tud dolgozni, ennek megfelel\u0151en a Jedi oszt\u00e1ly legyen publikus: <pre><code>public class Jedi { ...}\n</code></pre></p> <p>Fontos</p> <p>A ment\u00e9st \u00e9s bet\u00f6lt\u00e9st v\u00e9gz\u0151/demonstr\u00e1l\u00f3 k\u00f3dot \u00edrd egy k\u00f6z\u00f6s, erre dedik\u00e1lt f\u00fcggv\u00e9nybe, a f\u00fcggv\u00e9nyt pedig l\u00e1sd el a <code>[Description(\"Feladat2\")]</code> C# attrib\u00fatummal (a f\u00fcggv\u00e9ny el\u0151tti sorba kell be\u00edrni). A mentett/bet\u00f6lt\u00f6tt objektum lok\u00e1lis v\u00e1ltoz\u00f3k\u00e9nt legyen ebben a f\u00fcggv\u00e9nyben megval\u00f3s\u00edtva. Az oszt\u00e1ly/f\u00fcggv\u00e9ny neve b\u00e1rmi lehet (pl. ker\u00fclhet a <code>Program</code> oszt\u00e1lyba is). A f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l. A fenti attrib\u00fatum haszn\u00e1lat\u00e1hoz using-olni kell a <code>System.ComponentModel</code> n\u00e9vteret.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_1","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor 4. feladat\u00e1val anal\u00f3g m\u00f3don k\u00e9sz\u00edthet\u0151 el. A megold\u00e1shoz az al\u00e1bbi seg\u00edts\u00e9geket adjuk:</p> <ul> <li> <p>A soros\u00edt\u00e1st k\u00f6vet\u0151en az XML f\u00e1jlnak ehhez hasonl\u00f3an kell kin\u00e9znie:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;Jedi xmlns:xsi=\"...\" Nev=\"Obi-Wan\" MidiChlorianSzam=\"15000\" /&gt;\n</code></pre> <p>L\u00e9nyeges, hogy az egyes Jedik <code>Jedi</code> XML elemk\u00e9nt, nev\u00fck <code>Nev</code>, a midichloriansz\u00e1muk <code>MidiChlorianSzam</code> XML attrib\u00fatumk\u00e9nt jelenjen meg.</p> </li> <li> <p>A soros\u00edtott objektumok visszat\u00f6lt\u00e9s\u00e9re a labor sor\u00e1n nem n\u00e9zt\u00fcnk p\u00e9ldak\u00f3dot, ez\u00e9rt ezt itt megadjuk:</p> <pre><code>var serializer = new XmlSerializer(typeof(Jedi));\nvar stream = new FileStream(\"jedi.txt\", FileMode.Open);\nvar clone = (Jedi)serializer.Deserialize(stream);\nstream.Close();\n</code></pre> <p>Az el\u0151z\u0151 m\u0171veletsor el\u0151sz\u00f6r l\u00e9trehoz egy soros\u00edt\u00f3t (<code>serializer</code>), mellyel majd a beolvas\u00e1st k\u00e9s\u0151bb elv\u00e9gezz\u00fck. A beolvas\u00e1st egy <code>jedi.txt</code> nev\u0171 f\u00e1jlb\u00f3l fogjuk v\u00e9gezni, amelyet a m\u00e1sodik sorban olvas\u00e1sra nyitunk meg (figyelj\u00fck meg, hogy ha \u00edrni akartuk volna, akkor<code>FileMode.Create</code>-et kellett volna megadni).</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-3-a-sith-ek-bosszuja","title":"Feladat 3 \u2013 A Sith-ek bossz\u00faja","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_2","title":"Feladat","text":"<p>A Jeditan\u00e1csban az ut\u00f3bbi id\u0151ben nagy a fluktu\u00e1ci\u00f3. Hogy a v\u00e1ltoz\u00e1sokat k\u00f6nnyebben nyomon k\u00f6vethess\u00fck, k\u00e9sz\u00edts egy oszt\u00e1lyt, mely k\u00e9pes nyilv\u00e1ntartani a tan\u00e1cs tagjait \u00e9s minden v\u00e1ltoz\u00e1sr\u00f3l egy esem\u00e9ny form\u00e1j\u00e1ban sz\u00f6veges \u00e9rtes\u00edt\u00e9st k\u00fcldeni! A lista manipul\u00e1ci\u00f3j\u00e1t k\u00e9t f\u00fcggv\u00e9nnyel lehessen v\u00e9gezni. Az <code>Add</code> f\u00fcggv\u00e9ny egy \u00faj jedi lovagot regisztr\u00e1ljon a tan\u00e1csba, m\u00edg a <code>Remove</code> f\u00fcggv\u00e9ny t\u00e1vol\u00edtsa el a legutolj\u00e1ra felvett tan\u00e1cstagot. K\u00fcl\u00f6n \u00e9rtes\u00edt\u00e9s jelezze, ha a tan\u00e1cs teljesen ki\u00fcr\u00fcl (ehhez ugyanazt az esem\u00e9nyt haszn\u00e1ld, mint a t\u00f6bbi v\u00e1ltoz\u00e1s eset\u00e9n, csak m\u00e1s sz\u00f6veggel jelezze).</p> <p>A tan\u00e1cstagok (<code>members</code>) nyilv\u00e1ntart\u00e1s\u00e1t egy <code>List&lt;Jedi&gt;</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3ban t\u00e1roljuk, az <code>Add</code> f\u00fcggv\u00e9ny ehhez a list\u00e1hoz f\u0171zze hozz\u00e1 az \u00faj elemeket, m\u00edg a <code>Remove</code> f\u00fcggv\u00e9ny generikus lista <code>RemoveAt</code> utas\u00edt\u00e1s\u00e1val mindig a legutolj\u00e1ra felvett tagot t\u00e1vol\u00edtsa el (az utols\u00f3 elem index\u00e9t a lista hossza alapj\u00e1n tudjuk meghat\u00e1rozni, melyet a <code>Count</code> property ad vissza).</p> <p>Az \u00e9rtes\u00edt\u00e9s egy C# esem\u00e9nyen (C# event) kereszt\u00fcl t\u00f6rt\u00e9njen. Az esem\u00e9nyhez tartoz\u00f3 delegate t\u00edpus param\u00e9terk\u00e9nt egy egyszer\u0171 <code>string</code>-et kapjon. Az \u00faj tag hozz\u00e1ad\u00e1s\u00e1t, az egyes tagok elt\u00e1vol\u00edt\u00e1s\u00e1t, illetve az utols\u00f3 tag elt\u00e1vol\u00edt\u00e1s\u00e1t m\u00e1s-m\u00e1s sz\u00f6veg\u0171 \u00fczenet jelezze. Az esem\u00e9ny els\u00fct\u00e9s\u00e9t k\u00f6zvetlen\u00fcl az <code>Add</code> \u00e9s a <code>Remove</code> m\u0171veletekben v\u00e9gezd el (ne vezess be erre seg\u00e9df\u00fcggv\u00e9nyt).</p> <p>Az esem\u00e9ny t\u00edpus\u00e1nak ne haszn\u00e1lj be\u00e9p\u00edtett delegate t\u00edpust, hanem vezess be egy saj\u00e1tot.</p> <p>Fontos</p> <p>A Jeditan\u00e1cs objektumot l\u00e9trehoz\u00f3 \u00e9s azt tesztel\u0151 (C# esem\u00e9ny\u00e9re val\u00f3 feliratkoz\u00e1s, <code>Add</code> \u00e9s <code>Remove</code> h\u00edv\u00e1sa) k\u00f3d ker\u00fclj\u00f6n egy k\u00f6z\u00f6s, \u00f6n\u00e1ll\u00f3 f\u00fcggv\u00e9nybe, ezt a f\u00fcggv\u00e9nyt pedig l\u00e1sd el a <code>[Description(\"Feladat3\")]</code> C# attrib\u00fatummal.   Az oszt\u00e1ly/f\u00fcggv\u00e9ny neve b\u00e1rmi lehet.   A f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.   A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_2","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1sa a 2. labor t\u00f6bb r\u00e9szlet\u00e9re is \u00e9p\u00edt. Az \u00faj esem\u00e9ny bevezet\u00e9s\u00e9t a 2. \u00e9s a 3. feladatban le\u00edrt m\u00f3don tudjuk elv\u00e9gezni, m\u00edg a tan\u00e1cs tagjait egy list\u00e1ban tudjuk nyilv\u00e1ntartani.</p> <p>A fenti inform\u00e1ci\u00f3k alapj\u00e1n pr\u00f3b\u00e1ld meg \u00f6n\u00e1ll\u00f3an megoldani a feladatot, majd ha k\u00e9szen vagy, a k\u00f6vetkez\u0151 kinyithat\u00f3 blokkban folytasd az \u00fatmutat\u00f3 olvas\u00e1s\u00e1t \u00e9s vesd \u00f6ssze a megold\u00e1sodat a lenti referencia megold\u00e1ssal! Sz\u00fcks\u00e9g szerint korrig\u00e1ld a saj\u00e1t megold\u00e1sod!</p> <p>Publikus l\u00e1that\u00f3s\u00e1g</p> <p>A p\u00e9lda \u00e9p\u00edt arra, hogy a r\u00e9sztvev\u0151 oszt\u00e1lyok, tulajdons\u00e1gok, delegate-ek publikus l\u00e1that\u00f3s\u00e1g\u00faak. Amennyiben fura ford\u00edt\u00e1si hib\u00e1val tal\u00e1lkozol, vagy az <code>XmlSerializer</code> fut\u00e1sid\u0151ben hib\u00e1t dob, els\u0151 k\u00f6rben azt ellen\u0151rizd, hogy minden \u00e9rintett helyen megfelel\u0151en be\u00e1ll\u00edtottad-e a publikus l\u00e1that\u00f3s\u00e1got.</p> Referencia megold\u00e1s <p>A referencia megold\u00e1s l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ol> <li>Hozzunk l\u00e9tre egy \u00faj oszt\u00e1lyt, <code>JediCouncil</code> n\u00e9ven.</li> <li>Vegy\u00fcnk fel egy <code>List&lt;Jedi&gt;</code> t\u00edpus\u00fa mez\u0151t \u00e9s inicializ\u00e1ljuk egy \u00fcres list\u00e1val.</li> <li> <p>Val\u00f3s\u00edtsuk meg az <code>Add</code> \u00e9s a <code>Remove</code> f\u00fcggv\u00e9nyeket.</p> <p>A fenti l\u00e9p\u00e9seket k\u00f6vet\u0151en az al\u00e1bbi k\u00f3dot kapjuk:</p> <pre><code>public class JediCouncil\n{\n    List&lt;Jedi&gt; members = new List&lt;Jedi&gt;();\n\n    public void Add(Jedi newJedi)\n    {\n        members.Add(newJedi);\n    }\n\n    public void Remove()\n    {\n        // Elt\u00e1vol\u00edtja a lista utols\u00f3 elem\u00e9t\n        members.RemoveAt(members.Count - 1);\n    }\n}\n</code></pre> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sk\u00e9nt val\u00f3s\u00edtsuk meg az esem\u00e9nykezel\u00e9st. </p> </li> <li> <p>Defini\u00e1ljunk egy \u00faj deleg\u00e1t t\u00edpust (az oszt\u00e1lyon k\u00edv\u00fcl, mivel ez is egy t\u00edpus), mely az \u00e9rtes\u00edt\u00e9sek sz\u00f6veg\u00e9t adja majd \u00e1t:</p> <pre><code>public delegate void CouncilChangedDelegate(string message);\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>JediCouncil</code> oszt\u00e1lyt az esem\u00e9nykezel\u0151vel:</p> <pre><code>public class JediCouncil\n{\n    public event CouncilChangedDelegate CouncilChanged;\n\n    // ...\n}\n</code></pre> </li> <li> <p>S\u00fcss\u00fck el az esem\u00e9nyt, amikor \u00faj tan\u00e1cstagot vesz\u00fcnk fel. Ehhez az <code>Add</code> met\u00f3dust kell kieg\u00e9sz\u00edten\u00fcnk.</p> <pre><code>public void Add(Jedi newJedi)\n{\n    members.Add(newJedi);\n\n    // TODO: Itt s\u00fcsd el az esem\u00e9nyt.\n    // Figyelj arra, hogy csak akkor tedd meg, ha van legal\u00e1bb egy feliratkoz\u00f3/el\u0151fizet\u0151.\n    // Ennek sor\u00e1n ne a terjeng\u0151sebb null ellen\u0151rz\u00e9st, hanem a modernebb, ?.Invoke-ot haszn\u00e1ld.\n}\n</code></pre> </li> <li> <p>S\u00fcss\u00fck el az esem\u00e9nyt, amikor egy tan\u00e1cstag t\u00e1vozik! K\u00fcl\u00f6nb\u00f6ztess\u00fck meg azt az esetet, amikor a tan\u00e1cs teljesen ki\u00fcr\u00fcl. Ehhez a <code>Remove</code> met\u00f3dust kell kieg\u00e9sz\u00edten\u00fcnk.</p> <pre><code>public void Remove()\n{\n    // Elt\u00e1vol\u00edtja a lista utols\u00f3 elem\u00e9t\n    members.RemoveAt(members.Count - 1);\n\n    // TODO: Itt s\u00fcsd el az esem\u00e9nyt.\n    // Figyelj arra, hogy csak akkor tedd meg, ha van legal\u00e1bb egy feliratkoz\u00f3/el\u0151fizet\u0151.\n}\n</code></pre> </li> <li> <p>Megold\u00e1sunk tesztel\u00e9s\u00e9hez vegy\u00fcnk fel egy <code>MessageReceived</code> f\u00fcggv\u00e9nyt abba az oszt\u00e1lyba, ahol az esem\u00e9nyre val\u00f3 feliratkoz\u00e1st \u00e9s az esem\u00e9ny kezel\u00e9s\u00e9t tesztelni szeretn\u00e9nk (pl. a <code>Program</code> oszt\u00e1lyba). Ezt a f\u00fcggv\u00e9nyt fogjuk feliratkoztatni a <code>JediCouncil</code> \u00e9rtes\u00edt\u00e9seire.</p> Program.cs<pre><code>private static void MessageReceived(string message)\n{\n    Console.WriteLine(message);\n}\n</code></pre> </li> <li> <p>V\u00e9gezet\u00fcl tesztelj\u00fck az \u00faj oszt\u00e1lyunkat egy erre a c\u00e9lra dedik\u00e1lt f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val (ez t\u00f6rt\u00e9nhet pl. a <code>Program</code> oszt\u00e1lyban), a f\u00fcggv\u00e9ny f\u00f6l\u00e9 tegy\u00fck oda a <code>[Description(\"Feladat3\")]</code> attrib\u00fatumot! A f\u00fcggv\u00e9ny v\u00e1za:</p> <pre><code>// Tan\u00e1cs l\u00e9trehoz\u00e1sa\nvar council = new JediCouncil();\n\n// TODO: Itt iratkozz fel a council CouncilChanged esem\u00e9ny\u00e9re\n\n// TODO Itt adj hozz\u00e1 k\u00e9t Jedi objektumot a council objektumhoz az Add h\u00edv\u00e1s\u00e1val\n\ncouncil.Remove();\ncouncil.Remove();\n</code></pre> </li> <li> <p>Ha j\u00f3l v\u00e9gezt\u00fck a dolgunkat, a program futtat\u00e1s\u00e1t k\u00f6vet\u0151en a k\u00f6vetkez\u0151 kimenetet kell kapnunk:</p> <pre><code>\u00daj taggal b\u0151v\u00fclt\u00fcnk\n\u00daj taggal b\u0151v\u00fclt\u00fcnk\nZavart \u00e9rzek az er\u0151ben\nA tan\u00e1cs elesett!\n</code></pre> </li> </ol> <p>Esem\u00e9nyek null vizsg\u00e1lata</p> <p>Amennyiben a <code>JediCouncil.Add</code> m\u0171veletben <code>null</code> vizsg\u00e1lattal v\u00e9gezted annak ellen\u0151rz\u00e9s\u00e9t, hogy van-e legal\u00e1bb egy feliratkoz\u00f3 az esem\u00e9nyre, ezt alak\u00edtsd \u00e1t korszer\u0171bb megold\u00e1sra (<code>?.Invoke</code> alkalmaz\u00e1sa, mely t\u00f6m\u00f6rebb form\u00e1ban szint\u00e9n elv\u00e9gzi az ellen\u0151rz\u00e9st, de <code>null</code> vizsg\u00e1lat n\u00e9lk\u00fcl \u2013 err\u0151l a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1son \u00e9s laboron is volt sz\u00f3). Ezt el\u00e9g a <code>JediCouncil.Add</code> kapcs\u00e1n megtenni, a <code>JediCouncil.Remove</code> eset\u00e9ben mindk\u00e9t megold\u00e1s elfogadhat\u00f3 most.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-4-delegatok","title":"Feladat 4 \u2013 Deleg\u00e1tok","text":""},{"location":"hazi/2-nyelvi-eszkozok/#feladat_3","title":"Feladat","text":"<p>Eg\u00e9sz\u00edtsd ki a <code>JediCouncil</code> oszt\u00e1lyt egy olyan param\u00e9ter n\u00e9lk\u00fcli f\u00fcggv\u00e9nnyel (a f\u00fcggv\u00e9nyn\u00e9v v\u00e9gz\u0151dj\u00f6n <code>_Delegate</code>-re, ez k\u00f6telez\u0151), mely visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben visszaadja a Jedi tan\u00e1cs \u00f6sszes olyan tagj\u00e1t, melynek a midi-chlorian sz\u00e1ma 530 alatt van!</p> <ul> <li>F\u00fcggv\u00e9nyt haszn\u00e1lj, ne tulajdons\u00e1got a lek\u00e9rdez\u00e9sre.</li> <li>A f\u00fcggv\u00e9nyen bel\u00fcl a tagok kikeres\u00e9s\u00e9re haszn\u00e1ld a <code>List&lt;Jedi&gt;</code> oszt\u00e1ly <code>FindAll()</code> f\u00fcggv\u00e9ny\u00e9t.</li> <li>Ebben a feladatban m\u00e9g NEM haszn\u00e1lhatsz lambda kifejez\u00e9st!</li> </ul> <p>\u00cdrj egy dedik\u00e1lt \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt is (pl. a <code>Program</code> oszt\u00e1lyba), mely megh\u00edvja a fenti f\u00fcggv\u00e9ny\u00fcnket \u00e9s ki\u00edrja a visszaadott jedi lovagok neveit! Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.</p> <p>Fontos</p> <p>Ezt a \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt l\u00e1sd el a <code>[Description(\"Feladat4\")]</code> C# attrib\u00fatummal. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul> <p>Inicializ\u00e1ci\u00f3 kiszervez\u00e9se</p> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n vezess be egy k\u00fcl\u00f6n statikus met\u00f3dust (pl. a <code>Program</code> oszt\u00e1lyba), mely param\u00e9terk\u00e9nt egy Jeditan\u00e1cs objektumot kap, abba legal\u00e1bb h\u00e1rom felparam\u00e9terezett <code>Jedi</code> objektumot az <code>Add</code> h\u00edv\u00e1s\u00e1val felvesz. A c\u00e9lunk ezzel az, hogy egy olyan inicializ\u00e1l\u00f3 met\u00f3dusunk legyen, mely a k\u00e9s\u0151bbi feladat(ok) sor\u00e1n is felhaszn\u00e1lhat\u00f3, ne kelljen a kapcsol\u00f3d\u00f3 inicializ\u00e1l\u00f3 k\u00f3dot duplik\u00e1lni.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_3","title":"Megold\u00e1s","text":"<p>A feladat megold\u00e1s\u00e1hoz a 2. labor 6. feladat\u00e1t haszn\u00e1lhatjuk referenciak\u00e9nt. Seg\u00edts\u00e9gk\u00e9nt megadjuk a k\u00f6vetkez\u0151ket:</p> <ul> <li>a f\u00fcggv\u00e9ny\u00fcnk ak\u00e1r t\u00f6bb tal\u00e1latot is visszaadhat, ez\u00e9rt a visszat\u00e9r\u00e9si \u00e9rt\u00e9k t\u00edpusa <code>List&lt;Jedi&gt;</code>,</li> <li>a <code>FindAll</code> param\u00e9terk\u00e9nt az eset\u00fcnkben egy <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi j)</code> szignat\u00far\u00e1j\u00fa sz\u0171r\u0151f\u00fcggv\u00e9nyt v\u00e1r el.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-5-lambda-kifejezesek","title":"Feladat 5 \u2013 Lambda kifejez\u00e9sek","text":"<p>A feladat megfelel az el\u0151z\u0151nek, csak most lambda kifejez\u00e9s seg\u00edts\u00e9g\u00e9vel fogunk dolgozni. Ez a t\u00e9mak\u00f6r szerepelt el\u0151ad\u00e1son \u00e9s laboron is (2. labor 6. feladat).</p> <p>Eg\u00e9sz\u00edtsd ki a JediCouncil oszt\u00e1lyt egy olyan param\u00e9ter n\u00e9lk\u00fcli f\u00fcggv\u00e9nnyel (a f\u00fcggv\u00e9nyn\u00e9v v\u00e9gz\u0151dj\u00f6n <code>_Lambda</code>-ra, ez k\u00f6telez\u0151), mely visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9ben visszaadja a Jedi tan\u00e1cs \u00f6sszes olyan tagj\u00e1t, melynek a midi-chlorian sz\u00e1ma 1000 alatt van!</p> <ul> <li>F\u00fcggv\u00e9nyt haszn\u00e1lj, ne tulajdons\u00e1got a lek\u00e9rdez\u00e9sre.</li> <li>A f\u00fcggv\u00e9nyen bel\u00fcl a tagok kikeres\u00e9s\u00e9re haszn\u00e1ld a <code>List&lt;Jedi&gt;</code> oszt\u00e1ly <code>FindAll()</code> f\u00fcggv\u00e9ny\u00e9t.</li> <li>Ebben a feladatban k\u00f6telez\u0151en lambda kifejez\u00e9st kell haszn\u00e1lj (az mindegy, hogy statement vagy expression lambd\u00e1t)!</li> </ul> <p>\u00cdrj egy dedik\u00e1lt \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt is (pl. a <code>Program</code> oszt\u00e1lyba), mely megh\u00edvja a fenti f\u00fcggv\u00e9ny\u00fcnket \u00e9s ki\u00edrja a visszaadott jedi lovagok neveit! Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, \u00edgy m\u00e1s (r\u00e9sz)feladathoz tartoz\u00f3t sem.</p> <p>Fontos</p> <p>Ezt a \u201etesztel\u0151\u201d f\u00fcggv\u00e9nyt l\u00e1sd el a <code>[Description(\"Feladat5\")]</code> C# attrib\u00fatummal. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l.</p> <p>L\u00e9nyeges, hogy</p> <ul> <li>az attrib\u00fatumot f\u00fcggv\u00e9ny, \u00e9s NE oszt\u00e1ly f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatumot ne a logik\u00e1t megval\u00f3s\u00edt\u00f3, hanem a tesztel\u00e9st v\u00e9gz\u0151 f\u00fcggv\u00e9ny f\u00f6l\u00e9 \u00edrd,</li> <li>az attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-6-actionfunc-hasznalata","title":"Feladat 6 \u2013 <code>Action</code>/<code>Func</code> haszn\u00e1lata","text":"<p>Ez a feladat a 3. el\u0151ad\u00e1s anyag\u00e1ra \u00e9p\u00edt, laboron (id\u0151 hi\u00e1ny\u00e1ban) nem szerepelt. Ett\u0151l f\u00fcggetlen\u00fcl ez egy l\u00e9nyeges alapt\u00e9mak\u00f6r a t\u00e1rgyban.</p> <p>A projektbe vegy\u00e9l fel egy <code>Person</code> \u00e9s egy <code>ReportPrinter</code> oszt\u00e1lyt (egy-egy, az oszt\u00e1ly nev\u00e9vel egyez\u0151 f\u00e1jlba, az alap\u00e9rtelmezett, <code>ModernLangToolsApp</code> n\u00e9vt\u00e9rbe), a k\u00f6vetkez\u0151 tartalommal:</p> Person \u00e9s ReportPrinter oszt\u00e1lyok <pre><code>class Person\n{\n    public Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n</code></pre> <pre><code>class ReportPrinter\n{\n    private readonly IEnumerable&lt;Person&gt; people;\n    private readonly Action headerPrinter;\n\n    public ReportPrinter(IEnumerable&lt;Person&gt; people, Action headerPrinter)\n    {\n        this.people = people;\n        this.headerPrinter = headerPrinter;\n    }\n\n    public void PrintReport()\n    {\n        headerPrinter();\n        Console.WriteLine(\"-----------------------------------------\");\n        int i = 0;\n        foreach (var person in people)\n        {\n            Console.Write($\"{++i}. \");\n            Console.WriteLine(\"Person\");\n        }\n        Console.WriteLine(\"--------------- Summary -----------------\");\n        Console.WriteLine(\"Footer\");\n    }\n}\n</code></pre> <p>Ez a <code>ReportPrinter</code> oszt\u00e1ly arra haszn\u00e1lhat\u00f3, hogy a konstruktor\u00e1ban megadott szem\u00e9lyek adatair\u00f3l form\u00e1zott riportot \u00edrjon ki a konzolra fejl\u00e9c/adatok/l\u00e1bl\u00e9c h\u00e1rmas bont\u00e1sban. A <code>Program.cs</code> f\u00e1jlba vedd fel az al\u00e1bbi f\u00fcggv\u00e9nyt a <code>ReportPrinter</code> kipr\u00f3b\u00e1l\u00e1s\u00e1ra, \u00e9s ezt h\u00edvd is meg a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l:</p> ReportPrinter tesztel\u00e9se <pre><code>[Description(\"Feladat6\")]\nstatic void test6()\n{\n    var employees = new Person[] { new Person(\"Joe\", 20), new Person(\"Jill\", 30) };\n\n    ReportPrinter reportPrinter = new ReportPrinter(\n        employees,\n        () =&gt; Console.WriteLine(\"Employees\")\n        );\n\n    reportPrinter.PrintReport();\n}\n</code></pre> <p>Futtassuk az alkalmaz\u00e1st. Az al\u00e1bbi kimenetet kapjuk a konzolon:</p> <pre><code>Employees\n-----------------------------------------\n1. Person\n2. Person\n--------------- Summary -----------------\nFooter\n</code></pre> <p>Az els\u0151 sorban \"----\" felett tal\u00e1lhat\u00f3 a fejl\u00e9c. Alatta az egye szem\u00e9lyekhez egy-egy \"Person\" be\u00e9getett sz\u00f6veg, majd a \"----\" alatt a l\u00e1bl\u00e9c, egyel\u0151re csak egy be\u00e9getett \"Footer\" sz\u00f6veggel.</p> <p>A megold\u00e1sban l\u00e1that\u00f3, hogy a fejl\u00e9c sz\u00f6vege a <code>ReportPrinter</code> oszt\u00e1lyba nincs be\u00e9getve. Ezt <code>ReportPrinter</code> felhaszn\u00e1l\u00f3ja adja meg konstruktor param\u00e9terben egy delegate, eset\u00fcnkben egy lambda kifejez\u00e9s form\u00e1j\u00e1ban. A delegate t\u00edpusa a .NET be\u00e9p\u00edtett <code>Action</code> t\u00edpusa.</p> <p>A feladatok a k\u00f6vetkez\u0151k:</p> <p>Warning</p> <p>A megold\u00e1s sor\u00e1n NEM haszn\u00e1lhatsz saj\u00e1t delegate t\u00edpust (a .NET be\u00e9p\u00edtett delegate t\u00edpusaival dolgozz, a megold\u00e1s csak ekkor elfogadhat\u00f3).</p> <ol> <li> <p>Alak\u00edtsd \u00e1t a <code>ReportPrinter</code> oszt\u00e1lyt \u00fagy, hogy az oszt\u00e1ly haszn\u00e1l\u00f3ja ne csak a fejl\u00e9cet, hanem a l\u00e1bl\u00e9cet is meg tudja adni egy delegate form\u00e1j\u00e1ban a konstruktorban.</p> </li> <li> <p>Alak\u00edtsd tov\u00e1bb a <code>ReportPrinter</code> oszt\u00e1lyt \u00fagy, hogy az egyes szem\u00e9lyek ki\u00edr\u00e1sakor ne a fix \"Person\" sz\u00f6veg jelenjen meg, hanem a <code>ReportPrinter</code> oszt\u00e1ly haszn\u00e1l\u00f3ja tudja az egyes szem\u00e9lyek adatait az ig\u00e9nyeinek megfelel\u0151en ki\u00edrni a konzolra egy konstruktorban megadott delegate seg\u00edts\u00e9g\u00e9vel (a fix \"Person\" helyett). L\u00e9nyeges, hogy a sorsz\u00e1m a sor elej\u00e9n mindig meg kell jelenjen, ez nem lehet a <code>ReportPrinter</code> haszn\u00e1l\u00f3ja \u00e1ltal megv\u00e1ltoztathat\u00f3 (vagyis ezt a tov\u00e1bbiakban is a <code>ReportPrinter</code> oszt\u00e1lynak kell ki\u00edrnia)!</p> <p>Tipp a megold\u00e1shoz</p> <p>Hasonl\u00f3 megk\u00f6zel\u00edt\u00e9sben gondolkozz, mint a fejl\u00e9c \u00e9s l\u00e1bl\u00e9c eset\u00e9ben, de itt ehhez a <code>ReportPrinter</code> felhaszn\u00e1l\u00f3j\u00e1nak meg kell kapnia a szem\u00e9ly objektumot ahhoz, hogy azt form\u00e1zottan ki tudja \u00edrni a konzolra.</p> </li> <li> <p>A <code>Program.cs</code> f\u00e1jlban a <code>ReportPrinter</code> haszn\u00e1lat\u00e1t alak\u00edtsd \u00fagy (megfelel\u0151 lambda kifejez\u00e9sek megad\u00e1s\u00e1val), hogy a kimenet a konzolon a k\u00f6vetkez\u0151 legyen:</p> <pre><code>Employees\n-----------------------------------------\n1. Name: Joe (Age: 20)\n2. Name: Jill (Age: 30)\n--------------- Summary -----------------\nNumber of Employees: 2\n</code></pre> <p>L\u00e1bl\u00e9cben a dolgoz\u00f3k sz\u00e1m\u00e1nak ki\u00edr\u00e1sa</p> <p>Ahhoz, hogy a l\u00e1bl\u00e9cben a dolgoz\u00f3k sz\u00e1m\u00e1nak ki\u00edr\u00e1s\u00e1t eleg\u00e1ns m\u00f3don meg tudd tenni, sz\u00fcks\u00e9g van a \"variable capturing\" t\u00e9mak\u00f6r ismeret\u00e9re (l\u00e1sd 3. el\u0151ad\u00e1s \"Variable capturing, closure\" fejezet).</p> <p>H\u00e1zi feladat ellen\u0151rz\u00e9se</p> <p>A \"Feladat 6\" feladatot, vagyis azt, hogy a <code>ReportPrinter</code>-t \u00e9s annak haszn\u00e1lat\u00e1t j\u00f3l alak\u00edtottad-e \u00e1t, a GitHub-os automata ellen\u0151rz\u0151 NEM ellen\u0151rzi. Teszteld a megold\u00e1sod alaposan, hogy ne csak a hat\u00e1rid\u0151 ut\u00e1n ut\u00f3lag, a h\u00e1zi feladatok manu\u00e1lis ellen\u0151rz\u00e9se sor\u00e1n der\u00fclj\u00f6n ki, hogy a megold\u00e1s nem elfogadhat\u00f3. (Kieg\u00e9sz\u00edt\u00e9s: 2024.03.13 reggelt\u0151l kezdve m\u00e1r erre is van r\u00e9szleges automata ellen\u0151rz\u00e9s)</p> </li> <li> <p>A k\u00f6vetkez\u0151 feladat opcion\u00e1lis, a be\u00e9p\u00edtett <code>Func</code> delegate-ek gyakorl\u00e1s\u00e1ra ad j\u00f3 lehet\u0151s\u00e9get. A <code>ReportPrinter</code> oszt\u00e1lynak van egy komolyabb h\u00e1tr\u00e1nya: a kimeneti riportot csak a konzolon tudjuk a seg\u00edts\u00e9g\u00e9vel megjelen\u00edteni. Rugalmasabb megold\u00e1s lenne, ha nem \u00edrna a konzolra, hanem egy string form\u00e1j\u00e1ban lehetne a seg\u00edts\u00e9g\u00e9vel a riportot el\u0151\u00e1ll\u00edtani. Ezt a stringet m\u00e1r \u00fagy haszn\u00e1lhatn\u00e1nk fel, ahogy csak szeretn\u00e9nk (pl. \u00edrhatn\u00e1nk f\u00e1jlba is).</p> <p>A feladat a k\u00f6vetkez\u0151: vezess be egy <code>ReportBuilder</code> oszt\u00e1lyt a m\u00e1r megl\u00e9v\u0151 <code>ReportPrinter</code> mint\u00e1j\u00e1ra, de ez ne a konzolra \u00edrjon, hanem egy a teljes riportot tartalmaz\u00f3 stringet \u00e1ll\u00edtson el\u0151, melyet egy \u00fajonnan bevezetett, <code>GetResult()</code> m\u0171velettel lehessen t\u0151le lek\u00e9rdezni. </p> <p>Bead\u00e1s</p> <p>Ha beadod a feladatot, a <code>ReportBuilder</code>-t p\u00e9ld\u00e1nyos\u00edt\u00f3/tesztel\u0151 k\u00f3dot ne a fenti, <code>test6</code> f\u00fcggv\u00e9nybe tedd, hanem vezess be egy <code>test6b</code> nev\u0171 f\u00fcggv\u00e9nyt, \u00e9s l\u00e1sd el a <code>[Description(\"Feladat6b\")]</code> attrib\u00fatummal.</p> <p>Tippek a megold\u00e1shoz</p> <ul> <li>C\u00e9lszer\u0171 az oszt\u00e1lyba egy <code>StringBuilder</code> tagv\u00e1ltoz\u00f3t bevezetni, \u00e9s ennek seg\u00edts\u00e9g\u00e9vel dolgozni. Ez nagys\u00e1grenddel hat\u00e9konyabb, mint a stringek \"+\"-szal val\u00f3 \u00f6sszef\u0171z\u00f6get\u00e9se.</li> <li>A <code>ReportBuilder</code> oszt\u00e1ly haszn\u00e1l\u00f3ja itt m\u00e1r ne a konzolra \u00edrjon, hanem megfelel\u0151 be\u00e9p\u00edtett t\u00edpus\u00fa delegate-ek (itt az <code>Action</code> nem lesz megfelel\u0151) seg\u00edts\u00e9g\u00e9vel adja vissza a <code>ReportBuilder</code> sz\u00e1m\u00e1ra azokat a stringeket, melyeket bele kell f\u0171znie a kimenetbe. A tesztel\u00e9s sor\u00e1n most is lambda kifejez\u00e9seket haszn\u00e1lj!</li> </ul> </li> </ol>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat-7-imsc-beepitett-funcaction-generikus-delegate-tipusok-hasznalata","title":"Feladat 7 (IMSc) \u2013 be\u00e9p\u00edtett <code>Func</code>/<code>Action</code> generikus delegate t\u00edpusok haszn\u00e1lata","text":"<p>A feladat megold\u00e1sa nem k\u00f6telez\u0151, de er\u0151sen aj\u00e1nlott: alapanyag, \u00edgy ZH-n/vizsg\u00e1n szerepelhet. Laboron nem volt, csak el\u0151ad\u00e1son.</p> <p>A megold\u00e1s\u00e9rt +2 IMSc pont is j\u00e1r.</p>"},{"location":"hazi/2-nyelvi-eszkozok/#feladat_4","title":"Feladat","text":"<p>B\u0151v\u00edtsd ki a <code>JediCouncil</code> oszt\u00e1lyt.</p> <ul> <li> <p>K\u00e9sz\u00edts egy <code>Count</code> nev\u0171 <code>int</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171 property-t (tulajdons\u00e1got), amely minden lek\u00e9rdez\u00e9skor a tan\u00e1csban aktu\u00e1lisan tal\u00e1lhat\u00f3 Jedi-k sz\u00e1m\u00e1t adja vissza. \u00dcgyelj arra, hogy ezt az \u00e9rt\u00e9ket csak lek\u00e9rdezni lehessen (be\u00e1ll\u00edtani nem).</p> <p>Tipp</p> <p>A <code>JediCouncil</code>-ban tal\u00e1lhat\u00f3 members nev\u0171 tagv\u00e1ltoz\u00f3nak van egy <code>Count</code> nev\u0171 property-je, a megold\u00e1s \u00e9p\u00edtsen erre.</p> </li> <li> <p>K\u00e9sz\u00edts egy <code>CountIf</code> nev\u0171 f\u00fcggv\u00e9nyt, amely szint\u00e9n a tan\u00e1cstagok megsz\u00e1ml\u00e1l\u00e1s\u00e1ra val\u00f3, de csak bizonyos felt\u00e9telnek eleget tev\u0151 tan\u00e1cstagokat vesz figyelembe. A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9ke <code>int</code>, \u00e9s a felt\u00e9telt, amelynek megfelel\u0151 tan\u00e1cstagok sz\u00e1m\u00e1t visszaadja, egy delegate seg\u00edts\u00e9g\u00e9vel kapja meg param\u00e9terk\u00e9nt (teh\u00e1t a <code>CountIf</code>-nek kell legyen param\u00e9tere).</p> <p>Delegate t\u00edpusa</p> <p>A delegate t\u00edpusa k\u00f6telez\u0151en a be\u00e9p\u00edtett generikus <code>Action</code> / <code>Func</code> delegate t\u00edpusok k\u00f6z\u00fcl a megfelel\u0151 kell legyen (vagyis saj\u00e1t delegate t\u00edpus, ill. a be\u00e9p\u00edtett <code>Predicate</code> t\u00edpus nem haszn\u00e1lhat\u00f3).</p> <p>Emiatt a list\u00e1n NEM haszn\u00e1lhatod a be\u00e9p\u00edtett <code>FindAll</code> m\u0171velet\u00e9t, mivel az \u00e1ltalunk haszn\u00e1lt delegate t\u00edpus nem lenne kompatibilis a <code>FindAll</code> \u00e1ltal v\u00e1rt param\u00e9terrel. A tagokon egy <code>foreach</code> ciklusban v\u00e9gigiter\u00e1lva dolgozz!</p> </li> <li> <p>A property \u00e9s a f\u00fcggv\u00e9ny m\u0171k\u00f6d\u00e9s\u00e9t demonstr\u00e1ld egy erre dedik\u00e1lt k\u00f6z\u00f6s f\u00fcggv\u00e9nyben, amit l\u00e1ss el a <code>[Description(\"Feladat7\")]</code> attrib\u00fatummal. Ez a f\u00fcggv\u00e9ny nem szorosan a feladathoz tartoz\u00f3 k\u00f3dot ne tartalmazzon, viszont a Jeditan\u00e1cs felt\u00f6lt\u00e9s\u00e9hez az el\u0151z\u0151 feladatban bevezetett seg\u00e9df\u00fcggv\u00e9nyt h\u00edvd. A f\u00fcggv\u00e9nyt h\u00edvd meg a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9b\u0151l. </p> <p>Fontos</p> <p>A <code>[Description(\"Feladat7\")]</code> attrib\u00fatum csak egyetlen f\u00fcggv\u00e9ny f\u00f6l\u00f6tt szerepelhet.</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#megoldas_4","title":"Megold\u00e1s","text":"<ul> <li>A <code>Count</code> nev\u0171 property eset\u00e9ben csak a <code>get</code> \u00e1gnak van \u00e9rtelme, ez\u00e9rt a <code>set</code> \u00e1gat meg se \u00edrjuk. Ez egy csak olvashat\u00f3 tulajdons\u00e1g legyen.</li> <li>A <code>CountIf</code> f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1ban a 4-es feladat ny\u00fajt seg\u00edts\u00e9get. A k\u00fcl\u00f6nbs\u00e9g, hogy a <code>CountIf</code> nem a tan\u00e1cstagokat, csak a darabsz\u00e1mot adja vissza.<ul> <li>A <code>CountIf</code> f\u00fcggv\u00e9ny a felt\u00e9telt param\u00e9terk\u00e9nt egy <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi jedi)</code> szignat\u00far\u00e1j\u00fa sz\u0171r\u0151f\u00fcggv\u00e9nyt v\u00e1rjon.</li> </ul> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/#beadas","title":"Bead\u00e1s","text":"<p>Ellen\u0151rz\u0151lista ism\u00e9tl\u00e9sk\u00e9ppen:</p> <ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/","title":"2. HF - Sprachwerkzeuge","text":""},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Die eigenst\u00e4ndige Aufgabe baut auf den Vorlesungen der Vorlesung 2 und der ersten H\u00e4lfte der Vorlesung 3 auf (diese sind im Vorlesungsmaterial \"Vorlesung 02 - Sprachliche Mittel\" enthalten). Labor 2 - Sprachwerkzeuge liefert den praktischen Hintergrund f\u00fcr die Labor\u00fcbung.</p> <p>Aufbauend auf den obigen Ausf\u00fchrungen k\u00f6nnen die Aufgaben in dieser Selbst\u00fcbung unter Verwendung der k\u00fcrzeren Richtlinien, die auf die Aufgabenbeschreibung folgen, erledigt werden.</p> <p>Das Ziel der unabh\u00e4ngigen \u00dcbung:</p> <ul> <li>Praktische Nutzung von Eigentum</li> <li>Delegierte und Ereignisse verwenden</li> <li>\u00fcben Sie die Verwendung von .NET-Attributen</li> <li>\u00dcben der Verwendung grundlegender Sammlungstypen</li> <li>\u00dcbung Lambda-Terme</li> </ul> <p>Die erforderliche Entwicklungsumgebung wird hier beschrieben.</p> <p>Using C# 12 (and newer) language elements</p> <p>C# 12 und neuere Sprachelemente (z.B. prim\u00e4rer Konstruktor) k\u00f6nnen in dieser Hausaufgabe nicht verwendet werden, da der Checker auf GitHub sie noch nicht unterst\u00fctzt.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#einreichungsverfahren-pre-checker","title":"Einreichungsverfahren, Pre-Checker","text":"<p>Der Einreichungsprozess ist derselbe wie bei der ersten Hausaufgabe (siehe Arbeitsablauf bei Hausaufgaben und Verwendung von Git/GitHub f\u00fcr eine detaillierte Beschreibung an der \u00fcblichen Stelle):</p> <ol> <li>Erstellen Sie mit GitHub Classroom ein Repository f\u00fcr sich selbst. Sie finden die Einladungs-URL in Moodle (Sie k\u00f6nnen sie sehen, indem Sie auf den Link*\"GitHub classroom links for homework*\" auf der Startseite des Fachs klicken). Es ist wichtig, dass Sie die richtige Einladungs-URL f\u00fcr diese Hausaufgabe verwenden (jede Hausaufgabe hat eine andere URL).</li> <li>Klonen Sie das resultierende Repository. Dazu geh\u00f6rt auch die erwartete Struktur der L\u00f6sung.</li> <li>Nachdem Sie die Aufgaben erledigt haben, \u00fcbergeben Sie Ihre L\u00f6sung alt und dr\u00fccken Sie sie alt.</li> </ol> <p>Auch der Pre-Checker funktioniert wie gewohnt. Ausf\u00fchrliche Beschreibung: Vorabkontrolle und formale Bewertung der Hausaufgaben.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#aufgabe-1-ominose-schatten","title":"Aufgabe 1 - Omin\u00f6se Schatten","text":""},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#verfasst-am","title":"Verfasst am","text":"<p>Die Macht der Jedi-Ritter kommt bekanntlich von den winzigen Lebensformen, die in ihren Zellen leben, den Midi-Chlorianern. Der h\u00f6chste jemals gemessene Midi-Chlor-Wert (\u00fcber 20.000) wurde bei Anakin Skywalker gemessen.</p> <p>Erstellen Sie eine Klasse mit dem Namen <code>Jedi</code>, die eine Eigenschaft <code>Name</code> vom Typ <code>string</code> und eine Eigenschaft <code>MidiChlorianCount</code> vom Typ <code>int</code> hat. Bei letzterem ist darauf zu achten, dass der Wert von <code>MidiChlorianCount</code> nicht auf 35 oder weniger gesetzt werden kann. W\u00e4hlen Sie f\u00fcr die Validierung die einfachste und sauberste L\u00f6sung, die m\u00f6glich ist: Verwenden Sie ein einfaches <code>if</code>im Property Setter und l\u00f6sen Sie eine Exception aus, keine <code>else</code> Verzweigung von <code>if</code>, und keine Notwendigkeit, <code>return</code> zu verwenden.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#losung","title":"L\u00f6sung","text":"<p>Die L\u00f6sung dieser Aufgabe kann auf \u00e4hnliche Weise vorbereitet werden wie in Labor 2, Aufgabe 1. L\u00f6sen Sie im Setter der Eigenschaft <code>MidiChlorianCount</code> eine Ausnahme f\u00fcr einen ung\u00fcltigen Wert aus. Dies kann zum Beispiel mit dem folgenden Befehl geschehen:</p> <pre><code>throw new ArgumentException(\"You are not a true jedi!\");\n</code></pre>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#aufgabe-2-angriff-auf-die-klone","title":"Aufgabe 2 - Angriff auf die Klone","text":""},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#verfasst-am_1","title":"Verfasst am","text":"<p>F\u00fcgen Sie der Klasse, die Sie in \u00dcbung 1 erstellt haben, Attribute hinzu, so dass, wenn Sie ein Objekt <code>Jedi</code> mit der Klasse <code>XmlSerializer</code> in eine XML-Datendatei schreiben/zuweisen, seine Eigenschaften in Englisch als XML-Attribute angezeigt werden Schreiben Sie dann eine Funktion, die eine Instanz der Klasse <code>Jedi</code> in eine Textdatei sortiert und sie in ein neues Objekt zur\u00fcckliest (und damit das urspr\u00fcngliche Objekt klont).</p> <p>XML-Sortierattribute</p> <p>Platzieren Sie die Attribute, die die XML-Sortierung steuern, \u00fcber den Eigenschaften, nicht \u00fcber den Mitgliedsvariablen!</p> <p>Die Jedi-Klasse sollte \u00f6ffentlich sein</p> <p>Der XML-Sorter kann nur mit \u00f6ffentlichen Klassen arbeiten, daher sollte die Jedi-Klasse \u00f6ffentlich sein: <code>csharp     public class Jedi { ...}</code></p> <p>Wichtig</p> <p>Schreiben Sie den Code zum Speichern und Laden/Demonstrieren in eine gemeinsame dedizierte Funktion, und verweisen Sie auf die Funktion mit dem C#-Attribut <code>[Description(\"Task2\")]</code> (das in der Zeile vor der Funktion eingegeben werden muss). Das gespeicherte/geladene Objekt sollte in dieser Funktion als lokale Variable implementiert werden. Der Name der Klasse/Funktion kann beliebig sein (z. B. kann er in der Klasse <code>Program</code> stehen). Die Funktion sollte keinen Code enthalten, der nicht strikt mit der Aufgabe und somit auch nicht mit einer anderen (Unter-)Aufgabe zusammenh\u00e4ngt. Rufen Sie die Funktion \u00fcber die Funktion <code>Main</code> der Klasse <code>Program</code> auf. Um das oben genannte Attribut zu verwenden, m\u00fcssen Sie den Namespace <code>System.ComponentModel</code> verwenden.</p> <p>Es ist wichtig, dass</p> <ul> <li>attribut \u00fcber Funktion und NE-Klasse,</li> <li>schreiben Sie das Attribut nicht \u00fcber die Funktion, die die Logik implementiert, sondern \u00fcber die Funktion, die sie testet,</li> <li>das Attribut kann nur \u00fcber einer einzigen Funktion erscheinen.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#losung_1","title":"L\u00f6sung","text":"<p>Die L\u00f6sung dieser Aufgabe kann auf \u00e4hnliche Weise wie in Labor 2, Aufgabe 4, vorbereitet werden. Die folgende Hilfe wird angeboten:</p> <ul> <li> <p>Nach der Sortierung sollte die XML-Datei etwa so aussehen:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;Jedi xmlns:xsi=\"...\" Nev=\"Obi-Wan\" MidiChlorianSzam=\"15000\" /&gt;\n</code></pre> <p>Es ist wichtig, dass jeder Jedi als XML-Element <code>Jedi</code> erscheint, sein Name <code>Name</code>, seine Midichlorian-Nummer <code>MidiChlorianCount</code> als XML-Attribut.</p> </li> <li> <p>Wir haben uns im Labor keinen Beispielcode f\u00fcr die R\u00fcckgabe sortierter Objekte angesehen, daher stellen wir ihn hier zur Verf\u00fcgung:</p> <pre><code>var serializer = new XmlSerializer(typeof(Jedi));\nvar stream = new FileStream(\"jedi.txt\", FileMode.Open);\nvar clone = (Jedi)serializer.Deserialize(stream);\nstream.Close();\n</code></pre> <p>In der vorherigen Zeile wird zun\u00e4chst eine Sortiertabelle (<code>serializer</code>) erstellt, die sp\u00e4ter zur Durchf\u00fchrung der Suche verwendet wird. Gelesen wird aus einer Datei namens <code>jedi.txt</code>, die in der zweiten Zeile zum Lesen ge\u00f6ffnet wird (wenn wir schreiben wollten, h\u00e4tten wir<code>FileMode.Create</code>angeben m\u00fcssen).</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#herausforderung-3-die-rache-der-sith","title":"Herausforderung 3 - Die Rache der Sith","text":""},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#verfasst-am_2","title":"Verfasst am","text":"<p>Im Rat der Jedi hat es in letzter Zeit eine hohe Fluktuation gegeben. Um den \u00dcberblick \u00fcber \u00c4nderungen zu behalten, erstellen Sie eine Klasse, die Vorstandsmitglieder registrieren und eine Textbenachrichtigung \u00fcber \u00c4nderungen in Form eines Ereignisses senden kann! Die Liste kann mit zwei Funktionen bearbeitet werden. Die Funktion <code>Add</code> nimmt einen neuen Jedi-Ritter in den Rat auf, w\u00e4hrend die Funktion <code>Remove</code> das zuletzt aufgenommene Ratsmitglied wieder entfernt. Separate Benachrichtigung, wenn der Rat komplett leer ist (verwenden Sie dasselbe Ereignis wie f\u00fcr andere \u00c4nderungen, nur mit anderem Text).</p> <p>Die Liste der Vorstandsmitglieder (<code>members</code>) wird in einer Mitgliedsvariablen des Typs <code>List&lt;Jedi&gt;</code> gespeichert, die Funktion <code>Add</code> f\u00fcgt dieser Liste neue Mitglieder hinzu, w\u00e4hrend die Funktion <code>Remove</code> immer das letzte durch die generische Liste <code>RemoveAt</code> hinzugef\u00fcgte Mitglied entfernt (der Index des letzten Mitglieds wird durch die L\u00e4nge der Liste bestimmt, die durch die Eigenschaft <code>Count</code> zur\u00fcckgegeben wird).</p> <p>Die Benachrichtigung sollte \u00fcber ein C#-Ereignis erfolgen. Der Delegatentyp f\u00fcr das Ereignis sollte ein einfacher <code>string</code>sein. Das Hinzuf\u00fcgen eines neuen Mitglieds, das Entfernen jedes Mitglieds und das Entfernen des letzten Mitglieds sollte durch einen anderen Nachrichtentext angezeigt werden. Das Ausl\u00f6sen von Ereignissen sollte direkt in <code>Add</code> und <code>Remove</code> erfolgen (f\u00fchren Sie keine Hilfsfunktion ein).</p> <p>Verwenden Sie keinen eingebauten Delegatentyp f\u00fcr den Ereignistyp, sondern f\u00fchren Sie einen eigenen ein.</p> <p>Wichtig</p> <p>Der Code, der das Jeditan\u00e1cs-Objekt erstellt und testet (Abonnieren eines C#-Ereignisses, Aufrufen von <code>Add</code> und <code>Remove</code> ), sollte in einer gemeinsamen, separaten Funktion untergebracht werden, und diese Funktion sollte durch das C#-Attribut <code>[Description(\"Task3\")]</code> dargestellt werden. Der Name der Klasse/Funktion kann beliebig sein. Die Funktion sollte keinen Code enthalten, der nicht strikt mit der Aufgabe und somit auch nicht mit einer anderen (Unter-)Aufgabe zusammenh\u00e4ngt. Rufen Sie die Funktion \u00fcber die Funktion <code>Main</code> der Klasse <code>Program</code> auf.</p> <p>Es ist wichtig, dass</p> <ul> <li>attribut \u00fcber Funktion und NE-Klasse,</li> <li>schreiben Sie das Attribut nicht \u00fcber die Funktion, die die Logik implementiert, sondern \u00fcber die Funktion, die sie testet,</li> <li>das Attribut kann nur \u00fcber einer einzigen Funktion erscheinen.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#losung_2","title":"L\u00f6sung","text":"<p>Die L\u00f6sung dieses Problems baut auf mehreren Details aus Labor 2 auf. Die Einf\u00fchrung einer neuen Veranstaltung kann wie in den \u00dcbungen 2 und 3 beschrieben erfolgen, wobei die Mitglieder des Gremiums in einer Liste eingetragen werden k\u00f6nnen.</p> <p>Versuchen Sie anhand der obigen Informationen, das Problem selbst zu l\u00f6sen. Wenn Sie fertig sind, lesen Sie die Anleitung im n\u00e4chsten zu \u00f6ffnenden Block weiter und vergleichen Sie Ihre L\u00f6sung mit der Referenzl\u00f6sung unten Korrigieren Sie gegebenenfalls Ihre eigene L\u00f6sung!</p> <p>\u00d6ffentliche Sichtbarkeit</p> <p>Das Beispiel baut auf der Tatsache auf, dass die beteiligten Klassen, Eigenschaften und Delegierten \u00f6ffentlich sichtbar sind. Wenn Sie auf einen seltsamen \u00dcbersetzungsfehler sto\u00dfen oder <code>XmlSerializer</code> zur Laufzeit einen Fehler ausl\u00f6st, \u00fcberpr\u00fcfen Sie zun\u00e4chst, ob Sie die \u00f6ffentliche Sichtbarkeit auf allen relevanten Websites korrekt eingestellt haben.</p> Referenzl\u00f6sung <p>Die Schritte der Referenzl\u00f6sung sind wie folgt:</p> <ol> <li>Erstelle eine neue Klasse mit dem Namen <code>JediCouncil</code>.</li> <li>Man nehme ein Feld vom Typ \"Liste\" und initialisiere es mit einer leeren Liste. <li> <p>Machen Sie die Funktionen \"Hinzuf\u00fcgen\" und \"Entfernen\" g\u00fcltig.</p> <p>Nach den obigen Schritten erhalten wir den folgenden Code:</p> <pre><code>public class JediCouncil\n{\n    Liste&lt;Jedi&gt; members = new List&lt;Jedi&gt;();\n\n    public void Add(Jedi newJedi)\n    {\n        members.Add(newJedi);\n    }\n\n    public void Remove()\n    {\n        // Entfernt den letzten Eintrag in der Liste\n        members.RemoveAt(members.Count - 1);\n    }\n}\n</code></pre> <p>Der n\u00e4chste Schritt ist die Implementierung der Ereignisbehandlung. </p> </li> <li> <p>Definieren Sie einen neuen Delegatentyp (au\u00dferhalb der Klasse, da es sich ebenfalls um einen Typ handelt), der den Benachrichtigungstext \u00fcbergeben wird:</p> <pre><code>public delegate void CouncilChangedDelegate(string message);\n</code></pre> </li> <li> <p>F\u00fcgen Sie die Klasse \"JediCouncil\" zum Ereignis-Handler hinzu:</p> <pre><code>public class JediCouncil\n{\n    public event CouncilChangedDelegate CouncilChanged;\n\n    // ...\n}\n</code></pre> </li> <li> <p>Lassen Sie uns das Ereignis feiern, wenn wir ein neues Vorstandsmitglied aufnehmen. Zu diesem Zweck m\u00fcssen wir die Methode \"Hinzuf\u00fcgen\" hinzuf\u00fcgen.</p> <pre><code>public void Add(Jedi newJedi)\n{\n    members.Add(newJedi);\n\n    // TODO: Fry die Veranstaltung hier.\n    // Beachten Sie, dass Sie dies nur tun sollten, wenn Sie mindestens einen Teilnehmer haben.\n    // Verwenden Sie dabei das modernere ?.Invoke und nicht die h\u00e4ufigere Nullpr\u00fcfung.\n}\n</code></pre> </li> <li> <p>Braten Sie das Ereignis, wenn ein Ratsmitglied geht! Unterscheiden Sie den Fall, dass der Rat v\u00f6llig leer ist. Dazu m\u00fcssen wir die Methode <code>Remove</code> hinzuf\u00fcgen.</p> <pre><code>public void Remove()\n{\n    // Entfernt den letzten Eintrag in der Liste\n    members.RemoveAt(members.Count - 1);\n\n    // TODO: Fry die Veranstaltung hier.\n    // Beachten Sie, dass Sie dies nur tun sollten, wenn Sie mindestens einen Teilnehmer haben.\n}\n</code></pre> </li> <li> <p>Um unsere L\u00f6sung zu testen, f\u00fcgen Sie eine Funktion <code>MessageReceived</code> zu der Klasse hinzu, in der wir das Ereignisabonnement und die Ereignisbehandlung testen wollen (z.B. die Klasse <code>Program</code>). Diese Funktion wird verwendet, um `JediCouncil'-Benachrichtigungen zu abonnieren.</p> Programm.cs<pre><code>private static void MessageReceived(string message)\n{\n    Console.WriteLine(Nachricht);\n}\n</code></pre> </li> <li> <p>Testen Sie schlie\u00dflich die neue Klasse, indem Sie eine eigene Funktion schreiben (dies kann in der Klasse <code>Programm</code> geschehen) und f\u00fcgen Sie das Attribut <code>[Description(\"Task3\")]</code> oberhalb der Funktion hinzu Das Grundger\u00fcst der Funktion:</p> <pre><code>// Einrichtung des Rates\nvar council = new JediCouncil();\n\n// TODO: Melden Sie sich hier f\u00fcr die CouncilChanged-Veranstaltung an\n\n// TODO Hier f\u00fcgen Sie zwei Jedi-Objekte zum Ratsobjekt hinzu, indem Sie Add\n\ncouncil.Remove();\ncouncil.Remove();\n</code></pre> </li> <li> <p>Wenn wir unsere Arbeit gut gemacht haben, sollten wir nach der Ausf\u00fchrung des Programms die folgende Ausgabe erhalten:</p> <p>``Text Wir haben ein neues Mitglied Wir haben ein neues Mitglied Ich sp\u00fcre eine St\u00f6rung in der Kraft Der Rat ist gefallen! ```</p> </li> <p>Nullpr\u00fcfung von Ereignissen</p> <p>Wenn Sie <code>null</code> in der Operation <code>JediCouncil.Add</code> verwendet haben, um zu pr\u00fcfen, ob es mindestens einen Abonnenten des Ereignisses gibt, konvertieren Sie dies in eine modernere L\u00f6sung (unter Verwendung von<code>?.Invoke</code>, die die Pr\u00fcfung auch in einer pr\u00e4gnanteren Form durchf\u00fchrt, aber ohne <code>null</code> Pr\u00fcfung - dies wurde in der zugeh\u00f6rigen Pr\u00e4sentation und im Labor besprochen). F\u00fcr <code>JediCouncil.Add</code> ist dies ausreichend, f\u00fcr <code>JediCouncil.Remove</code> sind beide L\u00f6sungen vorerst akzeptabel.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#aufgabe-4-delegierte","title":"Aufgabe 4 - Delegierte","text":""},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#verfasst-am_3","title":"Verfasst am","text":"<p>Erg\u00e4nzen Sie die Klasse <code>JediCouncil</code> um eine parameterlose Funktion**(der Funktionsname muss ** mit** <code>_Delegate</code>enden , das ist zwingend erforderlich**), die alle Mitglieder des Jedi-Rates mit einer Midi-Chlorzahl unter 530 zur\u00fcckgibt</p> <ul> <li>Verwenden Sie zur Abfrage eine Funktion, keine Eigenschaft.</li> <li>Um die Mitglieder innerhalb der Funktion zu finden, verwenden Sie die Funktion <code>FindAll()</code> der Klasse <code>List&lt;Jedi&gt;</code>. </li> <li>In dieser \u00dcbung k\u00f6nnen Sie lambda noch NICHT verwenden!</li> </ul> <p>Schreibe auch eine eigene \"Tester\"-Funktion (z.B. in der Klasse <code>Program</code> ), die unsere obige Funktion aufruft und die Namen der zur\u00fcckgegebenen Jedi-Ritter ausgibt! Diese Funktion sollte keinen Code enthalten, der nicht strikt mit der Aufgabe und somit auch nicht mit einer anderen (Unter-)Aufgabe zusammenh\u00e4ngt.</p> <p>Danger</p> <p>Gefahr \"Wichtig\" Siehe diese \"Tester\"-Funktion mit dem <code>[Description(\"Task4\")]</code> C#-Attribut. Rufen Sie die Funktion \u00fcber die Funktion <code>Main</code> der Klasse <code>Program</code> auf.</p> <p>Es ist wichtig, dass</p> <ul> <li>attribut \u00fcber Funktion und NE-Klasse,</li> <li>schreiben Sie das Attribut nicht \u00fcber die Funktion, die die Logik implementiert, sondern \u00fcber die Funktion, die sie testet,</li> <li>das Attribut kann nur \u00fcber einer einzigen Funktion erscheinen.</li> </ul> <p>Initialisierung auslagern</p> <p>F\u00fchren Sie bei der Implementierung eine eigene statische Methode ein (z.B. in der Klasse <code>Program</code> ), die ein Jeditan\u00e1cs-Objekt als Parameter annimmt und durch Aufruf von <code>Add</code> mindestens drei parametrisierte <code>Jedi</code> -Objekte hinzuf\u00fcgt. Unser Ziel ist es, eine Initialisierungsmethode zu haben, die in der/den sp\u00e4teren Aufgabe(n) verwendet werden kann, ohne dass der entsprechende Initialisierungscode dupliziert werden muss.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#losung_3","title":"L\u00f6sung","text":"<p>Zur L\u00f6sung dieser Aufgabe k\u00f6nnen Sie Labor 2 Labor 6 als Referenz verwenden. Um Sie zu unterst\u00fctzen, bieten wir Folgendes an:</p> <ul> <li>unsere Funktion kann mehrere Treffer zur\u00fcckgeben, daher ist der R\u00fcckgabetyp <code>List&lt;Jedi&gt;</code>,</li> <li>erwartet in unserem Fall eine Filterfunktion mit <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi j)</code> als Parameter <code>FindAll</code>. </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#ubung-5-lambda-ausdrucke","title":"\u00dcbung 5 - Lambda-Ausdr\u00fccke","text":"<p>Die \u00dcbung ist dieselbe wie die vorhergehende, nur dass wir diesmal mit Lambda-Ausdr\u00fccken arbeiten werden. Dieses Thema wurde sowohl in der Vorlesung als auch im Labor (Labor 2, \u00dcbung 6) behandelt.</p> <p>F\u00fcge der Klasse JediCouncil eine Funktion ohne Parameter hinzu**(der Funktionsname muss ** mit** <code>_Lambda</code>enden , das ist obligatorisch**), die alle Mitglieder des Jedi-Rates mit einer Midi-Chlorianzahl unter 1000 zur\u00fcckgibt</p> <ul> <li>Verwenden Sie zur Abfrage eine Funktion, keine Eigenschaft.</li> <li>Um die Mitglieder innerhalb der Funktion zu finden, verwenden Sie die Funktion <code>FindAll()</code> der Klasse <code>List&lt;Jedi&gt;</code>. </li> <li>In dieser \u00dcbung m\u00fcssen Sie einen Lambda-Ausdruck verwenden (es spielt keine Rolle, ob Sie Anweisungs- oder Ausdrucks-Lambda verwenden)!</li> </ul> <p>Schreibe auch eine eigene \"Tester\"-Funktion (z.B. in der Klasse <code>Program</code> ), die unsere obige Funktion aufruft und die Namen der zur\u00fcckgegebenen Jedi-Ritter ausgibt! Diese Funktion sollte keinen Code enthalten, der nicht strikt mit der Aufgabe und somit auch nicht mit einer anderen (Unter-)Aufgabe zusammenh\u00e4ngt.</p> <p>Wichtig</p> <p>Siehe diese \"Tester\"-Funktion mit dem <code>[Description(\"Task5\")]</code> C#-Attribut. Rufen Sie die Funktion \u00fcber die Funktion <code>Main</code> der Klasse <code>Program</code> auf.</p> <p>Es ist wichtig, dass</p> <ul> <li>attribut \u00fcber Funktion und NE-Klasse,</li> <li>schreiben Sie das Attribut nicht \u00fcber die Funktion, die die Logik implementiert, sondern \u00fcber die Funktion, die sie testet,</li> <li>das Attribut kann nur \u00fcber einer einzigen Funktion erscheinen.</li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#aufgabe-6-actionfunc-verwenden","title":"Aufgabe 6 - <code>Action</code>/<code>Func</code> verwenden","text":"<p>Diese \u00dcbung baut auf dem Stoff der Vorlesung 3 auf und war (aus Zeitgr\u00fcnden) nicht Bestandteil des Praktikums. Dennoch handelt es sich um ein wesentliches Kernthema des Fachs.</p> <p>F\u00fcgen Sie dem Projekt eine Klasse <code>Person</code> und eine Klasse <code>ReportPrinter</code> (jeweils in einer Datei mit dem gleichen Namen wie die Klasse) mit folgendem Inhalt hinzu:</p> Person und ReportPrinter Klassen <pre><code>class Person\n{\n    public Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n</code></pre> <pre><code>class ReportPrinter\n{\n    private readonly IEnumerable&lt;Person&gt; people;\n    private readonly Action headerPrinter;\n\n    public ReportPrinter(IEnumerable&lt;Person&gt; people, Action headerPrinter)\n    {\n        this.people = people;\n        this.headerPrinter = headerPrinter;\n    }\n\n    public void PrintReport()\n    {\n        headerPrinter();\n        Console.WriteLine(\"-----------------------------------------\");\n        int i = 0;\n        foreach (var person in people)\n        {\n            Console.Write($\"{++i}. \");\n            Console.WriteLine(\"Person\");\n        }\n        Console.WriteLine(\"--------------- Summary -----------------\");\n        Console.WriteLine(\"Footer\");\n    }\n}\n</code></pre> <p>Diese Klasse <code>ReportPrinter</code> kann verwendet werden, um einen formatierten Bericht \u00fcber die Daten der in ihrem Konstruktor angegebenen Personen in die Konsole zu schreiben, und zwar in einer Dreifachaufteilung von Kopfzeile/Daten/Fu\u00dfzeile. F\u00fcgen Sie die folgende Funktion zu <code>Program.cs</code> hinzu, um <code>ReportPrinter</code> zu testen, und rufen Sie sie von <code>Main</code> aus auf:</p> Test ReportPrinter <pre><code>[Description(\"Task6\")]\nstatic void test6()\n{\n    var employees = new Person[] { new Person(\"Joe\", 20), new Person(\"Jill\", 30) };\n\n    ReportPrinter reportPrinter = new ReportPrinter(\n        employees,\n        () =&gt; Console.WriteLine(\"Employees\")\n        );\n\n    reportPrinter.PrintReport();\n}\n</code></pre> <p>F\u00fchren Sie die Anwendung aus. Die Ausgabe auf der Konsole sieht wie folgt aus:</p> <pre><code>Employees\n-----------------------------------------\n1. Person\n2. Person\n--------------- Summary -----------------\nFooter\n</code></pre> <p>Die erste Zeile \u00fcber \"----\" ist die Kopfzeile. Unter jeder Person befindet sich ein eingebrannter \"Person\"-Text, dann unter \"----\" die Fu\u00dfzeile, vorerst nur mit einem eingebrannten \"Footer\"-Text.</p> <p>In der L\u00f6sung k\u00f6nnen Sie sehen, dass der \u00dcberschriftentext nicht in die Klasse <code>ReportPrinter</code> eingebrannt wird. Diese wird vom Benutzer von <code>ReportPrinter</code> in einem Konstruktorparameter in Form eines Delegaten, in unserem Fall eines Lambda-Ausdrucks, angegeben. Der Delegatentyp ist der in .NET integrierte Typ <code>Action</code>. </p> <p>Die Aufgaben sind:</p> <p>Warning</p> <p>Sie k\u00f6nnen NICHT Ihren eigenen Delegattyp in der L\u00f6sung verwenden (arbeiten Sie mit .NET eingebauten Delegattypen, die L\u00f6sung ist nur dann akzeptabel).</p> <ol> <li> <p>Umstrukturierung der Klasse <code>ReportPrinter</code>, so dass der Benutzer der Klasse nicht nur die Kopfzeile, sondern auch die Fu\u00dfzeile in Form eines Delegaten angeben kann.</p> </li> <li> <p>\u00c4ndern Sie die Klasse <code>ReportPrinter</code> so, dass der feste Text \"Person\" nicht angezeigt wird, wenn jede Person hinzugef\u00fcgt wird, sondern der Benutzer der Klasse <code>ReportPrinter</code> die Daten jeder Person nach Bedarf \u00fcber einen Delegaten hinzuf\u00fcgen kann (anstelle des festen Texts \"Person\"). Es ist wichtig, dass die Zeilennummer immer am Anfang der Zeile steht, sie kann vom Benutzer von <code>ReportPrinter</code> nicht ge\u00e4ndert werden!</p> <p>Tipp f\u00fcr die L\u00f6sung</p> <p>Denken Sie an einen \u00e4hnlichen Ansatz wie f\u00fcr die Kopf- und Fu\u00dfzeile, aber hier muss der Benutzer von <code>ReportPrinter</code> das Personenobjekt erhalten, um es formatiert in die Konsole schreiben zu k\u00f6nnen.</p> </li> <li> <p>\u00c4ndern Sie in der Datei <code>Program.cs</code> die Verwendung von <code>ReportPrinter</code> (mit den entsprechenden Lambda-Ausdr\u00fccken), so dass die Ausgabe auf der Konsole lautet:</p> <pre><code>Employees\n-----------------------------------------\n1. Name: Joe (Age: 20)\n2. Name: Jill (Age: 30)\n--------------- Summary -----------------\nAnzahl der Mitarbeiter: 2\n</code></pre> <p>Hausaufgabenpr\u00fcfung</p> <p>Die Aufgabe \"Aufgabe 6\", d.h. ob Sie <code>ReportPrinter</code>und dessen Verwendung korrekt konvertiert haben, wird NICHT vom automatischen GitHub-Checker gepr\u00fcft. Testen Sie Ihre L\u00f6sung gr\u00fcndlich, damit Sie nicht erst nach dem Abgabetermin bei der manuellen Kontrolle Ihrer Hausaufgaben feststellen, dass sie nicht akzeptabel ist.</p> </li> <li> <p>Die n\u00e4chste \u00dcbung ist optional und bietet Ihnen eine gute Gelegenheit, die eingebauten <code>Func</code> Delegierten zu \u00fcben. Die Klasse <code>ReportPrinter</code> hat einen gro\u00dfen Nachteil: Der Ausgabebericht kann nur auf der Konsole angezeigt werden. Eine flexiblere L\u00f6sung w\u00e4re, nicht in die Konsole zu schreiben, sondern einen String zu verwenden, um den Bericht zu erstellen. Diese Zeichenkette kann auf beliebige Weise verwendet werden (z. B. in eine Datei schreiben).</p> <p>Die Aufgabe besteht darin, eine Klasse <code>ReportBuilder</code> einzuf\u00fchren, die auf der bestehenden <code>ReportPrinter</code> basiert, aber nicht in die Konsole schreibt, sondern eine Zeichenkette mit dem vollst\u00e4ndigen Bericht erzeugt, der durch eine neu eingef\u00fchrte Operation <code>GetResult()</code> abgerufen werden kann. </p> <p>Tipps f\u00fcr die L\u00f6sung</p> <ul> <li>Es ist eine gute Idee, eine <code>StringBuilder</code> Mitgliedsvariable in die Klasse einzuf\u00fchren und mit ihr zu arbeiten. Dies ist um Gr\u00f6\u00dfenordnungen effizienter als die Verkettung von Zeichenketten mit \"+\".</li> <li>In diesem Fall sollte der Benutzer der Klasse <code>ReportBuilder</code> nicht mehr in die Konsole schreiben, sondern die an die Ausgabe anzuh\u00e4ngenden Zeichenketten an <code>ReportBuilder</code> zur\u00fcckgeben und dabei die entsprechenden eingebauten Typdelegierten verwenden ( <code>Action</code> ist hier nicht geeignet). Verwenden Sie jetzt Lambda-Terme in der Pr\u00fcfung!</li> </ul> </li> </ol>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#aufgabe-7-imsc-verwendung-eingebauter-funcaction-generischer-delegatentypen","title":"Aufgabe 7 (IMSc) - Verwendung eingebauter <code>Func</code>/<code>Action</code> generischer Delegatentypen","text":"<p>Das L\u00f6sen der Aufgabe ist nicht obligatorisch, aber sehr empfehlenswert: Es handelt sich um einen Grundstoff, der in die ZH/Pr\u00fcfung aufgenommen werden kann. Nicht in einem Labor, nur in einer Vorlesung.</p> <p>Die L\u00f6sung bringt au\u00dferdem +2 IMSc-Punkte ein.</p>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#verfasst-am_4","title":"Verfasst am","text":"<p>Erweitern Sie die Klasse <code>JediCouncil</code>. </p> <ul> <li> <p>Erstellen Sie eine Eigenschaft <code>Count</code> mit dem R\u00fcckgabewert <code>int</code>, die bei jeder Abfrage die aktuelle Anzahl der Jedi im Rat zur\u00fcckgibt. Achten Sie darauf, dass dieser Wert nur abgefragt (nicht gesetzt) werden kann.</p> <p>Tipp</p> <p>Die Membervariable members in <code>JediCouncil</code>hat eine Eigenschaft <code>Count</code>, die L\u00f6sung baut darauf auf.</p> </li> <li> <p>Erstellen Sie eine Funktion namens <code>CountIf</code>, die ebenfalls die Anzahl der Ratsmitglieder z\u00e4hlt, aber nur die Ratsmitglieder ber\u00fccksichtigt, die bestimmte Bedingungen erf\u00fcllen. Der R\u00fcckgabewert der Funktion ist <code>int</code>, und die Bedingung, f\u00fcr die sie die entsprechende Anzahl von Ratsmitgliedern zur\u00fcckgibt, wird als Parameter \u00fcber einen Delegaten zur\u00fcckgegeben ( <code>CountIf</code>muss also einen Parameter haben).</p> <p>Delegatentyp</p> <p>Der Delegatentyp muss der richtige der eingebauten generischen <code>Action</code> / <code>Func</code> Delegatentypen sein (d.h. Sie k\u00f6nnen nicht Ihren eigenen Delegatentyp oder den eingebauten <code>Predicate</code> Typ verwenden).</p> <p>Aus diesem Grund k\u00f6nnen Sie die eingebaute Operation <code>FindAll</code> f\u00fcr die Liste NICHT verwenden, da der von uns verwendete Delegatentyp nicht mit dem von <code>FindAll</code> erwarteten Parameter kompatibel w\u00e4re. Bearbeite die Tags, indem du eine `foreach'-Schleife durchl\u00e4ufst!</p> </li> <li> <p>Zeigen Sie die Eigenschaft und die Funktion in einer eigenen gemeinsamen Funktion, die Sie mit dem Attribut <code>[Description(\"Task7\")]</code> bereitstellen k\u00f6nnen. Diese Funktion sollte keinen Code enthalten, der nicht unmittelbar mit der Aufgabe zusammenh\u00e4ngt. Um den Jedi-Rat zu laden, rufen Sie die in der vorherigen Aufgabe vorgestellte Hilfsfunktion auf. Rufen Sie die Funktion \u00fcber die Funktion <code>Main</code> der Klasse <code>Program</code> auf. </p> <p>Wichtig</p> <p>Das Attribut <code>[Description(\"Task7\")]</code> kann nur oberhalb einer einzigen Funktion verwendet werden.</p> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#losung_4","title":"L\u00f6sung","text":"<ul> <li>Bei einer Eigenschaft namens <code>Count</code> ist nur der Zweig <code>get</code> sinnvoll, der Zweig <code>set</code> wird also nicht geschrieben. Diese Eigenschaft sollte schreibgesch\u00fctzt sein.</li> <li>\u00dcbung 4 hilft Ihnen, die Funktion <code>CountIf</code> zu schreiben. Der Unterschied besteht darin, dass <code>CountIf</code> nicht die Anzahl der Ratsmitglieder, sondern nur die Anzahl der St\u00fccke angibt.<ul> <li>Die Funktion <code>CountIf</code> sollte eine Filterfunktion mit der Signatur <code>bool F\u00fcggv\u00e9nyn\u00e9v(Jedi jedi)</code> als Bedingungsparameter erwarten.</li> </ul> </li> </ul>"},{"location":"hazi/2-nyelvi-eszkozok/index_ger/#vorlegen-bei","title":"Vorlegen bei","text":"<p>Checkliste f\u00fcr Wiederholungen:</p> <ul> <li>Geben Sie in der Datei neptun.txt im Stammverzeichnis des Repositorys Ihren Neptun-Code in Gro\u00dfbuchstaben ein. Die Datei sollte nur diese sechs Zeichen enthalten und nichts anderes.</li> <li>Sie sollten in den urspr\u00fcnglichen L\u00f6sungen/Projekten arbeiten, die Sie von GitHub heruntergeladen haben, und nicht in neu erstellten Projekten.</li> <li>Solange Sie nicht mit Visual Studio Git vertraut sind, sollten Sie nach dem Push (sp\u00e4testens wenn die Hausarbeit als eingereicht gilt) \u00fcberpr\u00fcfen, ob Sie alle \u00c4nderungen hochgeladen haben, indem Sie sich die Dateien im Repository auf der GitHub-Weboberfl\u00e4che ansehen.</li> <li>\u00dcberpr\u00fcfen Sie in der GitHub-Schnittstelle nach dem Push, ob der GitHub Action-basierte Pre-Validator fehlerfrei gelaufen ist.</li> <li>Es ist wichtig, dass Aufgaben nur angenommen werden, wenn sie vollst\u00e4ndig abgeschlossen sind und den Anforderungen in jeder Hinsicht entsprechen. Nicht rotierenden Codes oder Teill\u00f6sungen sollte man nicht trauen.</li> <li>Nat\u00fcrlich m\u00fcssen Sie Ihre eigene Arbeit einreichen (da sie bewertet wird).</li> </ul>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/","title":"3. HF - Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa","text":""},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A h\u00e1zi feladatban elk\u00e9sz\u00edtend\u0151 kis szoftver egy egyszer\u0171 feladatkezel\u0151 alkalmaz\u00e1s, amelyben a felhaszn\u00e1l\u00f3k feladatokat tudnak list\u00e1zni l\u00e9trehozni, m\u00f3dos\u00edtani.</p> <p>Az \u00f6n\u00e1ll\u00f3 feladat a XAML el\u0151ad\u00e1sokon elhangzottakra \u00e9p\u00edt. A feladatok gyakorlati h\u00e1tter\u00e9\u00fcl a 3. labor \u2013 Felhaszn\u00e1l\u00f3i fel\u00fcletek kialak\u00edt\u00e1sa laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel (n\u00e9ha alap\u00e9rtelmezetten \u00f6sszecsukva) \u00f6n\u00e1ll\u00f3an elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>XAML fel\u00fcletle\u00edr\u00f3 nyelv haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Alapvet\u0151 vez\u00e9rl\u0151k (t\u00e1bl\u00e1zat, gomb, sz\u00f6vegdoboz, list\u00e1k) haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Fel\u00fcleti interakci\u00f3k kezel\u00e9se esem\u00e9nyvez\u00e9relten</li> <li>Adatok megjelen\u00edt\u00e9se a fel\u00fcleten adatk\u00f6t\u00e9ssel</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p> <p>Fejleszt\u0151k\u00f6rnyezet WinUI3 fejleszt\u00e9shez</p> <p>A kor\u00e1bbi laborokhoz k\u00e9pest plusz komponensek telep\u00edt\u00e9se sz\u00fcks\u00e9ges. A fenti oldal eml\u00edti, hogy sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re, valamint ugyanitt az oldal alj\u00e1n van egy \"WinUI t\u00e1mogat\u00e1s\" fejezet, az itt megadott l\u00e9p\u00e9seket is mindenk\u00e9ppen meg kell tenni!</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<p> B\u00e1r az alapok hasonl\u00f3k, vannak l\u00e9nyeges, a folyamatra \u00e9s k\u00f6vetelm\u00e9nyekre vonatkoz\u00f3 elt\u00e9r\u00e9sek a kor\u00e1bbi h\u00e1zi feladatokhoz k\u00e9pest, \u00edgy mindenk\u00e9ppen figyelmesen olvasd el a k\u00f6vetkez\u0151ket.</p> <ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>TodoXaml.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> <li> Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</li> </ul>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#kikotesek","title":"Kik\u00f6t\u00e9sek","text":"<p> MVVM minta - ne alkalmazd!   Jelen h\u00e1zi feladatban az MVVM mint\u00e1t m\u00e9g NE haszn\u00e1ld (egyik k\u00e9s\u0151bbi r\u00e9szfeladatn\u00e1l sem), <code>ViewModel</code> oszt\u00e1lyt NE vezess be. Az MVVM egy k\u00e9s\u0151bb h\u00e1zi feladatnak lesz a t\u00e1rgya.</p> <p> Layout - egyszer\u0171s\u00e9g Mint \u00e1ltal\u00e1ban, a jelen h\u00e1zi feladat keret\u00e9ben elk\u00e9sz\u00edtend\u0151 feladatra is igaz, hogy az oldal alapelrendez\u00e9s\u00e9t <code>Grid</code>-del c\u00e9lszer\u0171 kialak\u00edtani. Ugyanakkor az egyes bels\u0151 r\u00e9szek elrendez\u00e9s\u00e9nek kialak\u00edt\u00e1sakor t\u00f6rekedj az egyszer\u0171s\u00e9gre: ahol az <code>StackPanel</code>-t is lehet haszn\u00e1lni, ne haszn\u00e1lj <code>Grid</code>-et.</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#1-feladat-modell-kialakitasa-es-tesztadatok","title":"1. feladat - Modell kialak\u00edt\u00e1sa \u00e9s tesztadatok","text":"<p>A projekten bel\u00fcl hozzunk l\u00e9tre egy <code>Models</code> mapp\u00e1t (VS Solution Exporerben), majd a mapp\u00e1ba az al\u00e1bbi \u00e1br\u00e1n l\u00e1that\u00f3 oszt\u00e1lyt \u00e9s enum t\u00edpust. A <code>TodoItem</code> oszt\u00e1ly fogja tartalmazni a teend\u0151k adatait, a priorit\u00e1shoz egy felsorolt t\u00edpust hozunk l\u00e9tre.</p> <p></p> <p>Mindk\u00e9t t\u00edpus legyen publikus (\u00edrjuk a <code>class</code> \u00e9s az <code>enum</code> el\u00e9 a <code>public</code> kulcssz\u00f3t), k\u00fcl\u00f6nben \"Inconsistent accessibility\" hib\u00e1t kapn\u00e1nk a k\u00e9s\u0151bbiekben a ford\u00edt\u00e1s sor\u00e1n.</p> <p>A <code>MainPage</code> oldal fogja a teend\u0151k list\u00e1j\u00e1t megjelen\u00edteni. Most mem\u00f3ri\u00e1ban l\u00e9v\u0151 tesztadatokat haszn\u00e1ljunk, melyeket a <code>Views</code> mapp\u00e1ban tal\u00e1lhat\u00f3 <code>MainPage.xaml.cs</code>-ben hozzunk l\u00e9tre: itt <code>Todos</code> n\u00e9ven vezess\u00fcnk be egy <code>List&lt;TodoItem&gt;</code> tulajdons\u00e1got (melyet k\u00e9s\u0151bb a fel\u00fcleten elhelyezett <code>ListView</code> vez\u00e9rl\u0151h\u00f6z k\u00f6t\u00fcnk adatk\u00f6t\u00e9ssel). Ez a lista <code>TodoItem</code> objektumokat tartalmaz.</p> MainPage.xaml.cs<pre><code>public List&lt;TodoItem&gt; Todos { get; set; } = new()\n{\n    new TodoItem()\n    {\n        Id = 3,\n        Title = \"Add Neptun code to neptun.txt\",\n        Description = \"NEPTUN\",\n        Priority = Priority.Normal,\n        IsDone = false,\n        Deadline = new DateTime(2024, 11, 08)\n    },\n    new TodoItem()\n    {\n        Id = 1,\n        Title = \"Buy milk\",\n        Description = \"Should be lactose and gluten free!\",\n        Priority = Priority.Low,\n        IsDone = true,\n        Deadline = DateTimeOffset.Now + TimeSpan.FromDays(1)\n    },\n    new TodoItem()\n    {\n        Id = 2,\n        Title = \"Do the Computer Graphics homework\",\n        Description = \"Ray tracing, make it shiny and gleamy! :)\",\n        Priority = Priority.High,\n        IsDone = false,\n        Deadline = new DateTime(2024, 11, 08)\n    },\n};\n</code></pre> A fenti k\u00f3d magyar\u00e1zata <p>A fenti k\u00f3dr\u00e9szletben t\u00f6bb modern C# nyelvi elemet kombin\u00e1ltunk:</p> <ul> <li>Ez egy auto-implement\u00e1lt tulajdons\u00e1g (l\u00e1sd 2. labor).</li> <li>Kedz\u0151\u00e9rt\u00e9ket adtunk neki.</li> <li>A <code>new</code> ut\u00e1n nem adtuk meg a t\u00edpust, mert a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni (l\u00e1sd 2. labor \"Target-typed new expressions\").</li> <li>A gy\u0171jtem\u00e9ny elemeit <code>{}</code> k\u00f6z\u00f6tt soroljuk fel (l\u00e1sd 2. labor \"Collection initializer szintaxis\").</li> </ul> <p><code>MainPage</code> oszt\u00e1ly</p> <p>A h\u00e1zi feladat sor\u00e1n a be\u00e9p\u00edtett <code>Page</code> oszt\u00e1lyb\u00f3l sz\u00e1rmaz\u00f3 <code>MainPage</code> oszt\u00e1lyban dolgozunk. A <code>Page</code> oszt\u00e1ly az ablakon bel\u00fcli oldalak k\u00f6z\u00f6tti navig\u00e1ci\u00f3t seg\u00edti. B\u00e1r jelen feladatban ezt nem haszn\u00e1ljuk ki, \u00e9rdemes megszokni a haszn\u00e1lat\u00e1t. Mivel alkalmaz\u00e1sunk egyetlen oldalb\u00f3l \u00e1ll, a f\u0151ablakban egyszer\u0171en csak p\u00e9ld\u00e1nyos\u00edtunk egy <code>MainPage</code> objektumot (\u00e9rdemes a <code>MainWindow.xaml</code> f\u00e1jlban ezt megtekinteni).</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#2-feladat-oldal-elrendezese-layout-lista-megjelenitese","title":"2. feladat - Oldal elrendez\u00e9se (layout), lista megjelen\u00edt\u00e9se","text":""},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#layout","title":"Layout","text":"<p>A <code>MainPage.xaml</code>-ben hozzuk l\u00e9tre a fel\u00fcletet, amelyen a teend\u0151k list\u00e1j\u00e1t megjelen\u00edtj\u00fck.</p> <p> K\u00e9sz\u00edtend\u0151 alkalmaz\u00e1s list\u00e1z\u00f3 fel\u00fclettel</p> <p>Mint a fenti \u00e1bra a h\u00e1rom teend\u0151vel mutatja, a teend\u0151k adatait egym\u00e1s alatt kell megjelen\u00edteni, a teend\u0151k priorit\u00e1s\u00e1t sz\u00ednek jelzik, a k\u00e9sz teend\u0151k mellett azok jobb oldal\u00e1n egy pipa jelenik meg.</p> <p>A fel\u00fcleten a k\u00f6vetkez\u0151 strukt\u00far\u00e1ban helyezkednek el az elemek:</p> <ul> <li>A <code>MainPage</code>-en bel\u00fcl egy <code>Grid</code>-et haszn\u00e1ljunk, amelyben k\u00e9t sorban \u00e9s k\u00e9t oszlopban helyezkednek el az elemek. Az els\u0151 oszlop fix sz\u00e9les legyen (pl.: 300 px), a m\u00e1sodik pedig a marad\u00e9k helyet foglalja el.</li> <li> <p>Az els\u0151 oszlop els\u0151 sor\u00e1ban egy <code>CommandBar</code> vez\u00e9rl\u0151 ker\u00fclj\u00f6n, melyben egy c\u00edm \u00e9s egy gomb helyezkedik el. Ehhez az al\u00e1bbi p\u00e9lda szolg\u00e1l seg\u00edts\u00e9g\u00fcl:</p> <pre><code>&lt;CommandBar VerticalContentAlignment=\"Center\"\n            Background=\"{ThemeResource AppBarBackgroundThemeBrush}\"\n            DefaultLabelPosition=\"Right\"&gt;\n    &lt;CommandBar.Content&gt;\n        &lt;TextBlock Margin=\"12,0,0,0\"\n                   Style=\"{ThemeResource SubtitleTextBlockStyle}\"\n                   Text=\"To-Dos\" /&gt;\n    &lt;/CommandBar.Content&gt;\n\n    &lt;AppBarButton Icon=\"Add\"\n                  Label=\"Add\" /&gt;\n&lt;/CommandBar&gt;\n</code></pre> <p>Vil\u00e1gos/s\u00f6t\u00e9t megjelen\u00e9s</p> <p>A Windows be\u00e1ll\u00edtasainak f\u00fcggv\u00e9ny\u00e9ben (light/dark mode) lehets\u00e9ges, hogy s\u00f6t\u00e9t h\u00e1tt\u00e9ren vil\u00e1gos sz\u00ednekkel jelenik meg a fel\u00fclet, ez is teljesen rendben van. A WinUI alkalmaz\u00e1sok alap\u00e9rtelemezett esetben alkalmazkodnak az oper\u00e1ci\u00f3s rendszer be\u00e1ll\u00edt\u00e1s\u00e1hoz, ebb\u0151l ered ez a viselked\u00e9s.</p> <p>ThemeResource</p> <p>A p\u00e9ld\u00e1ban szerepl\u0151 <code>ThemeResource</code>-okat haszn\u00e1lhatjuk a sz\u00ednek \u00e9s st\u00edlusok be\u00e1ll\u00edt\u00e1s\u00e1ra, melyek a fel\u00fclet t\u00e9m\u00e1j\u00e1t\u00f3l f\u00fcgg\u0151en v\u00e1ltoznak. P\u00e9ld\u00e1ul a <code>AppBarBackgroundThemeBrush</code> a fel\u00fclet t\u00e9m\u00e1j\u00e1t\u00f3l (vil\u00e1gos/s\u00f6t\u00e9t) f\u00fcgg\u0151en a megfelel\u0151 sz\u00edn\u0171 h\u00e1tt\u00e9r lesz.</p> <p>R\u00e9szletek\u00e9rt l\u00e1sd a dokument\u00e1ci\u00f3t \u00e9s a WinUI 3 Gallery App Colors p\u00e9ld\u00e1it.</p> </li> </ul> <p>Ha j\u00f3l dolgoztunk, az alkalmaz\u00e1st futtatva, <code>CommandBar</code>-nak a megfelel\u0151 helyen meg kell jelennie.</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#lista-megjelenitese","title":"Lista megjelen\u00edt\u00e9se","text":"<p>A <code>CommandBar</code> alatti cell\u00e1ban egy list\u00e1ba (<code>ListView</code>) ker\u00fcljenek a teend\u0151k a k\u00f6vetkez\u0151 tartalommal egym\u00e1s alatt. Az adatok adatk\u00f6t\u00e9sen kereszt\u00fcl hassanak a fel\u00fclet megjelen\u00edt\u00e9s\u00e9re (a kor\u00e1bban bevezetett <code>Todos</code> list\u00e1b\u00f3l jelenjenek meg adatk\u00f6t\u00e9ssel az elemek).</p> <ul> <li>Teend\u0151 c\u00edme<ul> <li>F\u00e9lk\u00f6v\u00e9r (SemiBold) bet\u0171t\u00edpussal</li> <li>Priorit\u00e1s alapj\u00e1n sz\u00ednezve<ul> <li>Magas priorit\u00e1s: piros egy \u00e1rnyalata</li> <li>Norm\u00e1l priorit\u00e1s: be\u00e9p\u00edtett el\u0151t\u00e9rsz\u00edn</li> <li>Alacsony priorit\u00e1s: k\u00e9k egy \u00e1rnyalata</li> </ul> </li> </ul> </li> <li>A teend\u0151 c\u00edm\u00e9vel egy sorban jobbra rendezve egy pipa ikon, ha a teend\u0151 el van v\u00e9gezve</li> <li>Teend\u0151 le\u00edr\u00e1sa</li> <li>Teend\u0151 hat\u00e1rideje <code>yyyy.MM.dd</code> form\u00e1tumban</li> <li>A <code>ListView</code> h\u00e1ttere legyen azonos a <code>CommandBar</code>-\u00e9val, \u00edgy baloldalt egy egybef\u00fcgg\u0151 s\u00e1vot alkotnak.</li> </ul> Elemek a list\u00e1ban <p>Mindig gondoljuk \u00e1t, hogy egy objektumhoz t\u00f6rt\u00e9n\u0151, vagy list\u00e1s adatk\u00f6t\u00e9sr\u0151l van-e sz\u00f3, \u00e9s ennek megfelel\u0151 technik\u00e1t alkalmazzunk! Jelen h\u00e1zi feladatban nem biztos, olyan sorrendben j\u00f6nnek ezek el\u0151, mint ahogy laboron szerepeltek!\"</p> Felt\u00e9teles sz\u00ednez\u00e9s <p>A c\u00edm sz\u00ednez\u00e9s\u00e9re haszn\u00e1lhatunk konvertert vagy <code>x:Bind</code> alap\u00fa f\u00fcggv\u00e9ny k\u00f6t\u00e9st is.</p> <ul> <li> <p><code>x:Bind</code> alap\u00fa f\u00fcggv\u00e9ny k\u00f6t\u00e9s p\u00e9lda:</p> <pre><code>Foreground=\"{x:Bind local:MainPage.GetForeground(Priority)}\"\n</code></pre> <p>Itt a <code>GetForeground</code> egy publikus statikus f\u00fcggv\u00e9ny a <code>MainPage</code> oszt\u00e1lyban, amely a <code>Priority</code> felsorolt t\u00edpus alapj\u00e1n visszaadja a megfelel\u0151 sz\u00edn\u0171 <code>Brush</code> objektumot. Alap esetben nem lenne fontos a f\u00fcggv\u00e9nynek statikusnak lennie, de mivel itt egy <code>DataTemplate</code>-ben haszn\u00e1ljuk az adatk\u00f6t\u00e9st, ez\u00e9rt az <code>x:Bind</code> kontextusa nem az oldal p\u00e9ld\u00e1nya lesz, hanem a listaelem.</p> </li> <li> <p>Converter haszn\u00e1lat\u00e1ra p\u00e9lda:</p> <p>Hozzunk l\u00e9tre egy konverter oszt\u00e1lyt egy <code>Converters</code> mapp\u00e1ba, ami megval\u00f3s\u00edtja az <code>IValueConverter</code> interf\u00e9szt.</p> <pre><code>public class PriorityBrushConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, string language)\n    {\n        // TODO return a SolidColorBrush instance\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, string language)\n    {\n        throw new NotImplementedException();\n    }\n}\n</code></pre> <p>P\u00e9ld\u00e1nyos\u00edtsuk a konvertert a <code>MainPage</code> er\u0151forr\u00e1sai k\u00f6z\u00f6tt.</p> <pre><code>xmlns:c=\"using:TodoXaml.Converters\"\n\n&lt;Page.Resources&gt;\n    &lt;c:PriorityBrushConverter x:Key=\"PriorityBrushConverter\" /&gt;\n&lt;/Page.Resources&gt;\n</code></pre> <p>Haszn\u00e1ljuk az adatk\u00f6t\u00e9sben statikus er\u0151forr\u00e1sk\u00e9nt a konvertert</p> <pre><code>Foreground=\"{x:Bind Priority, Converter={StaticResource PriorityBrushConverter}}\"\n</code></pre> </li> </ul> <p>A Brushok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1hoz haszn\u00e1ljuk a <code>SolidColorBrush</code> oszt\u00e1lyt, vagy haszn\u00e1lhatunk be\u00e9p\u00edtett ecseteket is C#-k\u00f3db\u00f3l (mint fentebb a <code>ThemeResource</code>-szal).</p> <pre><code>new SolidColorBrush(Colors.Red);\n\n(Brush)App.Current.Resources[\"ApplicationForegroundThemeBrush\"]\n</code></pre> F\u00e9lk\u00f6v\u00e9r bet\u0171t\u00edpus <p>A bet\u0171jellemz\u0151ket a \"Font...\" nev\u0171 tulajdons\u00e1gok hat\u00e1rozz\u00e1k meg: <code>FontFamily</code>, <code>FontSize</code>, <code>FontStyle</code>, <code>FontStretch</code> \u00e9s <code>FontWeight</code>.</p> Pipa ikon l\u00e1that\u00f3s\u00e1ga <p>A pipa ikonhoz haszn\u00e1ljunk egy <code>SymbolIcon</code>-t, aminek az <code>Symbol</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be <code>Accept</code> \u00e9rt\u00e9kre.</p> <p>A pipa ikon megjelen\u00edt\u00e9sekor egy igaz-hamis \u00e9rt\u00e9ket kell \u00e1talak\u00edtani <code>Visibility</code> t\u00edpus\u00fara. Erre ugyan haszn\u00e1lhatn\u00e1nk konvertert is, de ez a konverzi\u00f3 annyira gyakori, hogy az <code>x:Bind</code> adatk\u00f6t\u00e9s be\u00e9p\u00edtetten konvert\u00e1lja a <code>bool</code> \u00e9rt\u00e9ket <code>Visibility</code>-re.</p> Pipa ikon igaz\u00edt\u00e1sa <p>A teend\u0151 c\u00edme \u00e9s a pipa ikon egy sorban kell elhelyezkedjenek (egyik balra, m\u00e1sik jobbra igaz\u00edtva). Ehhez egy tipp: pl. be lehet vetni egy egycell\u00e1s <code>Grid</code>-et. <code>Grid</code>-ben lehet olyat csin\u00e1lni, hogy egy cell\u00e1ba t\u00f6bb vez\u00e9rl\u0151t tesz\u00fcnk \"egym\u00e1sra\", melyek igaz\u00edt\u00e1sa k\u00fcl\u00f6n szab\u00e1lyozhat\u00f3. A m\u00e1sodik laboron \u00edgy oldottuk meg a <code>ListView</code> <code>DataTemplate</code>-ben a n\u00e9v \u00e9s a kor megjelen\u00edt\u00e9s\u00e9t.</p> D\u00e1tumok form\u00e1z\u00e1sa <p>A hat\u00e1rid\u0151 d\u00e1tum form\u00e1z\u00e1s\u00e1ra haszn\u00e1lhatunk szint\u00e9n konvertert vagy <code>x:Bind</code> alap\u00fa f\u00fcggv\u00e9ny k\u00f6t\u00e9st is, ahol a <code>DateTime.ToString</code> f\u00fcggv\u00e9ny\u00e9t k\u00f6tj\u00fck ki param\u00e9terezve.</p> <pre><code>Text=\"{x:Bind Deadline.ToString('yyyy.MM.dd', x:Null)}\"\n</code></pre> <p>A <code>x:Null</code> az\u00e9rt kell, mert a <code>ToString</code> f\u00fcggv\u00e9nynek a m\u00e1sodik param\u00e9ter\u00e9t is meg kell adni, de az lehet <code>null</code> is ebben az esetben.</p> Listaelemek k\u00f6z\u00f6tti hely <p>Az \u00fatmutat\u00f3 k\u00e9perny\u0151ment\u00e9s\u00e9n l\u00e1tszik, hogy a listaelemek k\u00f6z\u00f6tt f\u00fcgg\u0151legesen van kihagyott hely, a listaelemek \u00edgy j\u00f3l elk\u00fcl\u00f6n\u00fclnek. Alapesetben ez nincs \u00edgy. Szerencs\u00e9re a megold\u00e1s sor\u00e1n \u00fagyis kell DataTemplate-et alkalmazni az elemek megjelen\u00edt\u00e9s\u00e9re, \u00edgy ennek kicsi hangol\u00e1s\u00e1val (tipp: egyetlen Margin/Padding megad\u00e1sa) k\u00f6nnyed\u00e9n el\u00e9rhetj\u00fck, hogy a listaelemek k\u00f6z\u00f6tt legyen n\u00e9mi hely a jobb olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben. </p> <p>2. feladat BEADAND\u00d3</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol az egyik teend\u0151nek a list\u00e1ban a neve vagy le\u00edr\u00e1sa a NEPTUN k\u00f3dod legyen! (<code>f2.png</code>)</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#3-feladat-uj-teendo-hozzaadasa","title":"3. feladat - \u00daj teend\u0151 hozz\u00e1ad\u00e1sa","text":"<p>A grid jobb oldal\u00e1n az 1. sorban a \"To-Do item\" sz\u00f6veg legyen l\u00e1that\u00f3, 25-\u00f6s bet\u0171m\u00e9rettel, v\u00edzszintesen balra, f\u00fcgg\u0151legesen pedig k\u00f6z\u00e9pre igaz\u00edtva, baloldalon 20 pixelnyi \u00fcres hellyel.</p> <p>A fel\u00fcleten a Hozz\u00e1ad\u00e1s gombra kattintva jelenjen a 2. sorban egy \u0171rlap, ahol \u00faj teend\u0151t lehet felvenni.</p> <p>Az \u0171rlap kin\u00e9zete legyen a k\u00f6vetkez\u0151:</p> <p> Teend\u0151 szerkeszt\u0151 \u0171rlap</p> <p>Az \u0171rlapban a k\u00f6vetkez\u0151 elemek legyenek egym\u00e1s alatt.</p> <ul> <li>C\u00edm: sz\u00f6veges beviteli mez\u0151</li> <li>Le\u00edr\u00e1s: magasabb sz\u00f6veges beviteli mez\u0151, fogadjon el sort\u00f6r\u00e9st (enter) is (<code>AcceptsReturn=\"True\"</code>)</li> <li>Hat\u00e1rid\u0151: d\u00e1tumv\u00e1laszt\u00f3 (<code>DatePicker</code>) (Megj.: Ez\u00e9rt a vez\u00e9rl\u0151 miatt haszn\u00e1lunk a modellben <code>DateTimeOffset</code> t\u00edpust.)</li> <li>Priorit\u00e1s: leg\u00f6rd\u00fcl\u0151 lista (<code>ComboBox</code>), melyben a <code>Priority</code> felsorolt t\u00edpus \u00e9rt\u00e9kei szerepelnek</li> <li>K\u00e9sz\u00fclts\u00e9g: jel\u00f6l\u0151n\u00e9gyzet (<code>CheckBox</code>)</li> <li>Ment\u00e9s: gomb be\u00e9p\u00edtett accent st\u00edlussal (<code>Style=\"{StaticResource AccentButtonStyle}\"</code>)</li> </ul> <p>Az \u0171rlaphoz nem kell speci\u00e1lis, egyedi vez\u00e9rl\u0151t (pl. <code>UserControl</code> k\u00e9sz\u00edteni): egyszer\u0171en haszn\u00e1ljuk valamelyik, a feladathoz j\u00f3l illeszked\u0151 layout panel t\u00edpust. </p> <p>N\u00e9h\u00e1ny fenti \u00e9s al\u00e1bb meghat\u00e1rozott k\u00f6vetelm\u00e9ny megval\u00f3s\u00edt\u00e1sa kapcs\u00e1n lentebb g\u00f6rgetve leny\u00edl\u00f3 mez\u0151kben n\u00e9mi ir\u00e1nymutat\u00e1st ad az \u00fatmutat\u00f3.</p> <p>Tov\u00e1bbi funkcion\u00e1lis k\u00f6vetelm\u00e9nyek:</p> <ul> <li>Az \u0171rlap csak akkor legyen l\u00e1that\u00f3, ha a Hozz\u00e1ad\u00e1s gombra kattintottak, \u00e9s t\u0171nj\u00f6n el, ha a teend\u0151 ment\u00e9sre ker\u00fcl.</li> <li>A Ment\u00e9s gombra kattintva a felvitt adatok ker\u00fcljenek a list\u00e1ba, \u00e9s az \u0171rlap t\u0171nj\u00f6n el.</li> <li>A Hozz\u00e1ad\u00e1s gombra kattintva a list\u00e1ban \u00fcr\u00edts\u00fck ki az aktu\u00e1lisan kiv\u00e1lasztott elem jel\u00f6l\u00e9s\u00e9t (<code>SelectedItem</code>)</li> <li>Opcion\u00e1lis feladat: Az \u0171rlap legyen g\u00f6rgethet\u0151, ha a tartalma nem f\u00e9r ki a k\u00e9perny\u0151re (<code>ScrollViewer</code> haszn\u00e1lata).</li> </ul> <p>Az \u0171rlap elrendez\u00e9se</p> <ul> <li>A <code>TextBox</code>, <code>ComboBox</code> \u00e9s <code>DatePicker</code> vez\u00e9rl\u0151k rendelkeznek egy <code>Header</code> tulajdons\u00e1ggal, melyben a vez\u00e9rl\u0151 feletti fejl\u00e9csz\u00f6veg megadhat\u00f3. A fejl\u00e9csz\u00f6vegek megad\u00e1s\u00e1hoz ezt haszn\u00e1ljuk, ne k\u00fcl\u00f6n <code>TextBlock</code>-ot!</li> <li>Az \u0171rlapon az elemek ne legyenek t\u00fal s\u0171r\u0171n egym\u00e1s alatt, legyen k\u00f6z\u00f6tt\u00fck kb. 15 pixel extra hely (erre remek\u00fcl alkalmazhat\u00f3 pl. a <code>StackPanel</code> <code>Spacing</code> tulajdons\u00e1ga).</li> <li>Az \u0171rlapnak \u00e1ll\u00edtsunk be egy j\u00f3l l\u00e1that\u00f3 keretet. Ezt nem az\u00e9rt tessz\u00fck, hogy szebb legyen a fel\u00fclet\u00fcnk, hanem az\u00e9rt, hogy j\u00f3l l\u00e1that\u00f3 legyen, pontosan hol helyezkedik el az \u0171rlapunk (alternat\u00edva lehetne a h\u00e1tt\u00e9rsz\u00edn\u00e9nek a megv\u00e1ltoztat\u00e1sa). Ezt a \"tr\u00fckk\u00f6t\" ideiglenesen is szoktuk alkalmazni a fel\u00fcletkialak\u00edt\u00e1s sor\u00e1n, ha nem egy\u00e9rtelm\u0171, pontosan mi hol helyezkedik el a fel\u00fcleten. Ehhez az \u0171rlap kont\u00e9ner <code>BorderThickness</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk 1-re, valamint a keret sz\u00edn\u00e9t (<code>BorderBrush</code> tulajdons\u00e1g) valamilyen j\u00f3l l\u00e1that\u00f3 sz\u00ednre (pl. <code>LightGray</code>-re).</li> <li>Az \u0171rlap baloldal\u00e1n, jobboldal\u00e1n, \u00e9s alj\u00e1n haszn\u00e1ljunk 8-as, tetej\u00e9n pedig 0-\u00e1s marg\u00f3t (ekkora hely legyen az \u0171rlap kerete \u00e9s a tartalmaz\u00f3ja k\u00f6z\u00f6tt, ak\u00e1rmekkor\u00e1ra is m\u00e9retezi a felhaszn\u00e1l\u00f3 fut\u00e1s k\u00f6zben az ablakot). </li> <li>Az \u0171rlap kerete, \u00e9s a benne lev\u0151 vez\u00e9rl\u0151k sz\u00e9le k\u00f6z\u00f6tt legyen alul \u00e9s fel\u00fcl 15, bal \u00e9s jobb oldalt 10 pixel szabad hely minden ir\u00e1nyban. Ehhez ne az \u0171rlapban lev\u0151 vez\u00e9rl\u0151k marg\u00f3it \u00e1ll\u00edtsuk egyes\u00e9vel, hanem az \u0171rlap kont\u00e9ner egy megfelel\u0151 tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be (mely azt szab\u00e1lyozza, mennyi hely van a sz\u00e9le, a bels\u0151 tartalma k\u00f6z\u00f6tt)!</li> <li> <p>Az el\u0151z\u0151 k\u00e9t pont azt is jelenti, hogy az \u0171rlapnak, \u00e9s benne a sz\u00f6vegdobozoknak automatikusan m\u00e9retez\u0151dni\u00fck kell az ablakkal, ezt az al\u00e1bbi lenyithat\u00f3 szekci\u00f3 alatt megjelen\u0151 k\u00e9pek illusztr\u00e1lj\u00e1k.</p> Az \u0171rlap viselked\u00e9s\u00e9nek \u00e9s elv\u00e1rt m\u00e9retek illusztr\u00e1l\u00e1sa <p> </p> </li> </ul> Ment\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1nak l\u00e9p\u00e9sei <ol> <li>Az \u0171rlapban l\u00e9v\u0151 adatokat egy \u00faj <code>TodoItem</code> objektumba gy\u0171jts\u00fck \u00f6ssze, melynek tulajdons\u00e1gait adatk\u00f6tj\u00fck (k\u00e9t ir\u00e1ny\u00faan!) a fel\u00fcleten. Vezess\u00fcnk be egy tulajdons\u00e1got ehhez <code>EditedTodo</code> n\u00e9ven. Ett\u0151l a pontt\u00f3l kezdve k\u00e9t megk\u00f6zel\u00edt\u00e9ssel dolgozhatunk:<ol> <li>Az EditedTodo alapesetben null. Amikor a felhaszn\u00e1l\u00f3 \u00faj to-do elem felv\u00e9tel\u00e9t kezdem\u00e9nyezi, akkor hozzuk l\u00e9tre az \u00faj EditedTodo objektumot, mely az adott \u00faj elem adatait t\u00e1rolja. Ment\u00e9skor ezt az objektumot tessz\u00fck bele a list\u00e1ba. \u00cdgy minden \u00faj elem felv\u00e9telekor az EditedTodo egy \u00faj objektumra hivatkozik. </li> <li>Egy k\u00f6z\u00f6s EditedTodo objektumot haszn\u00e1lunk minden to-do elem felv\u00e9telekor. Ezt m\u00e1r az oldal l\u00e9trehoz\u00e1skor p\u00e9ld\u00e1nyos\u00edtjuk. Amikor a felhaszn\u00e1l\u00f3 \u00faj to-do elem felv\u00e9tel\u00e9t kezdem\u00e9nyezi (vagy a ment\u00e9s v\u00e9g\u00e9n), akkor gondoskodni kell az EditedTodo alap\u00e9rtelmezett \u00e9rt\u00e9kekkel val\u00f3 felt\u00f6lt\u00e9s\u00e9r\u0151l. Ment\u00e9skor egy m\u00e1solatot kell k\u00e9sz\u00edteni r\u00f3la \u00e9s ezt kell a k\u00f6z\u00f6s list\u00e1ba beletenni.</li> </ol> </li> <li>A k\u00f6vezkez\u0151kben a fenti 1. megk\u00f6zel\u00edt\u00e9s l\u00e9p\u00e9seire adunk ir\u00e1nymutat\u00e1st, de mindenk\u00e9ppen \u00e9rdemes el\u0151sz\u00f6r \u00f6n\u00e1l\u00f3an pr\u00f3b\u00e1lkozni. </li> <li>Az EditedTodo kezd\u0151\u00e9rt\u00e9ke legyen null, illetve a Hozz\u00e1ad\u00e1s gombra kattintva legyen p\u00e9ld\u00e1nyos\u00edtva az <code>EditedTodo</code>. </li> <li>A ment\u00e9s sor\u00e1n a <code>Todos</code> list\u00e1hoz adjuk hozz\u00e1 a szerkesztett teend\u0151 objektumot. Gondoljunk arra, hogy az adatk\u00f6t\u00e9seknek friss\u00fclni\u00fck kell a fel\u00fcleten a lista tartalm\u00e1nak v\u00e1ltoz\u00e1sa sor\u00e1n (ehhez az adataink t\u00e1rol\u00e1s\u00e1n kell v\u00e1ltoztatni).</li> <li>A ment\u00e9s sor\u00e1n az <code>EditedTodo</code> property-t nullozzuk ki. Ezt annak \u00e9rdek\u00e9ben, tessz\u00fck, hogy a k\u00f6vetkez\u0151 to-do elem felv\u00e9telekor az adatk\u00f6t\u00e9s miatt \u00fcresek legyenek az \u0171rlapon a vez\u00e9rl\u0151k, ne a kor\u00e1bbi to-do elem adatai legyenek rajta. Gondoljuk \u00e1t, ez el\u00e9g lesz-e a megold\u00e1shoz? Pr\u00f3b\u00e1ljuk is ki a megold\u00e1sunkat! Amikor az <code>EditedTodo</code> tulajdons\u00e1got \u00e1ll\u00edtjuk, a k\u00f6t\u00f6tt vez\u00e9rl\u0151knek friss\u00fclni\u00fck kell. Mire van ehhez sz\u00fcks\u00e9g?      (Tipp: itt most nem az \u00e9rdekel minket, hogy az <code>EditedTodo</code> \u00e1ltal hivatkozott <code>TodoItem</code> tulajdons\u00e1gai, pl. <code>Title</code>, <code>Description</code> v\u00e1ltoznak, hanem a <code>MainPage</code> oszt\u00e1ly <code>EditedTodo</code> tulajdons\u00e1ga v\u00e1ltozik: ennek megfelel\u0151en az <code>EditedTodo</code>-t tartalmaz\u00f3 oszt\u00e1lyban kell a megfelel\u0151 interf\u00e9szt megval\u00f3s\u00edtani).</li> </ol> Az \u0171rlap l\u00e1that\u00f3s\u00e1g szab\u00e1lyoz\u00e1sa <p>Ha a fentieknek megfelel\u0151en dolgoztunk, az \u0171rlapunk pontosan akkor kell l\u00e1that\u00f3 legyen, amikor az <code>EditedTodo</code> \u00e9rt\u00e9ke nem null (gondoljuk \u00e1t, hogy val\u00f3ban \u00edgy van). Erre \u00e9p\u00edtve t\u00f6bb megold\u00e1st is kidolgozhatunk. A legegyszer\u0171bb a klasszikus <code>x:Bind</code> tulajdons\u00e1g alap\u00fa adatk\u00f6t\u00e9s alkalmaz\u00e1sa:</p> <ol> <li>Vezess\u00fcnk be egy \u00faj tulajdons\u00e1got a <code>MainPage</code> oszt\u00e1lyunkban (pl. <code>IsFormVisible</code> n\u00e9ven, bool t\u00edpussal).</li> <li>Ez pontosan akkor legyen igaz, amikor az <code>EditedTodo</code> nem null. Ennek a karbantart\u00e1sa a mi feladatunk, pl. az <code>EditedTodo</code> setter\u00e9ben.</li> <li>Ezt a tulajdons\u00e1got lehet adatk\u00f6tni az \u0171rlapunkat reprezent\u00e1l\u00f3 kont\u00e9ner l\u00e1that\u00f3s\u00e1g\u00e1hoz (<code>Visibility</code> tulajdons\u00e1g). Igaz, hogy a t\u00edpusuk nem egyezik, de WinUI alatt van automatikus konverzi\u00f3 a <code>bool</code> \u00e9s <code>Visibility</code> t\u00edpusok k\u00f6z\u00f6tt.</li> <li>Gondoljunk arra is, hogy amikor a forr\u00e1s tulajdons\u00e1g (<code>IsFormVisible</code>) v\u00e1ltozik, a hozz\u00e1 k\u00f6t\u00f6tt c\u00e9l tulajdons\u00e1got (vez\u00e9rl\u0151 l\u00e1that\u00f3s\u00e1g) eset\u00fcnkben mindig friss\u00edteni kell. Mire van ehhez sz\u00fcks\u00e9g? (Tipp: a tulajdons\u00e1got k\u00f6zvetlen\u00fcl tartalmaz\u00f3 oszt\u00e1lynak - gondoljuk \u00e1t, eset\u00fcnkben ez melyik oszt\u00e1ly - egy megfelel\u0151 interf\u00e9szt meg kell val\u00f3s\u00edtania stb.)</li> </ol> Alternat\u00edv lehet\u0151s\u00e9gek a megold\u00e1sra <p>Egy\u00e9b alternat\u00edv\u00e1k alkalmaz\u00e1sa is lehets\u00e9ges (csak \u00e9rdekess\u00e9gk\u00e9ppen, de ne ezeket alkalmazzuk a megold\u00e1s sor\u00e1n):</p> <ol> <li>F\u00fcggv\u00e9ny alap\u00fa adatk\u00f6t\u00e9s megval\u00f3s\u00edt\u00e1sa, de eset\u00fcnkben ez k\u00f6r\u00fclm\u00e9nyesebb lenne.<ul> <li>A <code>x:Bind</code> alapon k\u00f6t\u00f6tt f\u00fcggv\u00e9nynek a megjelen\u00edt\u00e9s \u00e9s elrejt\u00e9shez az <code>EditedTodo</code> property <code>null</code> vagy nem <code>null</code> \u00e9rt\u00e9k\u00e9t kell konvert\u00e1lni <code>Visibility</code>-re.</li> <li>Az adatk\u00f6t\u00e9s sor\u00e1n a <code>FallbackValue='Collapsed'</code> be\u00e1ll\u00edt\u00e1st is haszn\u00e1lnunk kell, mert sajnos az <code>x:Bind</code> alap\u00e9rtelmezetten nem h\u00edvja meg a f\u00fcggv\u00e9nyt, ha az \u00e9rt\u00e9k <code>null</code>.</li> <li>A k\u00f6t\u00f6tt f\u00fcggv\u00e9nynek param\u00e9terben meg kell adni azt a tulajdons\u00e1got, melynek v\u00e1ltoz\u00e1sa eset\u00e9n az adatk\u00f6t\u00e9st friss\u00edteni kell, illetve a tulajdons\u00e1gra vonatkoz\u00f3 v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9st itt is meg kell val\u00f3s\u00edtani.</li> </ul> </li> <li>Konverter alkalmaz\u00e1sa.</li> </ol> Priorit\u00e1sok list\u00e1ja <p>A <code>ComboBox</code>-ban a <code>Priority</code> felsorolt t\u00edpus \u00e9rt\u00e9keit jelen\u00edts\u00fck meg. Ehhez haszn\u00e1lhatjuk a <code>Enum.GetValues</code> f\u00fcggv\u00e9nyt, amihez k\u00e9sz\u00edts\u00fcnk egy tulajdons\u00e1got a <code>MainPage.xaml.cs</code>-ben.</p> <pre><code>public List&lt;Priority&gt; Priorities { get; } = Enum.GetValues(typeof(Priority)).Cast&lt;Priority&gt;().ToList();\n</code></pre> <p>A <code>ComboBox</code> <code>ItemsSource</code> tulajdons\u00e1g\u00e1hoz k\u00f6ss\u00fck az <code>Priorities</code> list\u00e1t.</p> <pre><code>&lt;ComboBox ItemsSource=\"{x:Bind Priorities}\" /&gt;\n</code></pre> <p>A fenti p\u00e9ld\u00e1ban az <code>ItemsSource</code> csak azt hat\u00e1rozza meg, hogy milyen elemek jelenjenek meg a <code>ComboBox</code> list\u00e1j\u00e1ban. De ez semmit nem mond arr\u00f3l, hogy a <code>ComboBox</code> kiv\u00e1lasztott elem\u00e9t mihez kell k\u00f6tni. Ehhez sz\u00fcks\u00e9g van m\u00e9g egy adatk\u00f6t\u00e9sre. Laboron ez nem szerepelt, el\u0151ad\u00e1sanyagban pl. a <code>SelectedItem</code>-re \u00e9rdemes r\u00e1keresni (minden el\u0151fordul\u00e1s\u00e1t \u00e9rdemes megn\u00e9zni).</p> N\u00e9h\u00e1ny fontosabb vez\u00e9rl\u0151 tulajdons\u00e1g <ul> <li>A <code>CheckBox</code> vez\u00e9rl\u0151 <code>IsChecked</code> (\u00e9s nem a <code>Checked</code>!) tulajdons\u00e1ga. A mellette jobbra megjelen\u0151 sz\u00f6veg a <code>Content</code> tulajdons\u00e1g\u00e1val adhat\u00f3 meg.</li> <li><code>DatePicker</code> vez\u00e9rl\u0151 <code>Date</code> tulajdons\u00e1ga</li> </ul> Furcsa, adatk\u00f6t\u00e9shez kapcsol\u00f3d\u00f3 NullReferenceException <p>Ha egy \"megfoghatatlannak\" t\u0171n\u0151 <code>NullReferenceException</code>-t kapsz az \u00faj elem felv\u00e9telekor, akkor ellen\u0151rizd, hogy a <code>ComboBox</code> eset\u00e9ben a <code>SelectedValue</code>-t k\u00f6t\u00f6tted-e esetleg a <code>SelectedItem</code> helyett (a <code>SelectedItem</code> haszn\u00e1land\u00f3).</p> <p>3. feladat BEADAND\u00d3</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol az \u00faj teend\u0151 felv\u00e9tele l\u00e1that\u00f3 m\u00e9g ment\u00e9s el\u0151tt! (<code>f3.1.png</code>)</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol az el\u0151z\u0151 k\u00e9pen l\u00e9v\u0151 teend\u0151 a list\u00e1ba ker\u00fclt \u00e9s elt\u0171nt az \u0171rlap! (<code>f3.2.png</code>)</p> <p>Fontos krit\u00e9riumok</p> <p>Az al\u00e1bbiakban megadunk n\u00e9h\u00e1ny fontos krit\u00e9riumot, melyek mindenk\u00e9ppen felt\u00e9telei a h\u00e1zi feladat elfogad\u00e1s\u00e1nak:</p> <ul> <li>A feladatki\u00edr\u00e1s kik\u00f6t\u00f6tte, hogy a list\u00e1ban \u00e9s az \u0171rlapon lev\u0151 vez\u00e9l\u0151k eset\u00e9ben is adatk\u00f6t\u00e9ssel kell dolgozni. Olyan megold\u00e1s nem elfogadhat\u00f3, mely ezt megker\u00fcli. \u00cdgy p\u00e9ld\u00e1ul nem lehet a code behind f\u00e1jlban (<code>MainPage.xaml.cs</code>) olyan k\u00f3d, mely az \u0171rlapokon lev\u0151 vez\u00e9rl\u0151k tulajdons\u00e1gait (pl. TextBox Text tulajdons\u00e1ga) k\u00f6zvetlen\u00fcl k\u00e9rdezi le vagy \u00e1ll\u00edtja.</li> <li>Az el\u0151z\u0151 pont al\u00f3l k\u00e9t kiv\u00e9tel van: <ul> <li>A <code>ListView</code> <code>SelectedItem</code> tulajdons\u00e1ga k\u00f6zvetlen\u00fcl \u00e1ll\u00edtand\u00f3.</li> <li>Az \u0171rlap l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1sa adatk\u00f6t\u00e9s n\u00e9lk\u00fcl is elfogadhat\u00f3 (b\u00e1r nem a legszebb megold\u00e1s, \u00e9s a gyakorl\u00e1s kedv\u00e9\u00e9rt is \u00e9rdemesebb adatk\u00f6t\u00e9ssel dolgozni).</li> </ul> </li> <li>Amikor egy \u00faj to-do elem felv\u00e9tele t\u00f6rt\u00e9nik, \u00e9s kor\u00e1bban m\u00e1r t\u00f6rt\u00e9nt egy ilyen elem felv\u00e9tele, akkor a kor\u00e1bbi elem adatai NEM lehetnek benne az \u0171rlap vez\u00e9rl\u0151iben.</li> </ul> <p>Opcion\u00e1lis gyakorl\u00f3 feladatok</p> Opcion\u00e1lis gyakorl\u00f3 feladat 1 - \u0170rlap g\u00f6rgethet\u0151v\u00e9 t\u00e9tele <p>Ehhez mind\u00f6ssze be kell csomagolni az \u0171rlapot egy <code>ScrollViewer</code> vez\u00e9rl\u0151be (illetve ne feledkezz\u00fcnk meg arr\u00f3l, hogy \u00edgy m\u00e1r ez lesz a legk\u00fcls\u0151 elem a grid cell\u00e1ban, \u00edgy r\u00e1 vonatkoz\u00f3an kell megadni a gridbeli poz\u00edci\u00f3t). Ha ezt megval\u00f3s\u00edtod, benne lehet a beadott megold\u00e1sodban.</p> Opcion\u00e1lis gyakorl\u00f3 feladat 2 - Fix sz\u00e9less\u00e9g\u0171 \u0171rlap <p>Jelen megold\u00e1sunkban az \u0171rlap automatikusan m\u00e9retez\u0151dik az ablakkal. J\u00f3 gyakorl\u00e1si lehet\u0151s\u00e9g ennek olyan \u00e1talak\u00edt\u00e1sa, mely esetben az \u0171rlap fix sz\u00e9less\u00e9g\u0171 (pl. 500 pixel) \u00e9s olyan magass\u00e1g\u00fa, mint a benne lev\u0151 elemek \u00f6ssz magass\u00e1ga. Ha az \u0171rlap eset\u00e9n StackPanellel dolgozt\u00e1l, ehhez mind\u00f6ssze h\u00e1rom attrib\u00fatumot kell felvenni vagy megv\u00e1ltoztatni. Ezt a viselked\u00e9st az al\u00e1bbi anim\u00e1lt k\u00e9p illusztr\u00e1lja. L\u00e9nyeges, hogy beadni a kor\u00e1bbi megold\u00e1st kell, nem ez az opcion\u00e1lis feladatban le\u00edrt viselked\u00e9st! </p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#4-opcionalis-feladat-3-imsc-pontert-teendo-szerkesztese","title":"4. Opcion\u00e1lis feladat 3 IMSc pont\u00e9rt - Teend\u0151 szerkeszt\u00e9se","text":"<p>Val\u00f3s\u00edtsd meg a teend\u0151k szerkeszt\u00e9s\u00e9nek lehet\u0151s\u00e9g\u00e9t az al\u00e1bbiak szerint:</p> <ul> <li>A fel\u00fcleten a teend\u0151k list\u00e1ban az elemre kattintva, az adott teend\u0151 adatai a szerkeszt\u0151 fel\u00fcleten (a kor\u00e1bbi feladatban bevezetett \u0171rlapon) ker\u00fcljenek megjelen\u00edt\u00e9sre, ahol azok \u00edgy szerkeszthet\u0151ek \u00e9s menthet\u0151ek lesznek.</li> <li>A ment\u00e9s sor\u00e1n a list\u00e1ban a szerkesztett teend\u0151 adatai friss\u00fcljenek, \u00e9s az \u0171rlap t\u0171nj\u00f6n el.</li> </ul> Megold\u00e1si tippek <ul> <li>\u00c9rdemes karbantartani a teend\u0151k egyedi azonos\u00edt\u00f3j\u00e1t a besz\u00far\u00e1s sor\u00e1n, hogy meg tudjuk k\u00fcl\u00f6nb\u00f6ztetni ment\u00e9skor, szerkeszt\u00e9s vagy besz\u00far\u00e1s esete \u00e1ll fenn. Pl. besz\u00far\u00e1s eset\u00e9n haszn\u00e1lhatjuk a -1 \u00e9rt\u00e9ket, melyet ment\u00e9s sor\u00e1n lecser\u00e9l\u00fcnk az eddig haszn\u00e1ltakn\u00e1l eggyel nagyobb sz\u00e1mra. De tegy\u00fck fel, hogy a -1 is egy olyan \u00e9rt\u00e9k, mellyel rendelkezhet egy \u00e9rv\u00e9nyes to-do objektum. Mit lehet ekkor tenni? A <code>TodoItem</code> oszt\u00e1lyban az <code>Id</code> t\u00edpus\u00e1t alak\u00edtsuk \u00e1t <code>int?</code>-re. A <code>?</code>-lel az \u00e9rt\u00e9k t\u00edpusok (<code>int</code>, <code>bool</code>, <code>char</code>, <code>enum</code>, <code>struct</code> stb.) is felvehetnek <code>null</code> \u00e9rt\u00e9ket. Ezeket nullable \u00e9rt\u00e9k t\u00edpusoknak (nullable value types) nevezz\u00fck. Ezek a <code>Nullable&lt;T&gt;</code> .NET strukt\u00far\u00e1ra k\u00e9pz\u0151dnek le ford\u00edt\u00e1s sor\u00e1n, melyek tartalmazz\u00e1k az eredeti v\u00e1ltoz\u00f3t, illetve egy flag-et, mely jelzi, ki van-e t\u00f6ltve az \u00e9rt\u00e9k, vagy sem. B\u0151vebben itt \u00e9s itt lehet ezekr\u0151l olvasni. Alkalmazzuk ezt a megold\u00e1s sor\u00e1n.</li> <li>A lista elemre kattint\u00e1shoz a <code>ListView</code> <code>ItemClick</code> esem\u00e9ny\u00e9t c\u00e9lszer\u0171 haszn\u00e1lni, miut\u00e1n bekapcsoltuk a <code>IsItemClickEnabled</code> tulajdons\u00e1got a <code>ListView</code>-n. Az \u00fajonnan kiv\u00e1lasztott listaelem kapcs\u00e1n inform\u00e1ci\u00f3t az esem\u00e9nykezel\u0151 <code>ItemClickEventArgs</code> param\u00e9ter\u00e9ben kapunk. </li> <li>A szerkesztend\u0151 adatok kezel\u00e9s\u00e9re t\u00f6bb megold\u00e1s is elk\u00e9pzelhet\u0151, ezekb\u0151l az egyik: <ul> <li>Az <code>EditedTodo</code> property-t \u00e1ll\u00edtsuk be a szerkesztett teend\u0151re a kattint\u00e1skor.</li> <li>A ment\u00e9s gombra kattintva a <code>Todos</code> list\u00e1ban cser\u00e9lj\u00fck le a szerkesztett teend\u0151t az <code>EditedTodo</code> \u00e9rt\u00e9k\u00e9re. Val\u00f3j\u00e1ban ugyanazt az elemet cser\u00e9lj\u00fck le \u00f6nmag\u00e1ra, de a <code>ListView</code> \u00edgy friss\u00fclni tud.</li> </ul> </li> </ul> <p>4. iMSc feladat BEADAND\u00d3</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol egy megl\u00e9v\u0151 elemre kattintva kit\u00f6lt\u0151dik az \u0171rlap! (<code>f4.imsc.1.png</code>)</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol az el\u0151z\u0151 k\u00e9pen kiv\u00e1lasztott teend\u0151 ment\u00e9s hat\u00e1s\u00e1ra friss\u00fcl a list\u00e1ban! (<code>f4.imsc.2.png</code>)</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/#beadas","title":"Bead\u00e1s","text":"<p>Ellen\u0151rz\u0151lista ism\u00e9tl\u00e9sk\u00e9ppen:</p> <ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/","title":"3. HA - Entwurf der Benutzeroberfl\u00e4che","text":""},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Die kleine Software, die in der Hausaufgabe verwirklicht werden soll, ist eine einfache Anwendung zur Aufgabenverwaltung, mit der Benutzer Aufgaben auflisten, erstellen und \u00e4ndern k\u00f6nnen.</p> <p>Die eigenst\u00e4ndige Aufgabe baut auf dem auf, was in den XAML-Vorlesungen vermittelt wurde. Den praktischen Hintergrund f\u00fcr die Aufgaben liefert das Labor 3 - Entwurf der Benutzeroberfl\u00e4che. </p> <p>Darauf aufbauend k\u00f6nnen die Aufgaben dieser Selbst\u00fcbung mit Hilfe der k\u00fcrzeren Leitf\u00e4den, die auf die Aufgabenbeschreibung folgen (manchmal standardm\u00e4\u00dfig eingeklappt), selbst\u00e4ndig bearbeitet werden.</p> <p>Das Ziel der Hausaufgabe:</p> <ul> <li>\u00dcben der Verwendung der Oberfl\u00e4chenbeschreibungssprache XAML</li> <li>\u00dcben der Verwendung grundlegender Steuerelemente (Tabelle, Taste, Textfeld, Listen)</li> <li>Ereignisgesteuerte Verwaltung von Oberfl\u00e4cheninteraktionen</li> <li>Anzeige von Daten auf der Oberfl\u00e4che mit Datenbindung</li> </ul> <p>Die erforderliche Entwicklungsumgebung wird hier beschrieben.</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#das-verfahren-der-eingabe","title":"Das Verfahren der Eingabe","text":"<p>Auf das Moodle soll ein ZIP-Archiv hochgeladen werden, das die folgenden Anforderungen entspricht:</p> <ul> <li>Die Aufgaben sind aufeinander basiert, deshalb ist es gen\u00fcgend den resultierenden Quellcode am Ende der letzten Aufgabe hochzuladen (Visual Studio Solution Verzeichnis). Der Name des Verzeichnisses soll \"TodoXaml_NEPTUN\" sein (wo NEPTUN Ihre Neptun-Code ist).</li> <li>Wir erwarten keine schriftliche Begr\u00fcndung oder Beschreibung, aber die komplexe Codeteile sollen mit Kommentaren versehen werden</li> <li>Das ZIP-Archiv darf die Ausgangsdaten (.exe) und die tempor\u00e4ren Dateien nicht enthalten. Um diese Best\u00e4nde zu l\u00f6schen, Visual Studio soll ge\u00f6ffnet werden und in dem Solution Explorer Rechtsklick an dem \u201eClean Solution\u201d Men\u00fcelement. Das manuelle L\u00f6schen von den \"obj\" und \"bin\" Verzeichnissen kann auch n\u00f6tig sein.</li> <li> In den Aufgaben werden Sie aufgefordert, einen Screenshot von einem Teil Ihrer L\u00f6sung zu machen, da dies beweist, dass Sie Ihre L\u00f6sung selbst erstellt haben. Der erwartete Inhalt der Screenshots ist immer in der Aufgabe angegeben. Die Screenshots sollten als Teil der L\u00f6sung eingegeben, also innerhalb dem ZIP-Archiv auf das Moodle hochgeladen werden. Wenn Sie Inhalte im Screenshot haben, die Sie nicht hochladen m\u00f6chten, k\u00f6nnen Sie diese aus dem Screenshot ausblenden.</li> </ul>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#vorbedingungen","title":"Vorbedingungen","text":"<p> MVVM-Modell - nicht benutzen!   Verwenden Sie in dieser Hausaufgabe NICHT das MVVM-Muster (auch nicht in den sp\u00e4teren Teilaufgaben), f\u00fchren Sie NICHT die Klasse <code>ViewModel</code> ein. MVVM wird das Thema einer sp\u00e4teren Hausaufgabe sein.</p> <p> Layout - Einfachheit Wie im Allgemeinen, auch in dieser Hausaufgabe sollte das grundlegende Layout der Seite mit <code>Grid</code> gestaltet werden. Bei der Gestaltung der einzelnen internen Abschnitte sollten Sie jedoch darauf achten, dass sie einfach gehalten sind: Wo <code>StackPanel</code>verwendet werden kann, sollten Sie nicht <code>Grid</code>verwenden.</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#aufgabe-1-modellentwurf-und-testdaten","title":"Aufgabe 1. - Modellentwurf und Testdaten","text":"<p>Erstellen Sie ein neuen Projekt mit Visual Studio (WinUI 3 Projekt, Blank App, Packaged (WinUI 3 in Desktop) type), und addieren Sie einen Ordner namens <code>Models</code> zu dem erzeugten Projekt. Erstellen Sie die Klasse und den Enum-Typ, die in der folgenden Abbildung gezeigt werden, im Ordner <code>Models</code>. Die Klasse <code>TodoItem</code> enth\u00e4lt die Details zu den Aufgaben, f\u00fcr die Priorit\u00e4t wird ein aufgelisteter Typ erstellt.</p> <p></p> <p>Beide Typen sollten \u00f6ffentlich sein ( <code>class</code> und <code>enum</code> mit <code>public</code> vorangestellt), da Ihr sonst sp\u00e4ter bei der \u00dcbersetzung einen Fehler \"Inconsistent accessibility\" erhalten w\u00fcrden.</p> <p>Auf der Seite <code>MainPage</code> wird eine Liste der zu erledigenden Aufgaben angezeigt. Jetzt verwenden Sie speicherinterne Testdaten, die in <code>MainPage.xaml.cs</code> erstellt wurden: Hier f\u00fchren Sie eine Eigenschaft <code>List&lt;TodoItem&gt;</code> mit dem Namen <code>Todos</code> ein (die sp\u00e4ter an das Steuerelement <code>ListView</code> auf der Benutzeroberfl\u00e4che gebunden wird). Diese Liste enth\u00e4lt <code>TodoItem</code> Objekte.</p> MainPage.xaml.cs<pre><code>public List&lt;TodoItem&gt; Todos { get; set; } = new()\n{\n    new TodoItem()\n    {\n        Id = 3,\n        Title = \"Add Neptun code to neptun.txt\",\n        Description = \"NEPTUN\",\n        Priority = Priority.Normal,\n        IsDone = false,\n        Deadline = new DateTime(2024, 11, 08)\n    },\n    new TodoItem()\n    {\n        Id = 1,\n        Title = \"Buy milk\",\n        Description = \"Should be lactose and gluten free!\",\n        Priority = Priority.Low,\n        IsDone = true,\n        Deadline = DateTimeOffset.Now + TimeSpan.FromDays(1)\n    },\n    new TodoItem()\n    {\n        Id = 2,\n        Title = \"Do the Computer Graphics homework\",\n        Description = \"Ray tracing, make it shiny and gleamy! :)\",\n        Priority = Priority.High,\n        IsDone = false,\n        Deadline = new DateTime(2024, 11, 08)\n    },\n};\n</code></pre> Erkl\u00e4rung des obigen Codes <p>In dem obigen Code sind mehrere moderne C#-Sprachelemente kombiniert:</p> <ul> <li>Dies ist eine automatisch implementierte Eigenschaft (siehe Labor 2 \"auto-implemented property\").</li> <li>Die Eigenschaft hat einen Anfangswert.</li> <li>Der Typ wird nicht nach <code>new</code> angegeben, da der Compiler ihn ableiten kann (siehe Labor 2 \"Target-typed new expressions\").</li> <li>Die Sammlungselemente werden in <code>{}</code> aufgelistet (siehe Labor 2 \"Collection initializer syntax\").</li> </ul> <p><code>MainPage</code> Klasse</p> <p>W\u00e4hrend der Hausaufgabe werden Sie in der Klasse <code>MainPage</code> arbeiten, die aus der eingebauten Klasse <code>Page</code> abgeleitet ist. Die Klasse <code>Page</code> hilft Ihnen, zwischen den Seiten innerhalb des Fensters zu navigieren. Obwohl sie in dieser Hausaufgaa\u00f3be nicht verwendet wird, lohnt es sich, sich an ihre Verwendung zu gew\u00f6hnen. Da unsere Anwendung aus einer einzigen Seite besteht, instanziieren wir einfach ein Objekt <code>MainPage</code> im Hauptfenster (Sie k\u00f6nnen es sich in der Datei <code>MainWindow.xaml</code> ansehen).</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#aufgabe-2-seitenlayout-liste-anzeigen","title":"Aufgabe 2 - Seitenlayout, Liste anzeigen","text":""},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#layout","title":"Layout","text":"<p>Unter <code>MainPage.xaml</code>erstellen Sie die Oberfl\u00e4che, auf der die Liste der Aufgaben angezeigt wird.</p> <p> Die zu erstellende Anwendung mit einer Benutzeroberfl\u00e4che f\u00fcr Listen</p> <p>Wie in der obigen Abbildung mit den drei Aufgaben zu sehen ist, werden die Aufgabendetails untereinander angezeigt, die Priorit\u00e4t der Aufgaben wird durch Farben angezeigt, und neben den erledigten Aufgaben werden mit einem H\u00e4kchen rechts bezeichnet.</p> <p>Die Elemente sind in der folgenden Struktur auf der Oberfl\u00e4che angeordnet:</p> <ul> <li>Verwenden Sie in <code>MainPage</code>eine <code>Grid</code>mit zwei Zeilen und zwei Spalten von Elementen. Die erste Spalte sollte eine feste Breite haben (z. B: 300 px) und die zweite nimmt den restlichen Platz ein.</li> <li> <p>Die erste Zeile der ersten Spalte sollte ein <code>CommandBar</code> Steuerelement mit einer Adresse und einer Taste enthalten. Das folgende Beispiel ist hilfreich:</p> <pre><code>&lt;CommandBar VerticalContentAlignment=\"Center\"\n            Background=\"{ThemeResource AppBarBackgroundThemeBrush}\"\n            DefaultLabelPosition=\"Right\"&gt;\n    &lt;CommandBar.Content&gt;\n        &lt;TextBlock Margin=\"12,0,0,0\"\n                   Style=\"{ThemeResource SubtitleTextBlockStyle}\"\n                   Text=\"To-Dos\" /&gt;\n    &lt;/CommandBar.Content&gt;\n\n    &lt;AppBarButton Icon=\"Add\"\n                  Label=\"Add\" /&gt;\n&lt;/CommandBar&gt;\n</code></pre> <p>ThemeResource</p> <p>Die <code>ThemeResource</code>im Beispiel kann verwendet werden, um die Farben und Stile einzustellen, die je nach Thema der Oberfl\u00e4che variieren werden. Zum Beispiel hat <code>AppBarBackgroundThemeBrush</code> die richtige Hintergrundfarbe je nach dem Thema der Oberfl\u00e4che (hell/dunkel).</p> <p>Einzelheiten finden Sie in der Dokumentation und die Beispiele in WinUI 3 Gallery App Colors.</p> </li> </ul> <p>Wenn Sie Ihre Arbeit richtig gemacht haben, sollte bei der Ausf\u00fchrung der Anwendung <code>CommandBar</code>an der richtigen Stelle erscheinen.</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#liste-anzeigen","title":"Liste anzeigen","text":"<p>Stellen Sie in der Zelle unter <code>CommandBar</code> in einer Liste (<code>ListView</code>) die Aufgaben mit folgendem Inhalt untereinander. Die Daten sollen \u00fcber Datenverbindung in der Benutzeroberfl\u00e4che angezeigt werden (die Elemente sollen \u00fcber Datenverbindung aus der zuvor vorgestellten Liste <code>Todos</code> angezeigt werden).</p> <ul> <li>Titel der Aufgabe<ul> <li>Fette Schriftart (SemiBold)</li> <li>Gef\u00e4rbt nach Priorit\u00e4t<ul> <li>Hohe Priorit\u00e4t: ein roter Farbton</li> <li>Normale Priorit\u00e4t: eingebaute Vordergrundfarbe</li> <li>Niedrige Priorit\u00e4t: ein blauer Farbton</li> </ul> </li> </ul> </li> <li>Ein H\u00e4kchensymbol rechts neben dem Aufgabentitel, wenn die Aufgabe fertig ist</li> <li>Beschreibung der Aufgabe</li> <li>Abgabetermin im Format <code>yyyy.MM.dd</code> </li> <li>Der Hintergrund von <code>ListView</code> sollte derselbe sein wie der von <code>CommandBar</code>, so dass sie einen durchgehenden Balken auf der linken Seite bilden.</li> </ul> Elemente in der Liste <p>\u00dcberlegen Sie immer, ob Sie Daten an ein Objekt oder an eine Liste binden, und verwenden Sie die entsprechende Technik! Bei dieser Hausaufgabe ist es nicht sicher, dass sie in der Reihenfolge kommen, in der sie im Labor waren!\"</p> Bedingte Einf\u00e4rbung <p>Sie k\u00f6nnen einen Konverter oder eine Funktionsbindung auf Basis von <code>x:Bind</code> verwenden, um die Adresse einzuf\u00e4rben.</p> <ul> <li> <p>Beispiel f\u00fcr Funktionsbindung auf der Grundlage von \"x:Bind\":</p> <pre><code>Foreground=\"{x:Bind local:MainPage.GetForeground(Priority)}\"\n</code></pre> <p>Hier ist \"GetForeground\" eine \u00f6ffentliche statische Funktion in der Klasse \"MainPage\", die das Objekt \"Brush\" mit der entsprechenden Farbe auf der Grundlage des aufgelisteten Typs \"Priorit\u00e4t\" zur\u00fcckgibt. Normalerweise w\u00e4re es nicht wichtig, dass die Funktion statisch ist, aber da wir die Datenverbindung in einem <code>DataTemplate</code> verwenden, ist der Kontext von <code>x:Bind</code> nicht die Seiteninstanz, sondern das Listenelement.</p> </li> <li> <p>Beispiel f\u00fcr die Verwendung des Konverters:</p> <p>Erstellen Sie eine Konverterklasse in einem Ordner <code>Converters</code>, die die Schnittstelle <code>IValueConverter</code> implementiert.</p> <pre><code>public class PriorityBrushConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, string language)\n    {\n        // TODO R\u00fcckgabe einer SolidColorBrush-Instanz\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, string language)\n    {\n        throw new NotImplementedException();\n    }\n}\n</code></pre> <p>Instanziierung des Konverters unter den Ressourcen der <code>MainPage</code>.</p> <pre><code>xmlns:c=\"using:TodoXaml.Converters\"\n\n&lt;Page.Resources&gt;\n    &lt;c:PriorityBrushConverter x:Key=\"PriorityBrushConverter\" /&gt;\n&lt;/Page.Resources&gt;\n</code></pre> <p>Verwendung des Konverters als statische Ressource in der Datenverbindung</p> <p>``xml Foreground=\"{x:Bind Priority, Converter={StaticResource PriorityBrushConverter}}\" ```</p> </li> </ul> <p>Um die Pinsel (Brush) zu instanziieren, verwenden Sie die Klasse <code>SolidColorBrush</code>, oder k\u00f6nnen Sie auch eingebaute Pinsel aus C#-Code (wie mit <code>ThemeResource</code> oben) benutzen.</p> <pre><code>new SolidColorBrush(Colors.Red);\n\n(Brush)App.Current.Resources[\"ApplicationForegroundThemeBrush\"]\n</code></pre> Fette Schriftart <p>Schriftattribute k\u00f6nnen unter die Eigenschaften namens \"Font...\" eingestellt werden: <code>FontFamily</code> , <code>FontSize</code>, <code>FontStyle</code>, <code>FontStretch</code> und <code>FontWeight</code>.</p> Sichtbarkeit des H\u00e4kchen-Symbol <p>F\u00fcr das H\u00e4kchen-Symbol verwenden Sie <code>SymbolIcon</code>, wobei die Eigenschaft <code>Symbol</code> auf <code>Accept</code> gesetzt ist.</p> <p>Wenn das H\u00e4kchen-Symbol angezeigt wird, muss ein Wahr-Falsch-Wert in einen <code>Sichtbarkeit</code>-Typ umgewandelt werden. Man k\u00f6nnte daf\u00fcr einen Konverter verwenden, aber diese Konvertierung ist so \u00fcblich, dass in der Datenverbindung <code>x:Bind</code> die Konvertierung von <code>bool</code> in <code>Sichtbarkeit</code> bereits eingebaut ist.</p> Ausrichtung des H\u00e4kchen-Symbols <p>Der Titel der Aufgabe und das H\u00e4kchen-Symbol m\u00fcssen ausgerichtet sein (eines nach links und eines nach rechts). Hier ein Tipp: Sie k\u00f6nnen z. B. eine einzelne Zelle verwenden <code>Grid</code>. In <code>Grid</code>k\u00f6nnen Sie mehrere Steuerelemente in einer Zelle \"stapeln\" und ihre Ausrichtung separat einstellen. Im zweiten Labor haben wir das Problem der Anzeige von Name und Alter in <code>ListView</code> <code>DataTemplate</code>folgenderma\u00dfen gel\u00f6st.</p> Datumsformatierung <p>Zur Formatierung des Datums der Abgabefrist k\u00f6nnen Sie auch einen Konverter oder eine Funktionsbindung auf der Grundlage von <code>x:Bind</code> verwenden, wobei Sie die Funktion <code>DateTime.ToString</code> mit Parametern binden.</p> <pre><code>Text=\"{x:Bind Deadline.ToString('yyyy.MM.dd', x:Null)}\"\n</code></pre> <p>Das <code>x:Null</code> wird ben\u00f6tigt, weil der zweite Parameter der Funktion <code>ToString</code> angegeben werden muss, aber in diesem Fall kann er <code>null</code> sein.</p> Abstand zwischen den Listenelementen <p>Auf dem Screenshot der Anleitung sehen Sie, dass zwischen den Listenelementen ein vertikaler Abstand besteht, so dass die Listenelemente gut voneinander getrennt sind. Dies ist nicht standardm\u00e4\u00dfig der Fall. Gl\u00fccklicherweise erfordert die L\u00f6sung, dass DataTemplate f\u00fcr die Anzeige der Elemente verwendet wird, so dass Sie durch eine kleine Anpassung (Tipp: geben Sie einen einzelnen Margin/Padding an) leicht etwas Platz zwischen den Listenelementen f\u00fcr eine bessere Lesbarkeit erreichen k\u00f6nnen. </p> <p>Aufgabe 2 - EINGABE</p> <p>F\u00fcgen Sie ein Bildschirmfoto der Anwendung ein, in der eine der Aufgaben in der Liste Ihren NEPTUN-Code als Namen oder Beschreibung hat (<code>f2.png</code>).</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#aufgabe-3-eine-neue-aufgabe-hinzufugen","title":"Aufgabe 3 - Eine neue Aufgabe hinzuf\u00fcgen","text":"<p>Der Text \"To-Do item\" sollte auf der rechten Seite des Grids in Zeile 1 angezeigt werden, mit Schriftgrad 25, horizontal links ausgerichtet und vertikal zentriert, mit 20 Pixel Leerraum auf der linken Seite.</p> <p>Klicken Sie auf der Oberfl\u00e4che auf die Taste Add, um in der zweiten Zeile ein Formular anzuzeigen, in dem Sie eine neue Aufgabe hinzuf\u00fcgen k\u00f6nnen.</p> <p>Das Formular sollte wie das folgende aussehen:</p> <p> Formular f\u00fcr die Bearbeitung einer Aufgabe</p> <p>Das Formular sollte die folgenden Elemente enthalten, die untereinander angeordnet sind.</p> <ul> <li>Titel: Texteingabefeld</li> <li>Beschreibung: h\u00f6heres Texteingabefeld, akzeptiert auch Zeilenumbruch (Enter) (<code>AcceptsReturn=\"True\"</code>)</li> <li>Abgabetermin: Datumsausw\u00e4hler (<code>DatePicker</code>) (Bemerkung: wir verwenden im Modell <code>DateTimeOffset</code> wegen dieses Controllers)</li> <li>Priorit\u00e4t: Dropdown-Liste (<code>ComboBox</code>) mit den Werten des Typs <code>Priority</code> </li> <li>Bereitschaft: Kontrollk\u00e4stchen (<code>CheckBox</code>)</li> <li>Speichern: Taste mit eingebautem Stil accent (<code>Style=\"{StaticResource AccentButtonStyle}\"</code>)</li> </ul> <p>Das Formular ben\u00f6tigt kein spezielles, benutzerdefiniertes Steuerelement (z. B. <code>UserControl</code> ): Verwenden Sie einfach einen der Layout-Paneltypen, die f\u00fcr die Aufgabe geeignet sind.</p> <p>Zus\u00e4tzliche funktionale Anforderungen:</p> <ul> <li>Das Formular sollte nur sichtbar sein, wenn die Taste Add angeklickt wird, und verschwinden, wenn die Aufgabe gespeichert wird.</li> <li>Klicken Sie auf Save, um die Daten zur Liste hinzuzuf\u00fcgen, und das Formular wird ausgeblendet.</li> <li>Mit dem Klicken auf die Taste Add soll die Auswahl der aktuellen Element in der Liste entfernt werden (<code>SelectedItem</code>). (Nur die Auswahl, nicht das Element sich selbst.)</li> <li>Optionale Aufgabe: Das Formular sollte scrollbar sein, wenn sein Inhalt nicht auf den Bildschirm passt (verwenden Sie<code>ScrollViewer</code> ).</li> </ul> <p>Layout des Formulars</p> <ul> <li>Die Steuerelemente <code>TextBox</code>, <code>ComboBox</code> und <code>DatePicker</code> haben eine Eigenschaft <code>Header</code>, in der der \u00dcberschrifttext \u00fcber dem Steuerelement angegeben werden kann. Verwenden Sie dies, um Kopftexte anzugeben, nicht eine separate <code>TextBlock</code>!</li> <li>Auf dem Formular sollten die Elemente nicht zu dicht nebeneinander liegen, mit etwa 15 Pixeln zus\u00e4tzlichem Abstand zwischen ihnen (die Eigenschaft <code>StackPanel</code> <code>Spacing</code> ist eine gute M\u00f6glichkeit, dies zu erreichen).</li> <li>Legen Sie einen sichtbaren Rahmen f\u00fcr das Formular fest. Wir tun dies nicht, um unsere Benutzeroberfl\u00e4che h\u00fcbscher zu machen, sondern um besser erkennen zu k\u00f6nnen, wo genau sich unser Formular befindet (eine Alternative w\u00e4re, die Hintergrundfarbe zu \u00e4ndern). Dieser \"Trick\" wird tempor\u00e4r auch w\u00e4hren der Gestaltung der Oberfl\u00e4che eingesetzt, wenn nicht klar ist, wo genau sich etwas auf der Oberfl\u00e4che befindet. Setzen Sie dazu die Eigenschaft <code>BorderThickness</code> des Formular-Containers auf 1 und die Rahmenfarbe (Eigenschaft<code>BorderBrush</code> ) auf eine sichtbare Farbe (z.B. <code>LightGray</code>).</li> <li>Verwenden Sie links, rechts und unten im Formular einen Rand von 8 und oben einen Rand von 0 (dies ist der Abstand zwischen dem Rand des Formulars und seinem Inhalt, unabh\u00e4ngig davon, wie gro\u00df der Benutzer das Fenster zur Laufzeit skaliert). </li> <li>Zwischen dem Rahmen des Formulars und dem Rand der Steuerelemente sollten oben und unten jeweils 15 Pixel und links und rechts jeweils 10 Pixel Platz sein. Um dies zu tun, setzen Sie nicht die R\u00e4nder der Steuerelemente im Formular einzeln, sondern setzen Sie eine entsprechende Eigenschaft des Formular-Containers (die steuert, wie viel Platz zwischen den R\u00e4ndern des Containers und seinem inneren Inhalt vorhanden ist)!</li> <li> <p>Die beiden vorangegangenen Punkte bedeuten auch, dass das Formular und die darin enthaltenen Textfelder automatisch mit dem Fenster skaliert werden sollten, wie in den Bildern unter dem Dropdown-Bereich dargestellt.</p> Illustration des Formularverhaltens und der erwarteten Gr\u00f6\u00dfe <p> </p> </li> </ul> Schritte zur Implementierung des Speicherns und der Kontrolle der Formularsichtbarkeit <ol> <li>Die Daten im Formular werden in einem neuen \"ToDoItem\"-Objekt gesammelt, dessen Eigenschaften (bidirektional!) zu der Oberfl\u00e4che gebunden werden. Erstellen Sie eine Eigenschaft mit dem Namen <code>EditedTodo</code> (der Anfangswert sollte null sein).</li> <li>Klicken Sie auf die Taste Add, um <code>EditedTodo</code> zu kopieren. </li> <li>F\u00fcgen Sie beim Speichern das zu bearbeitende Objekt in die Liste \"ToDos\" ein. Denken Sie daran, dass die Datenverbindungen in der Oberfl\u00e4che aktualisiert werden m\u00fcssen, wenn sich der Inhalt der Liste \u00e4ndert (dies erfordert \u00c4nderungen an der Art und Weise, wie wir unsere Daten speichern).</li> <li>W\u00e4hrend des Speicherns wird die Eigenschaft \"EditedTodo\" gel\u00f6scht, auf \"null\" gesetzt.</li> <li>Wenn Sie das oben beschriebene getan haben, sollte das Formular genau dann sichtbar sein, wenn <code>EditedTodo</code> nicht null ist (stellen Sie sicher, dass es so ist). Darauf aufbauend k\u00f6nnen Sie mehrere L\u00f6sungen entwickeln. Am einfachsten ist es, die klassische, auf Eigenschaften basierende Datenverbindung \"x:Bind\" zu verwenden:<ol> <li>F\u00fchren Sie eine neue Eigenschaft in unsere Klasse <code>Page</code> ein (z.B. <code>IsFormVisible</code>, mit dem Typ bool).</li> <li>Dies sollte genau dann wahr sein, wenn <code>EditedTodo</code> nicht null ist. Sie sind daf\u00fcr verantwortlich, dies zu pflegen, z.B. im Setter <code>EditedTodo</code>.</li> <li>Diese Eigenschaft kann mit der Sichtbarkeit des Containers, der unser Formular darstellt, verkn\u00fcpft werden (Eigenschaft \"Visibility\"). Sie sind zwar nicht vom selben Typ, aber unter WinUI gibt es eine automatische Konvertierung zwischen den Typen <code>bool</code> und <code>Visibility</code>.</li> <li>Beachten Sie auch, dass bei einer \u00c4nderung der Quelleigenschaft (<code>IsFormVisible</code>) die damit verbundene Zieleigenschaft (Sichtbarkeit des Steuerelements) immer aktualisiert werden muss. Was wird ben\u00f6tigt? (Hinweis: in der Klasse, die direkt die Eigenschaft enth\u00e4lt - \u00fcberlegen Sie, um welche Klasse es in unserem Fall ist - muss eine geeignete Schnittstelle implementiert werden usw.)</li> </ol> </li> </ol> Alternative M\u00f6glichkeiten f\u00fcr die L\u00f6sung <p>Andere Alternativen sind ebenfalls m\u00f6glich (nur interessehalber, aber verwenden Sie sie nicht diese in der L\u00f6sung):</p> <ol> <li>Implementieren einer funktionsbasierte Datenverbindung, aber in unserem Fall w\u00e4re dies komplizierter.<ul> <li>Bei einer auf der Grundlage von \"x:Bind\" gebundenen Funktion wird der Wert \"null\" oder ein anderer Wert als \"null\" der Eigenschaft \"EditedTodo\" zum Anzeigen und Ausblenden in \"Sichtbarkeit\" umgewandelt.</li> <li>Wenn wir Daten binden, m\u00fcssen wir auch <code>FallbackValue='Collapsed'</code> verwenden, denn leider ruft <code>x:Bind</code> die Funktion standardm\u00e4\u00dfig nicht auf, wenn der Wert <code>null</code> ist.</li> <li>Die gebundene Funktion muss einen Parameter haben, der die Eigenschaft angibt, deren \u00c4nderung die Aktualisierung der Datenverbindung bewirkt, und auch die \u00c4nderungsmeldung f\u00fcr die Eigenschaft muss hier implementiert werden.</li> </ul> </li> <li>Anwendung des Konverters.</li> </ol> Liste der Priorit\u00e4ten <p>Zeigen Sie in <code>ComboBox</code>die Werte des aufgelisteten Typs <code>Priority</code> an. Zu diesem Zweck k\u00f6nnen Sie die Funktion <code>Enum.GetValues</code> verwenden und eine Eigenschaft in <code>MainPage.xaml.cs</code>erstellen.</p> <pre><code>public List&lt;Priority&gt; Priorities { get; } = Enum.GetValues(typeof(Priority)).Cast&lt;Priority&gt;().ToList();\n</code></pre> <p>Binden Sie die Liste \"Priorities\" an die Eigenschaft \"ItemsSource\" der \"ComboBox\".</p> <pre><code>&lt;ComboBox ItemsSource=\"{x:Bind Priorities}\" /&gt;\n</code></pre> <p>Im obigen Beispiel gibt <code>ItemsSource</code> nur an, welche Elemente in der Liste der <code>ComboBox</code> erscheinen sollen. Aber das sagt nichts dar\u00fcber aus, woran das ausgew\u00e4hlte Element in der \"ComboBox\" gebunden sein soll. Dies erfordert eine weitere Datenverbindung. Dies wurde in der \u00dcbung nicht erw\u00e4hnt, aber es lohnt sich im Vorlesungsmaterial zum Beispiel <code>SelectedItem</code> suchen (alle Vorkommen lohnt es sich anzuschauen).</p> Einige wichtige Controller-Eigenschaften <ul> <li>Die Eigenschaft <code>IsChecked</code> (und nicht <code>Checked</code>!) von<code>CheckBox</code> </li> <li>Die Eigenschaft <code>Date</code> von <code>DatePicker</code> </li> </ul> <p>Aufgabe 3 - EINGABE</p> <p>F\u00fcgen Sie ein Bildschirmfoto der Anwendung ein, auf dem das Hinzuf\u00fcgen der neuen Aufgabe vor dem Speichern sehbar ist! (<code>f3.1.png</code>)</p> <p>F\u00fcgen Sie ein Bildschirmfoto der Anwendung ein, auf dem die Aufgabe im vorherigen Bild der Liste hinzugef\u00fcgt wurde und das Formular verschwunden ist (<code>f3.2.png</code>)</p> <p>Optionale \u00dcbungsaufgaben</p> Optionale \u00dcbungsaufgabe 1 - Ein Formular scrollbar machen <p>Alles, was Sie tun m\u00fcssen, ist, das Formular in ein <code>ScrollViewer</code> Steuerelement einzuschlie\u00dfen (und denken Sie daran, dass dies das \u00e4u\u00dferste Element in der Gridzelle sein wird, so dass Sie die Position innerhalb dem Grid daf\u00fcr angeben m\u00fcssen). Wenn Sie dies implementieren, kann es in Ihre eingereichte L\u00f6sung aufgenommen werden.</p> Optionale \u00dcbungsaufgabe 2 - Formular mit fester Breite <p>In unserer L\u00f6sung wird das Formular automatisch mit dem Fenster skaliert. Eine gute M\u00f6glichkeit ist zu \u00fcben, dies so zu \u00e4ndern, dass das Formular eine feste Breite (z. B. 500 Pixel) und eine H\u00f6he hat, die der Gesamth\u00f6he der darin enthaltenen Elemente entspricht. Wenn Sie f\u00fcr das Formular mit StackPanel gearbeitet haben, m\u00fcssen Sie nur drei Attribute hinzuf\u00fcgen oder \u00e4ndern. Dieses Verhalten wird in der nachstehenden animierten Abbildung veranschaulicht. Es ist wichtig, dass Sie die vorherige L\u00f6sung eingaben soll und nicht das in dieser optionalen \u00dcbung beschriebene Verhalten! </p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#4-optionale-aufgabe-fur-3-imsc-punkte-bearbeiten-einer-aufgabe-todo","title":"4. Optionale Aufgabe f\u00fcr 3 IMSc-Punkte - Bearbeiten einer Aufgabe (ToDo)","text":"<p>Machen Sie es m\u00f6glich, die Aufgaben wie folgt zu bearbeiten:</p> <ul> <li>Wenn Sie auf der Benutzeroberfl\u00e4che auf ein Element in der Aufgabenliste klicken, werden die Daten f\u00fcr diese Aufgabe in der Bearbeitungsoberfl\u00e4che angezeigt (das in der vorherigen Aufgabe vorgestellte Formular), wo sie bearbeitet und gespeichert werden kann.</li> <li>Beim Speichern sollte die bearbeitete Aufgabenliste aktualisiert werden und das Formular verschwinden.</li> </ul> Tipps zur L\u00f6sung <ul> <li>Es lohnt sich, die eindeutige ID der Aufgaben w\u00e4hrend des Einf\u00fcgens beizubehalten, damit Sie w\u00e4hrend dem Speichern, zwischen Bearbeiten und Einf\u00fcgen unterscheiden k\u00f6nnen. Im Falle einer Einf\u00fcgung k\u00f6nnen Sie beispielsweise den Wert -1 verwenden, den wir durch eine Zahl ersetzen, die um eins gr\u00f6\u00dfer ist als die zuvor verwendete. Aber nehmen wir an, dass -1 auch ein Wert ist, den ein g\u00fcltiges Aufgabenobjekt haben kann. Was kann getan werden? \u00c4ndern Sie in der Klasse <code>TodoItem</code> den Typ von <code>Id</code> in <code>int?</code>. Bei <code>?</code>k\u00f6nnen die Wertetypen (<code>int</code>, <code>bool</code>, <code>char</code>, <code>enum</code>, <code>struct</code> usw.) auch den Wert <code>null</code> annehmen. Diese werden als nullable Werttypen (nullable value types) bezeichnet. Sie werden w\u00e4hrend der Kompilierung auf die Struktur <code>Nullable&lt;T&gt;</code>.NET abgebildet, die die urspr\u00fcngliche Variable und ein Flag enth\u00e4lt, das angibt, ob der Wert gef\u00fcllt ist oder nicht. Lesen Sie mehr \u00fcber sie hier und hier.  Wenden Sie dies in der L\u00f6sung an.</li> <li>Um auf das Listenelement zu klicken, empfiehlt es sich, das Ereignis <code>ListView</code> <code>ItemClick</code> zu verwenden, nachdem die Eigenschaft <code>IsItemClickEnabled</code> auf <code>ListView</code>aktiviert wurde. Informationen \u00fcber das neu ausgew\u00e4hlte Listenelement werden im Parameter <code>ItemClickEventArgs</code> des Ereignishandlers angegeben. </li> <li>Es gibt mehrere M\u00f6glichkeiten, die zu bearbeitenden Daten zu behandeln, eine davon ist: <ul> <li>Setzen Sie die Eigenschaft <code>EditedTodo</code> auf die bearbeitete Aufgabe, wenn Sie darauf klicken.</li> <li>Wenn Sie auf die Taste \"Save\" klicken, wird die bearbeitete Aufgabe in der Liste <code>Todos</code> durch den Wert <code>EditedTodo</code> ersetzt. Im Endeffekt ersetzen wir das gleiche Element durch sich selbst, aber <code>ListView</code> wird aktualisiert.</li> </ul> </li> </ul> <p>Aufgave 4. iMSc - EINGABE</p> <p>F\u00fcgen Sie ein Bildschirmfoto der Anwendung ein, bei der ein Klick auf einen vorhandenen Eintrag das Formular ausf\u00fcllt (<code>f4.imsc.1.png</code>)</p> <p>F\u00fcgen Sie ein Bildschirmfoto der Anwendung ein, auf dem die im vorherigen Screenshot ausgew\u00e4hlte Aufgabe in der Liste als Ergebnis der Speicheraktion aktualisiert wird! (<code>f4.imsc.2.png</code>)</p>"},{"location":"hazi/3-felhasznaloi-felulet-kialakitasa/index_ger/#eingabe","title":"Eingabe","text":"<p>Checkliste f\u00fcr Wiederholungen:</p> <ul> <li>Es ist wichtig, dass nur die Aufgaben akzeptiert werden, die Sie vollst\u00e4ndig gemacht haben und die die Anforderungen in jeder Hinsicht erf\u00fcllen. </li> <li>Sie m\u00fcssen nat\u00fcrlich Ihre eigene Arbeit eingeben (da sie bewertet wird).</li> <li>Nicht nur das Quellcode, sondern auch die erwartete Bildschirmfotos sollen eingegeben werden.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/","title":"4. HF - T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se","text":""},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#bevezetes","title":"Bevezet\u00e9s","text":"<p>Az \u00f6n\u00e1ll\u00f3 feladat a konkurens/t\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se el\u0151ad\u00e1sokon elhangzottakra \u00e9p\u00edt. A feladatok gyakorlati h\u00e1tter\u00e9\u00fcl a 4. labor \u2013 T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok fejleszt\u00e9se laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel elv\u00e9gezhet\u0151k. Az \u00f6n\u00e1ll\u00f3 gyakorlat a k\u00f6vetkez\u0151 ismeretek elm\u00e9ly\u00edt\u00e9s\u00e9t c\u00e9lozza:</p> <ul> <li>Sz\u00e1lak ind\u00edt\u00e1sa \u00e9s le\u00e1ll\u00edt\u00e1sa, sz\u00e1lf\u00fcggv\u00e9ny</li> <li>Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s (<code>ManualResetEvent</code>, <code>AutoResetEvent</code>)</li> <li>K\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1sa (<code>lock</code> haszn\u00e1lata)</li> <li>WinUI fel\u00fcletelemekhez hozz\u00e1f\u00e9r\u00e9s munkasz\u00e1lakb\u00f3l</li> <li>Delegate-ek haszn\u00e1lat\u00e1nak gyakorl\u00e1sa (<code>Action&lt;T&gt;</code>)</li> <li>Felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1s\u00e1nak gyakorl\u00e1sa: id\u0151z\u00edt\u0151 haszn\u00e1lata, fel\u00fcletelemek manipul\u00e1l\u00e1sa code behind f\u00e1jlb\u00f3l (ez nem kapcsol\u00f3dik a sz\u00e1lkezel\u00e9shez)</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezet a szok\u00e1sos, itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s (a le\u00edr\u00e1sban szerepl\u0151 Windows App SDK-ra is sz\u00fcks\u00e9g van).</p> <p>Ellen\u0151rz\u0151 futtat\u00e1sa</p> <p>Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi \u00e9s azt, van-e ford\u00edt\u00e1si hiba. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod!</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>MultiThreadedApp.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-0-a-feladat-attekintese-ismerkedes-a-kiindulo-kerettel","title":"Feladat 0 \u2013 A feladat \u00e1ttekint\u00e9se, ismerked\u00e9s a kiindul\u00f3 kerettel","text":"<p>A feladat egy bicikliversenyt szimul\u00e1l\u00f3 alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se. A megval\u00f3s\u00edt\u00e1s alappill\u00e9re az alkalmaz\u00e1slogika \u00e9s a megjelen\u00edt\u00e9s k\u00fcl\u00f6nv\u00e1laszt\u00e1sa: az alkalmaz\u00e1slogika semmilyen szinten nem f\u00fcgghet a megjelen\u00edt\u00e9st\u0151l, a megjelen\u00edt\u00e9s pedig f\u00fcgg az alkalmaz\u00e1slogik\u00e1t\u00f3l (\u00e9rtelemszer\u0171en, hiszen annak aktu\u00e1lis \u00e1llapot\u00e1t jelen\u00edti meg).</p> <p>A kiindul\u00f3 keret m\u00e1r tartalmaz n\u00e9mi alkalmaz\u00e1s \u00e9s megjelen\u00edt\u00e9shez kapcsol\u00f3d\u00f3 logik\u00e1t. Futtassuk az alkalmaz\u00e1st, \u00e9s tekints\u00fck \u00e1t a fel\u00fclet\u00e9t:</p> <p></p> <ul> <li>Az ablak fels\u0151 r\u00e9sz\u00e9n tal\u00e1lhat\u00f3 a versenyp\u00e1lya. Bal oldalon sorakoznak a biciklik, majd l\u00e1that\u00f3 a startvonal, a p\u00e1lya k\u00f6zepe fel\u00e9 egy k\u00f6ztes meg\u00e1ll\u00f3 (dep\u00f3), ill. a c\u00e9lvonal.</li> <li>Az ablak als\u00f3 r\u00e9sz\u00e9n a verseny vez\u00e9rl\u00e9s\u00e9re szolg\u00e1l\u00f3 gombok tal\u00e1lhat\u00f3k. M\u00e9g nem kapcsol\u00f3dik hozz\u00e1juk logika, a k\u00f6vetkez\u0151 viselked\u00e9st fogjuk a k\u00e9s\u0151bbiekben megval\u00f3s\u00edtani:<ul> <li><code>Prepare Race</code>: A verseny el\u0151k\u00e9sz\u00edt\u00e9se (biciklik l\u00e9trehoz\u00e1sa \u00e9s felsorakoztat\u00e1sa a startvonalhoz).</li> <li><code>Start Race</code>: A verseny ind\u00edt\u00e1sa, mely hat\u00e1s\u00e1ra a biciklik egym\u00e1ssal versenyezve el\u00e9rnek a dep\u00f3ba, \u00e9s ott v\u00e1rakoznak.</li> <li><code>Start Next Bike From Depo</code>: A dep\u00f3ban v\u00e1rakoz\u00f3 biciklik k\u00f6z\u00fcl elind\u00edt egyet (mely bicikli eg\u00e9szen a c\u00e9lvonalig halad). A gombon t\u00f6bbsz\u00f6r is lehet kattintani, minden alkalommal egy biciklit enged tov\u00e1bb.</li> </ul> </li> </ul> <p>Az al\u00e1bbi anim\u00e1lt k\u00e9pen azt illusztr\u00e1lja, hogy a megold\u00e1s sor\u00e1n hova szeretn\u00e9nk eljutni:</p> <p></p> <p>A j\u00e1t\u00e9k/szimul\u00e1ci\u00f3 alapelvelve a k\u00f6vetkez\u0151 (m\u00e9g nincs megval\u00f3s\u00edtva):</p> <ul> <li>Minden egyes biciklihez egy k\u00fcl\u00f6n sz\u00e1l tartozik.</li> <li>A j\u00e1t\u00e9k/szimul\u00e1ci\u00f3 iter\u00e1ci\u00f3kra bontott: minden iter\u00e1ci\u00f3ban a biciklihez tartoz\u00f3 sz\u00e1l (amennyiben az \u00e9ppen nem v\u00e1rakozik a verseny ind\u00edt\u00e1s\u00e1ra vagy a dep\u00f3ban) egy v\u00e9letlenszer\u0171 sz\u00e1m\u00e9rt\u00e9kkel l\u00e9p el\u0151re a p\u00e1ly\u00e1n, eg\u00e9szen addig, am\u00edg el nem \u00e9ri a c\u00e9lvonalat.</li> </ul> <p>Egy extra megval\u00f3s\u00edtott funkci\u00f3 (ez m\u00e1r m\u0171k\u00f6dik): a vil\u00e1gos \u00e9s s\u00f6t\u00e9t t\u00e9ma k\u00f6z\u00f6tti v\u00e1lt\u00e1sra lehet\u0151s\u00e9g van a Ctrl+T billenty\u0171kombin\u00e1ci\u00f3val.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#alkalmazaslogika","title":"Alkalmaz\u00e1slogika","text":"<p>A kiindul\u00f3 keretben az alkalmaz\u00e1slogika oszt\u00e1lyai csak kezdetleges \u00e1llapotban vannak megval\u00f3s\u00edtva. Az oszt\u00e1lyok az <code>AppLogic</code> mapp\u00e1ban/n\u00e9vt\u00e9rben tal\u00e1lhat\u00f3k, n\u00e9zz\u00fck meg ezek k\u00f3dj\u00e1t:</p> <ul> <li><code>Bike</code>: Egy biciklit reprezent\u00e1l, melyhez hozz\u00e1tartozik a bicikli rajtsz\u00e1ma, poz\u00edci\u00f3ja \u00e9s azon inform\u00e1ci\u00f3, hogy az adott bicikli nyerte-e meg a versenyt. A <code>Step</code> m\u0171velete a bicikli v\u00e9letlenszer\u0171 l\u00e9pt\u00e9kkel t\u00f6rt\u00e9n\u0151 l\u00e9ptet\u00e9s\u00e9re szolg\u00e1l a verseny k\u00f6zben.</li> <li><code>Game</code>: A j\u00e1t\u00e9k vez\u00e9rl\u00e9s\u00e9nek logik\u00e1ja (ezt tov\u00e1bb lehetne darabolni, de az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt alapvet\u0151en ebbe az oszt\u00e1lyba fogunk dolgozni).<ul> <li>Defini\u00e1lja az egyes versenyp\u00e1lya elemek, \u00fagymint startvonal, k\u00f6ztes meg\u00e1ll\u00f3 (dep\u00f3) \u00e9s c\u00e9lvonal poz\u00edci\u00f3it: <code>StartLinePosition</code>, <code>DepoPosition</code> \u00e9s <code>FinishLinePosition</code> konstansok.</li> <li>T\u00e1rolja a versenyz\u0151 bicikliket (<code>Bikes</code> tagv\u00e1ltoz\u00f3).</li> <li><code>PrepareRace</code> m\u0171velet: El\u0151k\u00e9sz\u00edti a versenyt. Egyel\u0151re a <code>CreateBike</code> seg\u00e9df\u00fcggv\u00e9ny felhaszn\u00e1l\u00e1s\u00e1val l\u00e9trehoz h\u00e1rom biciklit. A feladata lesz m\u00e9g a biciklik felsorakoztat\u00e1sa a startvonalhoz.</li> <li><code>StartBikes</code> m\u0171velet: Verseny ind\u00edt\u00e1sa (mely hat\u00e1s\u00e1ra a biciklik egym\u00e1ssal versenyezve el\u00e9rnek a dep\u00f3ba, \u00e9s ott v\u00e1rakoznak). Nincs megval\u00f3s\u00edtva.</li> <li><code>StartNextBikeFromDepo</code> m\u0171velet: A dep\u00f3ban v\u00e1rakoz\u00f3 biciklik k\u00f6z\u00fcl elind\u00edt egyet (de csak egyet). Nincs megval\u00f3s\u00edtva.</li> </ul> </li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#megjelenites","title":"Megjelen\u00edt\u00e9s","text":"<p>A kiindul\u00f3 keretben a megjelen\u00edt\u00e9s viszonylag j\u00f3l el\u0151 van k\u00e9sz\u00edtve, de ezen is fogunk m\u00e9g dolgozni.</p> <p>A fel\u00fclet kialak\u00edt\u00e1sa a <code>MainWindow.xaml</code>-ben tal\u00e1lhat\u00f3, a k\u00f6vetkez\u0151 alapelvek szerint:</p> <ul> <li>Az ablak alapelrendez\u00e9s\u00e9nek kialak\u00edt\u00e1s\u00e1ra \"szok\u00e1sosan\" egy <code>Grid</code>-et haszn\u00e1ltunk, mely k\u00e9t sorb\u00f3l \u00e1ll. Az els\u0151 sor\u00e1ban tal\u00e1lhat\u00f3 a versenyp\u00e1lya a biciklikkel (<code>*</code> sormagass\u00e1g), az als\u00f3 r\u00e9szben pedig egy <code>StackPanel</code> a gombokkal (<code>Auto</code> sormagass\u00e1g).</li> <li>A p\u00e1lya kialak\u00edt\u00e1s\u00e1ra <code>Rectangle</code> objektumokat (h\u00e1tt\u00e9r, startvonal, depo, c\u00e9legyenes), a sz\u00f6vegelemek elrendez\u00e9s\u00e9re pedig (r\u00e9szben elforgatott) <code>TextBlock</code> objektumokat haszn\u00e1ltunk.</li> <li>Az egyes bicikliket egy vertik\u00e1lis <code>StackPanel</code>-en helyezt\u00fck el. A bicikliket egy-egy <code>TextBlock</code> objektummal jelen\u00edtj\u00fck meg (<code>Webdings</code> bet\u0171t\u00edpus, <code>b</code> bet\u0171). Haszn\u00e1lhattunk volna <code>FontIcon</code>-t is, a <code>TextBlock</code>-ra csak az\u00e9rt esett a v\u00e1laszt\u00e1sunk, mert ezzel m\u00e1r kor\u00e1bban megismerkedt\u00fcnk.</li> <li>A p\u00e1lya valamennyi elem\u00e9t \u00e9s a bicikliket tartalmaz\u00f3 <code>StackPanel</code>-t is a <code>Grid</code> els\u0151 (technikailag 0-dik) sor\u00e1ban helyezt\u00fck el. Ezek a defini\u00e1l\u00e1suk sorrendj\u00e9ben rajzol\u00f3dnak ki, az igaz\u00edt\u00e1sok \u00e9s marg\u00f3k \u00e1ltal meghat\u00e1rozott helyen. A biciklik <code>TextBlock</code>-j\u00e1nak poz\u00edcion\u00e1l\u00e1s\u00e1ra is a marg\u00f3t haszn\u00e1ljuk majd. Egy alternat\u00edva megold\u00e1s lett volna, ha minden fel\u00fcletelemet egy <code>Canvas</code>-re helyezt\u00fcnk volna el, \u00e9s azon \u00e1ll\u00edtottuk volna be az elemek abszol\u00fat poz\u00edci\u00f3j\u00e1t \u00e9s m\u00e9ret\u00e9t (Left, Top, Width, Height) a marg\u00f3k alkalmaz\u00e1sa helyett.</li> </ul> <p>Az ablakhoz tartoz\u00f3 <code>MainWindow.cs</code> code behind f\u00e1jlt is n\u00e9zz\u00fck meg, f\u0151bb elemei a k\u00f6vetkez\u0151k:</p> <ul> <li><code>game</code> tagv\u00e1ltoz\u00f3: Maga a <code>Game</code> j\u00e1t\u00e9kobjektum, melynek \u00e1llapot\u00e1t a f\u0151ablak megjelen\u00edti.</li> <li><code>bikeTextBlocks</code> tagv\u00e1ltoz\u00f3: Ebben a list\u00e1ban t\u00e1roljuk majd a bicikliket megjelen\u00edt\u0151 <code>TextBlock</code> objektumokat. Egyel\u0151re \u00fcres, a karbantart\u00e1s\u00e1t nek\u00fcnk kell majd megval\u00f3s\u00edtani.</li> <li>Konstruktor: Be\u00e1ll\u00edtja a startvonal, dep\u00f3 \u00e9s c\u00e9lvonal fel\u00fcletelemek x koordin\u00e1t\u00e1j\u00e1t a <code>Game</code> \u00e1ltal meghat\u00e1rozott konstans \u00e9rt\u00e9kek alapj\u00e1n. Az x koordin\u00e1ta be\u00e1ll\u00edt\u00e1sa a baloldali marg\u00f3 (<code>Margin</code>) megfelel\u0151 be\u00e1ll\u00edt\u00e1s\u00e1val t\u00f6rt\u00e9nik (mivel ezek az elemek balra igaz\u00edtottak a kont\u00e9ner\u00fckben!). Ezen fel\u00fcl a <code>AddKeyboardAcceleratorToChangeTheme</code> seg\u00e9df\u00fcggv\u00e9ny seg\u00edts\u00e9g\u00e9vel beregisztr\u00e1lja a Ctrl+T gyors\u00edt\u00f3billenty\u0171t a vil\u00e1gos/s\u00f6t\u00e9t t\u00e9ma k\u00f6z\u00f6tti v\u00e1lt\u00e1sra.</li> <li><code>PrepareRaceButton_Click</code>, <code>StartRaceButton_Click</code>, <code>StartNextFromDepoButton_Click</code>: a h\u00e1rom gomb esem\u00e9nykezel\u0151je.</li> <li><code>UpdateUI</code> m\u0171velet: Kulcsfontoss\u00e1g\u00fa logik\u00e1t tartalmaz. A j\u00e1t\u00e9k \u00e1llapot\u00e1nak megfelel\u0151en friss\u00edti a fel\u00fcletet. V\u00e9gig iter\u00e1l a j\u00e1t\u00e9k \u00f6sszes biciklij\u00e9n, \u00e9s a biciklikhez tartoz\u00f3 <code>TextBlock</code>-ok x poz\u00edci\u00f3j\u00e1t be\u00e1ll\u00edtja a bicikli poz\u00edci\u00f3ja alapj\u00e1n (a baloldali marg\u00f3 megfelel\u0151 be\u00e1ll\u00edt\u00e1s\u00e1val). Az <code>UpdateUI</code> m\u0171velet egyel\u0151re soha nem h\u00edv\u00f3dik, \u00edgy a fel\u00fclet nem friss\u00fcl.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-1-a-felulet-frissitese","title":"Feladat 1 \u2013 A fel\u00fclet friss\u00edt\u00e9se","text":"<p>Jelen pillanatban hi\u00e1ba m\u00f3dos\u00edtan\u00e1nk fut\u00e1s k\u00f6zben a j\u00e1t\u00e9k \u00e1llapot\u00e1t: a fel\u00fcletbe be van \u00e9getve a h\u00e1rom bicikli fix poz\u00edci\u00f3ban, ezen fel\u00fcl a fel\u00fcletet friss\u00edt\u0151 <code>UpdateUI</code> m\u0171velet egyel\u0151re soha nem h\u00edv\u00f3dik. Miel\u0151tt belev\u00e1gn\u00e1nk a j\u00e1t\u00e9klogika megval\u00f3s\u00edt\u00e1s\u00e1ba, m\u00f3dos\u00edtsuk a fel\u00fclethez tartoz\u00f3 logik\u00e1t, hogy az k\u00e9pes legyen folyamatosan a j\u00e1t\u00e9k friss \u00e1llapot\u00e1t megjelen\u00edteni.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#a-biciklik-dinamikus-kezelese","title":"A biciklik dinamikus kezel\u00e9se","text":"<p>Az els\u0151 probl\u00e9ma: a <code>MainWindow.xaml</code>-be be van \u00e9getve a h\u00e1rom, biciklit megjelen\u00edt\u0151 <code>TextBlock</code>. \u00cdgy a fel\u00fclet\u00fcnk csak olyan j\u00e1t\u00e9k megjelen\u00edt\u00e9s\u00e9re lenne k\u00e9pes, melyben pontosan h\u00e1rom versenyz\u0151 szerepel. K\u00e9sz\u00edts\u00fck el\u0151 a megjelen\u00edt\u00e9st tetsz\u0151leges sz\u00e1m\u00fa bicikli kezel\u00e9s\u00e9re. Els\u0151 l\u00e9p\u00e9sben t\u00e1vol\u00edtsuk el a <code>MainWindow.xaml</code>-b\u0151l a h\u00e1rom biciklihez tartoz\u00f3 \"be\u00e9getett\" <code>TextBlock</code> defin\u00edci\u00f3t (kommentezz\u00fck ki a h\u00e1rom sort). Ezt k\u00f6vet\u0151en, a code behind f\u00e1jlban, a <code>PrepareRaceButton_Click</code> esem\u00e9nykezel\u0151ben a verseny el\u0151k\u00e9sz\u00edt\u00e9se (<code>game.PrepareRace()</code> h\u00edv\u00e1s) ut\u00e1n:</p> <ol> <li>Dinamikusan hozzunk l\u00e9tre minden, a <code>game</code> objektumban szerepl\u0151 biciklihez (<code>game.Bikes</code> tulajdons\u00e1g!) egy megfelel\u0151 <code>TextBlock</code> objektumot . A l\u00e9trehozott <code>TextBlock</code> tulajdons\u00e1gai pontosan feleljenek meg annak, mint amit a xaml f\u00e1jlban kiiktattunk (<code>FontFamily</code>, <code>FontSize</code>, <code>Margin</code>, <code>Text</code>)</li> <li>A l\u00e9trehozott <code>TextBlock</code> objektumokat fel kell venni a <code>bikesPanel</code> nev\u0171 <code>StackPanel</code> gyerekei k\u00f6z\u00e9 (a xaml f\u00e1jlban kikommentezett <code>TextBlock</code>-ok is ennek gyerekei voltak, ezt n\u00e9zz\u00fck meg!), m\u00e9gpedig a <code>bikesPanel.Children.Add</code> h\u00edv\u00e1s\u00e1val.</li> <li>A l\u00e9trehozott <code>TextBlock</code> objektumokat vegy\u00fck fel a <code>bikeTextBlocks</code> list\u00e1ba is. Ez az\u00e9rt fontos - n\u00e9zz\u00fck is meg a k\u00f3dban - mert az <code>UpdateUI</code> fel\u00fcletfriss\u00edt\u0151 f\u00fcggv\u00e9ny a biciklikhez tartoz\u00f3 <code>TextBlock</code>-okat a <code>bikeTextBlocks</code> list\u00e1ban keresi (t\u00f6mbindex alapj\u00e1n p\u00e1ros\u00edtja a bicikliket \u00e9s a <code>TextBlock</code>-okat).</li> </ol> <p>Annyiban megv\u00e1ltozik az alkalmaz\u00e1s m\u0171k\u00f6d\u00e9se (de ez sz\u00e1nd\u00e9kos), hogy indul\u00e1skor nem jelennek meg biciklik, hanem csak a <code>Prepare Race</code> gombon kattint\u00e1skor.</p> <p>Pr\u00f3b\u00e1ljuk a megold\u00e1st magunkt\u00f3l megval\u00f3s\u00edtani a fenti pontokat k\u00f6vetve, majd ellen\u0151rizz\u00fck, hogy alapvet\u0151en megfelel-e az al\u00e1bbi megold\u00e1snak.</p> Megold\u00e1s <pre><code>foreach (var bike in game.Bikes)\n{\n    var bikeTextBlock = new TextBlock()\n    {\n        Text = \"b\",\n        FontFamily = new FontFamily(\"Webdings\"),\n        FontSize = 64,\n        Margin = new Thickness(10, 0, 0, 0)\n    };\n\n    bikesPanel.Children.Add(bikeTextBlock);\n    bikeTextBlocks.Add(bikeTextBlock);\n}\n</code></pre>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#a-feluletfrissites-megvalositasa","title":"A fel\u00fcletfriss\u00edt\u00e9s megval\u00f3s\u00edt\u00e1sa","text":"<p>Most m\u00e1r pontosan annyi <code>TextBlock</code>-unk lesz, ah\u00e1ny bicikli van a <code>game</code> objektumban. S\u0151t, az <code>UpdateUI</code> m\u0171velettel tudjuk is a fel\u00fcletet b\u00e1rmikor friss\u00edteni (a <code>game</code> aktu\u00e1lis \u00e1llapot\u00e1nak megfelel\u0151en). A k\u00f6vetkez\u0151 kardin\u00e1lis k\u00e9rd\u00e9s: mikor h\u00edvjuk ez a f\u00fcggv\u00e9nyt, vagyis mikor friss\u00edts\u00fck a fel\u00fcletet. T\u00f6bb megold\u00e1s k\u00f6z\u00fcl v\u00e1laszthatunk:</p> <ul> <li>a) Mindig, amikor a <code>Game</code> \u00e1llapota megv\u00e1ltozik.</li> <li>b) Adott id\u0151k\u00f6z\u00f6nk\u00e9nt (pl. 100 ms-k\u00e9nt) \"folyamatosan\", egy id\u0151z\u00edt\u0151 seg\u00edts\u00e9g\u00e9vel.</li> </ul> <p>\u00c1ltal\u00e1noss\u00e1g\u00e1ban mindk\u00e9t megold\u00e1snak lehetnek el\u0151nyei \u00e9s h\u00e1tr\u00e1nyai. A b) bizonyos tekintetben egyszer\u0171bb (nem kell tudni, mikor v\u00e1ltozik a <code>Game</code> \u00e1llapota), ugyanakkor felesleges friss\u00edt\u00e9s is t\u00f6rt\u00e9nhet (ha nem v\u00e1ltozott az \u00e1llapot k\u00e9t friss\u00edt\u00e9s k\u00f6z\u00f6tt). De hat\u00e9konyabb is lehet, ha az \u00e1llapot nagyon gyakran v\u00e1ltozik, \u00e9s nem akarjuk minden v\u00e1ltoz\u00e1skor a fel\u00fcletet friss\u00edteni, el\u00e9g adott id\u0151k\u00f6z\u00f6nk\u00e9nt egyszer (pl. a szem\u00fcnk \u00fagysem tudja lek\u00f6vetni). Eset\u00fcnkben - els\u0151sorban egyszer\u0171s\u00e9ge miatt - a \"b)\", vagyis id\u0151z\u00edt\u0151 alap\u00fa megold\u00e1st v\u00e1lasztjuk.</p> <p>WinUI 3 k\u00f6rnyezetben periodikus esem\u00e9nyek kezel\u00e9s\u00e9re a <code>DispatchTimer</code> oszt\u00e1ly alkalmaz\u00e1sa javasolt (k\u00fcl\u00f6n\u00f6sen, ha a fel\u00fcletelemekhez is hozz\u00e1 k\u00edv\u00e1nunk f\u00e9rni az id\u0151z\u00edtett m\u0171veletben).</p> <p>A <code>MainWindow</code> oszt\u00e1lyban vezess\u00fcnk be egy tagv\u00e1ltoz\u00f3t:</p> <pre><code>    private DispatcherTimer timer;\n</code></pre> <p>Ezt k\u00f6vet\u0151en a konstruktorban p\u00e9ld\u00e1nyos\u00edtsuk a timert, rendelj\u00fcnk a <code>Tick</code> esem\u00e9ny\u00e9hez egy esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt (ez h\u00edv\u00f3dik adott id\u0151k\u00f6z\u00f6nk\u00e9nt), \u00e1ll\u00edtsuk be az id\u0151k\u00f6zt 100 ms-ra (<code>Interval</code> tulajdons\u00e1g), \u00e9s ind\u00edtsuk el a timert:</p> <pre><code>public MainWindow()\n{\n    ...\n\n    timer = new DispatcherTimer();\n    timer.Tick += Timer_Tick;\n    timer.Interval = TimeSpan.FromMilliseconds(100);\n    timer.Start();\n}\n\nprivate void Timer_Tick(object sender, object e)\n{\n    UpdateUI();\n}\n</code></pre> <p>Mint l\u00e1that\u00f3, az id\u0151z\u00edt\u0151 esem\u00e9nykezel\u0151ben az <code>UpdateUI</code> h\u00edv\u00e1s\u00e1val friss\u00edtj\u00fck a fel\u00fcletet.</p> <p>K\u00e9rd\u00e9s, hogyan tudjuk a megold\u00e1sunkat tesztelni, vagyis azt ellen\u0151rizni, hogy a <code>Timer_Tick</code> esem\u00e9nykezel\u0151 val\u00f3ban megh\u00edv\u00f3dik-e 100 ms-k\u00e9nt. Ehhez Trace-elj\u00fck ki ideiglenesen a Visual Studio Output ablak\u00e1ba az aktu\u00e1lis id\u0151t megfelel\u0151en form\u00e1zva az esem\u00e9nykezel\u0151ben:</p> <pre><code>private void Timer_Tick(object sender, object e)\n{\n    System.Diagnostics.Trace.WriteLine($\"Time: {DateTime.Now.ToString(\"hh:mm:ss.fff\")}\");\n\n    UpdateUI();\n}\n</code></pre> <p>A <code>Trace.WriteLine</code> m\u0171velet a Visual Studio Output ablak\u00e1ba \u00edr egy sort, a <code>DateTime.Now</code>-val pedig az aktu\u00e1lis id\u0151t lehet lek\u00e9rdeni. Ezt alak\u00edtjuk a <code>ToString</code> h\u00edv\u00e1ssal megfelel\u0151 form\u00e1tum\u00fa sz\u00f6vegg\u00e9. Futtassuk az alkalmaz\u00e1st (l\u00e9nyeges, hogy debuggolva, vagyis az F5 billenty\u0171vel) \u00e9s ellen\u0151rizz\u00fck a Visual Studio Output ablak\u00e1t, hogy val\u00f3ban megjelenik egy \u00faj sor 100 ms-k\u00e9nt. Ha minden j\u00f3l m\u0171k\u00f6dik, a Trace-el\u0151 sort kommentezz\u00fck ki.</p> <p>A DispatcherTimer pontoss\u00e1ga</p> <p>Azt megfigyelhetj\u00fck, hogy a <code>DispatcherTimer</code> nem k\u00fcl\u00f6n\u00f6sebben pontos, de c\u00e9ljainknak t\u00f6k\u00e9letesen megfelel. Ugyanakkor sz\u00e1munkra fontos tulajdons\u00e1ga, hogy a UI sz\u00e1lon h\u00edv\u00f3dik (a <code>Tick</code> esem\u00e9nye ezen s\u00fcl el), \u00edgy a kezel\u0151f\u00fcggv\u00e9ny\u00fcnkb\u0151l (<code>Timer_Tick</code>) hozz\u00e1 tudunk f\u00e9rni a fel\u00fcletelemekhez.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#foablak-fejlece","title":"F\u0151ablak fejl\u00e9ce","text":"<p> A f\u0151ablak fejl\u00e9ce a \"Tour de France\" sz\u00f6veg legyen, hozz\u00e1f\u0171zve a saj\u00e1t Neptun k\u00f3dod: (pl. \"ABCDEF\" Neptun k\u00f3d eset\u00e9n \"Tour de France - ABCDEF\"), fontos, hogy ez legyen a sz\u00f6veg! Ehhez a f\u0151ablakunk <code>Title</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be erre a sz\u00f6vegre a <code>MainWindow.xaml</code> f\u00e1jlban.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-2-a-verseny-elokeszitese","title":"Feladat 2 \u2013 A verseny el\u0151k\u00e9sz\u00edt\u00e9se","text":"<p>A fentiek sor\u00e1n el is k\u00e9sz\u00fclt\u00fcnk a megjelen\u00edt\u00e9si logik\u00e1val, a f\u00f3kuszunkat most m\u00e1r az alkalmaz\u00e1slogik\u00e1ra, \u00e9s az ahhoz kapcsol\u00f3d\u00f3 sz\u00e1lkezel\u00e9si t\u00e9mak\u00f6rre helyezz\u00fck \u00e1t. Ennek megfelel\u0151en mostant\u00f3l els\u0151dlegesen a <code>Game</code> oszt\u00e1lyban fogunk dolgozni.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt, a megold\u00e1sunk alapelve a k\u00f6vetkez\u0151 lesz:</p> <ul> <li>Minden egyes biciklihez egy k\u00fcl\u00f6n sz\u00e1lat ind\u00edtunk.</li> <li>A j\u00e1t\u00e9k/szimul\u00e1ci\u00f3 iter\u00e1ci\u00f3kra bontott: minden iter\u00e1ci\u00f3ban a biciklihez tartoz\u00f3 sz\u00e1l (amennyiben az \u00e9ppen nem v\u00e1rakozik a verseny ind\u00edt\u00e1s\u00e1ra vagy a dep\u00f3ban) egy v\u00e9letlenszer\u0171 sz\u00e1m\u00e9rt\u00e9kkel l\u00e9p el\u0151re a p\u00e1ly\u00e1n, eg\u00e9szen addig, am\u00edg el nem \u00e9ri a c\u00e9lvonalat.</li> </ul> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9seknek megfelel\u0151en alak\u00edtsuk ki a kereteket:</p> <ol> <li>A <code>Game</code> oszt\u00e1ly <code>CreateBike</code> f\u00fcggv\u00e9ny\u00e9nek a v\u00e9g\u00e9n ind\u00edtsunk el egy a ker\u00e9kp\u00e1rhoz tartoz\u00f3 sz\u00e1lat.</li> <li>A sz\u00e1lf\u00fcggv\u00e9ny a <code>Game</code> oszt\u00e1lyban legyen.</li> <li>A sz\u00e1lf\u00fcggv\u00e9nynek a <code>CreateBike</code> adja \u00e1t param\u00e9terk\u00e9nt a bicikli objektumot, melyet az adott sz\u00e1l mozgatni fog.</li> <li>A fut\u00f3 sz\u00e1lak ne blokkolj\u00e1k az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1t (vagyis, amikor bez\u00e1rjuk a f\u0151ablakot, de van m\u00e9g fut\u00f3 sz\u00e1l, a process azonnal sz\u0171nj\u00f6n meg, ne v\u00e1rja be ezeket a sz\u00e1lakat)</li> <li> <p>A sz\u00e1lf\u00fcggv\u00e9ny megval\u00f3s\u00edt\u00e1sa els\u0151 k\u00f6rben a k\u00f6vetkez\u0151kre terjedjen ki.</p> <p>Egy ciklusban minden iter\u00e1ci\u00f3ban:</p> <ul> <li>v\u00e9letlenszer\u0171 l\u00e9p\u00e9ssel (Bike oszt\u00e1ly <code>Step</code> f\u00fcggv\u00e9ny\u00e9nek h\u00edv\u00e1sa) l\u00e9ptesse a biciklit,</li> <li>majd altassa a sz\u00e1lat 100 ms-ig.</li> </ul> <p>Mindez a mozgat\u00e1s addig tartson, m\u00edg a bicikli el nem \u00e9ri a startvonalat (a poz\u00edci\u00f3ja el nem \u00e9ri a <code>StartLinePosition</code> tagv\u00e1ltoz\u00f3 \u00e1ltal meghat\u00e1rozott \u00e9rt\u00e9ket).</p> </li> </ol> <p>Pr\u00f3b\u00e1ld a fentieket \u00f6n\u00e1ll\u00f3an megval\u00f3s\u00edtani az el\u0151ad\u00e1son \u00e9s a laboron tanultak alapj\u00e1n. A megold\u00e1sod debuggol\u00e1ssal tudod tesztelni, illetve mivel a fel\u00fclet logik\u00e1t kor\u00e1bban megval\u00f3s\u00edtottuk, az alkalmaz\u00e1st futtatva a <code>Prepare Race</code> gombra kattintva is: ekkor a biciklik el kell g\u00f6rd\u00fcljenek fokozatosan haladva eg\u00e9szen a startvonalig.</p> <p>Ezekhez a l\u00e9p\u00e9sekhez m\u00e9g adunk megold\u00e1st (de sokkal t\u00f6bbet tanulsz bel\u0151le, ha magad pr\u00f3b\u00e1lkozol, csak ellen\u0151rz\u00e9sk\u00e9pen haszn\u00e1ld a megold\u00e1st):</p> Megold\u00e1s <p>A <code>Game</code> oszt\u00e1lyban a sz\u00e1lf\u00fcggv\u00e9ny:</p> <pre><code>void BikeThreadFunction(object bikeAsObject)\n{\n    Bike bike = (Bike)bikeAsObject;\n    while (bike.Position &lt;= StartLinePosition)\n    {\n        bike.Step();\n\n        Thread.Sleep(100);\n    }\n}\n</code></pre> <p>Mint l\u00e1that\u00f3, sz\u00e1lf\u00fcggv\u00e9nyn\u00e9l nem a param\u00e9ter n\u00e9lk\u00fcli, hanem az object param\u00e9ter\u0171 lehet\u0151s\u00e9get v\u00e1lasztottuk, hiszen a sz\u00e1lf\u00fcggv\u00e9nynek \u00e1t kell adni az \u00e1ltala mozgatott biciklit.</p> <p>A sz\u00e1l ind\u00edt\u00e1sa a <code>CreateBike</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9n:</p> <pre><code>private void CreateBike()\n{\n    ...\n\n    var thread = new Thread(BikeThreadFunction);\n    thread.IsBackground = true; // Ne blokkolja a sz\u00e1l a processz megsz\u0171n\u00e9s\u00e9t\n    thread.Start(bike); // itt adjuk \u00e1t param\u00e9terben a sz\u00e1lf\u00fcggv\u00e9nynek a biciklit\n}\n</code></pre> <p>BEADAND\u00d3</p> <p>Miel\u0151tt tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat1.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Game.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>Game</code> oszt\u00e1ly <code>CreateBike</code> \u00e9s <code>BikeThreadFunction</code> f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-2-a-verseny-inditasa","title":"Feladat 2 \u2013 A verseny ind\u00edt\u00e1sa","text":"<p>Val\u00f3s\u00edtsd meg a verseny ind\u00edt\u00e1s\u00e1t a rajtvonalr\u00f3l \u00e9s futtat\u00e1s\u00e1t mindaddig, am\u00edg a biciklik meg nem \u00e9rkeznek a dep\u00f3ba, a k\u00f6vetkez\u0151 ir\u00e1nyelveknek megfelel\u0151en:</p> <ul> <li>A versenyt a <code>Start Race</code> gombkattint\u00e1s sor\u00e1n m\u00e1r h\u00edvott <code>Game</code> oszt\u00e1lybeli <code>StartBikes</code> f\u00fcggv\u00e9ny ind\u00edtsa.</li> <li>Fontos, hogy a <code>StartBikes</code> m\u0171veletben ne \u00faj sz\u00e1lakat ind\u00edtsunk, hanem meg kell oldani, hogy megl\u00e9v\u0151 sz\u00e1lak v\u00e1rakozzanak, majd a <code>StartBikes</code> f\u00fcggv\u00e9ny h\u00edv\u00e1s\u00e1nak \"hat\u00e1s\u00e1ra\" folytass\u00e1k fut\u00e1sukat.</li> <li>Ha a felhaszn\u00e1l\u00f3 azel\u0151tt nyomja meg a <code>Start Race</code> gombot, hogy a biciklik el\u00e9rn\u00e9k a startvonalat, akkor a bicikliknek m\u00e1r nem kell meg\u00e1llni a startvonalon (de az is teljesen j\u00f3 megold\u00e1s, ha ilyen esetben a gomb lenyom\u00e1s\u00e1t m\u00e9g figyelmen k\u00edv\u00fcl hagyja az alkalmaz\u00e1s).</li> <li>A biciklik eg\u00e9szen a dep\u00f3ig haladjanak el (m\u00edg poz\u00edci\u00f3juk el nem \u00e9ri a <code>DepoPosition</code> tagv\u00e1ltoz\u00f3 \u00e1ltal meghat\u00e1rozott \u00e9rt\u00e9ket).</li> <li>A <code>Game</code> oszt\u00e1lyban dolgozz.</li> </ul> <p>Tipp a megold\u00e1shoz</p> <p>Mivel a v\u00e1rakoz\u00e1st k\u00f6vet\u0151en a versenyz\u0151knek egyszerre kell indulniuk, a v\u00e1rakoz\u00e1s \u00e9s ind\u00edt\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra egy <code>ManualResetEvent</code> objektumot c\u00e9lszer\u0171 haszn\u00e1lni.</p> <p>BEADAND\u00d3</p> <p>Miel\u0151tt tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat2.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Game.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>Game</code> oszt\u00e1ly <code>BikeThreadFunction</code> f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-3-a-versenyzok-inditasa-a-depobol","title":"Feladat 3 \u2013 A versenyz\u0151k ind\u00edt\u00e1sa a dep\u00f3b\u00f3l","text":"<p>Val\u00f3s\u00edtsd meg a versenyz\u0151k ind\u00edt\u00e1s\u00e1t a dep\u00f3b\u00f3l \u00e9s futtat\u00e1s\u00e1t mindaddig, am\u00edg a biciklik meg nem \u00e9rkeznek a c\u00e9lba, a k\u00f6vetkez\u0151 ir\u00e1nyelveknek megfelel\u0151en:</p> <ul> <li>Az egyes versenyz\u0151ket a <code>Start Next Bike From Depo</code> gombkattint\u00e1s sor\u00e1n m\u00e1r h\u00edvott <code>Game</code> oszt\u00e1lybeli <code>StartNextBikeFromDepo</code> f\u00fcggv\u00e9ny ind\u00edtsa a dep\u00f3b\u00f3l.</li> <li>Minden gombkattint\u00e1sra csak egyetlen versenyz\u0151 indulhat el a dep\u00f3b\u00f3l.</li> <li>Fontos, hogy a <code>StartNextBikeFromDepo</code> m\u0171veletben ne \u00faj sz\u00e1lakat ind\u00edtsunk, hanem meg kell oldani, hogy megl\u00e9v\u0151 sz\u00e1lak v\u00e1rakozzanak, majd a <code>StartNextBikeFromDepo</code> f\u00fcggv\u00e9ny h\u00edv\u00e1s\u00e1nak \"hat\u00e1s\u00e1ra\" folytass\u00e1k fut\u00e1sukat.</li> <li>Ha a felhaszn\u00e1l\u00f3 azel\u0151tt nyomja meg a <code>Start Next Bike From Depo</code> gombot, hogy a biciklik el\u00e9rn\u00e9k a dep\u00f3t, akkor egy bicikli m\u00e1r tov\u00e1bbmehet a dep\u00f3b\u00f3l, amikor meg\u00e9rkezik oda (de az is teljesen j\u00f3 megold\u00e1s, ha ilyen esetben a gomb lenyom\u00e1s\u00e1t m\u00e9g figyelmen k\u00edv\u00fcl hagyja az alkalmaz\u00e1s).</li> <li>A biciklik eg\u00e9szen a c\u00e9legyenesig haladjanak el (m\u00edg poz\u00edci\u00f3juk el nem \u00e9ri a <code>FinishLinePosition</code> tagv\u00e1ltoz\u00f3 \u00e1ltal meghat\u00e1rozott \u00e9rt\u00e9ket). Amikor egy bicikli el\u00e9ri a c\u00e9lvonalat, a biciklihez tartoz\u00f3 sz\u00e1l fejezze be a fut\u00e1s\u00e1t.</li> <li>A <code>Game</code> oszt\u00e1lyban dolgozz.</li> </ul> <p>Tipp a megold\u00e1shoz</p> <p>A feladat megold\u00e1sa anal\u00f3g az el\u0151z\u0151\u00e9vel, \u00e1m ez\u00fattal a <code>ManualResetEvent</code> helyett egy m\u00e1s t\u00edpus\u00fa, de hasonl\u00f3 objektumot kell haszn\u00e1lni...</p> <p>BEADAND\u00d3</p> <p>Miel\u0151tt tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat3.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Game.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>Game</code> oszt\u00e1ly <code>BikeThreadFunction</code> f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-4-gyoztes-bicikli-megvalositasa","title":"Feladat 4 \u2013 Gy\u0151ztes bicikli megval\u00f3s\u00edt\u00e1sa","text":"<p>Val\u00f3s\u00edtsd meg a gy\u0151ztes bicikli meghat\u00e1roz\u00e1s\u00e1nak \u00e9s megjelen\u00edt\u00e9s\u00e9nek logik\u00e1j\u00e1t, a k\u00f6vetkez\u0151 ir\u00e1nyelveknek megfelel\u0151en:</p> <ul> <li>A biciklik k\u00f6z\u00fcl az a gy\u0151ztes, mely el\u0151sz\u00f6r \u00e9ri ez a c\u00e9lvonalat (a poz\u00edci\u00f3ja el\u0151sz\u00f6r \u00e9ri el a <code>FinishLinePosition</code> tagv\u00e1ltoz\u00f3 \u00e1ltal meghat\u00e1rozott \u00e9rt\u00e9ket).</li> <li>A megold\u00e1s sor\u00e1n haszn\u00e1ld fel, hogy a <code>Bike</code> oszt\u00e1lyban m\u00e1r van egy <code>isWinner</code> v\u00e1ltoz\u00f3, mely \u00e9rt\u00e9ke kezdetben hamis, \u00e9s a <code>SetAsWinner</code> m\u0171velettel igazz\u00e1 tehet\u0151, illetve az \u00e9rt\u00e9ke az <code>IsWinner</code> tulajdons\u00e1ggal lek\u00e9rdezhet\u0151.</li> <li>Annak eld\u00f6nt\u00e9se, hogy az adott bicikli lett-e a gy\u0151ztes, a <code>Game</code> oszt\u00e1lyban biciklihez tartoz\u00f3 sz\u00e1lf\u00fcggv\u00e9ny feladata, ide tedd a d\u00f6nt\u00e9si logik\u00e1t.</li> <li> Kulcsfontoss\u00e1g\u00fa, hogy pontosan egy gy\u0151ztes lehet. Ha egyn\u00e9l t\u00f6bb bicikli ker\u00fcl gy\u0151ztesnek megjel\u00f6l\u00e9sre (vagyis a <code>Bike</code> oszt\u00e1ly <code>SetAsWinner</code> m\u0171velete t\u00f6bb biciklire is megh\u00edv\u00e1sra ker\u00fcl), az nagyon s\u00falyos hiba!</li> <li>A <code>Game</code> oszt\u00e1lyban dolgozz.</li> </ul> <p>A logika megval\u00f3s\u00edt\u00e1sa el\u0151tt egy kicsit finom\u00edtunk a megjelen\u00edt\u00e9sen, annak \u00e9rdek\u00e9ben, hogy a gy\u0151ztes bicikli megk\u00fcl\u00f6nb\u00f6ztethet\u0151 legyen a t\u00f6bbit\u0151l a fel\u00fcleten. Ehhez a <code>MainWindow</code> oszt\u00e1ly <code>UpdateUI</code> f\u00fcggv\u00e9ny\u00e9be tegy\u00fcnk be egy kis plusz logik\u00e1t: ha az adott bicikli gy\u0151ztes lett, akkor a megjelen\u00edt\u00e9s\u00e9t v\u00e1ltoztassuk \u00e1t egy serlegre. Ehhez a biciklihez tartoz\u00f3 <code>TextBlock</code> sz\u00f6veg\u00e9t kell \"%\"-ra v\u00e1ltoztatni:</p> <pre><code>private void UpdateUI()\n{\n    for (int i = 0; i &lt; game.Bikes.Count;i++)\n    {\n        ...\n\n        if (bike.IsWinner)\n            tbBike.Text = \"%\";\n    }\n}\n</code></pre> <p>A logik\u00e1t ezt k\u00f6vet\u0151en \u00f6n\u00e1ll\u00f3an val\u00f3s\u00edtsd meg, az al\u00e1bbi ir\u00e1nyleveknek \u00e9s tippeknek megfelel\u0151en.</p> <p>Ir\u00e1nyelvek \u00e9s tippek a megold\u00e1shoz</p> <ul> <li>Annak eld\u00f6nt\u00e9s\u00e9re, hogy volt-e m\u00e1r gy\u0151ztes, a <code>Game</code> oszt\u00e1lyban vezess be egy <code>bool hasWinner</code> seg\u00e9dv\u00e1ltoz\u00f3t (ez azt jelezze, volt-e m\u00e1r gy\u0151ztes hirdetve).</li> <li>El\u0151ad\u00e1son egy nagyon hasonl\u00f3 p\u00e9lda szerepelt a \"A lock haszn\u00e1lata\" t\u00e9mak\u00f6rben, r\u00e9szletes magyar\u00e1zattal.</li> <li>A megold\u00e1snak akkor is j\u00f3l kell m\u0171k\u00f6dnie (egy gy\u0151ztes lehet \u00e9s nem t\u00f6bb), ha a <code>hasWinner</code> felt\u00e9telvizsg\u00e1lat \u00e9s a <code>hasWinner</code> igazba \u00e1ll\u00edt\u00e1sa k\u00f6z\u00e9 egy hosszabb mesters\u00e9ges k\u00e9sleltet\u00e9s ker\u00fcl, azt szimul\u00e1lva, hogy a sz\u00e1l \"pechesen\" itt veszti el a fut\u00e1si jog\u00e1t, \u00e9s a dep\u00f3b\u00f3l a biciklik \"azonnal\" tov\u00e1bb vannak engedve (vagyis k\u00f6zel egyszerre \u00e9rnek a c\u00e9lba). </li> <li>A tesztel\u00e9s idej\u00e9re tegy\u00e9l ide (a felt\u00e9telvizsg\u00e1lat \u00e9s <code>hasWinner</code> \u00e1ll\u00edt\u00e1sa k\u00f6z\u00e9) egy <code>Thread.Sleep(2000)</code> sort, melyet tesztel\u00e9s ut\u00e1n kommentezz ki. Term\u00e9szetesen \u00fagy tesztelj, hogy a bicikliket a dep\u00f3b\u00f3l min\u00e9l ink\u00e1bb egyszerre engedd tov\u00e1bb a gombkattint\u00e1sokkal, hogy a biciklik kb. egyszerre \u00e9rjenek a c\u00e9lba. Ha t\u00f6bb gy\u0151ztes is lenne (mert nem j\u00f3 a megold\u00e1sod), akkor a c\u00e9lban t\u00f6bb bicikli is serlegg\u00e9 v\u00e1lik!</li> </ul> <p>BEADAND\u00d3</p> <p>Miel\u0151tt tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat4.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Game.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>Game</code> oszt\u00e1ly <code>BikeThreadFunction</code> f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-5-kolcsonos-kizaras-valamint-volatile","title":"Feladat 5 \u2013 K\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s, valamint volatile","text":"<p>Az el\u0151z\u0151 feladatban l\u00e1ttuk, hogy a hasWinner lek\u00e9rdez\u00e9s\u00e9t \u00e9s be\u00e1ll\u00edt\u00e1s\u00e1t \"oszthatatlann\u00e1\", \"atomiv\u00e1\" kellett tegy\u00fck, vagyis ennek sor\u00e1n meg kellett val\u00f3s\u00edtsuk a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1st. K\u00e9rd\u00e9s, van-e esetleg m\u00e1r olyan m\u00e1s logika is az alkalmaz\u00e1sban, ahol ezt meg kellet volna tenni a konzisztencia garant\u00e1l\u00e1s\u00e1nak \u00e9rdek\u00e9ben. Ehhez azt kell megvizsg\u00e1ljuk, melyek azok a v\u00e1ltoz\u00f3k, melyeket t\u00f6bb sz\u00e1lb\u00f3l is \u00edrunk (vagy egyikb\u0151l \u00edrunk \u00e9s m\u00e1sikb\u00f3l olvasunk). A k\u00f6vetkez\u0151k \u00e9rintettek:</p> <ul> <li><code>Bike</code> oszt\u00e1ly <code>position</code> tagja. Ezt a biciklik sz\u00e1lf\u00fcggv\u00e9nye m\u00f3dos\u00edtja a <code>+=</code> oper\u00e1torral, a f\u0151sz\u00e1l pedig olvassa a <code>Position</code> property seg\u00edts\u00e9g\u00e9vel a megjelen\u00edt\u00e9s sor\u00e1n. K\u00e9rd\u00e9s, lehet-e ebb\u0151l b\u00e1rmif\u00e9le inkonzisztencia (mert ha igen, akkor meg kellene val\u00f3s\u00edtani a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1st, pl. a <code>lock</code> utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel). Ez m\u00e9lyebb \u00e1tgondol\u00e1st ig\u00e9nyel. Az <code>int</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3k olvas\u00e1sa \u00e9s \u00edr\u00e1sa (sima <code>=</code> oper\u00e1tor) atomi, \u00edgy ez rendben is volna. Csakhogy itt m\u00f3dos\u00edt\u00e1sra nem az <code>=</code>, hanem <code>+=</code> oper\u00e1tort haszn\u00e1ljuk. A <code>+=</code> oper\u00e1tor nem atomi, t\u00f6bb l\u00e9p\u00e9sb\u0151l \u00e1ll: v\u00e1ltoz\u00f3 kiolvas\u00e1sa, n\u00f6vel\u00e9se, majd vissza\u00edr\u00e1sa (ha nem tiszta, pontosan mi\u00e9rt \u00e9s milyen probl\u00e9ma l\u00e9phet fel, mindenk\u00e9ppen n\u00e9zd \u00e1t a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1s di\u00e1t). \u00cdgy, ha t\u00f6bb sz\u00e1l is haszn\u00e1lja \"egyszerre\" a <code>+=</code> oper\u00e1tort ugyanazon a v\u00e1ltoz\u00f3n, akkor abb\u00f3l inkonzisztencia lehet. De ne kapkodjunk, gondoljunk bele jobban: a mi eset\u00fcnkben egyszerre egy sz\u00e1l h\u00edv <code>+=</code>-t, a m\u00e1sik sz\u00e1lunk csak olvassa a <code>position</code> \u00e9rt\u00e9k\u00e9t. Ebb\u0151l nem lehet inkonzisztencia, mert egyszer\u0171en csak arr\u00f3l van sz\u00f3, hogy az olvas\u00e1s el\u0151tt vagy a n\u00f6vel\u00e9s el\u0151tti \u00e9rt\u00e9ket, vagy az ut\u00e1ni \u00e9rt\u00e9ket kapja meg az olvas\u00f3 sz\u00e1l (ha szinte pont egyszerre olvas a += oper\u00e1tor-t v\u00e9grehajt\u00f3 m\u00e1sik sz\u00e1llal). \u00cdgy kijelenthetj\u00fck, ennek kapcs\u00e1n nincs sz\u00fcks\u00e9g k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra.</li> <li><code>Bike</code> oszt\u00e1ly <code>isWinner</code> tagja. Ezt a biciklik sz\u00e1lf\u00fcggv\u00e9nye m\u00f3dos\u00edtja a <code>SetAsWinner</code> h\u00edv\u00e1s\u00e1val, a f\u0151sz\u00e1l pedig olvassa az <code>IsWinner</code> property seg\u00edts\u00e9g\u00e9vel a megjelen\u00edt\u00e9s sor\u00e1n. T\u00edpusa <code>bool</code>, melynek \u00edr\u00e1sa \u00e9s olvas\u00e1sa atomi, \u00edgy nincs sz\u00fcks\u00e9g k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra.</li> <li><code>Game</code> oszt\u00e1ly <code>hasWinner</code> tagja. T\u00edpusa bool, melynek \u00edr\u00e1sa \u00e9s olvas\u00e1sa atomi, \u00edgy amiatt sz\u00fcks\u00e9g k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra. De volt egy plusz felt\u00e9tel\u00fcnk: csak egy gy\u0151ztes lehet versenyben, emiatt m\u00e9gis sz\u00fcks\u00e9g volt k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra (ezt az el\u0151z\u0151 feladatban meg is tett\u00fck).</li> </ul> <p>Azt is mondhatn\u00e1nk, hogy a fenti h\u00e1rom v\u00e1ltoz\u00f3 tekintet\u00e9ben akkor minden rendben is van, de ez nincs \u00edgy. Amikor a v\u00e1ltoz\u00f3k \u00e9rt\u00e9k\u00e9t az egyik sz\u00e1l m\u00f3dos\u00edtja, el\u0151fordulhat, hogy a v\u00e1ltoz\u00f3k \u00e9rt\u00e9k\u00e9t a rendszer cache-eli (pl. regiszterben), \u00edgy a m\u00e1sik sz\u00e1l a v\u00e1ltoztat\u00e1s ut\u00e1n is a kor\u00e1bbi \u00e9rt\u00e9ket l\u00e1tja. Ennek megakad\u00e1lyoz\u00e1s\u00e1ra ezeket a v\u00e1ltoz\u00f3kat volatile-nak kell defini\u00e1lni a <code>volatile</code> kulcssz\u00f3val, mely a v\u00e1ltoz\u00f3 megv\u00e1ltoztat\u00e1sa ut\u00e1n garant\u00e1lja, hogy annak ki\u00edr\u00e1sa megt\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ba, \u00e9s a m\u00e1sik sz\u00e1l friss \u00e9rt\u00e9ket olvas (a <code>volatile</code> m\u0171k\u00f6d\u00e9se enn\u00e9l valamivel \u00f6sszetettebb, el\u0151ad\u00e1son b\u0151vebben kifejt\u00e9sre ker\u00fcl). Fontos megjegyz\u00e9s: a <code>volatile</code> alkalmaz\u00e1s\u00e1ra nincs sz\u00fcks\u00e9g, ha az adott v\u00e1ltoz\u00f3t <code>lock</code> blokkb\u00f3l \u00edrjuk \u00e9s olvassuk, vagy az <code>Interlocked</code> oszt\u00e1ly seg\u00edts\u00e9g\u00e9vel m\u00f3dos\u00edtjuk. Amiatt csak a <code>position</code> \u00e9s az <code>isWinner</code> eset\u00e9ben vezess\u00fck be:</p> <pre><code>class Bike\n{\n    private volatile int position = 65;\n    private volatile bool isWinner;\n</code></pre>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-5-lepesek-naplozasa-nem-szalbiztos-net-osztalyok","title":"Feladat 5 \u2013 L\u00e9p\u00e9sek napl\u00f3z\u00e1sa (nem sz\u00e1lbiztos .NET oszt\u00e1lyok)","text":"<p>Val\u00f3s\u00edtsd meg a verseny sor\u00e1n a biciklik \u00e1ltal megtett minden egyes l\u00e9p\u00e9s napl\u00f3z\u00e1s\u00e1t a <code>Game</code> oszt\u00e1lyban egy (minden biciklire k\u00f6z\u00f6s) <code>List&lt;int&gt;</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3ba. A napl\u00f3zott \u00e9rt\u00e9kekkel nem kell semmit csin\u00e1lni (pl. megjelen\u00edteni sem). A megold\u00e1s sor\u00e1n ki kell haszn\u00e1lni, hogy a <code>Bike</code> oszt\u00e1ly <code>Step</code> m\u0171velete visszaadja a megtett l\u00e9p\u00e9st egy <code>int</code> v\u00e1ltoz\u00f3 form\u00e1j\u00e1ban, ezt kell napl\u00f3zni (csak bele kell tenni a list\u00e1ba).</p> Tipp a megold\u00e1shoz <p>Mivel a <code>List&lt;T&gt;</code> oszt\u00e1ly nem sz\u00e1lbiztos (nem thread safe), \u00e9s t\u00f6bb sz\u00e1lb\u00f3l is \u00edrunk bele, meg kell val\u00f3s\u00edtani a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1st a <code>lock</code> utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel.</p> <p>System.Collections.Concurrent n\u00e9vt\u00e9r gy\u0171jtem\u00e9nyoszt\u00e1lyai</p> <p>Ha a <code>List&lt;T&gt;</code> helyett egy a c\u00e9lnak megfelel\u0151, <code>System.Collections.Concurrent</code> n\u00e9vt\u00e9rbeli oszt\u00e1ly objektum\u00e1ba napl\u00f3zn\u00e1nk (pl. <code>ConcurrentQueue</code>), akkor nem lenne sz\u00fcks\u00e9g a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s megval\u00f3s\u00edt\u00e1s\u00e1ra, mert ebben a n\u00e9vt\u00e9rben sz\u00e1lbiztos (thread safe) gy\u0171jtem\u00e9nyoszt\u00e1lyok tal\u00e1lhat\u00f3k.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat-6-felulet-frissitese-minden-valtozas-eseten-felhasznaloi-feluletelemek-elerese-munkaszalakbol","title":"Feladat 6 \u2013 Fel\u00fclet friss\u00edt\u00e9se minden v\u00e1ltoz\u00e1s eset\u00e9n (felhaszn\u00e1l\u00f3i fel\u00fcletelemek el\u00e9r\u00e9se munkasz\u00e1lakb\u00f3l)","text":"<p>Aktu\u00e1lis megold\u00e1sunkban a fel\u00fclet friss\u00edt\u00e9s\u00e9t periodikusan, adott id\u0151k\u00f6z\u00f6nk\u00e9nt val\u00f3s\u00edtjuk meg egy id\u0151z\u00edt\u0151 seg\u00edts\u00e9g\u00e9vel. Ezt a megold\u00e1st most lecser\u00e9lj\u00fck. Alak\u00edtsd \u00e1t a megold\u00e1st \u00fagy, hogy a fel\u00fclet friss\u00edt\u00e9se minden esetben azonnal megt\u00f6rt\u00e9njen, amikor a <code>Game</code> \u00e1llapota megv\u00e1ltozik (az id\u0151z\u00edtett friss\u00edt\u00e9st pedig m\u00e1r ne haszn\u00e1ld).</p> <p>A k\u00f6vetkez\u0151 fejezetben a lehets\u00e9ges megold\u00e1sok r\u00f6viden \u00e1ttekint\u00e9sre ker\u00fclnek, \u00e9s v\u00e1lasztunk is egyet k\u00f6z\u00fcl\u00fck, de el\u0151bb pr\u00f3b\u00e1ld magadt\u00f3l \u00e1tgondolni, milyen megold\u00e1st c\u00e9lszer\u0171 ehhez v\u00e1lasztani. Kulcsfontoss\u00e1g\u00fa, hogy csak olyan megold\u00e1s fogadhat\u00f3 el, mely nem vezet be az alkalmaz\u00e1slogik\u00e1ban (<code>Game</code> oszt\u00e1ly) f\u00fcgg\u0151s\u00e9get a fel\u00fcltett\u0151l. Eml\u00e9kezz\u00fcnk vissza, az alapelv\u00fcnk az volt, hogy az alkalmaz\u00e1slogika nem f\u00fcgghet semmilyen szinten a fel\u00fclet logik\u00e1t\u00f3l!</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#a-felulet-ertesitesenek-megvalositasa","title":"A fel\u00fclet \u00e9rtes\u00edt\u00e9s\u00e9nek megval\u00f3s\u00edt\u00e1sa","text":"<p>Alternat\u00edv\u00e1k:</p> <ol> <li>Alkalmazhatjuk az Observer tervez\u00e9si mint\u00e1t. Err\u0151l a f\u00e9l\u00e9v sor\u00e1n k\u00e9s\u0151bb fogunk tanulni, b\u00e1r \u00e9rdemes megjegyezni, hogy a C# esem\u00e9nyek is az Observer minta alapkoncepci\u00f3ira \u00e9p\u00fclnek.</li> <li>K\u00e9zenfekv\u0151 megold\u00e1s lehet egy C# esem\u00e9ny bevezet\u00e9se (pl. <code>BikeStateChanged</code> n\u00e9ven), melyet a <code>Game</code> oszt\u00e1ly akkor s\u00fct el, amikor egy bicikli \u00e1llapota megv\u00e1ltozott, param\u00e9terk\u00e9nt \u00e1tadva a bicikli objektumot. Ez egy kerek, \u00e1ltal\u00e1nos megold\u00e1s lenne: b\u00e1rmikor, b\u00e1rmely oszt\u00e1ly feliratkozhatna az esem\u00e9nyre. Ehhez - ha k\u00f6vetni szeretn\u00e9nk a Microsoft aj\u00e1nl\u00e1sokat - be kellene vezetni egy <code>EventArgs</code> lesz\u00e1rmazott oszt\u00e1lyt (esem\u00e9ny param\u00e9ter), \u00e9s be kellene vezetni egy \u00faj delegate t\u00edpust (vagy haszn\u00e1lhatn\u00e1nk a be\u00e9p\u00edtett <code>EventHandler&lt;TEventArgs&gt;</code> generikus delegate t\u00edpust).</li> <li> <p>Az el\u0151z\u0151 pontban eml\u00edtett C# esem\u00e9ny alap\u00fa megold\u00e1s teljesen \"korrekt\" lenne, ugyanakkor nek\u00fcnk nem felt\u00e9tlen c\u00e9lunk, hogy b\u00e1rmikor b\u00e1rmely oszt\u00e1ly feliratkozhasson az \u00e1llapotv\u00e1ltoz\u00e1s esem\u00e9nyre. Emiatt \u00e1tgondolhatunk egy \"c\u00e9lir\u00e1nyosabb\" megold\u00e1st (\u00e9s ezt is fogjuk alkalmazni). Ez, b\u00e1r delegate-et haszn\u00e1l, nem vezet be <code>event</code> esem\u00e9nyt, \u00e9s alapvet\u0151en csak egyetlen objektum sz\u00e1m\u00e1ra biztos\u00edt \u00e9rtes\u00edt\u00e9st/visszah\u00edv\u00e1st (a <code>MainWindow</code>-nak, hiszen \u0151 kell friss\u00edtse a fel\u00fclet\u00e9t, amikor v\u00e1ltozik egy bicikli \u00e1llapota). Ezen megk\u00f6zel\u00edt\u00e9s elemei a k\u00f6vetkez\u0151k:</p> <ul> <li><code>Game</code> oszt\u00e1ly, mint \"\u00e9rtes\u00edt\u0151\":<ul> <li>Azt a f\u00fcggv\u00e9nyt (delegate objektumot), melyet <code>Game</code> oszt\u00e1ly a biciklik \u00e1llapot\u00e1nak v\u00e1ltoz\u00e1sakor megh\u00edv (\u00e9rtes\u00edt\u00e9s/visszah\u00edv\u00e1s), a <code>PrepareRace</code> m\u0171velet param\u00e9terek\u00e9nt kapja meg a <code>Game</code> oszt\u00e1ly, melyet egy tagv\u00e1ltoz\u00f3ban el is t\u00e1rol.</li> <li>Ennek a param\u00e9ternek \u00e9s tagv\u00e1ltoz\u00f3nak a t\u00edpusa legyen <code>Action&lt;Bike&gt;</code> (az <code>Action</code> \u00e9s <code>Action&lt;T&gt;</code> t\u00edpusokr\u00f3l m\u00e1r kor\u00e1bban tanultunk).</li> <li>Amikor megv\u00e1ltozik egy bicikli \u00e1llapota (helye vagy \"nyertes\" \u00e1llapota a sz\u00e1lf\u00fcggv\u00e9nyben), akkor a <code>Game</code> oszt\u00e1ly h\u00edvja meg ezt a tagv\u00e1ltoz\u00f3ban t\u00e1rolt f\u00fcggv\u00e9nyt (de csak ha nem null, vagyis ez a f\u00fcggv\u00e9ny m\u00e1r be lett \u00e1ll\u00edtva, ill. a <code>?.Invoke</code> is haszn\u00e1lhat\u00f3), param\u00e9terk\u00e9nt \u00e1tadva neki a megv\u00e1ltozott bicikli objektumot. Ez\u00e1ltal \u00e9rtes\u00edti az el\u0151fizet\u0151t.</li> </ul> </li> <li><code>MainWindow</code>, mint \"el\u0151fizet\u0151\":<ul> <li>A <code>MainWindow</code> oszt\u00e1lyban be kell vezetni egy <code>UpdateBikeUI(Bike bike)</code> f\u00fcggv\u00e9nyt, \u00e9s a <code>Game.PrepareRace</code> h\u00edv\u00e1sakor ezt kell \u00e1tadni param\u00e9terk\u00e9nt (delegate objektumk\u00e9nt). Ebben az <code>UpdateBikeUI</code> f\u00fcggv\u00e9nyben kell gondoskodni arr\u00f3l, hogy a param\u00e9terk\u00e9nt kapott bicikli objektumhoz tartoz\u00f3 fel\u00fcletelem (<code>TextBlock</code>) friss\u00fclj\u00f6n.</li> <li>Az el\u0151z\u0151 pontban v\u00e1lik egy\u00e9rtelm\u0171v\u00e9, mi\u00e9rt <code>Action&lt;Bike&gt;</code> t\u00edpus\u00fa delegate-et haszn\u00e1ltunk, \u00e9s mi\u00e9rt nem pl. <code>Action</code>-t: a <code>Game</code> a \u00e9rtes\u00edt\u00e9s/visszah\u00edv\u00e1s sor\u00e1n \u00edgy meg tudja adna, mely bicikli v\u00e1ltozott, \u00e9s a visszah\u00edvott/beregisztr\u00e1lt f\u00fcggv\u00e9ny (eset\u00fcnkben <code>MainWindow.UpdateBikeUI</code>) \u00edgy megkapja ezt param\u00e9terben, \u00e9s \u00edgy tudja a megjelen\u00e9s\u00e9t friss\u00edteni (kapott bicikli \u00e1llapota alapj\u00e1n).</li> </ul> </li> <li>Az id\u0151z\u00edt\u0151 ind\u00edt\u00e1s\u00e1t (<code>MainWindow</code> konstruktorban <code>timer.Start()</code> h\u00edv\u00e1s) kommentezd ki (hiszen a fel\u00fclet friss\u00edt\u00e9s\u00e9t m\u00e1r a fenti <code>Action&lt;Bike&gt;</code>) alap\u00fa \u00e9rtes\u00edt\u00e9s/visszah\u00edv\u00e1s seg\u00edts\u00e9g\u00e9vel oldjuk meg.</li> </ul> </li> </ol> <p>Val\u00f3s\u00edtsd meg a fenti 3. pontban v\u00e1zolt \u00e9rtes\u00edt\u00e9st! A <code>MainWindow.UpdateBikeUI</code> implement\u00e1ci\u00f3j\u00e1t megadjuk seg\u00edts\u00e9gk\u00e9ppen (a l\u00e9nyege az, hogy a param\u00e9terben kapott <code>Bike</code> alapj\u00e1n friss\u00edti a biciklit megjelen\u00edt\u0151 <code>TextBlock</code>-ot):</p> <pre><code>private void UpdateBikeUI(Bike bike)\n{\n    // El\u0151fordulhat, hogy az UpdateBikeUI olyan kor\u00e1n h\u00edv\u00f3dik, hogy a\n    // bikeTextBlocks m\u00e9g nincs felt\u00f6ltve, ilyenkor m\u00e9g nem tudjuk friss\u00edteni\n    // a fel\u00fcletet, t\u00e9rj\u00fcnk vissza.\n    if (bikeTextBlocks.Count != game.Bikes.Count)\n        return;\n\n    int marginAdjustmentForWheel = 8;\n\n    // Biciklihez tartoz\u00f3 TextBlock kikeres\u00e9se (azonos t\u00f6mbindex alapj\u00e1n).\n    var tbBike = bikeTextBlocks[game.Bikes.IndexOf(bike)];\n\n    // Akkor m\u00e9g ne \u00e1ll\u00edtsuk a bicikli poz\u00edci\u00f3j\u00e1t, amikor a m\u00e9rete a layout sor\u00e1n nem\n    // ker\u00fclt meghat\u00e1roz\u00e1sra (k\u00fcl\u00f6nben ugr\u00e1lna a bicikli, hiszen al\u00e1bb, a marg\u00f3 be\u00e1ll\u00edt\u00e1sakor\n    // \"\u00e9rv\u00e9nytelen\" 0 sz\u00e9less\u00e9g\u00e9rt\u00e9kkel sz\u00e1moln\u00e1nk.\n    if (tbBike.ActualWidth == 0)\n        return;\n\n    // Az ablak 0,0 pontja az orig\u00f3, ehhez k\u00e9pest n\u00e9zz\u00fck a start/dep\u00f3/finish vonalat.\n    // A gomb jobb sz\u00e9l\u00e9n van a ker\u00e9k, de ezt a gomb bal oldal\u00e1ra kell mozgatni: ActualWidth-et ki kell vonni.\n    tbBike.Margin = new Thickness(bike.Position - tbBike.ActualWidth + marginAdjustmentForWheel, 0, 0, 0);\n\n    if (bike.IsWinner)\n        tbBike.Text = \"%\"; // display a cup\n}\n</code></pre> <p>Fontos</p> <p>A fenti l\u00e9p\u00e9sek/elvek megfelel\u0151 k\u00f6vet\u00e9se eset\u00e9n is fenn\u00e1ll, hogy megold\u00e1s m\u00e9g nem m\u0171k\u00f6d\u0151k\u00e9pes. Ha elind\u00edtjuk a versenyt, az al\u00e1bbi kiv\u00e9tel dob\u00f3dik az <code>UpdateBikeUI</code> f\u00fcggv\u00e9nyben a biciklihez tartoz\u00f3 <code>TextBlock</code> hozz\u00e1f\u00e9r\u00e9s sor\u00e1n: <code>System.Runtime.InteropServices.COMException: 'The application called an interface that was marshalled for a different thread. (0x8001010E (RPC_E_WRONG_THREAD))</code></p> <p>Mi ennek a hib\u00e1nak az oka? Miel\u0151tt az al\u00e1bbi eml\u00e9keztet\u0151t kinyitod, pr\u00f3b\u00e1lj magadt\u00f3l r\u00e1j\u00f6nni az el\u0151ad\u00e1son/laboron tanultak alapj\u00e1n.</p> Eml\u00e9keztet\u0151 <p>Egy WinUI fel\u00fcletelemhez/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l lehet hozz\u00e1f\u00e9rni, mely az adott fel\u00fcletelemet l\u00e9trehozta, ugyanis ezek a fel\u00fcletelemek nem sz\u00e1lbiztosak, \u00e9s kiv\u00e9tel dob\u00e1s\u00e1val jelzik, ha m\u00e9gis \u201erosszul\u201d pr\u00f3b\u00e1ljuk \u0151ket haszn\u00e1lni.</p> <p>A megold\u00e1st a k\u00f6vetkez\u0151 r\u00e9szfeladatban dolgozzuk ki.</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#a-dispatecherqueue-alkalmazasa","title":"A DispatecherQueue alkalmaz\u00e1sa","text":"<p>Eset\u00fcnkben a konkr\u00e9t probl\u00e9m\u00e1t az okozza, hogy amikor a <code>Game</code> \u00e1llapota megv\u00e1ltozik, akkor <code>Game</code> oszt\u00e1lyban a v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u0151 delegate h\u00edv\u00e1sa a biciklikhez tartoz\u00f3 munkasz\u00e1lakon t\u00f6rt\u00e9nik, \u00edgy a beregisztr\u00e1lt <code>MainWindow.UpdateBikeUI</code> kezel\u0151f\u00fcggv\u00e9ny is ezekr\u0151l a sz\u00e1lakr\u00f3l h\u00edv\u00f3dik. Az <code>UpdateBikeUI</code> f\u00fcggv\u00e9nyben hozz\u00e1f\u00e9r\u00fcnk a fel\u00fcletelemekhez (biciklihez tartoz\u00f3 <code>TextBlock</code>- hoz). De ezeket a fel\u00fcletelemeket a f\u0151sz\u00e1lb\u00f3l hoztuk l\u00e9tre: \u00edgy csak a f\u0151 sz\u00e1lb\u00f3l szabad(na) hozz\u00e1juk f\u00e9rni.</p> <p> A probl\u00e9m\u00e1ra a <code>DispatcherQueue</code> alkalmaz\u00e1sa jelent megold\u00e1st, mellyel a munkasz\u00e1lakb\u00f3l a h\u00edv\u00e1st \"\u00e1t tudjuk j\u00e1tszani\" a f\u0151sz\u00e1lba, melyb\u0151l m\u00e1r hozz\u00e1 tudunk f\u00e9rni a vez\u00e9rl\u0151kh\u00f6z. A <code>DispacherQueue</code> alkalmaz\u00e1sa el\u0151ad\u00e1son \u00e9s a kapcsol\u00f3d\u00f3 laboron is r\u00e9szletesen ismertet\u00e9sre ker\u00fclt.</p> <p>Feladat: m\u00f3dos\u00edtsd \u00fagy a <code>MainWindow.UpdateBikeUI</code> f\u00fcggv\u00e9nyt, hogy a <code>DispacherQueue</code> alkalmaz\u00e1s\u00e1val a megfelel\u0151 sz\u00e1lb\u00f3l t\u00f6rt\u00e9njen a fel\u00fcletelemekhez t\u00f6rt\u00e9n\u0151 hozz\u00e1f\u00e9r\u00e9s (\u00e9s \u00edgy a mostani kiv\u00e9telt el tudd ker\u00fclni).</p> <p>BEADAND\u00d3</p> <p>Miel\u0151tt tov\u00e1bbmenn\u00e9l a k\u00f6vetkez\u0151 feladatra, egy k\u00e9perny\u0151ment\u00e9st kell k\u00e9sz\u00edtened.</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat6.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>MainWindow.xaml.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>MainWindow</code> oszt\u00e1ly <code>UpdateBikeUI</code> f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul> <p>Hasonl\u00f3 j\u00e1t\u00e9k megval\u00f3s\u00edt\u00e1sa a gyakorlatban</p> <p>L\u00e9nyeges, hogy egy hasonl\u00f3 \"j\u00e1t\u00e9k\" megval\u00f3s\u00edt\u00e1s\u00e1ra nem szoktunk sz\u00e1lakat ind\u00edtani: a biciklik l\u00e9ptet\u00e9s\u00e9re egy timer sokkal praktikusabb lenne, mert az eg\u00e9sz j\u00e1t\u00e9k egysz\u00e1l\u00fa maradhatna, \u00e9s elker\u00fclhetn\u00e9nk sz\u00e1mos, a t\u00f6bbsz\u00e1l\u00fas\u00e1gb\u00f3l ad\u00f3d\u00f3 neh\u00e9zs\u00e9ge (jelen feladat keret\u00e9ben a c\u00e9lunk \u00e9rtelemszer\u0171en pont a t\u00f6bbsz\u00e1l\u00fas\u00e1g t\u00e9mak\u00f6r\u00e9nek gyakorl\u00e1sa volt).</p>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#opcionalis-feladat-2-imsc-pontert","title":"Opcion\u00e1lis feladat \u2013 2 IMSc pont\u00e9rt","text":""},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#feladat","title":"Feladat","text":"<p>Tedd lehet\u0151v\u00e9 a biciklik gombkattint\u00e1sra t\u00f6rt\u00e9n\u0151 meg\u00e1ll\u00edt\u00e1s\u00e1t:</p> <ul> <li>Helyezz el egy gombot jobbra a t\u00f6bbit\u0151l, Stop Race felirattal.</li> <li>A Stop Race gombra kattint\u00e1s \u00e1ll\u00edtsa meg az \u00f6sszes biciklit, \u00e9s \u00e1ll\u00edtsa le a bicikliket futtat\u00f3 sz\u00e1lakat is. Ehhez vezess be egy <code>StopRace</code> publikus f\u00fcggv\u00e9nyt a <code>Game</code> oszt\u00e1lyba.</li> <li>A verseny ak\u00e1r az elind\u00edt\u00e1sa el\u0151tt is le\u00e1ll\u00edthat\u00f3 legyen.</li> <li>A <code>StopRace</code> m\u0171velet sz\u00e1lak le\u00e1ll\u00edt\u00e1sa ut\u00e1n v\u00e1rja meg, m\u00edg valamennyi sz\u00e1l val\u00f3ban be is fejezi a fut\u00e1s\u00e1t.</li> <li>A verseny le\u00e1ll\u00edt\u00e1sa ut\u00e1n (Stop Race kattint\u00e1s) semelyik gombra ne lehessen kattintani (minden gomb legyen letiltva, <code>IsEnabled</code> tulajdons\u00e1gukat \u00e1ll\u00edtsuk hamisba).</li> </ul>"},{"location":"hazi/4-tobbszalu-alkalmazasok-fejlesztese/#megoldas","title":"Megold\u00e1s","text":"<p>A k\u00f6vetkez\u0151kben megadjuk a feladat megold\u00e1s\u00e1nak n\u00e9h\u00e1ny fontos elem\u00e9t:</p> <ul> <li>Tegy\u00e9l fel egy Stop Race gombot a fel\u00fcletre, k\u00e9sz\u00edts hozz\u00e1 kezel\u0151f\u00fcggv\u00e9nyt, \u00e9s ebb\u0151l meg kell h\u00edvni az \u00fajonnan bevezetend\u0151 <code>Game.StopRace</code> f\u00fcggv\u00e9nyt.</li> <li>A meg\u00e1ll\u00edt\u00e1shoz sz\u00fcks\u00e9g lesz egy jelz\u00e9sre a bicikliket futtat\u00f3 sz\u00e1l fel\u00e9. Ez legyen egy <code>bool</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3, amelyet a bicikliket futtat\u00f3 sz\u00e1l ciklusa figyel. Vedd fel ezt <code>raceEnded</code> n\u00e9ven, \u00e9s m\u00f3dos\u00edtsd a sz\u00e1lf\u00fcggv\u00e9nyt, hogy ha ennek \u00e9rt\u00e9ke igaz lesz, a sz\u00e1l fejezze be a fut\u00e1s\u00e1t (t\u00e9rjen vissza).</li> <li>Az el\u0151bb bevezetett bool v\u00e1ltoz\u00f3 \u00f6nmag\u00e1ban nem lesz el\u00e9g. Hiszen, amikor a bicikli a startvonaln\u00e1l vagy a dep\u00f3ban v\u00e1r, akkor a sz\u00e1la blokkolt \u00e1llapotban van (esem\u00e9ny jelz\u00e9sre v\u00e1r), ekkor nem tudja a <code>raceEnded</code>bool v\u00e1ltoz\u00f3t vizsg\u00e1lni. Emiatt be kell vezetni fel egy \u00faj <code>ManualResetEvent</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3t, amely a le\u00e1ll\u00edt\u00e1s esem\u00e9nyt fogja jelezni (\u00e9s v\u00e1rakozni is lehet r\u00e1).</li> <li>Ezt az esem\u00e9nyt a <code>bool</code> v\u00e1ltoz\u00f3val egy\u00fctt a Stop Race gombra val\u00f3 kattint\u00e1s sor\u00e1n kell jelzettbe \u00e1ll\u00edtani (a <code>Game.StopRace</code>-ben).</li> <li>A bicikliket mozgat\u00f3 sz\u00e1lf\u00fcggv\u00e9nyben kommentezd ki (ne t\u00f6r\u00f6ld!) az eddigi v\u00e1rakoz\u00e1st megval\u00f3s\u00edt\u00f3 k\u00f3dr\u00e9szeket, \u00e9s k\u00e9sz\u00edts egy \u00faj megold\u00e1st az el\u0151bb felvett le\u00e1ll\u00edt\u00e1st jelz\u0151 <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel. A v\u00e1rakoz\u00e1sokra tov\u00e1bbra is sz\u00fcks\u00e9g lesz, azonban a v\u00e1rakoz\u00f3 \u00e1llapotb\u00f3l akkor is ki kell l\u00e9pni, ha a le\u00e1ll\u00edt\u00e1st jelz\u0151 <code>ManualResetEvent</code> esem\u00e9ny lesz jelzett.</li> <li>Ha le\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nt, a sz\u00e1l fut\u00e1s\u00e1t be kell fejezni (a sz\u00e1lf\u00fcggv\u00e9nyb\u0151l ki kell l\u00e9pni, pl. egy <code>return</code> utas\u00edt\u00e1ssal).</li> <li>A <code>Game.StopRace</code> m\u0171velet\u00e9ben a sz\u00e1laknak t\u00f6rt\u00e9n\u0151 jelz\u00e9s ut\u00e1n meg kell v\u00e1rni, m\u00edg a sz\u00e1lak val\u00f3ban ki is l\u00e9pnek. Ehhez az egyes biciklikhez tartoz\u00f3 sz\u00e1l objektumokra kell sorban <code>Join()</code>-t h\u00edvni. Ahhoz, hogy ez megtehet\u0151 legyen, a sz\u00e1lak ind\u00edt\u00e1sakor a sz\u00e1l objektumokat el kell t\u00e1rolni egy tagv\u00e1ltoz\u00f3ban (pl. egy <code>List&lt;Thread&gt;</code> -ben)</li> </ul> <p>Megjegyz\u00e9s: sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9re alternat\u00edv megold\u00e1s lett volna a bool \u00e9s <code>ManualResetEvent</code> bevezet\u00e9se helyett a sz\u00e1lakra <code>Interrupt</code> m\u0171velet h\u00edv\u00e1sa, \u00e9s a sz\u00e1lf\u00fcggv\u00e9nyekben az ennek hat\u00e1s\u00e1ra kiv\u00e1lt\u00f3d\u00f3 <code>ThreadInterruptedException</code> elkap\u00e1sa. Ez a t\u00e9mak\u00f6r el\u0151ad\u00e1son ker\u00fclt ismertet\u00e9sre.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>Feladat_IMSc.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Game.cs</code> megnyitva,</li> <li>VS-ben zoomolj \u00fagy, hogy a <code>Game</code> oszt\u00e1ly sz\u00e1lf\u00fcggv\u00e9nye f\u00fcggv\u00e9nye l\u00e1that\u00f3 legyen, az el\u0151t\u00e9rben pedig az alkalmaz\u00e1sod ablaka.</li> </ul>"},{"location":"hazi/5-mvvm/","title":"5. HF - Az MVVM minta \u00e9s az MVVM Toolkit alkalmaz\u00e1sa","text":""},{"location":"hazi/5-mvvm/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A h\u00e1zi feladatban a 3. XAML laboron megval\u00f3s\u00edtott szem\u00e9ly regisztr\u00e1ci\u00f3s alkalmaz\u00e1st alak\u00edtjuk \u00e1t olyan m\u00f3don, hogy az MVVM mint\u00e1ra \u00e9p\u00fclj\u00f6n, valamint megismerked\u00fcnk az MVVM Toolkit alkalmaz\u00e1s\u00e1val.</p> <p>Az \u00f6n\u00e1ll\u00f3 feladat a WinUI el\u0151ad\u00e1ssorozat v\u00e9g\u00e9n elhangzott MVVM t\u00e9mak\u00f6rre \u00e9p\u00edt. Megjegyz\u00e9s: az 5. labor \u2013 MVVM labor nagyon szerte\u00e1gaz\u00f3, \u00e9s egy komplexebb alkalmaz\u00e1s kontextus\u00e1ban mutat p\u00e9ld\u00e1t az MVVM minta alkalmaz\u00e1s\u00e1ra, sok m\u00e1s t\u00e9mak\u00f6r mellett. Jelen h\u00e1zi feladat sokkal f\u00f3kusz\u00e1ltabb, kisebb l\u00e9p\u00e9sekben \u00e9p\u00edtkezik: est\u00fcnkben esetben ink\u00e1bb a jelen h\u00e1zi feladat megold\u00e1sa seg\u00edti az 5. labor \u2013 MVVM kapcsol\u00f3d\u00f3 r\u00e9szeinek k\u00f6nnyebb meg\u00e9rt\u00e9s\u00e9t.</p> <p>Az kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sanyag feldolgoz\u00e1s\u00e1val, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel (n\u00e9ha alap\u00e9rtelmezetten \u00f6sszecsukva) \u00f6n\u00e1ll\u00f3an elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Az MVVM minta haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>NuGet referenci\u00e1k alkalmaz\u00e1sa</li> <li>Az MVVM Toolkit alapjaival val\u00f3 ismerked\u00e9s</li> <li>XAML technik\u00e1k gyakorl\u00e1sa</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s, megegyezik a 3. h\u00e1zi feladat\u00e9val (XAML alapok).</p>"},{"location":"hazi/5-mvvm/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>HelloXaml.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> <li> Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</li> </ul>"},{"location":"hazi/5-mvvm/#kikotesek","title":"Kik\u00f6t\u00e9sek","text":"<p> MVVM minta k\u00f6telez\u0151 alkalmaz\u00e1sa!   Jelen h\u00e1zi feladatban az MVVM mint\u00e1t gyakoroljuk, \u00edgy a feladatok megold\u00e1s\u00e1ban k\u00f6telez\u0151 az MVVM minta alkalmaz\u00e1sa. Az ett\u0151l val\u00f3 elt\u00e9r\u00e9s a feladatok \u00e9rt\u00e9kel\u00e9s\u00e9nek elutas\u00edt\u00e1s\u00e1t vonja maga ut\u00e1n.</p>"},{"location":"hazi/5-mvvm/#feladat-0-kiindulo-allapot-attekintese","title":"Feladat 0 - Kiindul\u00f3 \u00e1llapot \u00e1ttekint\u00e9se","text":"<p>A kiindul\u00f3 \u00e1llapot alapvet\u0151en megegyezik a 3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa v\u00e9g\u00e1llapot\u00e1val. Vagyis egy olyan alkalmaz\u00e1s, melyben egy list\u00e1ban szem\u00e9lyek adatait lehet r\u00f6gz\u00edteni.  A labor v\u00e9g\u00e1llapot\u00e1hoz k\u00e9pest egy kisebb v\u00e1ltoz\u00e1st tartalmaz. Laboron a fel\u00fclet teljes le\u00edr\u00e1s\u00e1t a <code>MainWindow.xaml</code> (\u00e9s a kapcsol\u00f3d\u00f3 code-behind f\u00e1jl) tartalmazta. Jelen kiindul\u00f3 megold\u00e1sban az a k\u00fcl\u00f6nbs\u00e9g, hogy ez \u00e1t lett mozgatva a <code>Views</code> mapp\u00e1ban lev\u0151 <code>PersonListPage.xaml</code> (\u00e9s code behind) f\u00e1jlba. A <code>PersonListPage</code> nem egy <code>Window</code>, hanem egy <code>Page</code> lesz\u00e1rmazott oszt\u00e1ly (ellen\u0151rizz\u00fck ezt a code behind f\u00e1jlban). De semmi m\u00e1s v\u00e1ltoz\u00e1s nincs! Mint a neve is utal r\u00e1, a <code>Page</code> egy \"oldalt\" reprezent\u00e1l az alkalmaz\u00e1sban: \u00f6nmag\u00e1ban nem tud megjelenni, hanem pl. egy ablakon kell elhelyezni. El\u0151nye, hogy az ablakon - megfelel\u0151 navig\u00e1ci\u00f3 kialak\u00edt\u00e1s\u00e1val - lehet\u0151s\u00e9g van oldalak (k\u00fcl\u00f6nb\u00f6z\u0151 <code>Page</code> lesz\u00e1rmazottak) k\u00f6z\u00f6tt navig\u00e1lni. Ezt mi nem fogjuk kihaszn\u00e1lni, egyetlen oldalunk lesz csak. Az oldal bevezet\u00e9s\u00e9vel a c\u00e9lunk mind\u00f6ssze az volt, hogy szeml\u00e9ltess\u00fck: az MVVM architekt\u00far\u00e1ban a n\u00e9zeteket nem csak <code>Window</code> (teljes ablak), hanem pl. <code>Page</code> objektumokkal is meg lehet val\u00f3s\u00edtani. </p> <p>Mivel mindent \u00e1tmozgattunk a <code>MainWindow</code>-b\u00f3l a <code>PersonListPage</code>-be, a <code>MainWindow.xaml</code>-ban m\u00e1r semmi m\u00e1s nincs, mint egy ilyen <code>PersonListPage</code> objektum p\u00e9ld\u00e1nyos\u00edt\u00e1sa:</p> <pre><code>&lt;views:PersonListPage/&gt;\n</code></pre> <p>Ellen\u0151rizd a k\u00f3dban, hogy val\u00f3ban ez a helyzet!</p>"},{"location":"hazi/5-mvvm/#foablak-fejlece","title":"F\u0151ablak fejl\u00e9ce","text":"<p> A f\u0151ablak fejl\u00e9ce az \"MVVM\" sz\u00f6veg legyen, hozz\u00e1f\u0171zve a saj\u00e1t Neptun k\u00f3dod: (pl. \"ABCDEF\" Neptun k\u00f3d eset\u00e9n \"MVVM - ABCDEF\"), fontos, hogy ez legyen a sz\u00f6veg! Ehhez a f\u0151ablakunk <code>Title</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtsuk be erre a sz\u00f6vegre a <code>MainWindow.xaml</code> f\u00e1jlban.</p>"},{"location":"hazi/5-mvvm/#feladat-1-mvvm-toolkit-alkalmazasa","title":"Feladat 1 - MVVM Toolkit alkalmaz\u00e1sa","text":"<p>A megl\u00e9v\u0151 alkalmaz\u00e1sban a <code>Models</code> mapp\u00e1ban lev\u0151 <code>Person</code> oszt\u00e1ly m\u00e1r implement\u00e1lja az <code>INotifyPropertyChanged</code> (becenev\u00e9n INPC) interf\u00e9szt (\u00edgy rendelkezik egy <code>PropertyChanged</code> esem\u00e9nnyel), valamint a <code>Name</code> \u00e9s az <code>Age</code> setter\u00e9ben jelzi is a tulajdons\u00e1g v\u00e1ltoz\u00e1s\u00e1t a <code>PropertyChanged</code> esem\u00e9ny els\u00fct\u00e9s\u00e9vel (n\u00e9zd meg ezt alaposan a <code>Person.cs</code> f\u00e1jlban).</p> <p>Bemeleg\u00edt\u00e9sk\u00e9ppen/ism\u00e9tl\u00e9sk\u00e9ppen - a k\u00f3dot (<code>PersonListPage.xaml</code> \u00e9s <code>PersonListPage.xaml.cs</code>) alaposan \u00e1tn\u00e9zve \u00e9s az alkalmaz\u00e1st futtatva - fogalmazd meg magadban, mi\u00e9rt is volt erre az alkalmaz\u00e1sban sz\u00fcks\u00e9g!</p> A v\u00e1lasz (ism\u00e9tl\u00e9s) <p>Az alkalmaz\u00e1sban a <code>PersonListPage.xaml</code>-ben a <code>TextBox</code>-ok <code>Text</code> tulajdons\u00e1ga (ez a c\u00e9l tulajdons\u00e1g) hozz\u00e1 vannak k\u00f6tve a code behindban lev\u0151 <code>Person</code> t\u00edpus\u00fa <code>NewPerson</code> tag <code>Age</code> \u00e9s <code>Name</code> tulajdons\u00e1gaihoz (ezek a forr\u00e1sok a k\u00e9t adatk\u00f6t\u00e9sben). N\u00e9zz\u00fck meg a k\u00f3dban, hogy a <code>NewPerson.Name</code> \u00e9s <code>NewPerson.Age</code> forr\u00e1s tulajdons\u00e1gokat v\u00e1ltoztatjuk is a k\u00f3dban: a vez\u00e9rl\u0151 csak akkor tud ezekr\u0151l \u00e9rtes\u00fclni (\u00e9s \u00edgy szinkronban maradni a forr\u00e1ssal), ha ezekr\u0151l a <code>Name</code> \u00e9s <code>Age</code> v\u00e1ltoz\u00e1sokr\u00f3l \u00e9rtes\u00edt\u00e9st kap. Emiatt az <code>Age</code> \u00e9s <code>Name</code> tulajdons\u00e1gokat tartalmaz\u00f3 oszt\u00e1lynak, vagyis a <code>Person</code>-nek meg kell val\u00f3s\u00edtania az <code>INotifyPropertyChanged</code> interf\u00e9szt, \u00e9s a tulajdons\u00e1gok v\u00e1ltoz\u00e1sakor el kell s\u00fctnie a <code>PropertyChanged</code> esem\u00e9nyt megfelel\u0151en param\u00e9terezve.</p> <p>Az alkalmaz\u00e1st futtatva ellen\u0151rizd, hogy a '+' \u00e9s '-' gombok hat\u00e1s\u00e1ra eszk\u00f6z\u00f6lt <code>NewPerson.Age</code> v\u00e1ltoz\u00e1sok val\u00f3ban \u00e9rv\u00e9nyre jutnak az \u00e9letkort megjelen\u00edt\u0151 <code>TextBox</code>-ban. </p> <p>A <code>Person</code> oszt\u00e1lyban l\u00e1tszik, hogy az <code>INotifyPropertyChanged</code> megval\u00f3s\u00edt\u00e1sa \u00e9s a kapcsol\u00f3d\u00f3 k\u00f3d igencsak terjeng\u0151s. N\u00e9zd meg az el\u0151ad\u00e1sanyagban, milyen alternat\u00edv\u00e1k vannak az interf\u00e9sz megval\u00f3s\u00edt\u00e1s\u00e1ra (az \"INPC p\u00e9lda 1\" c\u00edm\u0171 di\u00e1t\u00f3l kezd\u0151d\u0151en kb. n\u00e9gy dia a n\u00e9gy lehet\u0151s\u00e9g illusztr\u00e1l\u00e1s\u00e1ra)! A legt\u00f6m\u00f6rebb legold\u00e1st az MVVM Toolkit alkalmaz\u00e1sa jelenti. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben jelen terjeng\u0151sebb \"manu\u00e1lis\" INPC megval\u00f3s\u00edt\u00e1st \u00e1talak\u00edtjuk MVVM toolkit alap\u00fara.</p>"},{"location":"hazi/5-mvvm/#feladat-1a-mvvm-toolkit-nuget-referencia-felvetele","title":"Feladat 1/a - MVVM Toolkit NuGet referencia felv\u00e9tele","text":"<p>Els\u0151 l\u00e9p\u00e9sben NuGet referenci\u00e1t kell tenni az MVVM Toolkitre annak \u00e9rdek\u00e9ben, hogy haszn\u00e1lni lehessen a projektben. </p> <p>Feladat: Vegy\u00e9l fel egy NuGet referenci\u00e1t a projektben a \"CommunityToolkit.Mvvm\" NuGet csomagra. Ez a Visual Studio oldal \u00edrja le, hogyan lehet egy NuGet referenci\u00e1t a projektbe felvenni NuGet Package Manager. Az el\u0151z\u0151 link az oldalon bel\u00fcl a \"NuGet Package Manager\" fejezetre ugrik, az itt megadott n\u00e9gy l\u00e9p\u00e9st kell k\u00f6vetni (term\u00e9szetesen azzal a k\u00fcl\u00f6nbs\u00e9ggel, hogy nem a \"Newtonsoft.Json\" hanem a \"CommunityToolkit.Mvvm\" csomagra kell a referenci\u00e1t felvenni).</p> <p>Most, hogy a projekt\u00fcnkbe felvett\u00fck ezt a NuGet referenci\u00e1t, a k\u00f6vetkez\u0151 build sor\u00e1n (mivel annak r\u00e9szek\u00e9nt lefut egy NuGet restore l\u00e9p\u00e9s!) let\u00f6lt\u0151dik a NuGet csomag, kicsomagol\u00f3dnak a benne lev\u0151 DLL-ek a kimeneti mapp\u00e1ba, \u00edgy azok m\u00e1r szerves r\u00e9sz\u00e9t k\u00e9pezik az alkalmaz\u00e1snak (egy NuGet csomag tulajdonk\u00e9ppen egy zip \u00e1llom\u00e1ny). Fontos megeml\u00edteni, hogy Git-be sem a NuGet zip, sem a benne lev\u0151 dll-ek nem ker\u00fclnek fel, a solution gy\u00f6ker\u00e9ben lev\u0151 <code>.gitignore</code> f\u00e1jl ezeket kisz\u0171ri. Pont ez a NuGet koncepci\u00f3 l\u00e9nyege: a repository kicsi maradhat, mert a projektf\u00e1jl csak hivatkoz\u00e1sokat tartalmazza a NuGet csomagokra, \u00e9s amikor valaki egy frissen clone-ozott solution-t buildel, csak ekkor t\u00f6lt\u0151dnek le az online NuGet forr\u00e1sokb\u00f3l a hivatkozott NuGet csomagok.</p> <p> A fenti NuGet-re vonatkoz\u00f3 koncepci\u00f3k ismerete fontos, a tananyag fontos r\u00e9sz\u00e9t k\u00e9pezik!</p> <p>Egy NuGet referencia tulajdonk\u00e9ppen csak egy sor a <code>.csproj</code> projektle\u00edr\u00f3 f\u00e1jlban. A Solution Explorerben a \"HelloXaml\" projekt csom\u00f3pontra kattintva nyisd meg a <code>.csproj</code> projektf\u00e1jlt, \u00e9s ellen\u0151rizd, benne van ez a sor (a verzi\u00f3 lehet m\u00e1s lesz):</p> <pre><code>    &lt;PackageReference Include=\"CommunityToolkit.Mvvm\" Version=\"8.2.2\" /&gt;\n</code></pre> <p>A <code>csproj</code> f\u00e1jl megnyit\u00e1sa n\u00e9lk\u00fcl is ellen\u0151rizd a NuGet referenci\u00e1nkat: Solution Explorerben nyisd le a \"HelloXaml\"/\"Dependencies\"/\"Packages\" csom\u00f3pontot: ha minden rendben van, alatta l\u00e1that\u00f3 egy \"CommunityToolkit.Mvvm (verzi\u00f3)\" csom\u00f3pont.</p>"},{"location":"hazi/5-mvvm/#feladat-1b-inpc-megvalositas-mvvm-toolkit-alapokon","title":"Feladat 1/b - INPC megval\u00f3s\u00edt\u00e1s MVVM Toolkit alapokon","text":"<p>Most m\u00e1r tudjuk haszn\u00e1lni az MVVM Toolkit NuGet package-ben lev\u0151 oszt\u00e1lyokat, interf\u00e9szeket, attrib\u00fatumokat stb., \u00edgy \u00e1t tudunk t\u00e9rni az MVVM Toolkit alap\u00fa INPC megval\u00f3s\u00edt\u00e1sra.</p> <ul> <li>Kommentezd ki a <code>Person</code> oszt\u00e1lyt teljes eg\u00e9sz\u00e9ben. </li> <li>A kikommentezett r\u00e9sz felett vedd fel az oszt\u00e1lyt \u00fajonnan, de MVVM Toolkit alap\u00fa INPC megval\u00f3s\u00edt\u00e1ssal.<ul> <li>A megval\u00f3s\u00edt\u00e1sban a \"INPC p\u00e9lda 4 \u2013 MVVM Toolkittel\" el\u0151ad\u00e1sdia seg\u00edt.</li> <li>Partial class kell legyen (vagyis az oszt\u00e1ly r\u00e9szei t\u00f6bb f\u00e1jlban is defini\u00e1lhat\u00f3k).</li> <li>A Toolkit-beli <code>ObservableObject</code>-b\u0151l sz\u00e1rmazzon: ez az \u0151s val\u00f3s\u00edtja meg az <code>INotifyPropertyChanged</code> interf\u00e9szt, \u00edgy nek\u00fcnk m\u00e1r nem kell.</li> <li><code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1gok helyett <code>name</code> \u00e9s <code>age</code> tagv\u00e1ltoz\u00f3kat vezess\u00fcnk be, <code>ObservableProperty</code> attrib\u00fatummal ell\u00e1tva.</li> </ul> </li> </ul> <p>Meg is vagyunk.</p> A megold\u00e1s ellen\u0151rz\u00e9se <pre><code>public partial class Person : ObservableObject\n{\n    [ObservableProperty]\n    private string name;\n\n    [ObservableProperty]\n    private int age;\n}\n</code></pre> <p>Ez a k\u00f3d, egy ford\u00edt\u00e1st k\u00f6vet\u0151en, alapjaiban ugyanazt a megold\u00e1st eredm\u00e9nyezi, mint a kor\u00e1bbi, sokkal terjeng\u0151sebb, imm\u00e1r kikommentezett forma. Vagyis (m\u00e9g ha nem is l\u00e1tjuk egyel\u0151re) sz\u00fcletik <code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1g, megfelel\u0151 <code>PropertyChanged</code> esem\u00e9ny els\u00fct\u00e9sekkel. Hogyan lehets\u00e9ges ez? </p> <ul> <li>Egyr\u00e9szt az <code>ObservableObject</code> \u0151s m\u00e1r megval\u00f3s\u00edtja az <code>INotifyPropertyChanged</code> interf\u00e9szt, \u00edgy a <code>PropertyChanged</code> esem\u00e9ny tagot is tartalmazza, ezt a sz\u00e1rmaztat\u00e1s r\u00e9v\u00e9n \"meg\u00f6r\u00f6kli\" az oszt\u00e1lyunk.</li> <li>A ford\u00edt\u00e1s sor\u00e1n lefut az MVVM Toolkit k\u00f3dgener\u00e1tora, mely minden <code>ObservableProperty</code> attrib\u00fatummal ell\u00e1tott tagv\u00e1ltoz\u00f3hoz gener\u00e1l egy ugyanolyan nev\u0171, de nagybet\u0171vel kezd\u0151d\u0151 tulajdons\u00e1got az oszt\u00e1lyba, mely tulajdons\u00e1g settere els\u00fcti megfelel\u0151 felt\u00e9telek mellett \u00e9s megfelel\u0151 param\u00e9terekkel a <code>PropertyChanged</code> esem\u00e9nyt. Hurr\u00e1, ezt a k\u00f3dot akkor nem nek\u00fcnk kell meg\u00edrni.</li> <li>K\u00e9rd\u00e9s, hol keletkezi ez a k\u00f3d. Az oszt\u00e1lyunk egy m\u00e1sik \"partial\" r\u00e9sz\u00e9ben. Egy ford\u00edt\u00e1st k\u00f6vet\u0151en Visual Studio-ban jobb gombbal kattintsunk a <code>Person</code> oszt\u00e1ly nev\u00e9n, majd a felugr\u00f3 men\u00fcben \"Go to Definition\". Ekkor egy als\u00f3 ablakban k\u00e9t tal\u00e1latot is kapunk: az egyik az \u00e1ltalunk \u00edrt fenti k\u00f3d, a m\u00e1sik (\"public class Person\") a gener\u00e1lt r\u00e9szre ugrik egy duplakatt hat\u00e1s\u00e1ra: l\u00e1tszik, hogy viszonylag terjeng\u0151s k\u00f3dot gener\u00e1lt a k\u00f3dgener\u00e1tor, de ami nek\u00fcnk fontos, hogy itt tal\u00e1lhat\u00f3 a <code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1g, benne - t\u00f6bbek k\u00f6z\u00f6tt - a <code>OnPropertyChanged</code> els\u00fct\u00e9s\u00e9vel.</li> </ul> <p> A k\u00f3dgener\u00e1tor szok\u00e1sosan az oszt\u00e1lyunk m\u00e1sik \"partial\" fel\u00e9be dolgozik, annak \u00e9rdek\u00e9ben, hogy ne keveredjen az \u00e1ltalunk \u00edrt \u00e9s a gener\u00e1lt k\u00f3d! A partial classokat leggyakrabban a k\u00e9zzel \u00edrt \u00e9s a gener\u00e1lt k\u00f3d \"k\u00fcl\u00f6nv\u00e1laszt\u00e1s\u00e1ra\" haszn\u00e1ljuk.</p> <p>Mivel sokkal kevesebb k\u00f3dot kell \u00edrni, a gyakorlatban az MVVM Toolkit alap\u00fa megold\u00e1st szoktuk haszn\u00e1lni (de a manu\u00e1lis megold\u00e1st is tudni kell, ez alapj\u00e1n \u00e9rthet\u0151, mi is t\u00f6rt\u00e9nik a sz\u00ednfalak m\u00f6g\u00f6tt).</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>f1b.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>Person.cs</code> megnyitva.</li> </ul>"},{"location":"hazi/5-mvvm/#feladat-2-atteres-mvvm-alapu-megoldasra","title":"Feladat 2 - \u00c1tt\u00e9r\u00e9s MVVM alap\u00fa megold\u00e1sra","text":"<p>Az el\u0151z\u0151 l\u00e9p\u00e9sben, b\u00e1r az MVVM Toolkitet haszn\u00e1ltuk, m\u00e9g nem t\u00e9rt\u00fcnk \u00e1t MVVM alap\u00fa megold\u00e1ra (a toolkitet csak az INPC egyszer\u0171bb megval\u00f3s\u00edt\u00e1s\u00e1ra haszn\u00e1ltuk). </p> <p>A k\u00f6vetkez\u0151kben \u00e1talak\u00edtjuk az alkalmaz\u00e1sunk architekt\u00far\u00e1j\u00e1t, hogy az MVVM koncepci\u00f3j\u00e1t k\u00f6vesse. Az egyszer\u0171bb megval\u00f3s\u00edt\u00e1s \u00e9rdek\u00e9ben \u00e9p\u00edt\u00fcnk az MVVM Toolkitre.</p> <p>Feladat: Dolgozd fel a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sanyagot (WinUI anyagr\u00e9sz v\u00e9g\u00e9n tal\u00e1lhat\u00f3):</p> <ul> <li>\u00c9rtsd meg az MVVM minta alapkoncepci\u00f3it.</li> <li>Az el\u0151ad\u00e1sdi\u00e1kon tal\u00e1lhat\u00f3 p\u00e9ld\u00e1k teljes k\u00f3dja el\u00e9rhet\u0151 az El\u0151ad\u00e1s GitHub repository \"04-05 WinUI\\DancerProfiles\" mapp\u00e1ban (\"RelaxedMVVM\" \u00e9s \"StrictMVVM\"), ezek seg\u00edthetnek a meg\u00e9rt\u00e9sben \u00e9s a k\u00e9s\u0151bbi feladatok megold\u00e1s\u00e1ban. </li> </ul> <p>Mit is jelent az MVVM minta a p\u00e9ld\u00e1nkra vet\u00edtve:</p> <ul> <li>A model oszt\u00e1ly a <code>Models</code> mapp\u00e1ban lev\u0151 <code>Person</code> oszt\u00e1ly, egy szem\u00e9ly adatait reprezent\u00e1lja (UI logik\u00e1t NEM tartalmaz, f\u00fcggetlen mindenf\u00e9le megjelen\u00edt\u00e9st\u0151l).</li> <li>Jelen pillanatban minden,  megjelen\u00edt\u00e9shez kapcsol\u00f3d\u00f3 le\u00edr\u00e1s/logika a <code>PersonListPage</code>-ben van.  A mostani <code>PersonListPage</code>-et kett\u00e9v\u00e1gjuk:<ul> <li>A <code>PersonListPage.xaml</code> \u00e9s a code behindja lesz a View.</li> <li>Bevezet\u00fcnk egy a <code>PersonListPage</code>-hez tartoz\u00f3 ViewModel-t <code>PersonListPageViewModel</code> n\u00e9ven.<ul> <li> Kulcsfontoss\u00e1g\u00fa: a <code>PersonListPage</code> code behindb\u00f3l minden megjelen\u00edt\u00e9si logik\u00e1t \u00e1tmozgatunk a <code>PersonListPageViewModel</code>-be. A minta l\u00e9nyege az, hogy a View csak tiszt\u00e1n a fel\u00fclet le\u00edr\u00e1s\u00e1t tartalmazza, a megjelen\u00edt\u00e9si logik\u00e1nak a ViewModelben van a helye. </li> </ul> </li> </ul> </li> <li>A minta m\u00e1sik alappill\u00e9re: a View-nk tartalmaz egy hivatkoz\u00e1st a ViewModelj\u00e9re (m\u00e9gpedig egy tulajdons\u00e1g form\u00e1j\u00e1ban).<ul> <li>A p\u00e9ld\u00e1nkban azt jelenti, hogy a <code>PersonListPage</code>-nek kell legyen egy <code>PersonListPageViewModel</code> tulajdons\u00e1ga. </li> <li> Ez az\u00e9rt kulcsfontoss\u00e1g\u00fa, mert <code>PersonListPage</code> xaml f\u00e1jlunkban ezen tulajdons\u00e1gon kereszt\u00fcl tudunk adatk\u00f6t\u00e9st megval\u00f3s\u00edtani a ViewModel-be \u00e1tmozgatott tulajdons\u00e1gokra \u00e9s esem\u00e9nykezel\u0151kre! </li> </ul> </li> <li>A <code>PersonListPageViewModel</code> \"dolgozik\" a modellel \u00e9s kezeli a felhaszn\u00e1l\u00f3i interakci\u00f3kat (esem\u00e9nykezel\u0151k).</li> <li>Mivel a Relaxed, \u00e9s nem a Strict MVVM mint\u00e1t haszn\u00e1ljuk, a <code>Person</code> modelloszt\u00e1lyunk k\u00f6r\u00e9 m\u00e1r nem vezet\u00fcnk be egy <code>PersonViewModel</code> csomagol\u00f3t.</li> </ul> <p>Feladat: alak\u00edtsd \u00e1t a megl\u00e9v\u0151 logik\u00e1t \u00edgy, hogy a fenti elveket k\u00f6vet\u0151 MVVM mint\u00e1t k\u00f6vesse. A <code>PersonListPageViewModel</code> oszt\u00e1lyt egy \u00fajonnan l\u00e9trehozott <code>ViewModels</code> mapp\u00e1ba tedd. Pr\u00f3b\u00e1ld magad kidolgozni a megold\u00e1st a fenti seg\u00edts\u00e9g alapj\u00e1n! Ehhez egy el\u0151zetes tippet adunk, mert erre nehezebb r\u00e1j\u00f6nni: Az esem\u00e9nyekhez az esem\u00e9nykezel\u0151 m\u0171veleteket adatk\u00f6t\u00e9ssel is meg lehet adni: l\u00e1sd el\u0151ad\u00e1s dia \"Esem\u00e9nyek \u00e9s funkci\u00f3k k\u00f6t\u00e9se\" c\u00edmmel (az \u00e1talak\u00edt\u00e1s ut\u00e1n az esem\u00e9nykezel\u0151ket csak \u00edgy tudjuk megadni). Az is fontos, hogy adatk\u00f6tni csak publikus tulajdons\u00e1ghoz/m\u0171velethez lehet, ennek kapcs\u00e1n is lesz \u00e1talak\u00edtand\u00f3!</p> Tippek / megold\u00e1s visszaellen\u0151rz\u00e9se <ol> <li><code>PersonListPage.xaml.cs</code> code-behind f\u00e1jlb\u00f3l szinte mindent (kiv\u00e9ve <code>this.InitializeComponent()</code> h\u00edv\u00e1s a konstruktorban) \u00e1t kell mozgatni az \u00fajonnan bevezetett <code>PersonListPageViewModel</code>-be, mert ez mind UI logika.</li> <li>A <code>PersonListPageViewModel</code> publikus oszt\u00e1ly legyen.</li> <li>A <code>PersonListPage</code> code behindba fel kell venni egy ViewModel nev\u0171, <code>PersonListPageViewModel</code> t\u00edpus\u00fa, csak getterrel rendelkez\u0151 auto implement\u00e1lt tulajdons\u00e1got, \u00e9s ezt egy \u00faj objektumra inicializ\u00e1lni is kell. Vagyis a view hozza l\u00e9tre \u00e9s tartalmazza a ViewModel-t!</li> <li>A <code>PersonListPage.xaml</code>-ben az k\u00e9t <code>TextBox</code> adatk\u00f6t\u00e9s\u00e9t megfelel\u0151en igaz\u00edtani kell (a <code>NewPerson.Name</code> \u00e9s <code>NewPerson.Age</code> m\u00e1r egy szinttel m\u00e9lyebben, a code behind ViewModel tulajdons\u00e1g\u00e1n kereszt\u00fcl \u00e9rhet\u0151 el).</li> <li>A <code>PersonListPage.xaml</code>-ben az esem\u00e9nykezel\u0151k (<code>Click</code>) igaz\u00edt\u00e1sa h\u00e1rom helyen. Ezt tr\u00fckk\u00f6sebb. Esem\u00e9nykezel\u0151 f\u00fcggv\u00e9ny az eddig alkalmazott szintaktik\u00e1val nem adhat\u00f3 m\u00e1r meg, mert az esem\u00e9nykezel\u0151k nem a code behindban tal\u00e1lhat\u00f3k (\u00e1tker\u00fcltek a ViewModel-be). <ul> <li>Az esem\u00e9nyekhez az esem\u00e9nykezel\u0151 m\u0171veleteket adatk\u00f6t\u00e9ssel is meg lehet adni! L\u00e1sd el\u0151ad\u00e1s dia \"Esem\u00e9nyek \u00e9s funkci\u00f3k k\u00f6t\u00e9se\" c\u00edmmel. Ez nek\u00fcnk az\u00e9rt j\u00f3, mert a code behind ViewModel tulajdons\u00e1g\u00e1ban ott a <code>PersonListPageViewModel</code> objektum, melyben ott vannak az esem\u00e9nykezel\u0151k (<code>AddButton_Click</code>, <code>IncreaseButton_Click</code>, <code>DecreaseButton_Click</code>), ezeket kell k\u00f6t\u00f6tt tulajdons\u00e1gk\u00e9nt megadni az adatk\u00f6t\u00e9sben (pl. <code>ViewModel.AddButton_Click</code> stb.).</li> <li>Fontos, hogy az esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyek legyenek publikusak, m\u00e1sk\u00fcl\u00f6nben nem m\u0171k\u00f6dik az adatk\u00f6t\u00e9s (\u00e1t kell alak\u00edtani priv\u00e1tr\u00f3l).</li> </ul> </li> </ol> <p>Tov\u00e1bbi l\u00e9nyeges \u00e1talak\u00edtand\u00f3k:</p> <ul> <li>A ViewModel-ben jelenleg a <code>Click</code> esem\u00e9nykezel\u0151k nevei: <code>AddButton_Click</code>, <code>IncreaseButton_Click</code> \u00e9s <code>DecreaseButton_Click</code>. Ez nem szerencs\u00e9s. A ViewModel-ben \"szemantikailag\" nem esem\u00e9nykezel\u0151kben gondolkodunk. Helyette m\u00f3dos\u00edt\u00f3 m\u0171veletekben, melyek m\u00f3dos\u00edtj\u00e1k a ViewModel \u00e1llapot\u00e1t. A fentiek helyett ennek megfelel\u0151en sokkal jobban passzol\u00f3 \u00e9s kifejez\u0151 nevek az <code>AddPersonToList</code>, <code>IncreaseAge</code> \u00e9s <code>DecreaseAge</code>. Nevezd \u00e1t a f\u00fcggv\u00e9nyeket ennek megfelel\u0151en! Persze a tov\u00e1bbiakban is adatk\u00f6t\u00e9ssel ezeket kell k\u00f6tni a XAML f\u00e1jlban a <code>Click</code> esem\u00e9nyekhez.</li> <li>A fenti f\u00fcggv\u00e9nyek param\u00e9terlist\u00e1ja egyel\u0151re az \"<code>object sender, RoutedEventArgs e</code>\". Ugyanakkor ezeket a param\u00e9tereket nem haszn\u00e1ljuk semmire. Szerencs\u00e9re a x:Bind esem\u00e9ny adatk\u00f6t\u00e9s rugalmas annyira, hogy param\u00e9ter n\u00e9lk\u00fcli m\u0171velet is megadhat\u00f3, azzal is j\u00f3l m\u0171k\u00f6dik. Ennek tudat\u00e1ban t\u00e1vol\u00edtsd el a fenti felesleges param\u00e9tereket a ViewModel\u00fcnk h\u00e1rom f\u00fcggv\u00e9ny\u00e9b\u0151l. \u00cdgy egy letisztultabb megold\u00e1st kapunk.</li> </ul> <p>Ellen\u0151rizd, hogy az \u00e1talak\u00edt\u00e1sok ut\u00e1n is pontosan ugyan\u00fagy m\u0171k\u00f6dik az alkalmaz\u00e1s, mint el\u0151tte!</p> <p>Mit nyert\u00fcnk azzal, hogy kor\u00e1bbi megold\u00e1sunkat MVVM alap\u00fara alak\u00edtottuk \u00e1t? A v\u00e1laszt az el\u0151ad\u00e1sanyag adja meg! P\u00e1r dolog kiemelve:</p> <ul> <li>Sz\u00e9pen k\u00fcl\u00f6nv\u00e1lnak (nem keverednek) a k\u00fcl\u00f6nb\u00f6z\u0151 felel\u0151ss\u00e9g\u0171 r\u00e9szek, \u00edgy jobban meg\u00e9rthet\u0151:<ul> <li>UI f\u00fcggetlen logika (model \u00e9s kapcsol\u00f3d\u00f3 oszt\u00e1lyok).</li> <li>UI logika (ViewModel)</li> <li>UI puszta megjelen\u00e9s (View)</li> </ul> </li> <li>Mivel a UI logika k\u00fcl\u00f6n van, lehet(ne) hozz\u00e1 unit teszteket \u00edrni</li> </ul> <p>Min\u00e9l komplexebb egy alkalmaz\u00e1s, ann\u00e1l ink\u00e1bb igazak ezek.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>f2.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>PersonListPageViewModel.cs</code> megnyitva.</li> </ul>"},{"location":"hazi/5-mvvm/#feladat-3-vezerlok-tiltasaengedelyezese","title":"Feladat 3 - Vez\u00e9rl\u0151k tilt\u00e1sa/enged\u00e9lyez\u00e9se","text":"<p>Jelen \u00e1llapotban kiss\u00e9 furcs\u00e1n viselkedik az alkalmaz\u00e1s: a \"-\" gombbal negat\u00edv tartom\u00e1nyba is vihet\u0151 egy \u00e9letkor, vagy a \"+\"-szal 150 f\u00f6l\u00e9, illetve a \"+Add\" gombbal olyan szem\u00e9ly is felvehet\u0151, mely \u00e9rtelmetlen tulajdons\u00e1gokkal rendelkezik. Ezeket a gombokat le kellene tiltani, amikor az \u00e1ltaluk kiv\u00e1ltott m\u0171veletnek nincs \u00e9rtelme, illetve enged\u00e9lyezni, amikor van.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtsuk meg a \"-\" gomb tilt\u00e1s\u00e1t/enged\u00e9lyez\u00e9s\u00e9t ennek megfelel\u0151en. A gomb akkor legyen csak enged\u00e9lyezett, ha a szem\u00e9ly \u00e9letkora 0-n\u00e1l nagyobb.</p> <p>Pr\u00f3b\u00e1ld ezt els\u0151 k\u00f6rben magadt\u00f3l megval\u00f3s\u00edtani, legal\u00e1bbis az alapjait lefektetni! Mindenk\u00e9ppen adatk\u00f6t\u00e9s alap\u00fa megold\u00e1sban gondolkozz, csak ez fogadhat\u00f3 el! Ha elakadsz, a megold\u00e1sod nem \"akar\" m\u0171k\u00f6dni, akkor gondold \u00e1t, mi lehet az oka, a megold\u00e1st pedig az al\u00e1bbiaknak megfelel\u0151en alak\u00edtsd ki.</p> <p>A probl\u00e9m\u00e1ra t\u00f6bbf\u00e9le megold\u00e1s is kidolgozhat\u00f3. Mindben k\u00f6z\u00f6s, hogy a \"-\" gomb <code>IsEnabled</code> tulajdons\u00e1g\u00e1t k\u00f6tj\u00fck valamilyen m\u00f3don. Az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban egy a <code>PersonListPageViewModel</code>-ben \u00fajonnan bevezetett bool tulajdons\u00e1ghoz k\u00f6ss\u00fck. </p> PersonListPageViewModel.cs<pre><code>    public bool IsDecrementEnabled\n    {\n        get { return NewPerson.Age &gt; 0; }\n    }\n</code></pre> PersonListPage.xaml-be a '-' gombhoz<pre><code>    IsEnabled=\"{x:Bind ViewModel.IsDecrementEnabled, Mode=OneWay}\"\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki! Sajnos nem m\u0171k\u00f6dik, a \"-\" gomb nem tilt\u00f3dik le, amikor 0 vagy kisebb \u00e9rt\u00e9k\u0171 lesz az \u00e9letkor (pl. a gomb sokszori kattint\u00e1s\u00e1val). Ha t\u00f6r\u00e9spontot tesz\u00fcnk az <code>IsDecrementEnabled</code> belsej\u00e9be, \u00e9s \u00edgy ind\u00edtjuk az alkalmaz\u00e1st, azt tapasztaljuk, hogy a tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t csak egyszer k\u00e9rdezi le a k\u00f6t\u00f6tt vez\u00e9rl\u0151, az alkalmaz\u00e1s indul\u00e1sakor: ut\u00e1na hi\u00e1ba kattintunk pl. a \"-\" gombon, t\u00f6bbsz\u00f6r nem. Pr\u00f3b\u00e1ld is ki!</p> <p>Gondold \u00e1t, mi okozza ezt, \u00e9s csak ut\u00e1na haladj tov\u00e1bb az \u00fatmutat\u00f3val!</p> Indokl\u00e1s <p>A kor\u00e1bban tanultaknak megfelel\u0151en az adatk\u00f6t\u00e9s csak akkor k\u00e9rdezi le a forr\u00e1stulajdons\u00e1g (eset\u00fcnkben <code>IsDecrementEnabled</code>) \u00e9rt\u00e9k\u00e9t, ha annak v\u00e1ltoz\u00e1s\u00e1r\u00f3l az <code>INotifyPropertyChanged</code> seg\u00edts\u00e9g\u00e9vel \u00e9rtes\u00edt\u00e9st kap! M\u00e1rpedig, jelen megold\u00e1sunkban hi\u00e1ba v\u00e1ltozik a <code>NewPerson</code> objektum <code>Age</code> tulajdons\u00e1ga, ennek megt\u00f6rt\u00e9ntekor a semmif\u00e9le \u00e9rtes\u00edt\u00e9s nincs az erre \u00e9p\u00fcl\u0151 <code>IsDecrementEnabled</code> tulajdons\u00e1g megv\u00e1ltoz\u00e1s\u00e1r\u00f3l!</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtsd meg a kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9st a <code>PersonListPageViewModel</code> oszt\u00e1lyban:</p> <ul> <li>MVVM Toolkit \"alapokon\" val\u00f3s\u00edtsd meg az <code>INotifyPropertyChanged</code> interf\u00e9szt<ul> <li><code>ObservableObject</code> sz\u00e1rmaztat\u00e1st haszn\u00e1lj.</li> <li>Az <code>IsDecrementEnabled</code> tulajdons\u00e1g maradhat a mostani form\u00e1j\u00e1ban (egy getter only property), nem sz\u00fcks\u00e9ges <code>[ObservableProperty]</code> alap\u00fara \u00e1t\u00edrni (de az is j\u00f3 megold\u00e1s, \u00e9s a h\u00e1zi feladat tekintet\u00e9ben is teljesen elfogadhat\u00f3, csak kicsit m\u00e1sk\u00e9nt kell dolgozni a k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben).</li> </ul> </li> <li>Pr\u00f3b\u00e1ld magadt\u00f3l megval\u00f3s\u00edtani a k\u00f6vetkez\u0151t a ViewModel oszt\u00e1lyban (a <code>Person</code> oszt\u00e1ly marad v\u00e1ltozatlan): amikor a <code>NewPerson.Age</code> v\u00e1ltozik, akkor az <code>ObservableObject</code> \u0151sb\u0151l \u00f6r\u00f6k\u00f6lt <code>OnPropertyChanged</code> h\u00edv\u00e1s\u00e1val jelezz\u00fck a <code>IsDecrementEnabled</code> tulajdons\u00e1g v\u00e1ltoz\u00e1s\u00e1t. Tipp: a <code>Person</code> oszt\u00e1ly m\u00e1r rendelkezik <code>PropertyChanged</code> esem\u00e9nnyel, hiszen maga is megval\u00f3s\u00edtja az <code>INotifyPropertyChanged</code> interf\u00e9szt, erre az esem\u00e9nyre fel lehet iratkozni! Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben az nem zavar minket, ha az <code>IsDecrementEnabled</code> v\u00e1ltoz\u00e1s\u00e1t esetleg akkor is jelezz\u00fck, ha tulajdonk\u00e9pen \"logikailag\" estleg nem is v\u00e1ltozik.</li> <li>A fentieket k\u00fcl\u00f6n esem\u00e9nykezel\u0151 f\u00fcggv\u00e9ny bevezet\u00e9se n\u00e9lk\u00fcl is meg lehet oldani (tipp: esem\u00e9nykezel\u0151 megad\u00e1sa lambda kifejez\u00e9ssel).</li> </ul> <p>Teszteld is a megold\u00e1sod! Ha j\u00f3l dolgozt\u00e1l, a gombnak akkor is le kell tilt\u00f3dnia, ha a TextBoxba k\u00e9zzel \u00edrsz be negat\u00edv \u00e9letkor \u00e9rt\u00e9ket (\u00e9s ut\u00e1na kikattintasz a TextBoxb\u00f3l). Gondold \u00e1t, mi\u00e9rt van ez \u00edgy!</p> <p>A \"+\" gombra \u00e9s a \"+Add\" gomra is dolgozz ki hasonl\u00f3 megold\u00e1st!</p> <ul> <li>Az \u00e9letkor maxim\u00e1lis \"elfogadhat\u00f3\" \u00e9rt\u00e9ke 150 legyen.</li> <li>A n\u00e9v csak akkor elfogadhat\u00f3, ha van benne legal\u00e1bb egy nem whitespace karakter (ez ut\u00f3bbi ellen\u0151rz\u00e9s\u00e9re a string oszt\u00e1ly <code>IsNullOrWhiteSpace</code> statikus m\u0171velet\u00e9t haszn\u00e1ld).</li> <li>Azzal az esettel nem kell foglalkozni, hogy ha a felhaszn\u00e1l\u00f3 az \u00e9letkor TextBox-ba nem \u00e9rv\u00e9nyes sz\u00e1mot \u00edr be (ezt jelen megold\u00e1ssal nem is lehet kezelni).</li> </ul> <p>A tesztel\u00e9s sor\u00e1n azt tapasztaljuk, hogy ha pl. kit\u00f6r\u00f6lj\u00fck a nevet a n\u00e9v TextBox-ban, a \"+Add\" gomb \u00e1llapota nem azonnal v\u00e1ltozik, hanem csak ha elhagyjuk a TextBox-ot? Mi\u00e9rt van ez? M\u00f3dos\u00edtsd a megold\u00e1sod, hogy ez minden sz\u00f6veg v\u00e1ltoz\u00e1skor, a TextBox elhagy\u00e1sa n\u00e9lk\u00fcl is megt\u00f6rt\u00e9njen. Tipp: l\u00e1sd el\u0151ad\u00e1sanyag \"x:Bind mikor friss\u00fcl az adat?\" c\u00edm\u0171 dia.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>f3.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>az \u00e9letkor legyen 0-ra lecs\u00f6kkentve az alkalmaz\u00e1sban,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>PersonListPageViewModel.cs</code> megnyitva.</li> </ul>"},{"location":"hazi/5-mvvm/#feladat-4-command-hasznalata","title":"Feladat 4 - Command haszn\u00e1lata","text":"<p>Jelen pillanatban a \"-\" gomb vonatkoz\u00e1s\u00e1ban eset\u00e9ben k\u00e9t feladatunk van:</p> <ul> <li>A <code>Click</code> eset\u00e9n az esem\u00e9nykezel\u0151 m\u0171velet futtat\u00e1sa</li> <li>A gomb tilt\u00e1sa/enged\u00e9lyez\u00e9se az <code>IsEnabled</code> tulajdons\u00e1g seg\u00edts\u00e9g\u00e9vel</li> </ul> <p>Bizonyos vez\u00e9rl\u0151k - ilyen a gomb is - t\u00e1mogatj\u00e1k, hogy ezt a kett\u0151t, a Command mint\u00e1ra \u00e9p\u00edtve, egy parancs objektum seg\u00edts\u00e9g\u00e9vel adhassuk meg. A  Command tervez\u00e9si minta koncepci\u00f3j\u00e1val a \"Tervez\u00e9si mint\u00e1k 3\" el\u0151ad\u00e1s alapj\u00e1n lehet r\u00e9sztelesebben megismerkedni (b\u00e1r ott csak az alap Command mint\u00e1val ismerkedt\u00fcnk meg, mely a parancs futtat\u00e1s\u00e1t t\u00e1mogatja, tilt\u00e1s\u00e1t/enged\u00e9lyez\u00e9s\u00e9t nem). A Command minta MVVM specifikus megval\u00f3s\u00edt\u00e1s\u00e1val a WinUI el\u0151ad\u00e1ssorozat v\u00e9ge fel\u00e9, a \"Command minta\" c\u00edm\u0171 di\u00e1t\u00f3l kezdve lehet megismerkedni.</p> <p>Az alapelv a k\u00f6vetkez\u0151: a gombn\u00e1l a <code>Click</code> \u00e9s <code>IsEnabled</code> \"megad\u00e1sa\" helyett a gomb <code>Command</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtjuk egy <code>ICommand</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 command objektumra. A futtat\u00e1s, illetve tilt\u00e1s/enged\u00e9lyez\u00e9s m\u00e1r ezen command objektum feladata.</p> <p>Alapesetben egy alkalmaz\u00e1sban minden parancshoz egy k\u00fcl\u00f6n <code>ICommand</code> implement\u00e1ci\u00f3t kellene k\u00e9sz\u00edteni. Ez azonban sok parancs eset\u00e9n sok oszt\u00e1ly bevezet\u00e9s\u00e9t ig\u00e9nyli. Az MVVM Toolkit ebben is a seg\u00edts\u00e9g\u00fcnkre siet. Biztos\u00edt egy <code>RelayCommand</code> oszt\u00e1lyt, mely megval\u00f3s\u00edtja az <code>ICommand</code> interf\u00e9szt. Ez az oszt\u00e1ly b\u00e1rmilyen parancs/k\u00f3d futtat\u00e1s\u00e1ra haszn\u00e1lhat\u00f3, \u00edgy nem kell tov\u00e1bbi command oszt\u00e1lyokat bevezetni. Hogyan lehets\u00e9ges ez? \u00dagy, hogy a <code>RelayCommand</code>-nak konstruktor param\u00e9terekben, k\u00e9t delegate form\u00e1j\u00e1ban tudjuk a v\u00e9grehajt\u00e1shoz \u00e9s a tilt\u00e1shoz/enged\u00e9lyez\u00e9shez tartoz\u00f3k k\u00f3dot:</p> <ul> <li>Els\u0151 param\u00e9terben a parancs futtat\u00e1sakor v\u00e9grehajtand\u00f3 k\u00f3dot adjuk meg.</li> <li>M\u00e1sodik param\u00e9terben (ez opcion\u00e1lis) azt a k\u00f3dot, melyet a command h\u00edv annak ellen\u0151rz\u00e9s\u00e9re, hogy enged\u00e9lyezni/tiltani kell mag\u00e1t (az itt megadott f\u00fcggv\u00e9nynek  bool-lal kell visszat\u00e9rnie, true esetben enged\u00e9lyezett lesz a parancs).</li> </ul> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a \"-\" gomb kezel\u00e9s\u00e9t alak\u00edtjuk \u00e1t command alap\u00fara. El\u0151sz\u00f6r pr\u00f3b\u00e1ld a nagyj\u00e1t \u00f6n\u00e1ll\u00f3an megval\u00f3s\u00edtani a kapcsol\u00f3d\u00f3 WinUI el\u0151ad\u00e1sanyag alapj\u00e1n. A parancs futtat\u00e1sa egyszer\u0171bb, de a parancs tilt\u00e1s-enged\u00e9lyez\u00e9shez lesz m\u00e9g teend\u0151nk. F\u0151bb l\u00e9p\u00e9sek:</p> <ul> <li>Egy csak getterrel rendelkez\u0151 publikus <code>RelayCommand</code> tulajdons\u00e1g felv\u00e9tele a ViewModel-be, pl. <code>DecreaseAgeCommand</code> n\u00e9ven. Az el\u0151ad\u00e1sanyaggal ellent\u00e9tben eset\u00fcnkben nem kell a <code>RelayCommand</code>-nak generikus param\u00e9tert megadni, mert a parancskezel\u0151 f\u00fcggv\u00e9ny\u00fcnknek (<code>DecreaseAge</code>) nincs param\u00e9tere.</li> <li>Az \u00fajonnan bevezetett tulajdons\u00e1gnak a ViewModel konstruktorban \u00e9rt\u00e9ket adni. A <code>RelayCommand</code> konstruktor param\u00e9tereit add meg megfelel\u0151en.</li> <li>A <code>PersonListPage.xaml</code>-ben a \"-\" gombn\u00e1l a <code>Click</code> \u00e9s <code>IsEnabled</code> adatk\u00f6t\u00e9s\u00e9re nincs m\u00e1r sz\u00fcks\u00e9g, ezek t\u00f6rlend\u0151k. Helyette a gomb <code>Command</code> tulajdons\u00e1g\u00e1t k\u00f6sd a ViewModel-ben az el\u0151z\u0151 l\u00e9p\u00e9sben bevezetett <code>DecreaseAgeCommand</code> tulajdons\u00e1ghoz.</li> </ul> <p>Ha kipr\u00f3b\u00e1ljuk, a parancs futtat\u00e1s m\u0171k\u00f6dik, a tilt\u00e1s/enged\u00e9lyez\u00e9s viszont m\u00e9g nem: ha j\u00f3l megfigyelj\u00fck, a gomb mindig enged\u00e9lyezett marad megjelen\u00e9s\u00e9ben. Ennek, kicsit jobban belegondolva, logikus oka van: a <code>RelayCommand</code> meg tudja ugyan h\u00edvni a m\u00e1sodik konstruktor param\u00e9ter\u00e9ben megadott m\u0171veletet az \u00e1llapot ellen\u0151rz\u00e9s\u00e9hez, de nem tudja, hogy minden <code>NewPerson.Age</code> v\u00e1ltoz\u00e1skor meg kellene ezt tennie! Ezen tudunk seg\u00edteni. A ViewModel-\u00fcnk konstruktor\u00e1ban m\u00e1r feliratkoztunk kor\u00e1bban a <code>NewPerson.PropertyChanged</code> esem\u00e9nyre: erre \u00e9p\u00edtve, amikor v\u00e1ltozik az \u00e9letkor (vagy amikor v\u00e1ltozhat, az nem probl\u00e9ma, ha n\u00e9ha feleslegesen megtessz\u00fck) h\u00edvd meg a <code>DecreaseAgeCommand</code> <code>NotifyCanExecuteChanged</code> m\u0171velet\u00e9t. Ennek a m\u0171veletnek nagyon besz\u00e9des neve van: \u00e9rtes\u00edti a parancsot, hogy megv\u00e1ltoz(hat)ott azon \u00e1llapot, mely alapj\u00e1n a parancs tiltott/enged\u00e9lyezett \u00e1llapota \u00e9p\u00edt. \u00cdgy a parancs friss\u00edteni fogja mag\u00e1t, pontosabban a parancshoz tartoz\u00f3 gomb \u00e1llapot\u00e1t.</p> <p>\u00cdrd \u00e1t \"+\" gomb kezel\u00e9s\u00e9t is hasonl\u00f3an, parancs alap\u00fara! A \"+Add\" gomb kezel\u00e9s\u00e9t ne v\u00e1ltoztasd meg!</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>f4.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a n\u00e9v TextBox legyen \u00fcres az alkalmaz\u00e1sban,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>PersonListPageViewModel.cs</code> megnyitva.</li> </ul>"},{"location":"hazi/5-mvvm/#feladat-5-command-hasznalata-mvvm-toolkit-alapu-kodgeneralassal","title":"Feladat 5 - Command haszn\u00e1lata MVVM Toolkit alap\u00fa k\u00f3dgener\u00e1l\u00e1ssal","text":"<p>Az el\u0151z\u0151 feladatban a command tulajdons\u00e1gok bevezet\u00e9s\u00e9t \u00e9s azok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t \"manu\u00e1lisan\" oldottuk meg. Az MVVM Toolkit ezt le tudja egyszer\u0171s\u00edteni: megfelel\u0151 attrib\u00fatum alkalmaz\u00e1sa eset\u00e9n a tulajdons\u00e1got \u00e9s a p\u00e9ld\u00e1nyos\u00edt\u00e1st automatikusan le tudja gener\u00e1lni.</p> <p>Alak\u00edtsuk \u00e1t a <code>DecreaseAgeCommand</code> kezel\u00e9s\u00e9t (csak ezt, az <code>IncreaseAgeCommand</code> maradjon!) gener\u00e1lt k\u00f3d alap\u00fara:</p> <ol> <li>L\u00e1sd el a <code>PersonListPageViewModel</code> oszt\u00e1lyt a <code>partial</code> kulcssz\u00f3val.</li> <li>T\u00f6r\u00f6ld ki a <code>DecreaseAgeCommand</code> tulajdons\u00e1got \u00e9s ennek p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t a konstruktorb\u00f3l.</li> <li>A <code>DecreaseAge</code> m\u0171veletet l\u00e1sd el ezzel az attrib\u00fatummal: <code>[RelayCommand(CanExecute = nameof(IsDecrementEnabled))]</code>. <ul> <li>Ennek hat\u00e1s\u00e1ra a k\u00f3dgener\u00e1tor bevezet egy <code>RelayCommand</code> tulajdons\u00e1got az oszt\u00e1lyban, melynek neve a m\u0171velet\u00fcnk neve (<code>DecreaseAge</code>), hozz\u00e1f\u0171zve a \"Command\" stringet. Ezzel meg is kapjuk a kor\u00e1bban k\u00e9zzel bevezetett <code>DecreaseAgeCommand</code> nev\u0171 tulajdons\u00e1got.</li> <li>A <code>CanExecute</code> attrib\u00fatum tulajdons\u00e1gban egy string form\u00e1ban annak a boollal visszat\u00e9r\u0151 m\u0171veletnek vagy tulajdons\u00e1gnak a nev\u00e9t lehet megadni, melyet a gener\u00e1lt k\u00f3d a parancs tilt\u00e1s\u00e1nak/enged\u00e9lyez\u00e9s\u00e9nek sor\u00e1n haszn\u00e1l (a RelayCommand konstruktor m\u00e1sodik param\u00e9tere lesz). Nek\u00fcnk m\u00e1r van ilyen tulajdons\u00e1gunk, \"IsDecrementEnabled\" n\u00e9vben. Az\u00e9rt nem egyszer\u0171 string form\u00e1j\u00e1ban adjuk meg, mert ha ut\u00f3lag valaki \u00e1tnevezi az <code>IsDecrementEnabled</code> m\u0171veletet, akkor a mostani \"IsDecrementEnabled\" m\u00e1r nem j\u00f3 m\u0171veletre mutatna. A <code>nameof</code> kifejez\u00e9s haszn\u00e1lat\u00e1val ez a probl\u00e9ma elker\u00fclhet\u0151. A <code>CanExecute</code> megad\u00e1sa \u00e1ltal\u00e1noss\u00e1g\u00e1ban nem k\u00f6telez\u0151 (nem adjuk meg, ha nem akarjuk a parancsot soha tiltani).</li> </ul> </li> </ol> <p>Teszteld a megold\u00e1st (\u00e9letkor cs\u00f6kkent\u00e9se), ugyan\u00fagy kell m\u0171k\u00f6dnie, mint kor\u00e1bban.</p> <p>BEADAND\u00d3</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151ment\u00e9st <code>f5.png</code> n\u00e9ven az al\u00e1bbiak szerint:</p> <ul> <li>Ind\u00edtsd el az alkalmaz\u00e1st. Ha sz\u00fcks\u00e9ges, m\u00e9retezd \u00e1t kisebbre, hogy ne foglaljon sok helyet a k\u00e9perny\u0151n,</li> <li>a \u201eh\u00e1tt\u00e9rben\u201d a Visual Studio legyen, a <code>PersonListPageViewModel.cs</code> megnyitva.</li> </ul>"},{"location":"hazi/5-mvvm/#feladat-6-strict-mvvm","title":"Feladat 6 - Strict MVVM","text":"<p>Jelen megold\u00e1sunk a Relaxed MVVM megk\u00f6zel\u00edt\u00e9st k\u00f6veti. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben \u00e1tgondoljuk, mit is jelent ez pontosan, \u00e9s mit jelentene a Strict MVVM megk\u00f6zel\u00edt\u00e9sre val\u00f3 \u00e1t\u00e1ll\u00e1s (megval\u00f3s\u00edtani nem fogjuk).</p> <p>Jelen megold\u00e1sunk a Relaxed MVVM megk\u00f6zel\u00edt\u00e9st k\u00f6veti, vagyis a View-ban k\u00f6zvetlen\u00fcl a <code>Person</code> modell oszt\u00e1lyhoz adatk\u00f6t\u00fcnk (\u00e9s a <code>PersonPageViewModel</code>-ben is a <code>Person</code> modell oszt\u00e1lyt haszn\u00e1ljuk). Ennek el\u0151nye az egyszer\u0171s\u00e9g. De van egy h\u00e1tr\u00e1nya is: a <code>Person</code> modell oszt\u00e1lyunkban k\u00e9nytelenek voltunk megval\u00f3s\u00edtani az <code>INotifyPropertyChanged</code> interf\u00e9szt (m\u00e9gha az MVVM toolkit seg\u00edts\u00e9g\u00e9vel is), k\u00fcl\u00f6nben nem m\u0171k\u00f6dne j\u00f3l az adatk\u00f6t\u00e9s. Vannak olyan helyzetek, amikor a modell oszt\u00e1lyunkat nem szeretn\u00e9nk ilyen, n\u00e9mik\u00e9ppen m\u00e1r a fel\u00fcletet kiszolg\u00e1l\u00f3 logik\u00e1val \"szennyezni\", hanem a lehet\u0151 legtiszt\u00e1bb form\u00e1ban szeretn\u00e9nk a modell oszt\u00e1lyunkat tartani. Ekkor a Strict MVVM megk\u00f6zel\u00edt\u00e9s jelenti a megold\u00e1st (l\u00e1sd \"Strict MVVM \u2013 be\u00e1gyaz\u00e1s\" el\u0151ad\u00e1sdia). Mit jelentene ez a sz\u00e1munkra, mit kellene a k\u00f3don v\u00e1ltoztatni? Gondold \u00e1t az el\u0151ad\u00e1sdia alapj\u00e1n a sz\u00fcks\u00e9ges v\u00e1ltoztat\u00e1sokat! Megval\u00f3s\u00edtani/dokument\u00e1lni nem kell, ez csak egy \u00e1tgondol\u00f3s feladat \ud83d\ude0a!</p> Strict MVVM alap\u00fa megold\u00e1s <ul> <li>A <code>Person</code> modell oszt\u00e1lyban m\u00e1r nem val\u00f3s\u00edtan\u00e1nk meg az <code>INotifyPropertyChanged</code> interf\u00e9szt, az oszt\u00e1ly leegyszer\u0171s\u00f6dik, csak egyszer\u0171 tulajdons\u00e1gokat tartalmazna (ez volt a c\u00e9l).</li> <li>Be kellene vezetni egy <code>PersonViewModel</code> oszt\u00e1lyt (mely egy <code>Person</code> modell objektumot csomagolna be). Ebben:<ul> <li>Be kellene vezetni a <code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1gokat. </li> <li>Meg kellene val\u00f3s\u00edtani az <code>INotifyPropertyChanged</code> interf\u00e9szt:<ul> <li><code>ObservableObject</code> sz\u00e1rmaztat\u00e1s</li> <li>A tulajdons\u00e1gok setter\u00e9ben a <code>SetProperty</code> \u0151sb\u0151l \u00f6r\u00f6k\u00f6lt seg\u00e9df\u00fcggv\u00e9ny haszn\u00e1lata (hogy kiv\u00e1lt\u00f3djon a <code>PropertyChanged</code> esem\u00e9ny)</li> </ul> </li> </ul> </li> <li>A Viewhoz tartoz\u00f3 <code>PersonPageViewModel</code>-\u00fcnket \u00e1t kellene alak\u00edtani, hogy ne a <code>Person</code> modell, hanem az \u00faj <code>PersonViewModel</code>-t haszn\u00e1lja.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/","title":"5. HF - Verwendung der MVVM-Vorlage und des MVVM-Toolkits","text":""},{"location":"hazi/5-mvvm/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Bei den Hausaufgaben 3. Wir werden die im XAML-Labor implementierte Anwendung zur Personenregistrierung so anpassen, dass sie auf dem MVVM-Template basiert, und wir werden das MVVM-Toolkit kennenlernen.</p> <p>Die eigenst\u00e4ndige \u00dcbung baut auf dem MVVM-Thema auf, das am Ende der WinUI-Vorlesungsreihe behandelt wurde. Hinweis: Labor 5 - MVVM-Labor ist sehr abwechslungsreich und zeigt neben vielen anderen Themen ein Beispiel f\u00fcr das MVVM-Pattern im Kontext einer komplexeren Anwendung. Die vorliegende Hausaufgabe ist fokussierter, in kleineren Schritten aufgebaut: In unserem Fall ist es die L\u00f6sung der vorliegenden Hausaufgabe, die Ihnen helfen wird, die verwandten Teile von Lab 5 - MVVM zu verstehen.</p> <p>Durch das Durcharbeiten des zugeh\u00f6rigen Vorlesungsmaterials k\u00f6nnen die Aufgaben dieser eigenst\u00e4ndigen \u00dcbung mit Hilfe der k\u00fcrzeren Leitf\u00e4den, die auf die Aufgabenbeschreibung folgen (manchmal standardm\u00e4\u00dfig eingefaltet), selbst\u00e4ndig bearbeitet werden.</p> <p>Das Ziel der unabh\u00e4ngigen \u00dcbung:</p> <ul> <li>\u00dcben Sie die Verwendung der MVVM-Vorlage</li> <li>NuGet-Referenzen verwenden</li> <li>Kennenlernen der Grundlagen des MVVM-Toolkits</li> <li>\u00dcben von XAML-Techniken</li> </ul> <p>Die erforderliche Entwicklungsumgebung wird hier beschrieben, identisch mit Hausaufgabe 3 (XAML-Grundlagen).</p>"},{"location":"hazi/5-mvvm/index_ger/#das-verfahren-fur-die-einreichung","title":"Das Verfahren f\u00fcr die Einreichung","text":"<ul> <li>Der grundlegende Prozess ist derselbe wie zuvor. Erstellen Sie mit GitHub Classroom ein Repository f\u00fcr sich selbst. Sie finden die Einladungs-URL in Moodle (Sie k\u00f6nnen sie sehen, indem Sie auf den Link*\"GitHub classroom links for homework*\" auf der Startseite des Fachs klicken). Es ist wichtig, dass Sie die richtige Einladungs-URL f\u00fcr diese Hausaufgabe verwenden (jede Hausaufgabe hat eine andere URL). Klonen Sie das resultierende Repository. Dazu geh\u00f6rt auch die erwartete Struktur der L\u00f6sung. Nachdem Sie die Aufgaben erledigt haben, \u00fcbergeben Sie Ihre L\u00f6sung alt und dr\u00fccken Sie sie alt.</li> <li>Um mit den geklonten Dateien zu arbeiten, \u00f6ffnen Sie <code>HelloXaml.sln</code>.</li> <li> In den \u00dcbungen werden Sie aufgefordert, einen Screenshot von einem Teil Ihrer L\u00f6sung zu machen, da dies beweist, dass Sie Ihre L\u00f6sung selbst erstellt haben. **Der erwartete Inhalt der Screenshots ist immer in der Aufgabe angegeben. **Die Screenshots sollten als Teil der L\u00f6sung eingereicht werden, legen Sie sie in den Stammordner Ihres Repositorys (neben neptun.txt). Die Screenshots werden dann zusammen mit dem Inhalt des Git-Repositorys auf GitHub hochgeladen. Da das Repository privat ist, ist es f\u00fcr niemanden au\u00dfer den Ausbildern sichtbar. Wenn Sie Inhalte im Screenshot haben, die Sie nicht hochladen m\u00f6chten, k\u00f6nnen Sie diese aus dem Screenshot ausblenden.</li> <li> Diese Aufgabe enth\u00e4lt keinen sinnvollen Pre-Checker: Sie wird nach jedem Push ausgef\u00fchrt, pr\u00fcft aber nur, ob neptun.txt gef\u00fcllt ist. Die inhaltliche \u00dcberpr\u00fcfung wird von den Laborleitern nach Ablauf der Frist durchgef\u00fchrt.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/#verbindungen","title":"Verbindungen","text":"<p> Obligatorische Verwendung des MVVM-Beispiels!   In dieser Hausaufgabe \u00fcben wir das MVVM-Pattern, daher ist das MVVM-Pattern f\u00fcr die L\u00f6sung der Aufgaben zwingend erforderlich. Andernfalls wird die Bewertung der Aufgaben verweigert.</p>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-0-uberblick-uber-den-ausgangszustand","title":"Aufgabe 0 - \u00dcberblick \u00fcber den Ausgangszustand","text":"<p>Der Ausgangszustand ist im Grunde derselbe wie bei 3. Gestaltung der Benutzeroberfl\u00e4che im Endzustand von.  Mit anderen Worten, eine Anwendung zur Erfassung der Details von Personen in einer Liste.  Enth\u00e4lt eine geringf\u00fcgige \u00c4nderung gegen\u00fcber dem endg\u00fcltigen Zustand des Labors. Im Labor war die vollst\u00e4ndige Beschreibung der Schnittstelle unter <code>MainWindow.xaml</code> (und die zugeh\u00f6rige Code-Behind-Datei) verf\u00fcgbar. Der Unterschied zu dieser urspr\u00fcnglichen L\u00f6sung besteht darin, dass sie nach <code>PersonListPage.xaml</code> (und in den Code dahinter) im Ordner <code>Views</code> verschoben wurde.  <code>PersonListPage</code> ist keine <code>Window</code>, sondern eine von <code>Page</code> abgeleitete Klasse (siehe den Code hinter der Datei). Aber sonst hat sich nichts ge\u00e4ndert! Wie der Name schon sagt, stellt <code>Page</code> eine \"Seite\" in der Anwendung dar: Sie kann nicht selbst angezeigt werden, sondern muss z. B. in einem Fenster platziert werden. Der Vorteil dieses Fensters ist, dass es m\u00f6glich ist, zwischen den Seiten (verschiedene <code>Page</code> Nachkommen) zu navigieren, indem man die entsprechende Navigation verwendet. Wir werden das nicht ausnutzen, wir werden nur eine Seite haben. Der Zweck der Einf\u00fchrung dieser Seite war nur zu veranschaulichen, dass in der MVVM-Architektur, Ansichten k\u00f6nnen nicht nur mit <code>Window</code> (full window), sondern auch mit Objekten wie <code>Page</code> implementiert werden. </p> <p>Da alles von <code>MainWindow</code>nach <code>PersonListPage</code>verschoben wurde, gibt es auf <code>MainWindow.xaml</code>nichts anderes als eine Kopie eines solchen <code>PersonListPage</code> Objekts:</p> <pre><code>&lt;views:PersonListPage/&gt;\n</code></pre> <p>Pr\u00fcfen Sie im Code, ob dies tats\u00e4chlich der Fall ist!</p>"},{"location":"hazi/5-mvvm/index_ger/#kopfzeile-des-hauptfensters","title":"Kopfzeile des Hauptfensters","text":"<p> Die \u00dcberschrift des Hauptfensters sollte \"MVVM\" lauten, angeh\u00e4ngt mit Ihrem Neptun-Code: (z.B. \"ABCDEF\" im Falle des Neptun-Codes \"MVVM - ABCDEF\"), ist es wichtig, dass dies der Text ist! Setzen Sie dazu die Eigenschaft <code>Title</code> Ihres Hauptfensters auf diesen Text in der Datei <code>MainWindow.xaml</code>. </p>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-1-verwendung-des-mvvm-toolkits","title":"Aufgabe 1 - Verwendung des MVVM-Toolkits","text":"<p>In der bestehenden Anwendung implementiert die Klasse <code>Person</code> im Ordner <code>Models</code> bereits die Schnittstelle <code>INotifyPropertyChanged</code> (Spitzname INPC) (sie hat also ein Ereignis <code>PropertyChanged</code> ) und zeigt au\u00dferdem eine Eigenschafts\u00e4nderung in den Settern <code>Name</code> und <code>Age</code> an, indem sie das Ereignis <code>PropertyChanged</code> ausl\u00f6st (siehe <code>Person.cs</code> f\u00fcr eine detaillierte Betrachtung).</p> <p>Zum Aufw\u00e4rmen/Wiederholen - nachdem Sie sich den Code (<code>PersonListPage.xaml</code> und <code>PersonListPage.xaml.cs</code>) genau angesehen und die Anwendung ausgef\u00fchrt haben - sagen Sie sich, warum dies in der Anwendung erforderlich war!</p> Die Antwort (Wiederholung) <p>In der Anwendung ist die Eigenschaft <code>Text</code> von <code>TextBox</code>in <code>PersonListPage.xaml</code>(dies ist die Zieleigenschaft) an die Eigenschaften <code>Age</code> und <code>Name</code> des Tags <code>NewPerson</code> <code>Person</code> im Code hinter und gebunden (dies sind die Quellen in den beiden Datenbindungen). Beachten Sie im Code, dass die Quelleneigenschaften <code>NewPerson.Name</code> und <code>NewPerson.Age</code> ebenfalls im Code ge\u00e4ndert werden: Der Controller kann nur \u00fcber diese \u00c4nderungen informiert werden (und somit mit der Quelle synchron bleiben), wenn er \u00fcber diese \u00c4nderungen an <code>Name</code> und <code>Age</code> informiert wird. Aus diesem Grund muss die Klasse, die die Eigenschaften <code>Age</code> und <code>Name</code> enth\u00e4lt, d.h. <code>Person</code>, die Schnittstelle <code>INotifyPropertyChanged</code> implementieren und das Ereignis <code>PropertyChanged</code> ausl\u00f6sen, wenn sich die Eigenschaften \u00e4ndern, wobei das Ereignis entsprechend parametrisiert sein muss.</p> <p>Wenn Sie die Anwendung ausf\u00fchren, \u00fcberpr\u00fcfen Sie, ob die \u00c4nderungen, die Sie auf <code>NewPerson.Age</code> durch Dr\u00fccken der Schaltfl\u00e4chen \"+\" und \"-\" vornehmen, tats\u00e4chlich in der <code>TextBox</code>, die das Alter anzeigt, wiedergegeben werden. </p> <p>In der Klasse <code>Person</code> k\u00f6nnen Sie sehen, dass die Implementierung von <code>INotifyPropertyChanged</code> und der dazugeh\u00f6rige Code recht umfangreich ist. Schauen Sie sich die Vorlesungsunterlagen an, um zu sehen, welche Alternativen es f\u00fcr die Implementierung der Schnittstelle gibt (ausgehend von der Folie \"INPC Beispiel 1\", etwa vier Folien zur Veranschaulichung der vier M\u00f6glichkeiten) Die kompakteste L\u00f6sung ist das MVVM-Toolkit. Im n\u00e4chsten Schritt werden wir die derzeitige umfangreichere \"manuelle\" INPC-Implementierung in ein MVVM-Toolkit umwandeln.</p>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-1a-mvvm-toolkit-nuget-referenzaufnahme","title":"Aufgabe 1/a - MVVM Toolkit NuGet Referenzaufnahme","text":"<p>Zun\u00e4chst muss eine NuGet-Referenz auf das MVVM-Toolkit erstellt werden, damit es im Projekt verwendet werden kann. </p> <p>Aufgabe: F\u00fcgen Sie eine NuGet-Referenz f\u00fcr das NuGet-Paket \"CommunityToolkit.Mvvm\" in das Projekt ein. Auf dieser Visual Studio-Seite wird beschrieben, wie eine NuGet-Referenz mit dem NuGet Package Managerzu einem Projekt hinzugef\u00fcgt wird. Der vorhergehende Link auf der Seite f\u00fchrt Sie zum Abschnitt \"NuGet Package Manager\". Folgen Sie den vier hier angegebenen Schritten (mit dem Unterschied, dass Sie auf das Paket \"CommunityToolkit.Mvvm\" statt auf \"Newtonsoft.Json\" verweisen m\u00fcssen).</p> <p>Nachdem wir nun diese NuGet-Referenz zu unserem Projekt hinzugef\u00fcgt haben, wird der n\u00e4chste Build (da er einen NuGet-Wiederherstellungsschritt enth\u00e4lt!) das NuGet-Paket herunterladen, die darin enthaltenen DLLs in den Ausgabeordner entpacken und sie zu einem integralen Bestandteil der Anwendung machen (ein NuGet-Paket ist eigentlich eine Zip-Datei). Es ist wichtig zu beachten, dass weder die NuGet-Zipdatei noch die darin enthaltenen DLLs in Git enthalten sind. Sie werden von der Datei <code>.gitignore</code> im Stammverzeichnis der L\u00f6sung herausgefiltert. Dies ist der eigentliche Kern des NuGet-Konzepts: Das Repository kann klein bleiben, da die Projektdatei nur Verweise auf NuGet-Pakete enth\u00e4lt, und wenn jemand eine frisch geklonte L\u00f6sung erstellt, werden die referenzierten NuGet-Pakete erst dann aus den Online-NuGet-Ressourcen heruntergeladen.</p> <p> Die Kenntnis der oben genannten NuGet-Konzepte ist wichtig, sie sind ein wichtiger Teil des Lehrplans!</p> <p>Eine NuGet-Referenz ist eigentlich nur eine Zeile in der Projektbeschreibungsdatei <code>.csproj</code>.  Klicken Sie im Projektmappen-Explorer auf den Projektknoten \"HelloXaml\", \u00f6ffnen Sie die Projektdatei <code>.csproj</code> und \u00fcberpr\u00fcfen Sie, ob diese Zeile enthalten ist (die Version kann unterschiedlich sein):</p> <pre><code>    &lt;PackageReference Include=\"CommunityToolkit.Mvvm\" Version=\"8.2.2\" /&gt;\n</code></pre> <p>Sie k\u00f6nnen unsere NuGet-Referenz \u00fcberpr\u00fcfen, ohne die Datei <code>csproj</code> zu \u00f6ffnen: \u00d6ffnen Sie im Projektmappen-Explorer den Knoten \"HelloXaml\"/\"Abh\u00e4ngigkeiten\"/\"Pakete\": Wenn alles in Ordnung ist, sehen Sie darunter einen Knoten \"CommunityToolkit.Mvvm (Version)\".</p>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-1b-inpc-implementierung-auf-basis-des-mvvm-toolkits","title":"Aufgabe 1/b - INPC-Implementierung auf Basis des MVVM-Toolkits","text":"<p>Jetzt k\u00f6nnen wir die Klassen, Schnittstellen, Attribute usw. im MVVM Toolkit NuGet-Paket verwenden, so dass wir zur MVVM Toolkit-basierten INPC-Implementierung wechseln k\u00f6nnen.</p> <ul> <li>Kommentieren Sie die Klasse <code>Person</code> in ihrer Gesamtheit. </li> <li>F\u00fcgen Sie oberhalb des auskommentierten Teils die Klasse als neu hinzu, aber mit einer MVVM-Toolkit-basierten INPC-Implementierung.<ul> <li>Die Pr\u00e4sentation \"INPC Beispiel 4 - MVVM Toolkit\" wird Ihnen bei der Umsetzung helfen.</li> <li>Es muss sich um eine partielle Klasse handeln (d.h. Teile der Klasse k\u00f6nnen in mehreren Dateien definiert sein).</li> <li>Sie stammt von <code>ObservableObject</code>aus dem Toolkit: Dieser Vorg\u00e4nger implementiert die Schnittstelle <code>INotifyPropertyChanged</code>, so dass wir sie nicht mehr ben\u00f6tigen.</li> <li><code>Name</code> und <code>Age</code>, ersetzen Sie die Attribute <code>name</code> und <code>age</code> durch die Attribute <code>ObservableProperty</code>. </li> </ul> </li> </ul> <p>Jetzt geht's los.</p> \u00dcberpr\u00fcfen Sie die L\u00f6sung <p>```` csharp public partial class Person : ObservableObject {     [ObservableProperty]     private string name;</p> <pre><code>[ObservableProperty]\nprivate int Alter;\n</code></pre> <p>} ```</p> <p>Dieser Code ergibt nach einer \u00dcbersetzung im Wesentlichen die gleiche L\u00f6sung wie die fr\u00fchere, viel ausf\u00fchrlichere und jetzt auskommentierte Form. Das hei\u00dft (auch wenn wir es noch nicht sehen), es werden die Eigenschaften <code>Name</code> und <code>Age</code> erstellt, mit entsprechenden <code>PropertyChanged</code> Ereignisausl\u00f6sern. Wie ist das m\u00f6glich? </p> <ul> <li>Zum einen implementiert der Vorfahre <code>ObservableObject</code> bereits die Schnittstelle <code>INotifyPropertyChanged</code>, enth\u00e4lt also auch das Ereignis-Tag <code>PropertyChanged</code>, das durch Ableitung an unsere Klasse \"vererbt\" wird.</li> <li>W\u00e4hrend der Kompilierung wird der MVVM-Toolkit-Codegenerator ausgef\u00fchrt, der f\u00fcr jede Membervariable mit dem Attribut <code>ObservableProperty</code> in der Klasse eine Eigenschaft mit dem gleichen Namen, aber mit einem Gro\u00dfbuchstaben beginnend, erzeugt, die unter den richtigen Bedingungen und mit den richtigen Parametern das Ereignis <code>PropertyChanged</code> ausl\u00f6st. Hurra, wir m\u00fcssen diesen Code nicht schreiben.</li> <li>Die Frage ist, wo dieser Code generiert wird. In einem anderen \"partiellen\" Teil unserer Klasse. Nach einer \u00dcbersetzung in Visual Studio klicken Sie mit der rechten Maustaste auf den Klassennamen <code>Person</code> und w\u00e4hlen im Popup-Men\u00fc \"Go to Definition\". In einem unteren Fenster erhalten wir zwei Ergebnisse: das eine ist der Code, den wir oben geschrieben haben, das andere (\"public class Person\") springt nach einem Doppelklick zum generierten Teil des Codes: Sie sehen, dass der Code-Generator einen relativ ausf\u00fchrlichen Code generiert hat, aber was f\u00fcr uns wichtig ist, ist, dass die Eigenschaften <code>Name</code> und <code>Age</code> hier stehen, darunter - unter anderem - die Eigenschaft <code>OnPropertyChanged</code>. </li> </ul> <p> Der Code-Generator arbeitet in der Regel in der anderen \"partiellen\" H\u00e4lfte unserer Klasse, um den von uns geschriebenen und den von uns generierten Code nicht zu verwechseln! Teilklassen werden am h\u00e4ufigsten verwendet, um handgeschriebenen Code von generiertem Code zu \"trennen\".</p> <p>Da viel weniger Code geschrieben werden muss, verwenden wir in der Praxis die auf dem MVVM-Toolkit basierende L\u00f6sung (aber Sie m\u00fcssen auch die manuelle L\u00f6sung kennen, damit Sie verstehen k\u00f6nnen, was hinter den Kulissen geschieht).</p> <p>SUBMITTER</p> <p>Machen Sie einen Screenshot von <code>f1b.png</code> wie folgt:</p> <ul> <li>Starten Sie die App. Verkleinern Sie sie gegebenenfalls, damit sie nicht zu viel Platz auf dem Bildschirm einnimmt,</li> <li>im \"Hintergrund\" sollte Visual Studio mit \"Person.cs\" ge\u00f6ffnet sein.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-2-migration-zu-einer-mvvm-basierten-losung","title":"Aufgabe 2 - Migration zu einer MVVM-basierten L\u00f6sung","text":"<p>Im vorherigen Schritt haben wir zwar das MVVM-Toolkit verwendet, sind aber noch nicht zu einer MVVM-basierten L\u00f6sung \u00fcbergegangen (das Toolkit wurde nur f\u00fcr eine einfachere Implementierung von INPC verwendet). </p> <p>Im Folgenden werden wir die Architektur unserer Anwendung so anpassen, dass sie dem MVVM-Konzept folgt. Wir bauen auf dem MVVM-Toolkit auf, um die Implementierung zu erleichtern.</p> <p>Aufgabe: Arbeiten Sie das entsprechende Vorlesungsmaterial durch (am Ende des WinUI-Abschnitts):</p> <ul> <li>Verstehen der grundlegenden Konzepte des MVVM-Musters.</li> <li>Der vollst\u00e4ndige Code f\u00fcr die Beispiele in den Folien ist im Ordner \"04-05 WinUIDancerProfiles\" (\"RelaxedMVVM\" und \"StrictMVVM\") im Slideshow GitHub Repository verf\u00fcgbar und kann Ihnen helfen, die \u00dcbungen sp\u00e4ter zu verstehen und zu l\u00f6sen. </li> </ul> <p>Was bedeutet das MVVM Beispiel f\u00fcr unser Beispiel:</p> <ul> <li>Die Modellklasse ist die Klasse <code>Person</code> im Ordner <code>Models</code>, die die Daten einer Person repr\u00e4sentiert (sie enth\u00e4lt KEINE UI-Logik und ist unabh\u00e4ngig von einer Anzeige).</li> <li>Im Moment sind alle Beschreibungen/Logiken im Zusammenhang mit der Visualisierung in <code>PersonListPage</code>. :Ausrufezeichen: Die derzeitige Website <code>PersonListPage</code>wird in zwei Teile aufgeteilt:<ul> <li><code>PersonListPage.xaml</code> und der dahinter liegende Code wird die Ansicht sein.</li> <li>Wir f\u00fchren ein ViewModel f\u00fcr <code>PersonListPage</code>mit dem Namen <code>PersonListPageViewModel</code> ein.<ul> <li> Wichtigster Punkt: Die gesamte Anzeigelogik wird von <code>PersonListPage</code> Code auf <code>PersonListPageViewModel</code>verlagert. Der Sinn des Musters ist, dass die View nur eine reine Beschreibung der Schnittstelle enth\u00e4lt, die Anzeigelogik befindet sich im ViewModel. </li> </ul> </li> </ul> </li> <li>Eine weitere S\u00e4ule des Musters: Unsere View enth\u00e4lt einen Verweis auf ihr ViewModel (in Form einer Eigenschaft).<ul> <li>In unserem Beispiel bedeutet dies, dass <code>PersonListPage</code>eine <code>PersonListPageViewModel</code> Eigenschaft haben muss. </li> <li> Dies ist von entscheidender Bedeutung, da wir in unserer <code>PersonListPage</code> xaml-Datei diese Eigenschaft verwenden k\u00f6nnen, um die Datenbindung an Eigenschaften und Ereignisbehandler zu implementieren, die in das ViewModel verschoben wurden! </li> </ul> </li> <li><code>PersonListPageViewModel</code> \"arbeitet\" das Modell und behandelt die Benutzerinteraktionen (Event-Handler).</li> <li>Da wir eher das Relaxed- als das Strict-MVVM-Muster verwenden, f\u00fchren wir keinen <code>PersonViewModel</code> -Wrapper mehr um unsere <code>Person</code> -Modellklasse herum ein.</li> </ul> <p>Aufgabe: \u00c4ndern Sie die bestehende Logik so, dass sie dem MVVM-Muster folgt und den oben genannten Grunds\u00e4tzen entspricht. Legen Sie die Klasse <code>PersonListPageViewModel</code> in einem neu erstellten Ordner <code>ViewModels</code> ab. Versuchen Sie, die L\u00f6sung mithilfe der obigen Hilfe selbst zu finden! Hier ist ein vorl\u00e4ufiger Hinweis, denn das ist schwieriger herauszufinden: Sie k\u00f6nnen auch Ereignisbehandler f\u00fcr Ereignisse durch Datenbindung angeben: siehe die Folie \"Bindung von Ereignissen und Funktionen\" (nach der Konvertierung ist dies die einzige M\u00f6glichkeit, Ereignisbehandler anzugeben). Es ist auch wichtig zu beachten, dass Daten nur an \u00f6ffentliche Eigenschaften/Operationen gebunden werden k\u00f6nnen, so dass auch dies ge\u00e4ndert werden muss!</p> Tipps/L\u00f6sungs-Back-Check <ol> <li><code>PersonListPage.xaml.cs</code> Code-Behind-Datei sollte von fast allem (au\u00dfer <code>this.InitializeComponent()</code> Aufruf im Konstruktor) in die neu eingef\u00fchrte <code>PersonListPageViewModel</code>verschoben werden, da es sich um UI-Logik handelt.</li> <li><code>PersonListPageViewModel</code> sollte eine \u00f6ffentliche Klasse sein.</li> <li>In den <code>PersonListPage</code> Code dahinter m\u00fcssen Sie eine automatisch implementierte Eigenschaft namens ViewModel vom Typ <code>PersonListPageViewModel</code> mit nur Getter einf\u00fcgen und diese auf ein neues Objekt initialisieren. Mit anderen Worten, die Ansicht erstellt und enth\u00e4lt das ViewModel!</li> <li>In <code>PersonListPage.xaml</code>m\u00fcssen die beiden Datenbindungen <code>TextBox</code> entsprechend ausgerichtet werden ( <code>NewPerson.Name</code> und <code>NewPerson.Age</code> sind jetzt eine Ebene tiefer verf\u00fcgbar, \u00fcber die ViewModel-Eigenschaft des dahinter liegenden Codes).</li> <li>In <code>PersonListPage.xaml</code>m\u00fcssen die Ereignisbehandler (<code>Click</code>) an drei Stellen ausgerichtet werden. Dies ist komplizierter. Die Event-Handler-Funktion kann nicht mehr mit der bisher verwendeten Syntax angegeben werden, da die Event-Handler nicht mehr im dahinter liegenden Code liegen (sie wurden in das ViewModel verschoben). <ul> <li>Event-Handler k\u00f6nnen f\u00fcr Ereignisse durch Datenbindung angegeben werden! Siehe Pr\u00e4sentationsfolie \"Binden von Ereignissen und Funktionen\". Das ist gut f\u00fcr uns, denn im Code hinter der ViewModel-Eigenschaft gibt es das <code>PersonListPageViewModel</code> -Objekt, das die Event-Handler enth\u00e4lt (<code>AddButton_Click</code>, <code>IncreaseButton_Click</code>, <code>DecreaseButton_Click</code>), diese m\u00fcssen als gebundene Eigenschaften in der Datenbindung angegeben werden (z.B. <code>ViewModel.AddButton_Click</code> usw.).</li> <li>Es ist wichtig, dass die Event-Handler-Funktionen \u00f6ffentlich sind, sonst funktioniert die Datenbindung nicht (muss von privat konvertiert werden).</li> </ul> </li> </ol> <p>Andere wichtige Konverter:</p> <ul> <li>Die aktuellen Namen der Event-Handler <code>Click</code> in ViewModel lauten <code>AddButton_Click</code>, <code>IncreaseButton_Click</code> und <code>DecreaseButton_Click</code>. Das ist bedauerlich. Im ViewModel denken wir nicht \"semantisch\" im Sinne von Event-Handlern. Stattdessen werden bei Modifizierungsoperationen, die den Zustand des ViewModel \u00e4ndern, die Dementsprechend sind <code>AddPersonToList</code>, <code>IncreaseAge</code> und <code>DecreaseAge</code>geeignetere und aussagekr\u00e4ftigere Namen als die oben genannten. Benennen Sie die Funktionen entsprechend um! Nat\u00fcrlich m\u00fcssen Sie diese noch an die <code>Click</code> Ereignisse in der XAML-Datei binden.</li> <li>Die Parameterliste f\u00fcr die oben genannten Funktionen lautet vorl\u00e4ufig \"<code>object sender, RoutedEventArgs e</code>\". Diese Parameter werden jedoch nicht f\u00fcr irgendetwas verwendet. Gl\u00fccklicherweise ist die x:Bind-Ereignisbindung so flexibel, dass Sie auch eine Operation ohne Parameter angeben k\u00f6nnen, und das funktioniert auch problemlos. Entfernen Sie daher die oben genannten unn\u00f6tigen Parameter aus den drei Funktionen unseres ViewModel. Dies f\u00fchrt zu einer schlankeren L\u00f6sung.</li> </ul> <p>Pr\u00fcfen Sie, ob die Anwendung nach den \u00c4nderungen genauso funktioniert wie vorher!</p> <p>Was haben wir durch die Umstellung unserer bisherigen L\u00f6sung auf eine MVVM-Basis gewonnen? Die Antwort finden Sie in den Vorlesungsunterlagen! Ein paar Dinge sind hervorzuheben:</p> <ul> <li>Die verschiedenen Zust\u00e4ndigkeiten sind gut voneinander getrennt (nicht vermischt), so dass es leichter zu verstehen ist:<ul> <li>UI-unabh\u00e4ngige Logik (Modell und zugeh\u00f6rige Klassen).</li> <li>UI-Logik (ViewModel)</li> <li>Nur UI-Erscheinung (Ansicht)</li> </ul> </li> <li>Da die UI-Logik separat ist, k\u00f6nnen Sie (nicht) Unit-Tests f\u00fcr sie schreiben</li> </ul> <p>Je komplexer eine Anwendung ist, desto mehr trifft dies zu.</p> <p>SUBMITTER</p> <p>Machen Sie einen Screenshot von <code>f2.png</code> wie folgt:</p> <ul> <li>Starten Sie die App. Verkleinern Sie sie gegebenenfalls, damit sie nicht zu viel Platz auf dem Bildschirm einnimmt,</li> <li>im \"Hintergrund\" sollte Visual Studio mit <code>PersonListPageViewModel.cs</code> ge\u00f6ffnet sein.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-3-deaktivierenaktivieren-von-controllern","title":"Aufgabe 3 - Deaktivieren/Aktivieren von Controllern","text":"<p>In diesem Stadium verh\u00e4lt sich die Anwendung etwas seltsam: Sie k\u00f6nnen die Schaltfl\u00e4che \"-\" verwenden, um ein Alter in den negativen Bereich zu verschieben, oder die Schaltfl\u00e4che \"+\", um es \u00fcber 150 zu verschieben, oder die Schaltfl\u00e4che \"+Hinzuf\u00fcgen\", um eine Person mit sinnlosen Attributen hinzuzuf\u00fcgen. Diese Schaltfl\u00e4chen sollten deaktiviert werden, wenn die von ihnen ausgel\u00f6ste Aktion keinen Sinn ergibt, und aktiviert werden, wenn sie Sinn ergibt.</p> <p>Im n\u00e4chsten Schritt deaktivieren/aktivieren Sie die Schaltfl\u00e4che \"-\" entsprechend. Die Schaltfl\u00e4che sollte nur aktiviert werden, wenn das Alter der Person gr\u00f6\u00dfer als 0 ist.</p> <p>Versuchen Sie, es zuerst selbst zu tun, zumindest um die Grundlagen zu schaffen! Ziehen Sie unbedingt eine L\u00f6sung mit Datenbindung in Betracht, nur diese ist akzeptabel! Wenn Sie nicht weiterkommen und Ihre L\u00f6sung nicht funktionieren \"will\", \u00fcberlegen Sie, was der Grund daf\u00fcr sein k\u00f6nnte, und entwerfen Sie Ihre L\u00f6sung wie folgt.</p> <p>Es gibt mehrere m\u00f6gliche L\u00f6sungen f\u00fcr dieses Problem. Allen gemeinsam ist, dass die Eigenschaft <code>IsEnabled</code> der Schaltfl\u00e4che \"-\" in irgendeiner Weise gebunden ist. In unserer L\u00f6sung binden wir sie an eine bool-Eigenschaft, die in <code>PersonListPageViewModel</code>neu eingef\u00fchrt wurde. </p> PersonListPageViewModel.cs<pre><code>    public bool IsDecrementEnabled\n    {\n        get { return NewPerson.Age &gt; 0; }\n    }\n</code></pre> PersonListPage.xaml-be a '-' gombhoz<pre><code>    IsEnabled=\"{x:Bind ViewModel.IsDecrementEnabled, Mode=OneWay}\"\n</code></pre> <p>Probieren wir es aus! Leider funktioniert es nicht, die \"-\"-Schaltfl\u00e4che wird nicht deaktiviert, wenn das Alter auf 0 oder weniger gesetzt wird (z.B. durch wiederholtes Anklicken der Schaltfl\u00e4che). Wenn Sie einen Haltepunkt in <code>IsDecrementEnabled</code> setzen und die Anwendung auf diese Weise starten, werden Sie feststellen, dass der Wert der Eigenschaft nur einmal vom gestrickten Steuerelement abgefragt wird, wenn die Anwendung startet: Danach k\u00f6nnen Sie auf die Schaltfl\u00e4che \"-\" klicken, aber nicht mehr als einmal. Probieren Sie es aus!</p> <p>\u00dcberlegen Sie, was die Ursache daf\u00fcr ist, und folgen Sie dann dem Leitfaden</p> Reason <p>Wie wir bereits gelernt haben, ruft die Datenbindung den Wert der Quelleigenschaft (in diesem Fall <code>IsDecrementEnabled</code>) nur ab, wenn sie \u00fcber <code>INotifyPropertyChanged</code> \u00fcber eine \u00c4nderung informiert wird! In unserer L\u00f6sung wird jedoch, selbst wenn sich die Eigenschaft <code>Age</code> des Objekts <code>NewPerson</code> \u00e4ndert, keine Mitteilung \u00fcber die \u00c4nderung der darauf basierenden Eigenschaft <code>IsDecrementEnabled</code> gemacht!</p> <p>Im n\u00e4chsten Schritt implementieren Sie die entsprechende \u00c4nderungsmeldung in der Klasse <code>PersonListPageViewModel</code>: </p> <ul> <li>Implementieren Sie die <code>INotifyPropertyChanged</code> Schnittstelle auf MVVM Toolkit \"Grundlagen\"!</li> <li>Die Eigenschaft <code>IsDecrementEnabled</code> kann so bleiben, wie sie ist (eine reine Getter-Eigenschaft), sie muss nicht auf <code>[ObservableProperty]</code> umgeschrieben werden (aber das ist eine gute L\u00f6sung und f\u00fcr Hausaufgaben durchaus akzeptabel, sie muss nur in den n\u00e4chsten Schritten etwas anders bearbeitet werden).</li> <li>Versuchen Sie, Folgendes in der ViewModel-Klasse selbst zu implementieren (die Klasse <code>Person</code> bleibt unver\u00e4ndert): Wenn sich <code>NewPerson.Age</code> \u00e4ndert, wird die vom Vorg\u00e4nger geerbte Eigenschaft <code>OnPropertyChanged</code> aufgerufen, um die \u00c4nderung der Eigenschaft <code>IsDecrementEnabled</code> anzuzeigen. Hinweis: Die Klasse <code>Person</code> hat bereits ein Ereignis <code>PropertyChanged</code>, da sie selbst die Schnittstelle <code>INotifyPropertyChanged</code> implementiert, k\u00f6nnen Sie dieses Ereignis abonnieren! Der Einfachheit halber haben wir nichts dagegen, wenn wir eine \u00c4nderung an <code>IsDecrementEnabled</code> melden, auch wenn sie sich nicht wirklich \"logisch\" \u00e4ndert.</li> <li>Die obigen Schritte k\u00f6nnen auch ohne die Implementierung einer separaten Ereignisbehandlungsfunktion durchgef\u00fchrt werden: Dies wird empfohlen, ist aber nicht zwingend erforderlich (Tipp: Geben Sie eine Ereignisbehandlungsfunktion mit einem Lambda-Ausdruck an).</li> </ul> <p>Testen Sie Ihre L\u00f6sung! Wenn Sie richtig gearbeitet haben, sollte die Schaltfl\u00e4che auch dann deaktiviert sein, wenn Sie manuell einen negativen Alterswert in die Textbox eingeben (und dann aus der Textbox herausklicken). Denken Sie dar\u00fcber nach, warum das so ist!</p> <p>Erarbeiten Sie eine \u00e4hnliche L\u00f6sung f\u00fcr die Schaltfl\u00e4che \"+\" und die Schaltfl\u00e4che \"+Hinzuf\u00fcgen\"!</p> <ul> <li>Das \"akzeptable\" H\u00f6chstalter sollte 150 Jahre betragen.</li> <li>Der Name ist nur akzeptabel, wenn er mindestens ein Zeichen enth\u00e4lt, das kein Leerzeichen ist (um letzteres zu pr\u00fcfen, verwenden Sie die statische Operation der String-Klasse <code>IsNullOrWhiteSpace</code> ).</li> <li>Der Fall, dass der Benutzer eine ung\u00fcltige Zahl in die Alters-Textbox eingibt (was bei dieser L\u00f6sung nicht m\u00f6glich ist), muss nicht behandelt werden.</li> </ul> <p>Beim Testen haben wir festgestellt, dass sich der Zustand der Schaltfl\u00e4che \"+Hinzuf\u00fcgen\" nicht sofort \u00e4ndert, wenn wir beispielsweise den Namen in der Textbox \"Name\" l\u00f6schen, sondern erst, wenn wir die Textbox verlassen? Warum ist das so? \u00c4ndern Sie Ihre L\u00f6sung so, dass dies bei jeder Text\u00e4nderung geschieht, ohne die TextBox zu verlassen. Hinweis: siehe die Folie \"Wann wird x:Bind aktualisiert?\" in der Pr\u00e4sentation.</p> <p>SUBMITTER</p> <p>Machen Sie einen Screenshot von <code>f3.png</code> wie folgt:</p> <ul> <li>Starten Sie die App. Verkleinern Sie sie gegebenenfalls, damit sie nicht zu viel Platz auf dem Bildschirm einnimmt,</li> <li>sollte das Alter im Antrag auf 0 reduziert werden,</li> <li>im \"Hintergrund\" sollte Visual Studio mit <code>PersonListPageViewModel.cs</code> ge\u00f6ffnet sein.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-4-befehl-verwenden","title":"Aufgabe 4 - Befehl verwenden","text":"<p>Derzeit haben wir zwei Aufgaben f\u00fcr die Schaltfl\u00e4che \"-\":</p> <ul> <li>F\u00fcr <code>Click</code>, f\u00fchren Sie den Ereignisbehandlungsvorgang aus</li> <li>Deaktivieren/aktivieren Sie die Schaltfl\u00e4che mit der Eigenschaft <code>IsEnabled</code> </li> </ul> <p>Einige Controller, wie z. B. die Schaltfl\u00e4che, unterst\u00fctzen die M\u00f6glichkeit, beide Angaben, aufbauend auf dem Command-Muster, mit einem Command-Objekt zu machen. Das Konzept des Command-Entwurfsmusters kann in der Vorlesung \"Design Patterns 3\" ausf\u00fchrlicher behandelt werden (obwohl wir dort nur das grundlegende Command-Muster kennengelernt haben, das die Ausf\u00fchrung von Befehlen unterst\u00fctzt, nicht aber das Verbieten/Freigeben). Die MVVM-spezifische Umsetzung des Command-Patterns finden Sie gegen Ende der WinUI-Vorlesungsreihe, beginnend mit der Folie \"Command-Pattern\".</p> <p>Das Grundprinzip ist: Anstatt <code>Click</code> und <code>IsEnabled</code> f\u00fcr die Schaltfl\u00e4che zu \"spezifizieren\", setzen wir die Eigenschaft <code>Command</code> der Schaltfl\u00e4che auf ein Befehlsobjekt, das die Schnittstelle <code>ICommand</code> implementiert. Es liegt an diesem Befehlsobjekt, den Befehl auszuf\u00fchren oder zu deaktivieren/aktivieren.</p> <p>Standardm\u00e4\u00dfig sollte eine Anwendung f\u00fcr jeden Befehl eine eigene <code>ICommand</code> Implementierung haben. Dies erfordert jedoch die Einf\u00fchrung vieler Klassen f\u00fcr viele Befehle. Das MVVM-Toolkit ist hier, um zu helfen. Stellt eine Klasse <code>RelayCommand</code> zur Verf\u00fcgung, die die Schnittstelle <code>ICommand</code> implementiert. Diese Klasse kann zur Ausf\u00fchrung beliebiger Befehle/Codes verwendet werden, so dass keine zus\u00e4tzlichen Befehlsklassen eingef\u00fchrt werden m\u00fcssen. Wie ist das m\u00f6glich? So, dass <code>RelayCommand</code>hat den Code f\u00fcr die Ausf\u00fchrung und deaktivieren/aktivieren in Konstruktor-Parameter, in Form von zwei Delegaten:</p> <ul> <li>Der erste Parameter gibt den Code an, der ausgef\u00fchrt werden soll, wenn der Befehl ausgef\u00fchrt wird.</li> <li>Der zweite Parameter (optional) ist der Code, den der Befehl aufruft, um zu pr\u00fcfen, ob er sich selbst zulassen oder verbieten soll (die hier angegebene Funktion muss einen booleschen Wert zur\u00fcckgeben, im wahren Fall wird der Befehl zugelassen).</li> </ul> <p>Der n\u00e4chste Schritt besteht darin, die Handhabung der \"-\"-Schaltfl\u00e4che auf eine Befehlsbasis umzustellen. Versuchen Sie zun\u00e4chst, das meiste davon selbst zu implementieren, basierend auf dem zugeh\u00f6rigen WinUI-Tutorial. Das Ausf\u00fchren des Befehls ist einfacher, aber Sie m\u00fcssen etwas Arbeit investieren, um den Befehl zu deaktivieren und zu aktivieren. Die wichtigsten Schritte:</p> <ul> <li>F\u00fcgen Sie eine \u00f6ffentliche <code>RelayCommand</code> Eigenschaft mit nur Getter zum ViewModel hinzu, z.B. <code>DecreaseAgeCommand</code>.  Anders als in den Vorlesungsunterlagen brauchen wir in unserem Fall <code>RelayCommand</code>keinen allgemeinen Parameter zu geben, da unsere Befehlszeilenfunktion (<code>DecreaseAge</code>) keinen Parameter hat.</li> <li>Geben Sie der neu eingef\u00fchrten Eigenschaft im ViewModel-Konstruktor einen Wert. Geben Sie die Parameter des <code>RelayCommand</code> Konstruktors entsprechend an.</li> <li>In <code>PersonListPage.xaml</code>muss die Schaltfl\u00e4che \"-\" nicht mehr <code>Click</code> und <code>IsEnabled</code> binden, sie werden gel\u00f6scht. Binden Sie stattdessen die Eigenschaft <code>Command</code> der Schaltfl\u00e4che an die Eigenschaft <code>DecreaseAgeCommand</code>, die im vorherigen Schritt im ViewModel eingef\u00fchrt wurde.</li> </ul> <p>Wenn Sie es ausprobieren, funktioniert der Befehl run, aber das Deaktivieren/Aktivieren nicht: Wenn Sie es gut beobachten, bleibt die Schaltfl\u00e4che in ihrem Aussehen immer aktiviert. Es gibt einen logischen Grund daf\u00fcr, wenn man dar\u00fcber nachdenkt: <code>RelayCommand</code> kann die Aktion im zweiten Konstruktorparameter aufrufen, um den Zustand zu \u00fcberpr\u00fcfen, aber es wei\u00df nicht, dass es dies jedes Mal tun sollte, wenn <code>NewPerson.Age</code> sich \u00e4ndert! Wir k\u00f6nnen dabei helfen. In unserem ViewModel-Konstruktor haben wir bereits das <code>NewPerson.PropertyChanged</code> -Ereignis abonniert: Darauf aufbauend rufen wir, wenn sich das Alter \u00e4ndert (oder wenn es sich \u00e4ndern k\u00f6nnte, es ist kein Problem, dies manchmal unn\u00f6tigerweise zu tun), die Aktion <code>DecreaseAgeCommand</code> <code>NotifyCanExecuteChanged</code> auf. Diese Operation hat einen sehr aussagekr\u00e4ftigen Namen: Sie teilt dem Befehl mit, dass sich der Zustand, unter dem der verbotene/erlaubte Zustand des Befehls aufgebaut ist, ge\u00e4ndert hat. Auf diese Weise wird der Befehl selbst aktualisiert, genauer gesagt der Zustand der mit dem Befehl verbundenen Schaltfl\u00e4che.</p> <p>\u00c4ndern Sie die Handhabung der \"+\"-Schaltfl\u00e4che auf \u00e4hnliche Weise auf Befehlsbasis \u00c4ndern Sie nicht die Handhabung der Schaltfl\u00e4che \"+Hinzuf\u00fcgen\"!</p> <p>SUBMITTER</p> <p>Machen Sie einen Screenshot von <code>f4.png</code> wie folgt:</p> <ul> <li>Starten Sie die App. Verkleinern Sie sie gegebenenfalls, damit sie nicht zu viel Platz auf dem Bildschirm einnimmt,</li> <li>der Name TextBox sollte in der Anwendung leer sein,</li> <li>im \"Hintergrund\" sollte Visual Studio mit <code>PersonListPageViewModel.cs</code> ge\u00f6ffnet sein.</li> </ul>"},{"location":"hazi/5-mvvm/index_ger/#aufgabe-5-verwendung-von-command-mit-mvvm-toolkit-basierter-codegenerierung","title":"Aufgabe 5 - Verwendung von Command mit MVVM Toolkit-basierter Codegenerierung","text":"<p>In der vorangegangenen \u00dcbung wurde die Einf\u00fchrung von Befehlseigenschaften und deren Instanziierung \"manuell\" vorgenommen. Das MVVM Toolkit kann dies vereinfachen: Wenn das richtige Attribut verwendet wird, k\u00f6nnen die Eigenschaft und die Instanziierung automatisch generiert werden.</p> <p>Konvertieren wir die Handhabung von <code>DecreaseAgeCommand</code> (nur dieses eine, lassen Sie <code>IncreaseAgeCommand</code>! ) in eine generierte Codebasis:</p> <ol> <li>Siehe die Klasse <code>PersonListPageViewModel</code> mit dem Schl\u00fcsselwort <code>partial</code>. </li> <li>Entfernen Sie die Eigenschaft <code>DecreaseAgeCommand</code> und ihre Instanziierung aus dem Konstruktor.</li> <li>Siehe <code>DecreaseAge</code> mit diesem Attribut: <code>[RelayCommand(CanExecute = nameof(IsDecrementEnabled))]</code>. <ul> <li>Als Ergebnis f\u00fchrt der Codegenerator eine Eigenschaft <code>RelayCommand</code> in die Klasse ein, die mit dem Namen unserer Operation (<code>DecreaseAge</code>) benannt ist und an die die Zeichenfolge \"Command\" angeh\u00e4ngt ist. So erhalten wir die Eigenschaft <code>DecreaseAgeCommand</code>, die wir zuvor manuell eingef\u00fchrt haben.</li> <li>Die Attributeigenschaft <code>CanExecute</code> kann verwendet werden, um in Form einer Zeichenkette den Namen der booleschen R\u00fcckgabeoperation oder -eigenschaft anzugeben, die der generierte Code verwenden wird, wenn er den Befehl nicht zul\u00e4sst/erlaubt (er ist der zweite Parameter des Konstruktors RelayCommand). Wir haben bereits eine solche Eigenschaft, die \"IsDecrementEnabled\" hei\u00dft. Sie wird nicht als einfache Zeichenkette angegeben, denn wenn jemand die Operation <code>IsDecrementEnabled</code> nachtr\u00e4glich umbenennt, w\u00fcrde die aktuelle \"IsDecrementEnabled\" nicht auf die richtige Operation verweisen. Die Verwendung des Ausdrucks <code>nameof</code> vermeidet dieses Problem. Die Angabe von <code>CanExecute</code> ist im Allgemeinen optional (geben Sie es nicht an, wenn Sie den Befehl niemals deaktivieren wollen).</li> </ul> </li> </ol> <p>Testen Sie die L\u00f6sung (Herabsetzung des Alters), sie sollte genauso funktionieren wie zuvor.</p> <p>SUBMITTER</p> <p>Machen Sie einen Screenshot von <code>f5.png</code> wie folgt:</p> <ul> <li>Starten Sie die App. Verkleinern Sie sie gegebenenfalls, damit sie nicht zu viel Platz auf dem Bildschirm einnimmt,</li> <li>im \"Hintergrund\" sollte Visual Studio mit <code>PersonListPageViewModel.cs</code> ge\u00f6ffnet sein.</li> </ul>"},{"location":"hazi/5b-mvvm-advanced/","title":"5b. HF - MVVM mint\u00e1ra \u00e9p\u00fcl\u0151 alkalmaz\u00e1sok (opcion\u00e1lis)","text":""},{"location":"hazi/5b-mvvm-advanced/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A h\u00e1zi feladatban a laboron elkezdett recept alkalmaz\u00e1st fogjuk tov\u00e1bb b\u0151v\u00edteni az MVVM mint\u00e1t haszn\u00e1lva.</p> <p>Az \u00f6n\u00e1ll\u00f3 feladat az MVVM el\u0151ad\u00e1sokon elhangzottakra \u00e9p\u00edt. A feladatok gyakorlati h\u00e1tter\u00e9\u00fcl a 5. labor \u2013 MVVM laborgyakorlat szolg\u00e1l.</p> <p>A fentiekre \u00e9p\u00edtve, jelen \u00f6n\u00e1ll\u00f3 gyakorlat feladatai a feladatle\u00edr\u00e1st k\u00f6vet\u0151 r\u00f6videbb ir\u00e1nymutat\u00e1s seg\u00edts\u00e9g\u00e9vel (n\u00e9ha alap\u00e9rtelmezetten \u00f6sszecsukva) \u00f6n\u00e1ll\u00f3an elv\u00e9gezhet\u0151k.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>MVVM minta haszn\u00e1lat\u00e1nak gyakorl\u00e1sa</li> <li>Adatok megjelen\u00edt\u00e9se \u00e9s interakci\u00f3k kezel\u00e9se a fel\u00fcleten adatk\u00f6t\u00e9ssel</li> <li>Dependency Injection minta alkalmaz\u00e1sa</li> <li>Adatok kezel\u00e9se a szolg\u00e1ltat\u00e1s r\u00e9tegben HTTP k\u00e9r\u00e9seken illetve egy lok\u00e1lis adatt\u00e1r seg\u00edts\u00e9g\u00e9vel</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p> <p>Fejleszt\u0151k\u00f6rnyezet WinUI3 fejleszt\u00e9shez</p> <p>A kor\u00e1bbi laborokhoz hasonl\u00f3an plusz komponensek telep\u00edt\u00e9se sz\u00fcks\u00e9ges. A fenti oldal eml\u00edti, hogy sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re, valamint ugyanitt az oldal alj\u00e1n van egy \"WinUI t\u00e1mogat\u00e1s\" fejezet, az itt megadott l\u00e9p\u00e9seket is mindenk\u00e9ppen meg kell tenni!</p>"},{"location":"hazi/5b-mvvm-advanced/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>MvvmLab.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> <li> Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</li> </ul>"},{"location":"hazi/5b-mvvm-advanced/#kikotesek","title":"Kik\u00f6t\u00e9sek","text":"<p> MVVM minta k\u00f6telez\u0151 alkalmaz\u00e1sa!   Jelen h\u00e1zi feladatban az MVVM mint\u00e1t gyakoroljuk, \u00edgy a feladatok megold\u00e1s\u00e1ban k\u00f6telez\u0151 az MVVM minta alkalmaz\u00e1sa. Az ett\u0151l val\u00f3 elt\u00e9r\u00e9s a feladatok \u00e9rt\u00e9kel\u00e9s\u00e9nek elutas\u00edt\u00e1s\u00e1t vonja maga ut\u00e1n.</p>"},{"location":"hazi/5b-mvvm-advanced/#kiindulo-allapot","title":"Kiindul\u00f3 \u00e1llapot","text":"<p>A kiindul\u00f3 \u00e1llapot \u00e9p\u00edt az 5. labor v\u00e9g\u00e1llapot\u00e1ra, de ahhoz k\u00e9pest egy l\u00e9nyeges v\u00e1ltoztat\u00e1st tartalmaz.</p> <p>Az alkalmaz\u00e1s az indul\u00e1sa ut\u00e1n l\u00e9trehoz egy <code>ShellPage</code> t\u00edpus\u00fa oldalt, ami a projektben a <code>Views</code> mapp\u00e1ban tal\u00e1lhat\u00f3 meg. Ez egy <code>NavigationView</code>-t tartalmaz (aka. Hamburger men\u00fc), mely a navig\u00e1ci\u00f3t fogja eset\u00fcnkben kezelni. Tartalmazhat <code>NavigationViewItem</code>-eket, melyek a men\u00fcpontokat reprezent\u00e1lj\u00e1k, \u00e9s mindig el\u00e9rhet\u0151ek az alkalmaz\u00e1sban. A men\u00fcpontokra kattintva a <code>Frame</code>-en bel\u00fcl a megfelel\u0151 oldal jelenik meg a projektben tal\u00e1lhat\u00f3 seg\u00e9doszt\u00e1lyok seg\u00edts\u00e9g\u00e9vel, ami t\u00e1mogatja a kor\u00e1bbi oldalra t\u00f6rt\u00e9n\u0151 vissza navig\u00e1ci\u00f3t is.</p>"},{"location":"hazi/5b-mvvm-advanced/#1-feladat-receptek-kedvenckent-kezelese","title":"1. Feladat - Receptek kedvenck\u00e9nt kezel\u00e9se","text":"<p>Feladatunk funkcion\u00e1lis k\u00f6vetelm\u00e9nyei a k\u00f6vetkez\u0151ek:</p> <ul> <li> <p>A recepteket kedvencek k\u00f6z\u00e9 lehessen menteni</p> <ul> <li>Jelenjen meg egy kit\u00f6ltetlen csillag ikonnal rendelkez\u0151 gomb a recept r\u00e9szletes oldalon (pl. bal oldali oszlop tetej\u00e9n), amelyre kattintva a receptet a kedvencek k\u00f6z\u00e9 menthetj\u00fck.</li> <li>A kedvenc kezel\u0151 gomb ikonja v\u00e1ltson tele csillagra, a sz\u00f6vege pedig \"Remove from Favorites\"-re, ha a recept kedvencnek lett jel\u00f6lve.</li> <li>A kor\u00e1bban kedvencnek jel\u00f6lt recept kivehet\u0151 a kedvencek k\u00f6z\u00fcl ugyanezen a gombon t\u00f6rt\u00e9n\u0151 kattint\u00e1ssal: ekkor a gomb ikonja \u00e1llapota vissza\u00e1ll \u00fcres csillagra, a sz\u00f6vege pedig \"Add to Favorites\"-re.</li> <li> <p>A kedvenc receptek list\u00e1j\u00e1t lok\u00e1lisan t\u00e1roljuk, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1val ne vesszenek el.</p> Add To FavoritesRemove From Favorites <p></p> <p></p> <p>A k\u00e9t gomb \u00e1llapot megjelen\u00edt\u00e9se</p> <p>A fenti \u00e1bra felett az \"Add To Favorites\" \u00e9s \"Remove From Favorites\"-en kattintva lehet v\u00e1ltani a k\u00e9t \u00e1llapotot megjelen\u00edt\u0151 k\u00e9pek k\u00f6z\u00f6tt.</p> </li> </ul> </li> <li> <p>A kedvencek list\u00e1j\u00e1t jelen\u00edts\u00fck meg egy k\u00fcl\u00f6n oldalon.</p> <ul> <li>A kedvencek list\u00e1t a hamburger men\u00fcb\u0151l lehessen el\u00e9rni</li> <li>A list\u00e1ban l\u00e9v\u0151 elemek kin\u00e9zete hasonl\u00f3 legyen a receptek list\u00e1j\u00e1ban l\u00e9v\u0151 elemekhez</li> <li>A lista ne legyen csoportos\u00edtva</li> <li> <p>A kedvencek list\u00e1j\u00e1nak elemei k\u00f6z\u00f6tt a recepteket kattintva megnyithatjuk a recept r\u00e9szletes oldal\u00e1t (pont \u00fagy, mint a Recipes oldalon)</p> <p></p> </li> </ul> </li> </ul>"},{"location":"hazi/5b-mvvm-advanced/#11-kedvencek-kezelese-a-szolgaltatas-retegben","title":"1.1 Kedvencek kezel\u00e9se a szolg\u00e1ltat\u00e1s r\u00e9tegben","text":"<p>Bottom-up megval\u00f3s\u00edt\u00e1si sorrendben haladva k\u00e9sz\u00edts\u00fck el el\u0151sz\u00f6r a szolg\u00e1ltat\u00e1s r\u00e9tegben a kedvencek kezel\u00e9s\u00e9hez sz\u00fcks\u00e9ges funkci\u00f3kat.</p> <p>A kedvencnek megjel\u00f6l\u00e9st az online szolg\u00e1ltat\u00e1s nem t\u00e1mogatja. A megold\u00e1s alapelve \u00edgy a k\u00f6vetkez\u0151 lesz:</p> <ul> <li>Lok\u00e1lisan perzisztensen elt\u00e1roljuk a kedvencnek megjel\u00f6lt receptek azonos\u00edt\u00f3it (annak \u00e9rdek\u00e9ben, hogy a program \u00fajraindul\u00e1s\u00e1t k\u00f6vet\u0151en megmaradjon ez az inform\u00e1ci\u00f3).</li> <li>A kedvencnek megjel\u00f6lt receptek r\u00e9szletes adatait (c\u00edm, k\u00e9p) az online szolg\u00e1ltat\u00e1st\u00f3l k\u00e9rdezz\u00fck le (az azonos\u00edt\u00f3ik alapj\u00e1n).</li> </ul> <p>Lok\u00e1lis perzisztens adatt\u00e1rol\u00e1shoz a kiindul\u00f3 projektben el\u0151 van k\u00e9sz\u00edtve az <code>ILocalSettingsService</code> interf\u00e9sz (\u00e9s egy ezt megval\u00f3s\u00edt\u00f3 implement\u00e1ci\u00f3). Erre \u00e9p\u00edtve kulcs \u00e9rt\u00e9k p\u00e1rokat tudunk JSON soros\u00edtva t\u00e1rolni lok\u00e1lisan az alkalmaz\u00e1sban.</p> <pre><code>public interface ILocalSettingsService\n{\n    Task&lt;T&gt; ReadSettingAsync&lt;T&gt;(string key);\n    Task SaveSettingAsync&lt;T&gt;(string key, T value);\n}\n</code></pre> <p>Haszn\u00e1lata sor\u00e1n \u00e9rdemes odafigyelni arra, hogy a f\u00fcggv\u00e9nyek generikusak, \u00edgy a t\u00edpusokat explicit meg kell(het) adni a h\u00edv\u00e1s sor\u00e1n.</p> <p>A fenti <code>ILocalSettingsService</code> seg\u00edts\u00e9g\u00e9vel egy adott kulcs alatt fogjuk a kedvenc receptek azonos\u00edt\u00f3inak list\u00e1j\u00e1t elt\u00e1rolni.</p> <p>Szint\u00e9n fontos, hogy a f\u00fcggv\u00e9nyek <code>Task</code>-kal t\u00e9rnek vissza, teh\u00e1t aszinkronok, \u00edgy <code>await</code> kulcssz\u00f3val kell h\u00edvni \u0151ket, \u00e9s a h\u00edv\u00f3 f\u00fcggv\u00e9nynek is aszinkronnak kell lennie (a r\u00e9szletesebb szab\u00e1lyhalmaz a kapcsol\u00f3d\u00f3 \"5. MVVM\" labor le\u00edr\u00e1s\u00e1ban tal\u00e1lhat\u00f3).</p> <p>A kedvencek kezel\u00e9se a labor sor\u00e1n bevezetett <code>IRecipeService</code> interf\u00e9sz \u00e9s az ezt megval\u00f3s\u00edt\u00f3 <code>RecipeService</code> oszt\u00e1ly feladata legyen. </p> <p>Els\u0151 l\u00e9p\u00e9sben azt kell megoldani, hogy a <code>RecipeService</code> sz\u00e1m\u00e1ra rendelkez\u00e9sre \u00e1lljon egy <code>ILocalSettingsService</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektum, melyet fel tud haszn\u00e1lni  megval\u00f3s\u00edt\u00e1s\u00e1ban a kedvenc receptazonos\u00edt\u00f3k elt\u00e1rol\u00e1s\u00e1ra \u00e9s lek\u00e9rdez\u00e9s\u00e9re. A c\u00e9lunk az, hogy <code>RecipeService</code>-ben <code>ILocalSettingsService</code> interf\u00e9szk\u00e9nt kapjuk meg \u00e9s t\u00e1roljuk ezt az implement\u00e1ci\u00f3s objektumot, semmif\u00e9le f\u00fcgg\u00e9st nem szeretn\u00e9nk itt bevezetni a konkr\u00e9t implement\u00e1ci\u00f3t\u00f3l. Ezt a laboron m\u00e1r alkalmazott DI kont\u00e9ner seg\u00edts\u00e9g\u00e9vel val\u00f3s\u00edtsuk meg.</p> <p>Tip</p> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n a <code>RecipeService</code>-ben ahhoz hasonl\u00f3an kell kezelj\u00fck a <code>ILocalSettingsService</code>-t, mint a ahogy a labor sor\u00e1n a <code>MainPageViewModel</code>-ben kezelt\u00fck a <code>IRecipeService</code>-t.</p> <p>Miut\u00e1n a fenti el\u0151k\u00e9sz\u00edt\u00e9ssel elk\u00e9sz\u00fclt\u00e9l, val\u00f3s\u00edtsd meg a sz\u00fcks\u00e9ges funkci\u00f3kat a <code>RecipeService</code> oszt\u00e1lyban! Az al\u00e1bbiakban ehhez n\u00e9mi ir\u00e1nymutat\u00e1st adunk.</p> RecipeService v\u00e1za <p>A <code>RecipeService</code>-nek (\u00e9s interf\u00e9sznek) a k\u00f6vetkez\u0151 \u00faj funkci\u00f3kkal kell rendelkeznie:</p> <ol> <li> <p>Recept kedvenc \u00e1llapot\u00e1nak m\u00f3dos\u00edt\u00e1sa id (int) alapj\u00e1n az \u00faj \u00e1llapottal (bool). (Recept r\u00e9szletes oldalon gombra kattint\u00e1s sor\u00e1n haszn\u00e1ljuk.)</p> <ol> <li>K\u00e9rdezz\u00fck le az <code>ILocalSettingsService</code>-b\u0151l kedvencek azonos\u00edt\u00f3inak list\u00e1j\u00e1t. </li> <li>Lista m\u00f3dos\u00edt\u00e1sa a kapott id \u00e9s \u00faj kedvenc \u00e1llapot alapj\u00e1n.<ol> <li>Kedvencnek jel\u00f6l\u00e9s eset\u00e9n, berakjuk, egy\u00e9bk\u00e9nt t\u00f6r\u00f6lj\u00fck.</li> <li>Gondoljunk arra is, ha a lista m\u00e1r tartalmazza az adott id-t, akkor ne adjuk hozz\u00e1 \u00fajra. (Lista helyett egy\u00e9bk\u00e9nt lehet haszn\u00e1lni egy speci\u00e1lis halmaz tulajdons\u00e1g\u00fa kollekci\u00f3t is, a <code>HashSet&lt;T&gt;</code>-et, mely egy elemet csak egyszer tartalmaz.)</li> </ol> </li> </ol> </li> <li> <p>Kedvenc receptek lek\u00e9rdez\u00e9se. (Kedvencek oldalon list\u00e1z\u00e1s sor\u00e1n haszn\u00e1ljuk.)</p> <ol> <li>K\u00e9rdezz\u00fck le az <code>ILocalSettingsService</code>-b\u0151l a kedvenc receptek azonos\u00edt\u00f3inak list\u00e1j\u00e1t.</li> <li>A kapott id-k alapj\u00e1n egyes\u00e9vel k\u00e9rj\u00fck le a recepteket a REST API-t\u00f3l, a <code>GET /api/Recipes/{id}/Header</code> v\u00e9gponton kereszt\u00fcl. Ez a laborhoz k\u00e9pest egy \u00faj v\u00e9gpont, \u00e9s az adott azonos\u00edt\u00f3j\u00fa recept <code>RecipeHeader</code>-be soros\u00edtott adataival t\u00e9r vissza. Ehhez a v\u00e9gponthoz \u00e9rdemes \u00faj seg\u00e9df\u00fcggv\u00e9nyt is k\u00e9sz\u00edteni. Dolgozhatunk a laboron m\u00e1r bevezetett <code>RecipeService</code>-ben lev\u0151 <code>HttpClient</code>-et haszn\u00e1l\u00f3 m\u0171veletek \"mint\u00e1j\u00e1ra\".</li> <li>A lek\u00e9rdezett <code>RecipeHeader</code> objektumokb\u00f3l \u00f6ssze\u00e1ll\u00edtott list\u00e1val t\u00e9rj\u00fcnk vissza.</li> </ol> </li> <li> <p>Recept kedvenc \u00e1llapot\u00e1nak lek\u00e9rdez\u00e9se id alapj\u00e1n. (Recept r\u00e9szletes oldal bet\u00f6lt\u00e9sekor a gomb \u00e1llapot\u00e1nak be\u00e1ll\u00edt\u00e1s\u00e1hoz haszn\u00e1ljuk.)</p> <ol> <li>Igaz hamis \u00e9rt\u00e9kkel t\u00e9rj\u00fcnk vissza, att\u00f3l f\u00fcgg\u0151en, hogy az adott azonos\u00edt\u00f3 szerepel-e a kedvenc receptek list\u00e1j\u00e1ban.</li> </ol> </li> </ol> <p>Els\u0151 h\u00edv\u00e1s</p> <p>Gondolni kell arra is, ha m\u00e9g most h\u00edvjuk meg el\u0151sz\u00f6r a lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt, \u00e9s nincs m\u00e9g mentett kedvenc recept azonos\u00edt\u00f3 list\u00e1nk (<code>null</code>-lal t\u00e9r vissza az adott kulcs\u00fa elem lek\u00e9rdez\u00e9sekor az <code>ILocalSettingsService.ReadSettingAsync</code>).</p>"},{"location":"hazi/5b-mvvm-advanced/#12-kedvencnek-jeloles-a-reszletes-oldalon","title":"1.2 Kedvencnek jel\u00f6l\u00e9s a r\u00e9szletes oldalon","text":"<p>A recept r\u00e9szletes oldalon (a <code>RecipeDetailPage</code>-en) meg kell jelen\u00edteni egy gombot, melynek k\u00e9t \u00e1llapota van:</p> <ol> <li>Ha a recept nincs kedvencnek jel\u00f6lve, akkor egy \u00fcres csillag ikon jelenik meg a gombon, a gomb felirata pedig legyen \"Add to Favorites\".</li> <li>Ha a recept kedvencnek van jel\u00f6lve, akkor egy kit\u00f6lt\u00f6tt csillag ikon jelenik meg a gombon, a gomb felirata pedig legyen \"Remove from Favorites\".</li> </ol> Add To FavoritesRemove From Favorites <p></p> <p></p> <p>Ezt az igaz-hamis \u00e1llapotot \u00e9s m\u00f3dos\u00edt\u00f3 m\u0171veletet c\u00e9lszer\u0171 a <code>RecipeDetailPageViewModel</code>-ban t\u00e1rolni/bevezetni (mivel a ViewModelnek defin\u00edci\u00f3 szerint ez a feladata), majd adatk\u00f6t\u00e9ssel k\u00f6tni az \u00e1llapotot gomb kin\u00e9zet\u00e9hez, illetve a m\u0171veletet commandj\u00e1hoz. Mindenk\u00e9ppen az MVVM mint\u00e1t k\u00f6vetve dolgozzunk!</p> RecipeDetailPageViewModel m\u00f3dos\u00edt\u00e1sa <p>A <code>RecipeDetailViewModel</code>-t m\u00f3dos\u00edtani sz\u00fcks\u00e9ges a k\u00f6vetkez\u0151kkel:</p> <ol> <li>Kedvenc \u00e1llapot t\u00e1rol\u00e1sa<ol> <li>Az \u00e1llapotot egy <code>bool</code> t\u00edpus\u00fa property-ben t\u00e1roljuk (mindenk\u00e9ppen \u00e9rdemes az  <code>[ObservableProperty]</code> attrib\u00fatumot haszn\u00e1lni, m\u0171k\u00f6d\u00e9s\u00e9nek \u00e9s jelent\u0151s\u00e9g\u00e9nek \u00e1tism\u00e9tl\u00e9s\u00e9vel).</li> <li>Az \u00e1llapotot az <code>IRecipeService</code>-b\u0151l lek\u00e9rdezve inicializ\u00e1ljuk az oldalra val\u00f3 navig\u00e1l\u00e1skor.</li> </ol> </li> <li> <ol> <li>Elmenti az \u00faj kedvenc \u00e1llapotot az <code>IRecipeService</code> seg\u00edts\u00e9g\u00e9vel.</li> <li>Gondoskodik a ViewModel oszt\u00e1lyunkban t\u00e1rolt <code>bool</code> kedvenc \u00e1llapot tulajdons\u00e1g karbantart\u00e1s\u00e1r\u00f3l.</li> </ol> <p>\u00daj command f\u00fcggv\u00e9ny k\u00e9sz\u00edt\u00e9se, amely </p> Tipp a megold\u00e1shoz <p>A megold\u00e1s elve hasonl\u00edt a SendComment parancsf\u00fcggv\u00e9nyhez, de itt a CanExecute-tal nem kell foglalkozzunk, hiszen az \u00faj commandunk mindig futtathat\u00f3.</p> </li> </ol> <p>\u00c1llapot t\u00e1rol\u00e1sa a modellben</p> <p>A kedvenc \u00e1llapotot a <code>RecipeHeader</code> modellben is t\u00e1rolhatn\u00e1nk, viszont az k\u00e9t m\u00e1sik probl\u00e9m\u00e1t is gener\u00e1lna: a modellnek kell megval\u00f3s\u00edtania az <code>INotifyPropertyChanged</code> interf\u00e9szt, hogy az \u00e1llapot v\u00e1ltoz\u00e1s\u00e1t jelezni tudja.  Ezen fel\u00fcl az \u00faj property \u00e9rt\u00e9k\u00e9t valamelyik m\u00e1sik r\u00e9tegben (ViewModel vagy Service) kellene kit\u00f6lteni, mivel ez az inf\u00f3 csak lok\u00e1lisan \u00e9rhet\u0151 el, a <code>RecipeHeader</code>pedig alapvet\u0151en most csak egy DTO (Data Transfer Object) a modell r\u00e9tegben.</p> RecipeDetailPage (vagyis a View) m\u00f3dos\u00edt\u00e1sa <p>A <code>RecipeDetailPage</code>-en a k\u00f6vetkez\u0151ket kell m\u00f3dos\u00edtani:</p> <ol> <li>\u00daj gomb hozz\u00e1ad\u00e1sa az oldal tetej\u00e9re, tartalma legyen egy <code>SymbolIcon</code> \u00e9s egy <code>TextBlock</code> egym\u00e1s mellett.<ol> <li>A <code>SymbolIcon</code>-nak a <code>Symbol</code> tulajdons\u00e1g\u00e1hoz haszn\u00e1ljuk a <code>Symbol.SolidStar</code> \u00e9s <code>Symbol.OutlineStar</code> enum \u00e9rt\u00e9keket a csillag ikonokhoz.</li> </ol> </li> <li>A gomb commandj\u00e1t adatk\u00f6tni kell a ViewModel-ben tal\u00e1lhat\u00f3 command-hoz.</li> </ol> <p>A ViewModel-ben t\u00e1rolt <code>bool</code> \u00e9rt\u00e9ket valamilyen m\u00f3don <code>Symbol</code> enumra (gomb ikonja) \u00e9s <code>string</code>-re (gomb aktu\u00e1lis sz\u00f6vege) kell konvert\u00e1lni, hogy a fel\u00fcleten a gomb megjelen\u00e9se mindk\u00e9t \u00e1llapotban a megfelel\u0151 legyen. Erre t\u00f6bb megold\u00e1s is lehets\u00e9ges:</p> <ul> <li><code>x:Bind</code> haszn\u00e1lata, ahol nem property-t k\u00f6t\u00fcnk, hanem egy a xaml.cs-ben l\u00e9v\u0151 seg\u00e9df\u00fcggv\u00e9nyt, mely a konverzi\u00f3t elv\u00e9gzi. Vagyis property k\u00f6t\u00e9s helyett f\u00fcggv\u00e9ny/funkci\u00f3 k\u00f6t\u00e9st haszn\u00e1lunk. El\u0151ad\u00e1sanyagban a \"Property k\u00f6t\u00e9se funkci\u00f3khoz\"-ra \u00e9rdemes r\u00e1keresni, illetve a 3. h\u00e1zi feladatban a \"f\u00fcggv\u00e9ny k\u00f6t\u00e9s p\u00e9lda\"-ra.</li> <li>Az <code>IValueConverter</code> interf\u00e9sz implement\u00e1l\u00e1sa \u00e9s haszn\u00e1lata az adatk\u00f6t\u00e9s sor\u00e1n.</li> <li>A <code>RecipeDetailPageViewModel</code>-ben t\u00e1roljuk a n\u00e9zethez sz\u00fcks\u00e9ges adatokat \u00faj tuljadons\u00e1gokat bevezetve (a tulajdons\u00e1gok t\u00edpusa a n\u00e9zet sz\u00e1m\u00e1ra sz\u00fcks\u00e9ges <code>Symbol</code> \u00e9s <code>string</code>), \u00e9s ezekhez t\u00f6rt\u00e9nik az adatk\u00f6t\u00e9s.<ul> <li>Tal\u00e1n ez a legegyszer\u0171bb megold\u00e1s, ha nem szeretn\u00e9nk k\u00fcl\u00f6n konvertert \u00edrni vagy az adatk\u00f6t\u00e9seket \"bonyol\u00edtani\", viszont a legkev\u00e9sb\u00e9 is lesz karbantarthat\u00f3, mivel a ViewModel view specifikus adatokat is tartalmaz, melyeket k\u00fcl\u00f6n karban is kell tartani ha a bool property megv\u00e1ltozik.</li> </ul> </li> </ul> <p>1.2. feladat BEADAND\u00d3</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol a teend\u0151 r\u00e9szletes oldalon megjelenik a kedvencnek jel\u00f6l\u00e9s gomb! (<code>f1.2.1.png</code>)</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol a teend\u0151 r\u00e9szletes oldalon egy m\u00e1r kedvencnek jel\u00f6lt recepthez a kedvencekb\u0151l elt\u00e1vol\u00edt\u00e1s gomb jelenik meg! (<code>f1.2.2.png</code>)</p>"},{"location":"hazi/5b-mvvm-advanced/#13-kedvencek-oldal-navigacio","title":"1.3 Kedvencek oldal navig\u00e1ci\u00f3","text":"<p>A kedvencek oldalra navig\u00e1l\u00e1shoz t\u00f6bb l\u00e9p\u00e9sre is sz\u00fcks\u00e9g\u00fcnk lesz, melyek a kiindul\u00f3 projekt saj\u00e1toss\u00e1gaib\u00f3l ad\u00f3d\u00f3dnak, de ezeket itt r\u00e9szletesen \u00e1tvessz\u00fck (a navig\u00e1ci\u00f3 megval\u00f3s\u00edt\u00e1sa nem r\u00e9sze a tanagyagnak).</p> <ol> <li> <p>Hozzuk l\u00e9tre a <code>FavoritesPage</code>-et a <code>Views</code> mapp\u00e1ban (Add/New Item/Blank Page (WinUI3))</p> <p>Ford\u00edt\u00e1si hib\u00e1k</p> <p>Ha valami\u00e9rt egzotikus hib\u00e1kat kapn\u00e1nk az \u00faj oldal felv\u00e9tele ut\u00e1n t\u00f6r\u00f6lj\u00fck ki a projekt f\u00e1jlb\u00f3l az al\u00e1bbi sorokat:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;None Remove=\"Views\\FavoritesPage.xaml\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <pre><code>&lt;Page Update=\"Views\\FavoritesPage.xaml\"&gt;\n    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;\n&lt;/Page&gt;\n</code></pre> </li> <li> <p>Hozzuk l\u00e9tre a <code>FavoritesPageViewModel</code> oszt\u00e1lyt a <code>ViewModels</code> mapp\u00e1ban</p> <ol> <li>Gondoskodjunk arr\u00f3l, hogy a megfelel\u0151 oszt\u00e1lyb\u00f3l sz\u00e1rmazzon!</li> <li>Val\u00f3s\u00edtsa meg az <code>INavigationAware</code> interf\u00e9szt a navig\u00e1ci\u00f3 t\u00e1mogat\u00e1s\u00e1hoz (egyel\u0151re \u00fcres f\u00fcggv\u00e9nyt\u00f6rzzsel).</li> </ol> </li> <li> <p>Regisztr\u00e1ljuk be az <code>App.xaml.cs</code>-ben a Dependency Injection kont\u00e9nerbe az \u00faj n\u00e9zetet \u00e9s az \u00faj ViewModelt:</p> <pre><code>services.AddTransient&lt;FavoritesPage&gt;();\nservices.AddTransient&lt;FavoritesPageViewModel&gt;();\n</code></pre> </li> <li> <p>A <code>Pages</code> oszt\u00e1lyban (<code>PageService.cs</code>) vegy\u00fcnk fel egy \u00faj kulcsot a kedvencek oldalhoz, \u00e9s konfigur\u00e1ljuk a navig\u00e1ci\u00f3t ehhez a kulcshoz:</p> Pages<pre><code>public static string Favorites { get; } = \"Favorites\";\n</code></pre> PageService konstruktor<pre><code>Configure&lt;FavoritesPageViewModel, FavoritesPage&gt;(Pages.Favorites);\n</code></pre> </li> <li> <p>A <code>ShellPage</code>-en a <code>NavigationView</code>-hoz adjunk hozz\u00e1 egy \u00faj <code>NavigationViewItem</code>-et a kedvencek oldalhoz:</p> <pre><code>&lt;NavigationViewItem helpers:NavigationHelper.NavigateTo=\"Favorites\" Content=\"Favorites\"&gt;\n    &lt;NavigationViewItem.Icon&gt;\n        &lt;SymbolIcon Symbol=\"SolidStar\" /&gt;\n    &lt;/NavigationViewItem.Icon&gt;\n&lt;/NavigationViewItem&gt;\n</code></pre> <p>Navig\u00e1ci\u00f3</p> <p>A navig\u00e1ci\u00f3 a <code>helpers:NavigationHelper.NavigateTo=\"Favorites\"</code> attached property seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik, ahol azt a kulcsot adhatjuk meg, amilyen kulcs\u00fa oldalra navig\u00e1lni szeretn\u00e9nk.</p> </li> </ol>"},{"location":"hazi/5b-mvvm-advanced/#14-kedvencek-oldal-logika","title":"1.4 Kedvencek oldal logika","text":"<p>A kedvencek oldal (<code>FavoritesPage</code>) a <code>MainPage</code> mint\u00e1j\u00e1ra k\u00e9sz\u00fclj\u00f6n el, \u00e9s a receptek list\u00e1j\u00e1t jelen\u00edtse meg, csoportos\u00edt\u00e1s n\u00e9lk\u00fcl (!) egy <code>AdaptiveGridView</code> vez\u00e9rl\u0151ben.</p> <p></p> <p>A ViewModel (<code>FavoritesPageViewModel</code>) a <code>MainPageViewModel</code> mint\u00e1j\u00e1ra k\u00e9sz\u00fclj\u00f6n el, \u00e9s a navig\u00e1ci\u00f3 sor\u00e1n k\u00e9rdezze le az <code>IRecipeService</code>-t\u0151l a kedvenc receptek list\u00e1j\u00e1t (<code>GetFavoriteRecipesAsync</code>) \u00e9s t\u00e1rolja el egy megfelel\u0151, pl. gener\u00e1lt tulajdons\u00e1gba. Mivel itt nem csoportos\u00edtjuk a recepteket, <code>RecipeGroup</code>-ok helyett <code>RecipeHeader</code>-ekkel kell dolgozni.</p> <p>1.4. feladat BEADAND\u00d3</p> <p>Illessz be egy k\u00e9perny\u0151k\u00e9pet az alkalmaz\u00e1sr\u00f3l, ahol kedvencek lista l\u00e1that\u00f3! (<code>f1.4.png</code>)</p>"},{"location":"hazi/5b-mvvm-advanced/#beadas","title":"Bead\u00e1s","text":"<p>Ellen\u0151rz\u0151lista ism\u00e9tl\u00e9sk\u00e9ppen:</p> <ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/5b-mvvm-advanced/index_ger/","title":"5. HF - Anwendungen auf der Grundlage des MVVM-Modells","text":""},{"location":"hazi/5b-mvvm-advanced/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Als Hausaufgabe werden wir die in der \u00dcbung begonnene Rezeptanwendung mit Hilfe der MVVM-Vorlage erweitern.</p> <p>Die eigenst\u00e4ndige \u00dcbung baut auf dem auf, was in den MVVM-Vorlesungen gesagt wurde. Den praktischen Hintergrund f\u00fcr die \u00dcbungen liefert die Labor\u00fcbung 5 - MVVM-Labor\u00fcbung. </p> <p>Darauf aufbauend k\u00f6nnen die Aufgaben dieser Selbst\u00fcbung mit Hilfe der k\u00fcrzeren Leitf\u00e4den, die auf die Aufgabenbeschreibung folgen (manchmal standardm\u00e4\u00dfig eingeklappt), selbst\u00e4ndig bearbeitet werden.</p> <p>Das Ziel der unabh\u00e4ngigen \u00dcbung:</p> <ul> <li>\u00dcben mit dem MVVM-Beispiel</li> <li>Anzeige von Daten und Verwaltung von Interaktionen auf der Schnittstelle mit Datenbindung</li> <li>Anwendung des Dependency Injection-Musters</li> <li>Datenverwaltung auf der Dienstebene \u00fcber HTTP-Anfragen oder ein lokales Repository</li> </ul> <p>Die erforderliche Entwicklungsumgebung wird hier beschrieben.</p> <p>Entwicklungsumgebung f\u00fcr WinUI3-Entwicklung</p> <p>Wie in den vorherigen \u00dcbungen m\u00fcssen zus\u00e4tzliche Komponenten installiert werden. Auf der obigen Seite wird erw\u00e4hnt, dass Sie Visual Studio Workload f\u00fcr die \".NET-Desktop-Entwicklung\" installieren m\u00fcssen, und es gibt einen Abschnitt \"WinUI-Unterst\u00fctzung\" am unteren Ende der Seite, Sie sollten den Schritten dort folgen!</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#das-verfahren-fur-die-einreichung","title":"Das Verfahren f\u00fcr die Einreichung","text":"<ul> <li>Der grundlegende Prozess ist derselbe wie zuvor. Erstellen Sie mit GitHub Classroom ein Repository f\u00fcr sich selbst. Sie finden die Einladungs-URL in Moodle (Sie k\u00f6nnen sie sehen, indem Sie auf den Link*\"GitHub classroom links for homework*\" auf der Startseite des Fachs klicken). Es ist wichtig, dass Sie die richtige Einladungs-URL f\u00fcr diese Hausaufgabe verwenden (jede Hausaufgabe hat eine andere URL). Klonen Sie das resultierende Repository. Dazu geh\u00f6rt auch die erwartete Struktur der L\u00f6sung. Nachdem Sie die Aufgaben erledigt haben, \u00fcbergeben Sie Ihre L\u00f6sung alt und dr\u00fccken Sie sie alt.</li> <li>Um mit den geklonten Dateien zu arbeiten, \u00f6ffnen Sie <code>MvvmLab.sln</code>.</li> <li> In den \u00dcbungen werden Sie aufgefordert, einen Screenshot von einem Teil Ihrer L\u00f6sung zu machen, da dies beweist, dass Sie Ihre L\u00f6sung selbst erstellt haben. Der erwartete Inhalt der Screenshots wird immer in der Aufgabe angegeben. Screenshots sollten als Teil der L\u00f6sung eingereicht werden, legen Sie sie in den Stammordner Ihres Repositorys (neben neptun.txt). Die Screenshots werden dann zusammen mit dem Inhalt des Git-Repositorys auf GitHub hochgeladen. Da das Repository privat ist, ist es f\u00fcr niemanden au\u00dfer den Lehrkr\u00e4ften sichtbar. Wenn Sie Inhalte auf dem Screenshot haben, die Sie nicht hochladen m\u00f6chten, k\u00f6nnen Sie diese aus dem Screenshot herausschneiden.</li> <li> Diese Aufgabe enth\u00e4lt keinen sinnvollen Pre-Checker: Sie wird nach jedem Push ausgef\u00fchrt, pr\u00fcft aber nur, ob neptun.txt gef\u00fcllt ist. Die inhaltliche \u00dcberpr\u00fcfung wird von den Laborleitern nach Ablauf der Frist durchgef\u00fchrt.</li> </ul>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#verbindungen","title":"Verbindungen","text":"<p> Obligatorische Verwendung des MVVM-Beispiels!   In dieser Hausaufgabe \u00fcben wir das MVVM-Pattern, daher ist das MVVM-Pattern f\u00fcr die L\u00f6sung der Aufgaben zwingend erforderlich. Andernfalls wird die Bewertung der Aufgaben verweigert.</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#ausgangszustand","title":"Ausgangszustand","text":"<p>Der Ausgangszustand baut auf dem Endzustand von Labor 5 auf, allerdings mit einer wichtigen \u00c4nderung.</p> <p>Wenn die Anwendung gestartet wird, wird eine Seite des Typs <code>ShellPage</code> erstellt, die sich im Ordner <code>Views</code> des Projekts befindet. Es enth\u00e4lt eine <code>NavigationView</code>(aka. Hamburger Men\u00fc), das in unserem Fall die Navigation \u00fcbernimmt. Sie kann <code>NavigationViewItem</code>enthalten, die Men\u00fcpunkte darstellen und in der Anwendung immer verf\u00fcgbar sind. Wenn Sie auf die Men\u00fcpunkte innerhalb von <code>Frame</code>klicken, wird die entsprechende Seite mit Hilfe der Hilfsklassen im Projekt aufgerufen, die auch die Navigation zur\u00fcck zur vorherigen Seite unterst\u00fctzt.</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#1-aufgabe-rezepte-als-favoriten-verwalten","title":"1. Aufgabe - Rezepte als Favoriten verwalten","text":"<p>Die funktionalen Anforderungen an unsere Aufgabe sind:</p> <ul> <li> <p>Rezepte als Favoriten speichern</p> <ul> <li>Auf der Detailseite des Rezepts (z. B. oben in der linken Spalte) sollte eine Schaltfl\u00e4che mit einem nicht ausgef\u00fcllten Sternsymbol zu finden sein, die angeklickt werden kann, um das Rezept als Favorit zu speichern.</li> <li>Das Symbol der Favoriten-Schaltfl\u00e4che sollte sich in einen vollen Stern und der Text in \"Aus den Favoriten entfernen\" \u00e4ndern, wenn das Rezept als Favorit markiert wurde.</li> <li>Ein zuvor als Favorit gekennzeichnetes Rezept kann durch Klicken auf dieselbe Schaltfl\u00e4che aus den Favoriten entfernt werden: Das Symbol der Schaltfl\u00e4che wird dann wieder zu einem leeren Stern und der Text \u00e4ndert sich in \"Zu Favoriten hinzuf\u00fcgen\".</li> <li> <p>Ihre Liste der Lieblingsrezepte wird lokal gespeichert, damit sie nicht verloren geht, wenn Sie die App schlie\u00dfen.</p> <p>=== \"Zu Favoriten hinzuf\u00fcgen\" </p> <p>=== \"Aus Favoriten entfernen\" </p> <p>Zwei Schaltfl\u00e4chenstatus anzeigen</p> <p>Klicken Sie oberhalb der Abbildung auf \"Zu Favoriten hinzuf\u00fcgen\" und \"Aus Favoriten entfernen\", um zwischen den beiden Status der Bilder zu wechseln.</p> </li> </ul> </li> <li> <p>Zeigen Sie die Liste der Favoriten auf einer separaten Seite an.</p> <ul> <li>Die Favoritenliste kann \u00fcber das Hamburger-Men\u00fc aufgerufen werden</li> <li>Die Eintr\u00e4ge in der Liste sollten \u00e4hnlich aussehen wie die Eintr\u00e4ge in der Rezeptliste</li> <li>Die Liste sollte nicht gruppiert werden</li> <li> <p>Klicken Sie auf ein Rezept in der Favoritenliste, um die detaillierte Rezeptseite zu \u00f6ffnen (genau wie auf der Seite Rezepte)</p> <p></p> </li> </ul> </li> </ul>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#11-verwaltung-von-favoriten-in-der-dienstebene","title":"1.1 Verwaltung von Favoriten in der Dienstebene","text":"<p>In einer Bottom-up-Implementierungsreihenfolge erstellen wir zun\u00e4chst die Funktionen, die f\u00fcr die Verwaltung der Favoriten in der Dienstschicht erforderlich sind.</p> <p>Favoriten werden vom Online-Dienst nicht unterst\u00fctzt. Das Grundprinzip der L\u00f6sung lautet also:</p> <ul> <li>Die Kennungen der als Favoriten markierten Rezepte werden lokal gespeichert (damit diese Informationen bei einem Neustart des Programms erhalten bleiben).</li> <li>Die Angaben zu den als Favoriten gekennzeichneten Rezepten (Adresse, Bild) werden vom Online-Dienst angefordert (auf der Grundlage ihrer Kennungen).</li> </ul> <p>F\u00fcr die lokale persistente Datenspeicherung wird die Schnittstelle <code>ILocalSettingsService</code> (und eine Implementierung) im urspr\u00fcnglichen Projekt vorbereitet. Darauf aufbauend k\u00f6nnen wir nach JSON sortierte Schl\u00fcssel-Wert-Paare lokal in der Anwendung speichern.</p> <pre><code>public interface ILocalSettingsService\n{\n    Task&lt;T&gt; ReadSettingAsync&lt;T&gt;(string key);\n    Task SaveSettingAsync&lt;T&gt;(string key, T value);\n}\n</code></pre> <p>Bei der Verwendung ist zu beachten, dass die Funktionen generisch sind, so dass die Typen beim Aufruf explizit angegeben werden m\u00fcssen.</p> <p>Mit Hilfe der obigen <code>ILocalSettingsService</code> speichern wir eine Liste der bevorzugten Rezept-IDs unter einem bestimmten Schl\u00fcssel.</p> <p>Wichtig ist auch, dass die Funktionen <code>Task</code>zur\u00fcckgeben, also asynchron sind. Sie m\u00fcssen also mit dem Schl\u00fcsselwort <code>await</code> aufgerufen werden, und die aufrufende Funktion muss ebenfalls asynchron sein (f\u00fcr einen detaillierteren Satz von Regeln siehe den zugeh\u00f6rigen Abschnitt \"5. MVVM\" Laborbeschreibung).</p> <p>Die Verwaltung der Favoriten sollte in der Verantwortung der Schnittstelle <code>IRecipeService</code> und der Klasse <code>RecipeService</code> liegen, die sie implementiert. </p> <p>Der erste Schritt besteht darin, <code>RecipeService</code> ein Objekt zur Verf\u00fcgung zu stellen, das die Schnittstelle <code>ILocalSettingsService</code> implementiert, die es in seiner Implementierung verwenden kann, um seine bevorzugten Rezeptbezeichnungen zu speichern und abzurufen. Unser Ziel ist es, dieses Implementierungsobjekt in <code>RecipeService</code>als Schnittstelle zu <code>ILocalSettingsService</code> zu erhalten und zu speichern, wir wollen hier keine Abh\u00e4ngigkeiten von der spezifischen Implementierung einf\u00fchren. Dazu wird der bereits im Labor verwendete DI-Beh\u00e4lter verwendet.</p> <p>Tip</p> <p>Bei der Umsetzung sollten wir <code>ILocalSettingsService</code>in <code>RecipeService</code>genauso behandeln, wie wir <code>IRecipeService</code>in <code>MainPageViewModel</code>im Labor behandelt haben.</p> <p>Nachdem Sie die obigen Vorbereitungen getroffen haben, implementieren Sie die notwendige Funktionalit\u00e4t in der Klasse <code>RecipeService</code>!  Hier finden Sie einige Hinweise dazu.</p> RezeptService vase <p>Der <code>RecipeService</code> (und die Schnittstelle) sollten die folgenden neuen Eigenschaften haben:</p> <ol> <li> <p>\u00c4ndern Sie den Status des Rezeptfavoriten basierend auf id (int) mit dem neuen Status (bool). (Rezeptdetailseite, die beim Anklicken der Schaltfl\u00e4che angezeigt wird)</p> <ol> <li>Abfrage von <code>ILocalSettingsService</code> nach einer Liste von Favoriten-IDs. </li> <li>\u00c4ndern Sie die Liste anhand der erhaltenen ID und des neuen Favoritenstatus.<ol> <li>Wenn Sie es als Favorit markieren, wird es hinzugef\u00fcgt, andernfalls wird es gel\u00f6scht.</li> <li>Wenn die Liste die ID bereits enth\u00e4lt, f\u00fcgen Sie sie nicht erneut hinzu. (Anstelle einer Liste k\u00f6nnen Sie auch eine spezielle Sammlung mit Mengeneigenschaften verwenden, <code>HashSet&lt;T&gt;</code>, die ein Element nur einmal enth\u00e4lt)</li> </ol> </li> </ol> </li> <li> <p>Fragen Sie Ihre Lieblingsrezepte ab. (Wird f\u00fcr die Auflistung auf der Seite Favoriten verwendet.)</p> <ol> <li>Abfrage von <code>ILocalSettingsService</code> nach der Liste der IDs Ihrer Lieblingsrezepte.</li> <li>Auf der Grundlage der empfangenen IDs rufen wir die Rezepte einzeln von der REST-API ab, und zwar \u00fcber den Endpunkt \"GET /api/Recipes/{id}/Header\". Dies ist ein neuer Endpunkt in Bezug auf das Labor und gibt die Rezeptdaten mit der angegebenen ID zur\u00fcck, sortiert nach dem <code>RecipeHeader</code>. F\u00fcr diesen Endpunkt lohnt es sich auch, eine neue Hilfsfunktion zu erstellen. Wir k\u00f6nnen ein \"Muster\" von Operationen mit <code>HttpClient</code> in <code>RecipeService</code> erarbeiten, das bereits im Labor implementiert wurde.</li> <li>R\u00fcckgabe mit einer Liste der abgerufenen <code>RecipeHeader</code>-Objekte.</li> </ol> </li> <li> <p>Abfrage des Favoritenstatus eines Rezepts anhand der ID. (Dient zum Einstellen des Schaltfl\u00e4chenstatus beim Laden einer Rezeptdetailseite)</p> <ol> <li>R\u00fcckgabe mit einem true/false-Wert, je nachdem, ob die Kennung in der Liste der Lieblingsrezepte enthalten ist.</li> </ol> </li> </ol> <p>Erster Anruf</p> <p>Sie sollten auch bedenken, wenn Sie die Abfragefunktion zum ersten Mal aufrufen und keine ID-Liste der Lieblingsrezepte gespeichert haben (<code>null</code> wird zur\u00fcckgegeben, wenn <code>ILocalSettingsService.ReadSettingAsync</code> f\u00fcr das angegebene Schl\u00fcsselelement aufgerufen wird).</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#12-auf-der-detailseite-als-favorit-markieren","title":"1.2 Auf der Detailseite als Favorit markieren","text":"<p>Auf der Rezeptseite (unter <code>RecipeDetailPage</code>) sollten Sie eine Schaltfl\u00e4che mit zwei Zust\u00e4nden sehen:</p> <ol> <li>Wenn das Rezept nicht als Favorit markiert ist, erscheint ein leeres Sternsymbol auf der Schaltfl\u00e4che und die Schaltfl\u00e4che ist mit \"Zu Favoriten hinzuf\u00fcgen\" beschriftet.</li> <li>Wenn das Rezept als Favorit markiert ist, erscheint ein ausgef\u00fclltes Sternsymbol auf der Schaltfl\u00e4che und die Schaltfl\u00e4che ist mit \"Aus Favoriten entfernen\" beschriftet.</li> </ol> <p>=== \"Zu Favoriten hinzuf\u00fcgen\" </p> <p>=== \"Aus Favoriten entfernen\" </p> <p>Dieser true/false-Zustand und die \u00e4ndernde Aktion sollten in <code>RecipeDetailPageViewModel</code>gespeichert/implementiert werden (da dies per Definition die Aufgabe des ViewModels ist) und dann mit dem Zustand der Schaltfl\u00e4che und dem Befehl der Aktion datengebunden werden. Achten Sie darauf, das MVVM-Modell zu befolgen!</p> RecipeDetailPageViewModel modification <p>Das <code>RecipeDetailViewModel</code> sollte wie folgt ge\u00e4ndert werden:</p> <ol> <li>Favoritenstatus speichern<ol> <li>Der Zustand wird in einer Eigenschaft vom Typ <code>bool</code> gespeichert (verwenden Sie unbedingt das Attribut <code>[ObservableProperty]</code> und wiederholen Sie dessen Funktion und Bedeutung).</li> <li>Der Status wird initialisiert, indem er beim Aufrufen der Seite von \"IRecipeService\" abgerufen wird.</li> </ol> </li> <li> <ol> <li>Speichert den neuen Favoritenstatus unter Verwendung von <code>IRecipeService</code>.</li> <li>K\u00fcmmert sich um die Pflege der in unserer ViewModel-Klasse gespeicherten Eigenschaft \"bool\".</li> </ol> <p>Erstellen Sie eine neue Befehlsfunktion, die </p> Tipp f\u00fcr die L\u00f6sung <p>Das Prinzip ist \u00e4hnlich wie bei der Befehlsfunktion SendComment, aber hier m\u00fcssen wir uns nicht mit CanExecute befassen, da unser neuer Befehl immer ausf\u00fchrbar ist.</p> </li> </ol> <p>Speichern eines Zustands im Modell</p> <p>Der Status der Favoriten k\u00f6nnte im Modell \"RecipeHeader\" gespeichert werden, aber das w\u00fcrde zu zwei weiteren Problemen f\u00fchren: Das Modell m\u00fcsste die Schnittstelle \"INotifyPropertyChanged\" implementieren, um eine Status\u00e4nderung anzuzeigen.  Dar\u00fcber hinaus sollte der Wert der neuen Eigenschaft in einer anderen Schicht (ViewModel oder Service) gef\u00fcllt werden, da diese Information nur lokal verf\u00fcgbar ist und der \"RecipeHeader\" im Grunde nur noch ein DTO (Data Transfer Object) in der Modellschicht ist.</p> RecipeDetailPage (d.h. die Ansicht) \u00e4ndern <p>Auf der \"RecipeDetailPage\" sollte folgendes ge\u00e4ndert werden:</p> <ol> <li>F\u00fcgen Sie oben auf der Seite eine neue Schaltfl\u00e4che hinzu, mit einem \"SymbolSymbol\" und einem \"Textblock\" nebeneinander.<ol> <li>F\u00fcr die Eigenschaft <code>SymbolIcon</code> von <code>Symbol</code> sind die Enum-Werte <code>Symbol.SolidStar</code> und <code>Symbol.OutlineStar</code> f\u00fcr die Sternsymbole zu verwenden.</li> </ol> </li> <li>Der Schaltfl\u00e4chenbefehl muss mit dem Befehl im ViewModel datengebunden sein.</li> </ol> <p>Der im ViewModel gespeicherte \"bool\"-Wert muss auf irgendeine Weise in ein \"Symbol\"-Enum (Schaltfl\u00e4chensymbol) und einen \"String\" (tats\u00e4chlicher Schaltfl\u00e4chentext) umgewandelt werden, so dass die Schaltfl\u00e4che in beiden Zust\u00e4nden auf der Oberfl\u00e4che erscheint. Es gibt mehrere m\u00f6gliche L\u00f6sungen:</p> <ul> <li>verwenden Sie \"x:Bind\", wobei Sie keine Eigenschaft binden, sondern eine Hilfsfunktion in xaml.cs, die die Umwandlung vornimmt. Das hei\u00dft, dass wir anstelle der Eigenschaftsbindung eine Funktions-/Funktionsbindung verwenden. In den Vorlesungsunterlagen sollten Sie nach \"Binding Property to Functions\" und in Hausaufgabe 3 nach \"Function Binding Example\" suchen.</li> <li>Implementierung und Verwendung der Schnittstelle \"IValueConverter\" bei der Datenbindung.</li> <li>Im \"RecipeDetailPageViewModel\" werden die f\u00fcr die Ansicht erforderlichen Daten gespeichert, indem neue Ergebniseigenschaften eingef\u00fchrt werden (die f\u00fcr die Ansicht erforderlichen Eigenschaftstypen sind \"Symbol\" und \"String\") und die Daten an sie gebunden werden.<ul> <li>Dies ist wahrscheinlich die einfachste L\u00f6sung, wenn Sie keinen separaten Konverter schreiben oder die Datenbindungen \"verkomplizieren\" wollen, aber es ist auch die am wenigsten wartbare, da die ViewModel-Ansicht ansichtsspezifische Daten enth\u00e4lt, die separat gepflegt werden m\u00fcssen, wenn sich die bool-Eigenschaft \u00e4ndert.</li> </ul> </li> </ul> <p>Aufgabe 1.2. einzureichen</p> <p>F\u00fcgen Sie einen Screenshot des Antrags ein, auf dem Sie eine Schaltfl\u00e4che zum Markieren als Favorit auf der Detailseite sehen (<code>f1.2.1.png</code>)</p> <p>F\u00fcgen Sie einen Screenshot der App ein, auf der die Schaltfl\u00e4che \"Aus Favoriten entfernen\" auf der Detailseite eines bereits als Favorit markierten Rezepts erscheint (<code>f1.2.2.png</code>)</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#13-navigation-der-favoritenseite","title":"1.3 Navigation der Favoritenseite","text":"<p>Um zur Favoritenseite zu navigieren, sind mehrere Schritte erforderlich, die f\u00fcr das urspr\u00fcngliche Projekt spezifisch sind, aber wir werden sie hier im Detail erl\u00e4utern (die Implementierung der Navigation ist nicht Teil des Tutorials).</p> <ol> <li> <p>Erstellen Sie <code>FavoritesPage</code>im Ordner <code>Views</code> (Add/New Item/Blank Page (WinUI3))</p> <p>\u00dcbersetzungsfehler</p> <p>Wenn Sie aus irgendeinem Grund exotische Fehler erhalten, nachdem Sie eine neue Seite hinzugef\u00fcgt haben, l\u00f6schen Sie die folgenden Zeilen in der Projektdatei:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;Keine Remove=\"ViewsFavoritesPage.xaml\" /&gt;\n&lt;/EinzelteilGruppe&gt;\n</code></pre> <pre><code>&lt;Seite Update=\"ViewsFavoritesPage.xaml\"&gt;\n    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;\n&lt;/Seite&gt;\n</code></pre> </li> <li> <p>Erstellen Sie die Klasse <code>FavoritesPageViewModel</code> im Ordner <code>ViewModels</code> </p> <ol> <li>Achten Sie darauf, dass es aus der richtigen Klasse kommt!</li> <li>Konfigurieren Sie die Schnittstelle <code>INavigationAware</code> so, dass sie die Navigation unterst\u00fctzt (vorerst mit einer leeren Funktionstaste).</li> </ol> </li> <li> <p>Registrieren Sie den neuen View und das neue ViewModel im Dependency Injection Container in <code>App.xaml.cs</code>:</p> <pre><code>services.AddTransient&lt;FavoritesPage&gt;();\nservices.AddTransient&lt;FavoritesPageViewModel&gt;();\n</code></pre> </li> <li> <p>F\u00fcgen Sie in der Klasse <code>Pages</code> (<code>PageService.cs</code>) einen neuen Schl\u00fcssel f\u00fcr die Favoritenseite hinzu und konfigurieren Sie die Navigation zu diesem Schl\u00fcssel:</p> Pages<pre><code>public static string Favorites { get; } = \"Favorites\";\n</code></pre> PageService konstruktor<pre><code>Configure&lt;FavoritesPageViewModel, FavoritesPage&gt;(Pages.Favorites);\n</code></pre> </li> <li> <p>F\u00fcgen Sie unter <code>ShellPage</code>eine neue <code>NavigationViewItem</code>bis <code>NavigationView</code>f\u00fcr die Favoritenseite hinzu:</p> <pre><code>&lt;NavigationViewItem helpers:NavigationHelper.NavigateTo=\"Favorites\" Content=\"Favorites\"&gt;\n    &lt;NavigationViewItem.Icon&gt;\n        &lt;SymbolIcon Symbol=\"SolidStar\" /&gt;\n    &lt;/NavigationViewItem.Icon&gt;\n&lt;/NavigationViewItem&gt;\n</code></pre> <p>Navigation</p> <p>Die Navigation erfolgt \u00fcber die angeh\u00e4ngte Eigenschaft <code>helpers:NavigationHelper.NavigateTo=\"Favorites\"</code>, in der Sie den Schl\u00fcssel angeben k\u00f6nnen, um zu der Seite mit dem Schl\u00fcssel zu navigieren, zu dem Sie navigieren m\u00f6chten.</p> </li> </ol>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#14-logik-der-favoritenseite","title":"1.4 Logik der Favoritenseite","text":"<p>Die Favoritenseite (<code>FavoritesPage</code>) sollte nach dem Vorbild von <code>MainPage</code> gestaltet werden und die Liste der Rezepte ohne Gruppierung (!) in einem <code>AdaptiveGridView</code> Steuerelement anzeigen.</p> <p></p> <p>Erstellen Sie ein ViewModel (<code>FavoritesPageViewModel</code>) basierend auf <code>MainPageViewModel</code> und rufen Sie die Liste der Lieblingsrezepte ( <code>IRecipeService</code>) w\u00e4hrend der Navigation (<code>GetFavoriteRecipesAsync</code>) von ab und speichern Sie sie in einer geeigneten Eigenschaft, z.B. generated. Da wir die Rezepte hier nicht gruppieren, m\u00fcssen Sie mit <code>RecipeHeader</code>statt mit <code>RecipeGroup</code>arbeiten.</p> <p>1.4. exercise REQUIRED</p> <p>Einf\u00fcgen eines Screenshots der Anwendung mit einer Liste von Favoriten (<code>f1.4.png</code>)</p>"},{"location":"hazi/5b-mvvm-advanced/index_ger/#vorlegen-bei","title":"Vorlegen bei","text":"<p>Checkliste f\u00fcr Wiederholungen:</p> <ul> <li>Es ist wichtig, dass nur die Aufgaben akzeptiert werden, die Sie vollst\u00e4ndig gemacht haben und die die Anforderungen in jeder Hinsicht erf\u00fcllen. </li> <li>Sie m\u00fcssen nat\u00fcrlich Ihre eigene Arbeit eingeben (da sie bewertet wird).</li> <li>Nicht nur das Quellcode, sondern auch die erwartete Bildschirmfotos sollen eingegeben werden.</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/","title":"6. HF - Tervez\u00e9si mint\u00e1k (kiterjeszthet\u0151s\u00e9g)","text":"<p>A h\u00e1zi feladatban az a kapcsol\u00f3d\u00f3 laboron (6. labor \u2013 Tervez\u00e9si mint\u00e1k (kiterjeszthet\u0151s\u00e9g)) elkezdett adatfeldolgoz\u00f3/anonimiz\u00e1l\u00f3 alkalmaz\u00e1st fogjuk tov\u00e1bbfejleszteni.</p> <p>Az \u00f6n\u00e1ll\u00f3 feladat az tervez\u00e9si mint\u00e1k el\u0151ad\u00e1sokon elhangzottakra \u00e9p\u00edt: - \"El\u0151ad\u00e1s 08 - Tervez\u00e9si mint\u00e1k 1\" el\u0151ad\u00e1s: \"B\u0151v\u00edthet\u0151s\u00e9ghez, kiterjeszthet\u0151s\u00e9ghez kapcsol\u00f3d\u00f3 alap tervez\u00e9si mint\u00e1k\" nagyfejezet: bevezet\u0151 p\u00e9lda, Template Method, Strategy, Open/Closed elv, SRP elv, egy\u00e9b technik\u00e1k (met\u00f3dusreferencia/lambda) - \"El\u0151ad\u00e1s 09 - Tervez\u00e9si mint\u00e1k 1\" el\u0151ad\u00e1s: Dependency Injection minta</p> <p>A feladatok gyakorlati h\u00e1tter\u00e9\u00fcl a 6. labor \u2013 Tervez\u00e9si mint\u00e1k (kiterjeszthet\u0151s\u00e9g) laborgyakorlat szolg\u00e1l.</p> <p>Az \u00f6n\u00e1ll\u00f3 gyakorlat c\u00e9lja:</p> <ul> <li>Kapcsol\u00f3d\u00f3 tervez\u00e9si mint\u00e1k \u00e9s egy\u00e9b kiterjeszthet\u0151s\u00e9gi technik\u00e1k alkalmaz\u00e1sa</li> <li>Integr\u00e1ci\u00f3s \u00e9s egys\u00e9gtesztek koncepci\u00f3inak gyakorl\u00e1sa</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s. Enn\u00e9l a h\u00e1zi feladatn\u00e1l nincs sz\u00fcks\u00e9g WinUI-ra (egy konzol alap\u00fa alkalmaz\u00e1s kontextus\u00e1ban kell dolgozni), \u00edgy pl. Linux/MacOS k\u00f6rnyezetben is elv\u00e9gezhet\u0151.</p>"},{"location":"hazi/6-tervezesi-mintak/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li>A kikl\u00f3nozott f\u00e1jlok k\u00f6z\u00f6tt a <code>Patterns-Extensibility.sln</code>-t megnyitva kell dolgozni.</li> <li> A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, a repository-d gy\u00f6k\u00e9rmapp\u00e1j\u00e1ba tedd (a neptun.txt mell\u00e9). A k\u00e9perny\u0151k\u00e9pek \u00edgy felker\u00fclnek GitHub-ra a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</li> <li> Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#1-feladat","title":"1. Feladat","text":"<p>A h\u00e1zi feladat megold\u00e1s\u00e1nak alapja a k\u00f6vetkez\u0151:</p> <ul> <li>A Strategy \u00e9s a kapcsol\u00f3d\u00f3 Dependency Injection (DI) tervez\u00e9si minta ismerete</li> <li>Ezen mint\u00e1k alkalmaz\u00e1s\u00e1nak pontos meg\u00e9rt\u00e9se a labor feladat\u00e1nak a kontextus\u00e1ban (anonimiz\u00e1l\u00f3)</li> </ul> <p>A h\u00e1zi feladat kiindul\u00f3 \u00e1llapota megfelel a 6. labor v\u00e9g\u00e1llapot\u00e1nak: ez a h\u00e1zi feladat solutionj\u00e9ben a \"Strategy-DI\" projekt. Futtat\u00e1shoz/debuggol\u00e1shoz be kell \u00e1ll\u00edtani, hogy ez legyen a startup projekt (jobb katt, \"Set as Startup Project\"). Ennek forr\u00e1sk\u00f3dj\u00e1t alaposan n\u00e9zd \u00e1t \u00e9s \u00e9rtsd meg.</p> <ul> <li>A <code>Program.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 h\u00e1rom <code>Anonymizer</code>, elt\u00e9r\u0151 strategy implement\u00e1ci\u00f3kkal param\u00e9terezve. R\u00e1hangol\u00f3d\u00e1sk\u00e9ppen \u00e9rdemes ezeket egyes\u00e9vel kipr\u00f3b\u00e1lni/futtatni, \u00e9s megn\u00e9zni, hogy val\u00f3ban a v\u00e1lasztott strategy implement\u00e1ci\u00f3knak megfelel\u0151en t\u00f6rt\u00e9nik az anonimiz\u00e1l\u00e1s \u00e9s a progress kezel\u00e9s (eml\u00e9keztet\u0151 laborr\u00f3l: az anonimiz\u00e1l\u00f3 bemenete \"bin\\Debug\\net8.0\" mapp\u00e1ban lev\u0151 us-500.csv, kimenete az ugyanitt tal\u00e1lhat\u00f3 \"us-500.processed.txt\").</li> <li>Szint\u00e9n \u00e9rdemes a <code>Program.cs</code> f\u00e1jlban kiindulva, t\u00f6r\u00e9spontokat elhelyezve v\u00e9gig l\u00e9pkedni a k\u00f3don (ez is seg\u00edtheti az ism\u00e9tl\u00e9st/teljes meg\u00e9rt\u00e9st). </li> </ul> <p>Dependency Injection (manu\u00e1lis) vs. Dependency Injection Container</p> <p>A labor sor\u00e1n, \u00e9s jelen h\u00e1zi feladatban a Dependency Injection egyszer\u0171, manu\u00e1lis v\u00e1ltozat\u00e1t haszn\u00e1ljuk (el\u0151ad\u00e1son is ez szerepel). Ez esetben az oszt\u00e1ly f\u00fcgg\u0151s\u00e9geit manu\u00e1lisan p\u00e9ld\u00e1nyos\u00edtjuk \u00e9s adjuk \u00e1t az oszt\u00e1ly konstruktor\u00e1ban. Alternat\u00edv \u00e9s komplexebb alkalmaz\u00e1sok eset\u00e9ben gyakran haszn\u00e1lt alternat\u00edva egy Dependency Injection Container alkalmaz\u00e1sa, melybe beregisztr\u00e1lhatjuk, hogy az egyes interf\u00e9sz t\u00edpusokhoz milyen implement\u00e1ci\u00f3t k\u00edv\u00e1nunk haszn\u00e1lni. Az MVVM labor sor\u00e1n \"mell\u00e9kesen\" haszn\u00e1ltuk ezt a technik\u00e1t, de a DI kont\u00e9nerek alkalmaz\u00e1sa nem tananyag. A manu\u00e1lis v\u00e1ltozata viszont az, \u00e9s kiemelt fontoss\u00e1g\u00fa, hiszen en\u00e9lk\u00fcl nincs \u00e9rtelme a Strategy minta alkalmaz\u00e1s\u00e1nak.</p> <p> Saj\u00e1t szavaiddal megfogalmazva adj r\u00f6vid v\u00e1laszt a Feladatok mapp\u00e1ban tal\u00e1lthat\u00f3 <code>readme.md</code> f\u00e1jlban az al\u00e1bbi k\u00e9rd\u00e9sekre:</p> <ul> <li>Mit biztos\u00edt a Strategy a DI mint\u00e1val kombin\u00e1lva a labor p\u00e9lda keret\u00e9ben, mik az egy\u00fcttes alkalmaz\u00e1suk el\u0151nyei?</li> <li>Mit jelent az, hogy a Strategy minta alkalmaz\u00e1s\u00e1val az Open/Closed elv megval\u00f3sul a megold\u00e1sban? (az Open/Closed elvr\u0151l az el\u0151ad\u00e1s \u00e9s laboranyagban is olvashatsz).</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#2-feladat-null-strategy","title":"2. Feladat - Null Strategy","text":"<p>Az <code>Anonymizer</code> konstruktor param\u00e9tereit megvizsg\u00e1lva azt l\u00e1tjuk, hogy progress strat\u00e9gi\u00e1nak <code>null</code> is megadhat\u00f3. Ez logikus, hiszen lehet, hogy az <code>Anonymizer</code> felhaszn\u00e1l\u00f3ja nem k\u00edv\u00e1ncsi semmif\u00e9le progress inform\u00e1ci\u00f3ra. Ennek a megk\u00f6zel\u00edt\u00e9snek van egy h\u00e1tr\u00e1nya is. Ez esetben az oszt\u00e1lyban a <code>_progress</code> tagv\u00e1ltoz\u00f3 null lesz, \u00e9s \u00edgy az alkalmaz\u00e1sa sor\u00e1n sz\u00fcks\u00e9g van a null vizsg\u00e1latra. Ellen\u0151rizz\u00fck, hogy a <code>_progess</code> haszn\u00e1latakor val\u00f3ban van null vizsg\u00e1lat a <code>?.</code> oper\u00e1tor alkalmaz\u00e1s\u00e1val. De ez egy vesz\u00e9lyes j\u00e1t\u00e9k, mert komplexebb esetben hacsak egyetlen helyen is lefelejt\u0151dik a null vizsg\u00e1lat, akkor fut\u00e1s k\u00f6zben <code>NullReferenceException</code>-t kapunk. Az ehhez hasonl\u00f3 null hivatkoz\u00e1s hib\u00e1k a leggyakoribbak k\u00f6z\u00e9 tartoznak.</p> <p>Feladat: Dolgozz ki egy olyan megold\u00e1st, mely a fent v\u00e1zolt hibalehet\u0151s\u00e9get kiz\u00e1rja. Tipp: olyan megold\u00e1sra van sz\u00fcks\u00e9g, melyn\u00e9l a <code>_progress</code> tag soha nem lehet null. A megold\u00e1sra el\u0151sz\u00f6r magadt\u00f3l pr\u00f3b\u00e1lj r\u00e1j\u00f6nni.</p> Megold\u00e1s alapelve <p>A megold\u00e1s \"tr\u00fckkje\" a k\u00f6vetkez\u0151. Egy olyan <code>IProgress</code> strategy implement\u00e1ci\u00f3t kell k\u00e9sz\u00edteni (pl. <code>NullProgress</code> n\u00e9ven), melyet akkor haszn\u00e1lunk, amikor nincs sz\u00fcks\u00e9g progress inform\u00e1ci\u00f3ra. Ez az implement\u00e1ci\u00f3 a progress \"sor\u00e1n\" nem csin\u00e1l semmit, a f\u00fcggv\u00e9ny t\u00f6rzse \u00fcres. Amikor az <code>Anonymizer</code> konstruktor\u00e1ban null-t ad meg az oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edt\u00f3ja progressk\u00e9nt, akkor egy <code>NullProgress</code> objektumot hozzunk l\u00e9tre a konstruktorban, \u00e9s a <code>_progress</code> tagot \u00e1ll\u00edtsuk erre. Most m\u00e1r a <code>_progress</code> soha nem lehet null, a null vizsg\u00e1latot vegy\u00fck is ki a k\u00f3db\u00f3l.</p> <p>Ennek a technik\u00e1nak is van neve, Null Object n\u00e9ven szok\u00e1s r\u00e1 hivatkozni.</p>"},{"location":"hazi/6-tervezesi-mintak/#3-tesztelhetoseg","title":"3. Tesztelhet\u0151s\u00e9g","text":"<p>Vegy\u00fck \u00e9szre, hogy az <code>Anonymizer</code> oszt\u00e1ly m\u0171k\u00f6d\u00e9s\u00e9nek van m\u00e9g sz\u00e1mos aspektusa, melyeket valamelyik megold\u00e1sunkkal kiterjeszthet\u0151v\u00e9 lehetne tenni. T\u00f6bbek k\u00f6z\u00f6tt ilyen a:</p> <ul> <li>Bemenet kezel\u00e9se: Most csak f\u00e1jl alap\u00fa, adott CSV form\u00e1tumot t\u00e1mogatunk.</li> <li>Kimenet kezel\u00e9se: Most csak f\u00e1jl alap\u00fa, adott CSV form\u00e1tumot t\u00e1mogatunk.</li> </ul> <p>Ezeket az SRP elve miatt illene az oszt\u00e1lyr\u00f3l lev\u00e1lasztani, m\u00e1s oszt\u00e1lyba tenni (ism\u00e9teld \u00e1t, mit jelent az SRP elv). A lev\u00e1laszt\u00e1st nem felt\u00e9telen kiterjeszthet\u0151 m\u00f3don kellene megtenni, hiszen nem mer\u00fclt fel ig\u00e9ny arra, hogy k\u00fcl\u00f6nb\u00f6z\u0151 bemenetekkel \u00e9s kimenetekkel kellene tudni dolgozni. \u00cdgy a lev\u00e1laszt\u00e1s sor\u00e1n nem alkalmazn\u00e1nk a Strategy mint\u00e1t.</p> <p>Ugyanakkor van m\u00e9g egy kritikus szempont, melyr\u0151l nem besz\u00e9lt\u00fcnk (\u00e9s a r\u00e9gebbi, klasszikus design pattern irodalmak sem felt\u00e9tlen emlegetik). Ez az egys\u00e9gtesztelhet\u0151s\u00e9g.</p> <p>Jelen pillanatban az <code>Anonymizer</code> oszt\u00e1lyunkhoz automata integr\u00e1ci\u00f3s teszteket tudunk \u00edrni, automata egys\u00e9gteszteket nem:</p> <ul> <li>Az integr\u00e1ci\u00f3s tesztek a teljes m\u0171k\u00f6d\u00e9st egyben vizsg\u00e1lj\u00e1k: ebben benne van a bemenet feldolgoz\u00e1sa, adatfeldolgoz\u00e1s, kimenet el\u0151\u00e1ll\u00edt\u00e1sa. Ez p\u00e9ld\u00e1nkban egyszer\u0171: el\u00e1ll\u00edtunk bizonyos bemeneti CVS \u00e1llom\u00e1nyokat, \u00e9s megn\u00e9zz\u00fck, a v\u00e1rt kimeneti \u00e1llom\u00e1ny \u00e1ll\u00edt\u00f3dik-e el\u0151.</li> <li>Az integr\u00e1ci\u00f3s tesztek nagyon lass\u00faak tudnak lenni: sokszor f\u00e1jlokb\u00f3l, adatb\u00e1zisokb\u00f3l, felh\u0151 alap\u00fa szolg\u00e1ltat\u00e1sokb\u00f3l veszik a bemenetet, illetve ezek szolg\u00e1lnak kimenetk\u00e9nt. Egy nagyobb term\u00e9k eset\u00e9ben - mikor sok ezer teszt van - ez a lass\u00fas\u00e1g korl\u00e1toz\u00f3 t\u00e9nyez\u0151, ritk\u00e1bban tudjuk futtatni \u00e9s/vagy nem tudunk j\u00f3 tesztlefedetts\u00e9get el\u00e9rni.</li> </ul> <p>A fentiek miatt sokszor nagyobb k\u00f3dlefedetts\u00e9get nem a lassabb integr\u00e1ci\u00f3s, hanem nagyon gyorsan fut\u00f3 egys\u00e9gtesztekkel szoktunk/tudunk el\u00e9rni. Ezek mindenf\u00e9le lass\u00fa f\u00e1jl/adatb\u00e1zis/h\u00e1l\u00f3zat/felh\u0151 el\u00e9r\u00e9s n\u00e9lk\u00fcl \u00f6nmag\u00e1ban egy-egy logikai egys\u00e9get tesztelnek a k\u00f3dban, ezt viszont \u00edgy m\u00e1r vill\u00e1mgyorsan. \u00cdgy sokat tudunk futtatni adott id\u0151 alatt, j\u00f3 tesztlefedetts\u00e9ggel.</p> <p>Tesztpiramis</p> <p>Ezt egy tesztpiramissal szok\u00e1s szeml\u00e9ltetni, melynek t\u00f6bb form\u00e1ja terjedt el az irodalomban. Egy egyszer\u0171 vari\u00e1ns a k\u00f6vetkez\u0151:</p> <p></p> <p>Min\u00e9l fentebb vagyunk a piramis r\u00e9tegeiben, ann\u00e1l \u00e1tfog\u00f3bbak ugyan a tesztek, de ann\u00e1l lassabbak \u00e9s k\u00f6lts\u00e9gesebben is futtathat\u00f3k. \u00cdgy ezekb\u0151l \u00e1ltal\u00e1ban kevesebbet is k\u00e9sz\u00edt\u00fcnk (ez\u00e1ltal kisebb k\u00f3dlefedetts\u00e9get is \u00e9r\u00fcnk el vel\u00fck). A piramis talapzat\u00e1ban az egys\u00e9gtesztek vannak, ezekb\u0151l k\u00e9sz\u00edt\u00fcnk a legt\u00f6bbet.</p> <p>Fun fact: Amikor egy term\u00e9k fejleszt\u00e9se sor\u00e1n hossz\u00fa ideig elhanyagolj\u00e1k az egys\u00e9gtesztek k\u00e9sz\u00edt\u00e9s\u00e9t, akkor - mivel a k\u00f3d szerkezete nem t\u00e1mogatja - m\u00e1r nagyon neh\u00e9z egys\u00e9gteszteket ut\u00f3lag k\u00e9sz\u00edteni. \u00cdgy ezekb\u0151l csak nagyon kev\u00e9s lesz, n\u00e9mi integr\u00e1ci\u00f3s tesztekkel kieg\u00e9sz\u00edtve, \u00e9s jobb h\u00edj\u00e1n tesztel\u0151csapatok \u00e1ltal elk\u00e9sz\u00edtett sok-sok end-to-end teszttel (de ezzel sokszor nem lehet j\u00f3 tesztlefedetts\u00e9get el\u00e9rni egy komplex term\u00e9kben). \u00cdgy egy feje tetej\u00e9re \u00e1ll\u00edtott tesztpiramist kapunk: ennek fagyit\u00f6lcs\u00e9r form\u00e1ja van, csak p\u00e1r gomb\u00f3cot kell a tetej\u00e9re k\u00e9pzelni. Szok\u00e1s ezt fagyi \"mint\u00e1nak\" is nevezni (\u00e9s ez nem az a fagyi, amit szeret\u00fcnk). Azt az\u00e9rt \u00e9rdemes megjegyezni, hogy mindent a hely\u00e9n kell kezelni: az\u00e9rt vannak kiv\u00e9telek (olyan alkalmaz\u00e1sok, ahol az egyes r\u00e9szekben alig van logika, az eg\u00e9sz alkalmaz\u00e1sban az egyes nagyon egyszer\u0171 r\u00e9szek integr\u00e1ci\u00f3ja a hangs\u00falyos: ilyen esetben term\u00e9szetszer\u0171en az integr\u00e1ci\u00f3s tesztek t\u00fals\u00falyosak).</p> <p>Az oszt\u00e1lyok k\u00f3dja alapesetben sokszor nem egys\u00e9gtesztelhet\u0151. Jelen form\u00e1j\u00e1ban ilyen az <code>Anonymizer</code> is. Ebbe be van \u00e9getve, hogy csak a lass\u00fa, f\u00e1jl alap\u00fa bemenettel tud dolgozni. De amikor mi pl. a <code>Run</code> m\u0171velet logik\u00e1j\u00e1t szeretn\u00e9nk egys\u00e9gtesztelni, teljesen mindegy, hogy f\u00e1jlb\u00f3l j\u00f6nnek-e az adatok (lassan), vagy egyszer\u0171en k\u00f3db\u00f3l a <code>new</code> oper\u00e1torral el\u0151\u00e1ll\u00edtunk n\u00e9h\u00e1ny <code>Person</code> objektumot a tesztel\u00e9shez (t\u00f6bb nagys\u00e1grenddel gyorsabban).</p> <p>A megold\u00e1s - a k\u00f3dunk egys\u00e9gtesztelhet\u0151v\u00e9 t\u00e9tel\u00e9hez - egyszer\u0171:</p> <ul> <li> A Strategy (+DI) minta (vagy delegate-ek) alkalmaz\u00e1ssal v\u00e1lasszuk le az egys\u00e9gtesztelni k\u00edv\u00e1nt oszt\u00e1lyr\u00f3l a tesztel\u00e9st akad\u00e1lyoz\u00f3 vagy lass\u00edt\u00f3 (pl. bemenet/kimenet kezel\u00e9s) logik\u00e1kat. Ezeknek k\u00e9sz\u00edt\u00fcnk a val\u00f3di logik\u00e1t megval\u00f3s\u00edt\u00f3 implement\u00e1ci\u00f3it, illetve tesztel\u00e9st seg\u00edt\u0151, \u00fan. mock implement\u00e1ci\u00f3it.</li> </ul> <ul> <li> Ennek megfelel\u0151en a Strategy mint\u00e1t sokszor nem az\u00e9rt haszn\u00e1ljuk, mert az \u00fcgyf\u00e9lig\u00e9nyek miatt t\u00f6bbf\u00e9le viselked\u00e9st kell benevezni, hanem az\u00e9rt, hogy a k\u00f3dunk egys\u00e9gtesztelhet\u0151 legyen.</li> </ul> <p>Ennek megfelel\u0151en elk\u00e9sz\u00edtj\u00fck a megold\u00e1sunk egys\u00e9gtesztel\u00e9sre is el\u0151k\u00e9sz\u00edtett v\u00e1ltozat\u00e1t, melyben a bemenet \u00e9s kimenet kezel\u00e9se is le van v\u00e1lasztva a Strategy minta alkalmaz\u00e1s\u00e1val.</p> <p>Feladat: Alak\u00edtsd \u00e1t a Strategy-DI projektben tal\u00e1lhat\u00f3 megold\u00e1st olyan m\u00f3don, hogy az oszt\u00e1ly egys\u00e9g tesztelhet\u0151 legyen, m\u00e9gpedig a Strategy minta seg\u00edts\u00e9g\u00e9vel. R\u00e9szletesebben:</p> <ul> <li>Vezess be egy <code>InputReaders</code> mapp\u00e1t, melyben vezess be egy bemenet feldolgoz\u00f3 strategy interf\u00e9szt <code>IInputReader</code> n\u00e9ven (egyetlen, <code>List&lt;Person&gt; Read()</code> m\u0171velettel), \u00e9s az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l a Strategy mint\u00e1t k\u00f6vetve szervezd ki a bemenet feldolgoz\u00e1st egy <code>CsvInputReader</code> nev\u0171 strategy implement\u00e1ci\u00f3ba.</li> <li>Vezess be egy <code>ResultWriters</code> mapp\u00e1t, melyben vezess be egy eredm\u00e9ny ki\u00edr\u00f3 strategy interf\u00e9szt <code>IResultWriter</code> n\u00e9ven (egyetlen, <code>void Write(List&lt;Person&gt; persons)</code> m\u0171velettel), \u00e9s az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l a Strategy mint\u00e1t k\u00f6vetve szervezd ki a kimenet \u00edr\u00e1s\u00e1t egy <code>CsvResultWriter</code> nev\u0171 strategy implement\u00e1ci\u00f3ba. Ez az oszt\u00e1ly konstruktor param\u00e9terben kapja meg a f\u00e1jl \u00fatvonal\u00e1t, melybe a kimenetet bele kell \u00edrja.</li> <li>B\u0151v\u00edtsd ki a <code>Anonymizer</code> oszt\u00e1lyt, bele\u00e9rtve annak konstruktor\u00e1t (Strategy + DI minta), hogy b\u00e1rmilyen <code>IInputReader</code> \u00e9s <code>IResultWriter</code> implement\u00e1ci\u00f3val haszn\u00e1lhat\u00f3 legyen.</li> <li>A <code>Program.cs</code> f\u00e1jlban alak\u00edtsd \u00e1t az <code>Anonymizer</code> oszt\u00e1ly haszn\u00e1lat\u00e1t, hogy az \u00fajonnan bevezetett <code>CsvInputReader</code> \u00e9s <code>CsvResultWriter</code> oszt\u00e1lyok is \u00e1t legyenek param\u00e9terk\u00e9nt \u00e1tadva.</li> </ul> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9s egys\u00e9gtesztek k\u00e9sz\u00edt\u00e9se (lenne) az <code>Anonymizer</code> oszt\u00e1lyhoz. Ehhez olyan, \u00fan. mock strategy implement\u00e1ci\u00f3kat kell bevezetni, melyek nemcsak tesztadatokat szolg\u00e1ltatnak (term\u00e9szetesen gyorsan, f\u00e1jlkezel\u00e9s n\u00e9lk\u00fcl), hanem ellen\u0151rz\u00e9seket is v\u00e9geznek (adott logikai egys\u00e9g val\u00f3ban j\u00f3l m\u0171k\u00f6dik-e). Ez most bonyolultnak hangzik, de szerencs\u00e9re a legt\u00f6bb modern keretrendszerben van r\u00e1 k\u00f6nyvt\u00e1r t\u00e1mogat\u00e1s (.NET-ben a moq). Ennek alkalmaz\u00e1sa t\u00falmutat a t\u00e1rgy keretein, \u00edgy a feladatunk egys\u00e9gtesztelhet\u0151s\u00e9ghez kapcsol\u00f3d\u00f3 vonulat\u00e1t ebben a pontban lez\u00e1rjuk.</p> <p>3. feladat BEADAND\u00d3</p> <ul> <li>Illessz be egy k\u00e9perny\u0151k\u00e9pet, melyen az <code>Anonymizer</code> oszt\u00e1ly konstruktora \u00e9s a <code>Run</code> f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja l\u00e1tszik (<code>f3.1.png</code>).</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#4-delegate-ek-alkalmazasa","title":"4. Delegate-ek alkalmaz\u00e1sa","text":"<p>Napjainkban rohamosan terjed a kor\u00e1bban szigor\u00faan objektumorient\u00e1lt nyelvekben is a funkcion\u00e1lis programoz\u00e1st t\u00e1mogat\u00f3 eszk\u00f6z\u00f6k megjelen\u00e9se, \u00e9s az alkalmaz\u00e1sfejleszt\u0151k is egyre nagyobb szeretettel alkalmazz\u00e1k ezeket (merthogy sokszor jelent\u0151sen r\u00f6videbb k\u00f3ddal, kisebb \"cerem\u00f3ni\u00e1val\" lehet ugyanazt seg\u00edts\u00e9g\u00fckkel megval\u00f3s\u00edtani). Egy ilyen eszk\u00f6z C# nyelven a delegate, \u00e9s ehhez kapcsol\u00f3d\u00f3an a lambda kifejez\u00e9s.</p> <p>Mint a f\u00e9l\u00e9v sor\u00e1n kor\u00e1bban l\u00e1ttuk, delegate-ek seg\u00edts\u00e9g\u00e9vel olyan k\u00f3dot tudunk \u00edrni, melybe bizonyos logik\u00e1k/viselked\u00e9sek nincsenek be\u00e9getve, ezeket \"k\u00edv\u00fclr\u0151l\" kap meg a k\u00f3d. Pl. egy sorrendez\u0151 f\u00fcggv\u00e9nynek delegate form\u00e1j\u00e1ban adjuk \u00e1t param\u00e9terk\u00e9nt, hogyan kell k\u00e9t elemet \u00f6sszehasonl\u00edtani, vagy mely mez\u0151je/tulajdons\u00e1ga szerint kell az \u00f6sszehasonl\u00edt\u00e1st elv\u00e9gezni (\u00edgy v\u00e9gs\u0151 soron meghat\u00e1rozni a k\u00edv\u00e1nt sorrendet).</p> <p>Ennek megfelel\u0151en a delegate-ek alkalmaz\u00e1sa egy \u00fajabb alternat\u00edva (a Template Method \u00e9s a Strategy mellett) a k\u00f3d \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1/kiterjeszthet\u0151v\u00e9 t\u00e9tel\u00e9re, kiterjeszt\u00e9si pontok bevezet\u00e9s\u00e9re.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a kor\u00e1bban Strategy mint\u00e1val megval\u00f3s\u00edtott progress kezel\u00e9st alak\u00edtjuk \u00e1t delegate alap\u00fara (\u00faj funkci\u00f3t nem vezet\u00fcnk be, ez egy puszt\u00e1n \"technikai\" \u00e1talak\u00edt\u00e1s lesz).</p> <p>Feladat: Alak\u00edtsd \u00e1t a Strategy-DI projektben tal\u00e1lhat\u00f3 megold\u00e1st olyan m\u00f3don, hogy az progress kezel\u00e9s Strategy helyett delegate alapon legyen megval\u00f3s\u00edtva. R\u00e9szletesebben:</p> <ul> <li>Ne vezess be saj\u00e1t delegate t\u00edpust (haszn\u00e1ld a .NET \u00e1ltal biztos\u00edtott <code>Action</code> t\u00edpust).</li> <li>A megl\u00e9v\u0151 <code>SimpleProgress</code> \u00e9s <code>PercentProgress</code> oszt\u00e1lyokat ne haszn\u00e1ld a megold\u00e1sodban, ezeket r\u00f6videsen t\u00f6r\u00f6lni fogjuk (de egyel\u0151re ne t\u00f6r\u00f6ld).</li> <li>Legyen lehet\u0151s\u00e9ge az <code>Anonymizer</code> haszn\u00e1l\u00f3j\u00e1nak tov\u00e1bbiakban is null-t megadni a konstruktorban, ha nem k\u00edv\u00e1n semmif\u00e9le progress kezel\u00e9st haszn\u00e1lni.</li> <li>A <code>Program.cs</code> f\u00e1jlban kommentezd ki az eddigi <code>Anonymizer</code> haszn\u00e1latokat. Ugyanitt vezess be egy \u00faj p\u00e9ld\u00e1t az <code>Anonymizer</code> olyan haszn\u00e1lat\u00e1ra, melyben a progress kezel\u00e9s lambda kifejez\u00e9s form\u00e1j\u00e1ban van megadva, \u00e9s a lambda kifejez\u00e9s pontosan a kor\u00e1bbi \"simple progress\" logik\u00e1j\u00e1t val\u00f3s\u00edtja meg. A \"percent progress\"-re nem kell hasonl\u00f3t megval\u00f3s\u00edtani, azt ebben a megold\u00e1sban nem kell t\u00e1mogatni (a k\u00f6vetkez\u0151 feladatban t\u00e9r\u00fcnk vissza r\u00e1).</li> </ul> <p>Tippek</p> <ul> <li>A delegate alap\u00fa megold\u00e1s alapelve nagyon hasonl\u00edt a Strategy-hez: csak nem strategy-ket kap \u00e9s t\u00e1rol az oszt\u00e1ly tagv\u00e1ltoz\u00f3kban (interf\u00e9sz hivatkoz\u00e1sokon kereszt\u00fcl), hanem delegate-eket, \u00e9s az ezek \u00e1ltal hivatkozott f\u00fcggv\u00e9nyeket h\u00edvja a kiterjeszt\u00e9si pontokban.</li> <li>Ehhez hasonl\u00f3t m\u00e1r csin\u00e1lt\u00e1l is a 2. h\u00e1zi feladatban a ReportPrinter r\u00e9szben ;).</li> </ul> <p>4. feladat BEADAND\u00d3</p> <ul> <li>Illessz be egy k\u00e9perny\u0151k\u00e9pet, melyen az <code>Anonymizer</code> oszt\u00e1ly konstruktora \u00e9s a <code>Run</code> f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja l\u00e1tszik (<code>f4.1.png</code>).</li> <li>Illessz be egy k\u00e9perny\u0151k\u00e9pet, melyen a <code>Program.cs</code> f\u00e1jl tartalma (k\u00fcl\u00f6n\u00f6sen az \u00faj r\u00e9szek) l\u00e1tszik (<code>f4.2.png</code>).</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#5-delegate-ek-alkalmazasa-ujrafelhasznalhato-logikaval","title":"5. Delegate-ek alkalmaz\u00e1sa \u00fajrafelhaszn\u00e1lhat\u00f3 logik\u00e1val","text":"<p>Az el\u0151z\u0151 feladatban feltett\u00fck, hogy a \"simple progress\" \u00e9s a \"percent progress\" logik\u00e1j\u00e1t csak egyszer haszn\u00e1ltuk, \u00edgy nem kellett \u00fajrafelhaszn\u00e9lhat\u00f3v\u00e1 tenni. Ennek megfelel\u0151en pl. a \"simple progress\" logik\u00e1j\u00e1t a lehet\u0151 legegyszer\u0171bb form\u00e1ban, egy lambda kifejez\u00e9ssel adtuk meg (nem kellett k\u00fcl\u00f6n f\u00fcggv\u00e9nyt bevezetni r\u00e1). Amennyiben az <code>Anonymizer</code> l\u00e9trehoz\u00e1sakor a delegate-nek mindig m\u00e1s \u00e9s m\u00e1s implement\u00e1ci\u00f3t adunk meg, akkor ez a lambda alap\u00fa megold\u00e1s t\u00f6k\u00e9letes.</p> <p>Viszont mi a helyzet akkor, ha a fenti p\u00e9ld\u00e1ban szerepl\u0151 \"simple progress\" logik\u00e1t t\u00f6bb helyen, t\u00f6bb <code>Anonymizer</code> objektumn\u00e1l is fel szeretn\u00e9nk haszn\u00e1lni? S\u00falyos hiba lenne a lambda kifejez\u00e9st copy-paste-tel \"szapor\u00edtani\", k\u00f3dduplik\u00e1ci\u00f3hoz vezetne (ellentmondana a \"Do Not Repeat Yourself\", r\u00f6viden DRY elvnek).</p> <p>K\u00e9rd\u00e9s: van-e megold\u00e1s arra, hogy delegate-ek eset\u00e9ben is \u00fajrafelhaszn\u00e1lhat\u00f3 k\u00f3dot adjunk meg? Term\u00e9szetesen igen, hiszen delegate-ek eset\u00e9ben nem k\u00f6telez\u0151 a lambda kifejez\u00e9sek haszn\u00e1lata, lehet vel\u00fck k\u00f6z\u00f6ns\u00e9ges m\u0171veletekre (ak\u00e1r statikus, ak\u00e1r nem statikusakra is), mint azt kor\u00e1bban a f\u00e9l\u00e9v sor\u00e1n l\u00e1ttuk, \u00e9s sz\u00e1mos esetben alkalmaztuk is.</p> <p>Amennyiben a \"simple progress\" \u00e9s/vagy \"percent progress\" logik\u00e1t/logik\u00e1kat \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 szeretn\u00e9nk tenni delegate-ek alkalmaz\u00e1sakor, tegy\u00fck ezeket egy k\u00fcl\u00f6n f\u00fcggv\u00e9nyekbe valamilyen, az adott esetben legink\u00e1bb passzol\u00f3 oszt\u00e1lyba/oszt\u00e1lyokba, \u00e9s egy ilyen m\u0171veletet adjuk meg az <code>Anonymizer</code> konstruktornak param\u00e9terk\u00e9nt.</p> <p>Feladat: B\u0151v\u00edtsd ki a kor\u00e1bbi megold\u00e1st \u00fagy, hogy a \"simple progress\" \u00e9s \"percent progress\" logik\u00e1ja \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. R\u00e9szletesebben:</p> <ul> <li>A \"simple progress\" \u00e9s \"percent progress\" logik\u00e1kat egy \u00fajonnan bevezetett <code>AllProgresses</code> nev\u0171 statikus oszt\u00e1ly k\u00e9t statikus m\u0171velet\u00e9ben val\u00f3s\u00edtsd meg (az oszt\u00e1ly a projekt gy\u00f6ker\u00e9be ker\u00fclj\u00f6n).</li> <li>Vezess be k\u00e9t olyan \u00faj <code>Anonymizer</code> haszn\u00e1latot a <code>Program.cs</code> f\u00e1jlban, melyek az <code>AllProgresses</code> k\u00e9t m\u0171velet\u00e9t haszn\u00e1lj\u00e1k (itt ne haszn\u00e1lj lambda kifejez\u00e9st)-</li> <li>T\u00f6r\u00f6ld a megl\u00e9v\u0151 <code>IProgress</code> interf\u00e9szt \u00e9s ennek implement\u00e1ci\u00f3t (hiszen ezek m\u00e1r nincsenek haszn\u00e1latban).</li> </ul> <p>Elk\u00e9sz\u00fclt\u00fcnk, \u00e9rt\u00e9kelj\u00fck a megold\u00e1st:</p> <ul> <li>Kijelenthet\u0151, hogy a delegate alap\u00fa megold\u00e1s a Strategy-n\u00e9l kisebb cerem\u00f3ni\u00e1val j\u00e1rt: nem kellett interf\u00e9szt \u00e9s implement\u00e1ci\u00f3s oszt\u00e1lyokat bevezetni (a be\u00e9p\u00edtett <code>Action</code> \u00e9s <code>Func</code> generikus delegate t\u00edpusokat tudtuk haszn\u00e1lni).</li> <li>A teljesen \"eseti\" logik\u00e1t lambda kifejez\u00e9s form\u00e1j\u00e1ban legegyszer\u0171bb megadni. Ha \u00fajrafelhaszn\u00e1lhat\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g, akkor viszont vezess\u00fcnk be \"hagyom\u00e1nyos\", \u00fajrafelhaszn\u00e1lhat\u00f3 f\u00fcggv\u00e9nyeket.</li> </ul> <p>5. feladat BEADAND\u00d3</p> <ul> <li>Illessz be egy k\u00e9perny\u0151k\u00e9pet, melyen az <code>AllProgresses.cs</code> f\u00e1jl tartalma l\u00e1tszik (<code>f5.1.png</code>).</li> <li>Illessz be egy k\u00e9perny\u0151k\u00e9pet, melyen a <code>Program.cs</code> f\u00e1jl tartalma (k\u00fcl\u00f6n\u00f6sen az \u00faj r\u00e9szek) l\u00e1tszik (<code>f5.2.png</code>).</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#refaktoralas-refactoring","title":"Refaktor\u00e1l\u00e1s (Refactoring)","text":"<p>A labor \u00e9s a h\u00e1zi feladat megval\u00f3s\u00edt\u00e1sa sor\u00e1n sz\u00e1mos olyan l\u00e9p\u00e9s volt, mely sor\u00e1n a k\u00f3dot \u00fagy alak\u00edtottuk \u00e1t, hogy az alkalmaz\u00e1s k\u00fcls\u0151 viselked\u00e9se nem v\u00e1ltozott, csak a bels\u0151 fel\u00e9p\u00edt\u00e9se. M\u00e9gpedig annak \u00e9rdek\u00e9ben, hogy valamilyen szempontb\u00f3l jobb k\u00f3dmin\u0151s\u00e9gi jellemz\u0151kkel rendelkezzen. Ezt a k\u00f3d <code>refaktor\u00e1l\u00e1s\u00e1nak</code> (angolul <code>refactoring</code>) nevezz\u00fck. Ez egy nagyon fontos fogalom, a mindennapi munka sor\u00e1n nagyon gyakran haszn\u00e1ljuk. K\u00fcl\u00f6n irodalma van, a fontosabb technik\u00e1kkal a k\u00e9s\u0151bbiekben \u00e9rdemes megismerkedni. A komolyabb fejleszt\u0151eszk\u00f6z\u00f6k be\u00e9p\u00edtetten t\u00e1mogatnak bizonyos refaktor\u00e1l\u00e1si m\u0171veleteket: a Visual Studio ebben nem a leger\u0151sebb, de az\u00e9rt p\u00e1r alapm\u0171veletet t\u00e1mogat (pl. Extract Method, Extract base class stb.). Manu\u00e1lisan gyakoroltuk, ennek kapcs\u00e1n k\u00fcl\u00f6n feladatunk nem lesz.</p>"},{"location":"hazi/6-tervezesi-mintak/#osszegzes","title":"\u00d6sszegz\u00e9s","text":"<p>T\u00f6bb feladat nem lesz \ud83d\ude0a. De ha k\u00edv\u00e1ncsi vagy pl. arra, hogy jelen megold\u00e1s mennyire tekinthet\u0151 \"t\u00f6k\u00e9letesnek\"/hi\u00e1nyosnak, illetve mikor \u00e9rdemes Template Methoddal, Strategyvel, vagy ink\u00e1bb delegate-ekkel dolgozni, akkor \u00e9rdemes elolvasnod az al\u00e1bbiakat, melyben \u00e9rt\u00e9kelj\u00fck a laboron elkezdett \u00e9s a h\u00e1zi feladat keret\u00e9ben befejezett megold\u00e1st.</p>"},{"location":"hazi/6-tervezesi-mintak/#a-munkafolyamatunk-attekintese","title":"A munkafolyamatunk \u00e1ttekint\u00e9se","text":"<ul> <li>A v\u00e1ltoz\u00f3 ig\u00e9nyek sor\u00e1n organikusan jelentek meg tervez\u00e9si mint\u00e1k, \u00e9s vezett\u00fcnk be egy\u00e9b technik\u00e1kat a refaktor\u00e1l\u00e1sok sor\u00e1n. Ez teljesen term\u00e9szetes, a gyakorlatban is sokszor \u00edgy dolgozunk.</li> <li>Egy komplexebb feladat eset\u00e9ben egy\u00e9bk\u00e9nt is sokszor - k\u00fcl\u00f6n\u00f6sen ha nem rendelkez\u00fcnk sok\u00e9ves tapasztalattal - egy egyszer\u0171bb implement\u00e1ci\u00f3val indulunk (ezt l\u00e1tjuk \u00e1t els\u0151re), \u00e9s alak\u00edtjuk \u00e1t olyanra, hogy az adott kontextusban k\u00edv\u00e1nt kiterjeszthet\u0151s\u00e9gi/\u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1gi param\u00e9terekkel rendelkezzen.</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#ujrafelhasznalhatosagi-es-kiterjeszthetoseg-szintjei-az-egyes-megoldasokban","title":"\u00dajrafelhaszn\u00e1lhat\u00f3s\u00e1gi \u00e9s kiterjeszthet\u0151s\u00e9g szintjei az egyes megold\u00e1sokban","text":"<p>Megpr\u00f3b\u00e1lhatjuk \u00e1br\u00e1ba \u00f6nteni, hogy v\u00e1lt a megold\u00e1sunk az egyes iter\u00e1ci\u00f3kkal egyre ink\u00e1bb \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 \u00e9s kiterjeszthet\u0151v\u00e9:</p> <p></p> <p>Term\u00e9szetesen a % szinteket nem szabad t\u00fal komolyan venni. Mindenesetre a fejl\u0151d\u00e9s j\u00f3l megfigyelhet\u0151.</p> Mi\u00e9rt \"csak\" 70%-os a v\u00e9gs\u0151 megold\u00e1sn\u00e1l mutat\u00f3nk? <p>Felmer\u00fclhet a k\u00e9rd\u00e9s, mi\u00e9rt adunk jelem megold\u00e1sra kb. 70%-ot? T\u00f6bbek k\u00f6z\u00f6tt:</p> <ul> <li>Az <code>Anonymizer</code> oszt\u00e1lyba az adattiszt\u00edt\u00e1s m\u00f3dja mereven be van \u00e9getve (trimmel\u00e9s adott oszlopra adott m\u00f3don).</li> <li>Nem k\u00f6vett\u00fcnk egy nagyon fontos \u00e1ltal\u00e1nos alapelvet: a UI \u00e9s a logika k\u00fcl\u00f6nv\u00e1laszt\u00e1s\u00e1t. A k\u00f3dunk t\u00f6bb pontban konzolra \u00edr, \u00edgy p\u00e9ld\u00e1ul egy grafikus fel\u00fclettel nem haszn\u00e1lhat\u00f3!</li> <li>Bizonyos az anonimiz\u00e1l\u00f3 algoritmusaink nagyon specifikusak. Lehetne olyan \u00e1ltal\u00e1nosabb algoritmusokat k\u00e9sz\u00edteni, melyek tetsz\u0151leges mez\u0151ket kicsillagoznak (nem csak a nevet be\u00e9getetten), illetve tetsz\u0151leges mez\u0151ket s\u00e1vos\u00edtanak (nem csak az \u00e9letkort).</li> <li>Jelen megold\u00e1s csak <code>Person</code> objektumokkal tud m\u0171k\u00f6dni.</li> <li>Nem lehet egyszerre alkalmazni kombin\u00e1lni k\u00fcl\u00f6nb\u00f6z\u0151 anonimiz\u00e1l\u00f3 algoritmusokat.</li> </ul>"},{"location":"hazi/6-tervezesi-mintak/#kiterjesztesi-technikak-attekintese","title":"Kiterjeszt\u00e9si technik\u00e1k \u00e1ttekint\u00e9se","text":"<ul> <li>Template Method: Egyszer\u0171 esetben, ha a viselked\u00e9sek k\u00fcl\u00f6nb\u00f6z\u0151 aspektusainak nem kell sok keresztkombin\u00e1ci\u00f3j\u00e1t t\u00e1mogatni, nagyon k\u00e9nyelmes \u00e9s egyszer\u0171 megold\u00e1st ad, k\u00fcl\u00f6n\u00f6sen, ha egy\u00e9bk\u00e9nt is kell haszn\u00e1ljuk a sz\u00e1rmaztat\u00e1st. De nem, vagy csak nehezen egys\u00e9gtesztelhet\u0151 alaposzt\u00e1lyt eredm\u00e9nyez.</li> <li>Strategy: Nagyon rugalmas megold\u00e1st biztos\u00edt, \u00e9s nem vezet kombinatorikus robban\u00e1shoz, ha t\u00f6bb aspektus ment\u00e9n kell az oszt\u00e1lyt kiterjeszteni, \u00e9s t\u00f6bb keresztkombin\u00e1ci\u00f3ban is szeretn\u00e9nk ezeket haszn\u00e1lni. Sok esetben csak az\u00e9rt alkalmazzuk, hogy az oszt\u00e1lyunkr\u00f3l interf\u00e9szek seg\u00edts\u00e9g\u00e9vel lev\u00e1lasszuk a f\u00fcgg\u0151s\u00e9geit, \u00e9s \u00edgy egys\u00e9gtesztelhet\u0151v\u00e9 tegy\u00fck az oszt\u00e1lyunkat.</li> <li>Delegate/lambda: Ez a megk\u00f6zel\u00edt\u00e9s kisebb cerem\u00f3ni\u00e1val j\u00e1r, mint a Strategy alkalmaz\u00e1sa, ugyanis nincs sz\u00fcks\u00e9g interf\u00e9szek \u00e9s implement\u00e1ci\u00f3s oszt\u00e1lyok bevezet\u00e9s\u00e9re, emiatt egyre ink\u00e1bb (rohamosan) terjed a haszn\u00e1lata a modern objektumorient\u00e1lt nyelvekben is. K\u00fcl\u00f6n\u00f6sen akkor j\u00f6nnek ki az el\u0151nyei, ha a viselked\u00e9seket nem akarjuk \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 tenni (mert ekkor csak egy-egy lambda kifejez\u00e9ssel megadjuk ezeket, mindenf\u00e9le \u00faj oszt\u00e1lyok/k\u00fcl\u00f6n f\u00fcggv\u00e9nyek bevezet\u00e9se n\u00e9lk\u00fcl). </li> </ul> <p>\u00c9rdemes \u00f6sszeszedni, hogy a Strategy-nek mikor lehet/van van el\u0151nye a delegate-ekkel szemben:</p> <ul> <li>Ha kiterjesztend\u0151 oszt\u00e1ly adott aspektus\u00e1hoz t\u00f6bb (min\u00e9l t\u00f6bb, ann\u00e1l ink\u00e1bb) m\u0171velet tartozik. Ilyenkor a strategy interf\u00e9sz ezeket \"mag\u00e1t\u00f3l\" sz\u00e9pen \u00f6sszefogja, csoportos\u00edtja (mint a p\u00e9ld\u00e1nkban az <code>IAnonymizerAlgorithm</code> interf\u00e9sz az <code>Anonymize</code> \u00e9s <code>GetAnonymizerDescription</code> m\u0171veleteket). Ezek \u00e9rtelemszer\u0171en az interf\u00e9sz implement\u00e1ci\u00f3kban is egy\u00fctt jelennek meg (delegate-ek eset\u00e9ben nincs ilyen csoportos\u00edt\u00e1s). Ez \u00e1tl\u00e1that\u00f3bb\u00e1 teheti, sok m\u0171velet eset\u00e9n egy\u00e9rtelm\u0171en azz\u00e1 is teszi a megold\u00e1st.</li> <li>Az adott nyelv puszt\u00e1n objektumorient\u00e1lt, nem t\u00e1mogatja a delegate/lambda alkalmaz\u00e1s\u00e1t. De ma m\u00e1r a legt\u00f6bb modern OO nyelv szerencs\u00e9re t\u00e1mogatja valamilyen form\u00e1ban (Java \u00e9s C++ is).</li> <li> <p>A strategy implement\u00e1ci\u00f3k a tagv\u00e1ltoz\u00f3ikban \u00e1llapotot is tudnak t\u00e1rolni, melyet l\u00e9trehoz\u00e1sukkor meg tudunk adni. Ezt haszn\u00e1ltuk is (a <code>NameMaskingAnonymizerAlgorithm</code> eset\u00e9ben ilyen volt a <code>_mask</code>, a <code>AgeAnonymizerAlgorithm</code> eset\u00e9ben a <code>_rangeSize</code>). Ez nem azt jelenti, hogy ilyen esetben egy\u00e1ltal\u00e1n nem tudunk delegate-eket haszn\u00e1lni, hiszen:</p> <ul> <li>ezeket az adatokat ak\u00e1r \u00fajonnan bevezetett f\u00fcggv\u00e9ny param\u00e9terben is \u00e1tadhatjuk az egyes delegate h\u00edv\u00e1sok sor\u00e1n,</li> <li>illetve, lambda haszn\u00e1lata eset\u00e9n a \"variable capture\" mechanizmus seg\u00edts\u00e9g\u00e9vel a lambda f\u00fcggv\u00e9nyek tudnak \u00e1llapotot \u00e1tvenni k\u00f6rnyezet\u00fckb\u0151l.</li> </ul> <p>De ezek a megold\u00e1sok nem mindig alkalmazhat\u00f3k, vagy legal\u00e1bbis k\u00f6r\u00fclm\u00e9nyes lehet az alkalmaz\u00e1suk.</p> </li> </ul> <p>Mindenk\u00e9ppen meg kell eml\u00edteni, hogy nem csak jelen gyakorlatban eml\u00edtett n\u00e9h\u00e1ny minta szolg\u00e1lja a kiterjeszthet\u0151s\u00e9get \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got, hanem gyakorlatilag az \u00f6sszes. Most kiemelt\u00fcnk p\u00e1rat, melyek (m\u00e9g p. az Observert/Iteratort/Adaptert ide sorolva) tal\u00e1n a leggyakrabban, legsz\u00e9lesebb k\u00f6rben alkalmazhat\u00f3k \u00e9s bukkannak is fel keretrendszerekben.</p> <p>Ha id\u00e1ig olvastad, mindenk\u00e9ppen j\u00e1r egy extra thumbs up \ud83d\udc4d!</p>"},{"location":"hazi/beadas-ellenorzes/","title":"H\u00e1zi feladat bead\u00e1sa sor\u00e1n ellen\u0151rizend\u0151k","text":"<ul> <li>A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>A GitHub-r\u00f3l le\u00f6lt\u00f6tt kiindul\u00f3 solutionben/projektekben kell dolgozni, nem \u00fajonnan l\u00e9trehozottban.</li> <li>Am\u00edg nem vagy rutinos a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00e9l-e.</li> <li>A GitHub fel\u00fclet\u00e9n ellen\u0151rizd a push-t k\u00f6vet\u0151en, hogy a GitHub Action alap\u00fa el\u0151ellen\u0151rz\u0151 hiba n\u00e9lk\u00fcl lefutott-e.</li> <li>L\u00e9nyeges, hogy a feladatok csak akkor ker\u00fclnek elfogad\u00e1sra, ha teljesen elk\u00e9sz\u00fclnek, \u00e9s minden tekintetben teljes\u00edtik a k\u00f6vetelm\u00e9nyeket. Nem fordul\u00f3 k\u00f3d, illetve r\u00e9szleges megold\u00e1s elfogad\u00e1s\u00e1ban nem \u00e9rdemes b\u00edzni.</li> <li>Term\u00e9szetesen saj\u00e1t munk\u00e1t kell beadni (hiszen \u00e9rt\u00e9kel\u00e9sre ker\u00fcl).</li> </ul>"},{"location":"hazi/beadas-ellenorzes/index_ger/","title":"Bei der Abgabe von Hausaufgaben sollten Sie Folgendes \u00fcberpr\u00fcfen","text":"<ul> <li>Geben Sie in der Datei neptun.txt im Stammverzeichnis des Repositorys Ihren Neptun-Code in Gro\u00dfbuchstaben ein. Die Datei sollte nur diese sechs Zeichen enthalten und nichts anderes.</li> <li>Sie sollten in den urspr\u00fcnglichen L\u00f6sungen/Projekten arbeiten, die Sie von GitHub heruntergeladen haben, und nicht in neu erstellten Projekten.</li> <li>Solange Sie nicht mit Visual Studio Git vertraut sind, sollten Sie nach dem Push (sp\u00e4testens wenn die Hausarbeit als eingereicht gilt) \u00fcberpr\u00fcfen, ob Sie alle \u00c4nderungen hochgeladen haben, indem Sie sich die Dateien im Repository auf der GitHub-Weboberfl\u00e4che ansehen.</li> <li>\u00dcberpr\u00fcfen Sie in der GitHub-Schnittstelle nach dem Push, ob der GitHub Action-basierte Pre-Validator fehlerfrei gelaufen ist.</li> <li>Es ist wichtig, dass Aufgaben nur angenommen werden, wenn sie vollst\u00e4ndig abgeschlossen sind und den Anforderungen in jeder Hinsicht entsprechen. Nicht rotierenden Codes oder Teill\u00f6sungen sollte man nicht trauen.</li> <li>Nat\u00fcrlich m\u00fcssen Sie Ihre eigene Arbeit einreichen (da sie bewertet wird).</li> </ul>"},{"location":"hazi/eloellenorzes-ertekeles/","title":"A h\u00e1zi feladat el\u0151ellen\u0151rz\u00e9se \u00e9s hivatalos \u00e9rt\u00e9kel\u00e9se","text":"<p>Minden egyes alkalommal, miut\u00e1n a GitHub-ra push-olt\u00e1l k\u00f3dot, a GitHub-on automatikusan lefut a felt\u00f6lt\u00f6tt k\u00f3d (el\u0151)ellen\u0151rz\u00e9se, \u00e9s meg lehet n\u00e9zni a kimenet\u00e9t! Az ellen\u0151rz\u0151t maga a GitHub futtatja. A push-t k\u00f6vet\u0151en a feladat egy v\u00e1rakoz\u00e1si sorba ker\u00fcl, majd adott id\u0151 ut\u00e1n lefutnak az ellen\u0151rz\u0151 tesztek. Azt nem lehet tudni, mennyi ez az id\u0151, a GitHub-on m\u00falik. Amikor csak egy-k\u00e9t feladat van a sorban a szervezetre (ez n\u00e1lunk a t\u00e1rgy), akkor a tapasztalatok alapj\u00e1n az ellen\u0151rz\u00e9s 1-2 percen bel\u00fcl elindul. De ha a t\u00e1rgy alatt egyszerre sokan kezdik majd felt\u00f6lteni a megold\u00e1st, akkor ez j\u00f3 es\u00e9llyel belassul. Nem \u00e9rdemes ez\u00e9rt sem az utols\u00f3 pillanatra hagyni a bead\u00e1st: lehet, hogy ekkor a k\u00e9sleltet\u00e9sek miatt m\u00e1r nem kapsz esetleg id\u0151ben visszajelz\u00e9st.</p> <p> Hivatalosan a feladat azon \u00e1llapota ker\u00fcl \u00e9rt\u00e9kel\u00e9sre, amely a hat\u00e1rid\u0151 lej\u00e1rtakor GitHub-on fent van. A hivatalos ellen\u0151rz\u00e9st szok\u00e1sos m\u00f3don, saj\u00e1t, oktat\u00f3i k\u00f6rnyezetben v\u00e9gezz\u00fck \u00e9s az eredm\u00e9nyt Moodleben publik\u00e1ljuk a sz\u00e1monk\u00e9r\u00e9sn\u00e9l. Vagyis a hivatalos eredm\u00e9ny tekintet\u00e9ben teljesen mindegy, hogy a GitHub-on a hat\u00e1rid\u0151 lej\u00e1rta lefutott-e m\u00e1r b\u00e1rmif\u00e9le (el\u0151)ellen\u0151rz\u00e9s, vagy hogy az ellen\u0151rz\u00e9s esetleg csak k\u00e9s\u0151bb tudott elindulni. A GitHub \u00e1ltali ellen\u0151rz\u00e9s csak azt a c\u00e9lt szolg\u00e1lja, hogy m\u00e9g a hat\u00e1rid\u0151 lej\u00e1rta el\u0151tt visszajelz\u00e9st kaphasson mindenki. A hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1ni hivatalos ellen\u0151rz\u00e9s tartalmaz m\u00e9g plusz l\u00e9p\u00e9seket a GitHub alap\u00fa el\u0151ellen\u0151rz\u00e9shez k\u00e9pest, az el\u0151ellen\u0151rz\u00e9s ilyen \u00e9rtelemben r\u00e9szleges, de az\u00e9rt sok probl\u00e9m\u00e1t seg\u00edthet megfogni!</p> <p> Arra k\u00e9r\u00fcnk, hogy ne apr\u00e1nk\u00e9nt push-olj, csak a k\u00e9sz, \u00e1tn\u00e9zett, fordul\u00f3 megold\u00e1st tedd fel! Ez nem a legszerencs\u00e9sebb, de a GitHub korl\u00e1tozott id\u0151t biztos\u00edt az ellen\u0151rz\u0151k futtat\u00e1s\u00e1ra: ha elfogy a havi keret, akkor m\u00e1r nem fogsz visszajelz\u00e9st kapni, csak a hat\u00e1rid\u0151 ut\u00e1ni hivatalos ellen\u0151rz\u00e9s kimenet\u00e9t kapja meg mindenki.</p> <p>A (f\u00e9l)automata ellen\u0151rz\u0151, most m\u00e9g egy r\u00e9szben k\u00eds\u00e9rleti projekt. Ha valaki az \u00fatmutat\u00f3ban inkonzisztenci\u00e1t tal\u00e1l, vagy az ellen\u0151rz\u0151 adott helyzetet nem kezel \u00e9s indokolatlanul panaszkodik, Benedek Zolt\u00e1n felel\u0151s oktat\u00f3 fel\u00e9 legyen sz\u00edves jelezni! Ugyanakkor ezeket nagy t\u00f6megben nem fogjuk tudni kezelni. Ha j\u00f3 a megold\u00e1sod, \u00e9s az ellen\u0151rz\u0151 indokolatlanul panaszkodik, a hivatalos ellen\u0151rz\u00e9s sor\u00e1n term\u00e9szetesen el fogjuk fogadni.</p> <p>Az el\u0151ellen\u0151rz\u0151 \u2013 k\u00fcl\u00f6n\u00f6sen az els\u0151 h\u00e1zi feladat eset\u00e9ben \u2013 sokszor el\u00e9gg\u00e9 \"g\u00e9pk\u00f6zeli megfogalmaz\u00e1sban\" jelzi az esetleges probl\u00e9m\u00e1kat. Ha semmik\u00e9ppen nem tudod \u00e9rtelmezni, \u00edrj Benedek Zolt\u00e1nnak Teams-ben, a hiba\u00fczenet megad\u00e1s\u00e1val, illetve egy linkkel a GitHub repository-dra  (m\u00e1sk\u00fcl\u00f6nben nem tudjuk, hol tal\u00e1lhat\u00f3 a k\u00f3dod).</p> <p>Az, hogy az el\u0151ellen\u0151rz\u0151 milyen m\u00e9lys\u00e9gben ellen\u0151rzi a megold\u00e1st, a h\u00e1zi feladatt\u00f3l f\u00fcgg. Az 1-3 feladat eset\u00e9ben el\u00e9g alapos, m\u00edg a 4-5 feladat eset\u00e9n csak a Neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi, \u00e9s azt, van-e ford\u00edt\u00e1si hiba (az \u00e9rdemi \u00e9rt\u00e9kel\u00e9s ut\u00f3lag t\u00f6rt\u00e9nik).</p>"},{"location":"hazi/eloellenorzes-ertekeles/#a-github-altal-futtatott-ellenorzesek-megtekintese","title":"A GitHub \u00e1ltal futtatott ellen\u0151rz\u00e9sek megtekint\u00e9se","text":"<ol> <li>GitHub-on a navig\u00e1l\u00e1s a repository-hoz</li> <li>Actions tabf\u00fclre v\u00e1lt\u00e1s</li> <li>Itt megjelenik egy t\u00e1bl\u00e1zat, minden push \u00e1ltal futtatott ellen\u0151rz\u00e9shez egy k\u00fcl\u00f6n sor, a tetej\u00e9n van legfrissebb. A sor elej\u00e9n lev\u0151 ikon jelzi a st\u00e1tuszt: v\u00e1r, fut, sikeres, sikertelen lehet. A sor sz\u00f6vege a Git commit neve.</li> <li> <p>Egy sorban a commit nev\u00e9n kattintva jelenik meg egy \u00e1tfog\u00f3 oldal az ellen\u0151rz\u0151 fut\u00e1s\u00e1r\u00f3l, ez sok inform\u00e1ci\u00f3t nem tartalmaz. Ezen az oldalon baloldalt kell a \"build\" vagy \"build-and-check\" (vagy hasonl\u00f3 nev\u0171) linken  kattintani, ez \u00e1tnavig\u00e1l az ellen\u0151rz\u00e9s r\u00e9szletes n\u00e9zet\u00e9re. Ez egy \u201e\u00e9l\u0151\u201d n\u00e9zet, ha fut a teszt, folyamatosan friss\u00fcl. Ha v\u00e9gzett, a csom\u00f3pontokat lenyitva lehet megn\u00e9zni az adott l\u00e9p\u00e9s kimenet\u00e9t.  Ha minden siker\u00fclt, egy ehhez hasonl\u00f3 n\u00e9zet l\u00e1that\u00f3:</p> <p></p> </li> <li> <p>Itt a legfontosabb tal\u00e1n a \"Run tests\" l\u00e9p\u00e9s. Ha valamelyik l\u00e9p\u00e9s sikertelen, pipa helyett piros x van a csom\u00f3pont elej\u00e9n, \u00e9s a csom\u00f3pontot kibontva a teszt kimenete utal a hiba ok\u00e1ra. Az els\u0151 h\u00e1zi feladat eset\u00e9ben az \"Error Message\"-re, ill. az \"Assert\"-re \u00e9rdemes sz\u00f6vegesen (control+F) keresni a kimenetben, ennek a k\u00f6rny\u00e9k\u00e9n szokott lenni hivatkoz\u00e1s a hiba ok\u00e1ra.</p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/","title":"Fejleszt\u0151k\u00f6rnyezet h\u00e1zi feladatokhoz","text":""},{"location":"hazi/fejlesztokornyezet/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok megold\u00e1s\u00e1hoz a Visual Studio 2022 fejleszt\u0151k\u00f6rnyezetet kell haszn\u00e1lni (a Visual Studio for Mac nem alkalmas). Ennek futtat\u00e1s\u00e1hoz Windows oper\u00e1ci\u00f3s rendszerre van sz\u00fcks\u00e9g.  Ha telep\u00edtve van m\u00e1r a g\u00e9p\u00fcnkre a Visual Studio 2022, akkor a Start men\u00fcb\u0151l ind\u00edtsuk el a \u201eVisual Studio Installer\u201d-t. Ez indul\u00e1skor ellen\u0151rzi, \u00e9rhet\u0151-e el Visual Studio-b\u00f3l \u00fajabb v\u00e1ltozat online, \u00e9s ha igen, az Update gombra kattintva ind\u00edtsuk is el a legfrissebb verzi\u00f3 telep\u00edt\u00e9s\u00e9t.</p> Mi\u00e9rt is van sz\u00fcks\u00e9g Visual Studiora \u00e9s Windowsra? <p>VS Code, illetve a Visual Studio for Mac a k\u00f6vetkez\u0151k miatt nem haszn\u00e1lhat\u00f3k:</p> <ul> <li>Nem t\u00e1mogatj\u00e1k az UML (szer\u0171) modellez\u00e9st, melyre az els\u0151 h\u00e1zi feladatn\u00e1l sz\u00fcks\u00e9g van.</li> <li>\u00c9rdemben nem t\u00e1mogatj\u00e1k a WinUI3 felhaszn\u00e1l\u00f3i fel\u00fclettel rendelkez\u0151 .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9t (erre a 3. h\u00e1zi feladatt\u00f3l kezd\u0151d\u0151en \u00e9p\u00edtenek bizonyos h\u00e1zi feladatok).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/#visual-studio-edition-ok","title":"Visual Studio edition-\u00f6k","text":"<p>A Visual Studionak t\u00f6bb kiad\u00e1sa l\u00e9tezik:</p> <ul> <li>A t\u00e1rgy teljes\u00edt\u00e9s\u00e9hez megfelel a Microsoft honlapj\u00e1r\u00f3l let\u00f6lthet\u0151 \u00e9s ingyenesen haszn\u00e1lhat\u00f3 Community edition.</li> <li>Term\u00e9szetesen a Professional \u00e9s Enterprise v\u00e1ltozatok is haszn\u00e1lhat\u00f3k, a t\u00e1rgy vonatkoz\u00e1s\u00e1ban ugyanakkor ezek \u00e9rdemi pluszt nem adnak. Ezek az egy\u00e9bk\u00e9nt fizet\u0151s v\u00e1ltozatok az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ingyenesen el\u00e9rhet\u0151k (a https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/#telepitendo-komponensek","title":"Telep\u00edtend\u0151 komponensek","text":"<p>A t\u00e1rgy els\u0151 el\u0151ad\u00e1sa r\u00f6viden kit\u00e9r a .NET k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltozataira (.NET Framework, .NET Core, .NET 5-8 \u00e9s  stb.). A feladatok megold\u00e1s\u00e1hoz a .NET 8-et haszn\u00e1ljuk a f\u00e9l\u00e9v sor\u00e1n. A Visual Studio ezt telep\u00edti, de sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>Modify gombra kattint\u00e1s</li> <li>A megjelen\u0151 ablakban ellen\u0151rizz\u00fck, hogy a \".NET desktop development\" k\u00e1rtya ki van-e pip\u00e1lva.</li> <li>Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck.</li> </ol>"},{"location":"hazi/fejlesztokornyezet/#class-diagram-tamogatas","title":"Class diagram t\u00e1mogat\u00e1s","text":"<p>Bizonyos h\u00e1zi feladatok eset\u00e9n (m\u00e1r az els\u0151n\u00e9l is) sz\u00fcks\u00e9g van Visual Studio Class Diagram t\u00e1mogat\u00e1sra. Ezt a k\u00f6vetkez\u0151k\u00e9ppen tudjuk ut\u00f3lag telep\u00edteni a Visual Studio al\u00e1:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>Modify gombra kattint\u00e1s</li> <li>A megjelen\u0151 ablakban \"Individual components\" f\u00fcl kiv\u00e1laszt\u00e1sa</li> <li>A keres\u0151mez\u0151be \"class designer\" beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \"Class Designer\" elem ki van pip\u00e1lva.</li> <li> <p>Ha nincs, pip\u00e1ljuk ki, majd a jobb als\u00f3 sarokban a Modify gombra kattintva telep\u00edts\u00fck.</p> <p></p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/#winui-tamogatas","title":"WinUI t\u00e1mogat\u00e1s","text":"<p>XAML/WinUI technol\u00f3gi\u00e1khoz kapcsol\u00f3d\u00f3 feladatok eset\u00e9n (3. h\u00e1zi feladatt\u00f3l kezd\u0151d\u0151en) sz\u00fcks\u00e9g van Windows App SDK el\u0151zetes telep\u00edt\u00e9s\u00e9re \u00e9s bizonyos speci\u00e1lis g\u00e9pi szint\u0171 be\u00e1ll\u00edt\u00e1sok m\u00f3dos\u00edt\u00e1s\u00e1ra.</p> <ol> <li> <p>A sz\u00e1m\u00edt\u00f3g\u00e9pen enged\u00e9lyezni kell a \"Developer mode\" (\"Fejleszt\u0151i m\u00f3d\")-ot. A Windows Start men\u00fcben a \"Developer settings\"/\"Fejleszt\u0151i funkci\u00f3k\"-ra \u00e9rdemes keresni (annak f\u00fcggv\u00e9ny\u00e9ben hogy angol vagy magyar Windowst haszn\u00e1lunk).</p> </li> <li> <p>A Visual Studio telep\u00edt\u0151ben gy\u0151z\u0151dj\u00fcnk meg, hogy a \".NET Desktop Development\" workload telep\u00edtve van (ha nincs, pip\u00e1ljuk \u00e9s telep\u00edts\u00fck)</p> </li> <li> <p>\"Windows App SDK C# templates\" Visual Studio komponens telep\u00edt\u00e9se.</p> <p>A Visual Studio telep\u00edt\u0151ben v\u00e1lasszuk ki a \".NET Desktop Development\" workload-ot, jobb oldalt az \"Installation details\" panelen alul pip\u00e1ljuk a \"Windows App SDK C# Templates\" komponenst, majd jobb als\u00f3 sarokban \"Modify\" gomb. </p> </li> <li> <p>Windows App SDK telep\u00edt\u00e9se</p> <p>A legfrissebb innen telep\u00edthet\u0151: https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/downloads. Ugyanakkor a f\u00e9l\u00e9v sor\u00e1n laborokon, h\u00e1zikban az \"1.4.4 (1.4.231219000)\" verzi\u00f3t haszn\u00e1ljuk, \u00e9rdemes ezt telep\u00edteni akkor is, ha \u00fajabb verzi\u00f3 j\u00f6nne ki, mely innen \u00e9rhet\u0151 el: https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/older-downloads. Egy modern g\u00e9pre az x64-es verzi\u00f3t kell telep\u00edteni.</p> </li> <li> <p>Ha a fentiek telep\u00edt\u00e9se ut\u00e1n Windows 11-en nem akarna m\u0171k\u00f6dni, akkor fel kell tenni a Visual Studio telep\u00edt\u0151ben a Windows 10 SDK-b\u00f3l a 10.0.19041-et, vagy \u00fajabbat (az Idividual Comopnents alatt tal\u00e1lhat\u00f3)</p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/#macbook-es-linux-hasznalok-szamara-informaciok","title":"MacBook \u00e9s Linux haszn\u00e1l\u00f3k sz\u00e1m\u00e1ra inform\u00e1ci\u00f3k","text":"<p>A t\u00e1rgy felel\u0151s oktat\u00f3j\u00e1t\u00f3l (Benedek Zolt\u00e1n) BME Cloud hozz\u00e1f\u00e9r\u00e9s ig\u00e9nylelhet\u0151 e-mailben.</p>"},{"location":"hazi/fejlesztokornyezet/index_ger/","title":"Entwicklungsumgebung f\u00fcr Hausaufgaben","text":""},{"location":"hazi/fejlesztokornyezet/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>F\u00fcr die Hausaufgaben w\u00e4hrend des Semesters muss die Entwicklungsumgebung Visual Studio 2022 verwendet werden (Visual Studio f\u00fcr Mac ist nicht geeignet). Zum Ausf\u00fchren ben\u00f6tigen Sie ein Windows-Betriebssystem.  Wenn Sie Visual Studio 2022 bereits auf Ihrem Computer installiert haben, starten Sie den \"Visual Studio Installer\" \u00fcber das Startmen\u00fc. Dadurch wird beim Start gepr\u00fcft, ob eine neuere Version von Visual Studio online verf\u00fcgbar ist. Ist dies der Fall, klicken Sie auf Aktualisieren, um die Installation der neuesten Version zu starten.</p> Warum brauche ich Visual Studio und Windows? <p>VS Code oder Visual Studio f\u00fcr Mac kann aus folgenden Gr\u00fcnden nicht verwendet werden:</p> <ul> <li>Sie unterst\u00fctzen keine UML-\u00e4hnliche Modellierung, die f\u00fcr die erste Hausaufgabe ben\u00f6tigt wird.</li> <li>Sie unterst\u00fctzen nicht die Entwicklung von .NET-Anwendungen mit der Benutzeroberfl\u00e4che WinUI3 (einige Hausaufgaben ab Hausaufgabe 3 bauen darauf auf).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/index_ger/#visual-studio-ausgabe-ok","title":"Visual Studio Ausgabe-\u00f6k","text":"<p>Es gibt verschiedene Editionen von Visual Studio:</p> <ul> <li>Um den Kurs zu absolvieren, k\u00f6nnen Sie die kostenlose Community-Edition von der Microsoft-Website herunterladen.</li> <li>Die Professional- und Enterprise-Versionen k\u00f6nnen nat\u00fcrlich auch verwendet werden, bieten aber keinen inhaltlichen Mehrwert. Diese kostenpflichtigen Versionen sind f\u00fcr Universit\u00e4tsstudenten kostenlos erh\u00e4ltlich (unter https://azureforeducation.microsoft.com/devtools, als Teil des Azure Dev Tools for Teaching Programms).</li> </ul>"},{"location":"hazi/fejlesztokornyezet/index_ger/#zu-installierende-komponenten","title":"Zu installierende Komponenten","text":"<p>In der ersten Vorlesung des Kurses werden kurz die verschiedenen Versionen von .NET (.NET Framework, .NET Core, .NET 5-8 usw.) behandelt. Wir werden .NET 8 verwenden, um die Probleme w\u00e4hrend des Semesters zu l\u00f6sen. Visual Studio installiert dies, aber Sie m\u00fcssen den \".NET Desktop Development\" Visual Studio Workload installieren:</p> <ol> <li>Starten Sie das Visual Studio-Installationsprogramm (z. B. durch Eingabe von \"Visual Studio Installer\" im Windows-Startmen\u00fc).</li> <li>Klicken Sie auf die Schaltfl\u00e4che \u00c4ndern</li> <li>Vergewissern Sie sich in dem nun erscheinenden Fenster, dass die Karte \".NET-Desktop-Entwicklung\" aktiviert ist.</li> <li>Wenn nicht, entfernen Sie das H\u00e4kchen und klicken Sie unten rechts auf \u00c4ndern, um es zu installieren.</li> </ol>"},{"location":"hazi/fejlesztokornyezet/index_ger/#unterstutzung-von-klassendiagrammen","title":"Unterst\u00fctzung von Klassendiagrammen","text":"<p>F\u00fcr bestimmte Hausaufgaben (sogar f\u00fcr die erste) ben\u00f6tigen Sie die Unterst\u00fctzung von Visual Studio Class Diagram. Diese kann unter Visual Studio wie folgt installiert werden:</p> <ol> <li>Starten Sie das Visual Studio-Installationsprogramm (z. B. durch Eingabe von \"Visual Studio Installer\" im Windows-Startmen\u00fc).</li> <li>Klicken Sie auf die Schaltfl\u00e4che \u00c4ndern</li> <li>W\u00e4hlen Sie in dem nun erscheinenden Fenster die Registerkarte \"Einzelne Komponenten\"</li> <li>Geben Sie in das Suchfeld \"Klassendesigner\" ein und vergewissern Sie sich, dass \"Klassendesigner\" in der gefilterten Liste nicht angekreuzt ist.</li> <li> <p>Wenn nicht, entfernen Sie das H\u00e4kchen und klicken Sie unten rechts auf \u00c4ndern, um es zu installieren.</p> <p></p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/index_ger/#winui-unterstutzung","title":"WinUI-Unterst\u00fctzung","text":"<p>F\u00fcr Aufgaben, die sich auf XAML/WinUI-Technologien beziehen (ab Hausaufgabe 3), ist es notwendig, das Windows App SDK vorzuinstallieren und einige spezifische Einstellungen auf Maschinenebene zu \u00e4ndern.</p> <ol> <li> <p>Der \"Entwicklermodus\" muss auf dem Computer aktiviert sein. Suchen Sie im Windows-Startmen\u00fc nach \"Entwicklereinstellungen\" (je nachdem, ob Sie ein englisches oder ungarisches Windows verwenden).</p> </li> <li> <p>Vergewissern Sie sich im Visual Studio-Installationsprogramm, dass der \".NET Desktop Development\"-Workload installiert ist (falls nicht, entfernen Sie die Markierung und installieren Sie ihn)</p> </li> <li> <p>installation der Visual Studio Komponente \"Windows App SDK C# Templates\".</p> <p>W\u00e4hlen Sie im Visual Studio-Installationsprogramm den Workload \".NET Desktop Development\", markieren Sie die Komponente \"Windows App SDK C# Templates\" im Bereich \"Installationsdetails\" auf der rechten Seite und klicken Sie dann auf die Schaltfl\u00e4che \"\u00c4ndern\" in der rechten unteren Ecke. </p> </li> <li> <p>Windows-SDK installieren</p> <p>Es kann installiert werden von: https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/downloads. W\u00e4hrend des Semesters werden wir \"1.4.4 (1.4.231219000)\" in \u00dcbungen und Tutorien verwenden. Es wird empfohlen, diese Version zu installieren, auch wenn eine neuere Version ver\u00f6ffentlicht wird.</p> </li> </ol>"},{"location":"hazi/fejlesztokornyezet/index_ger/#informationen-fur-macbook-und-linux-benutzer","title":"Informationen f\u00fcr MacBook- und Linux-Benutzer","text":"<p>Sie k\u00f6nnen den Zugang zur BME-Cloud beim zust\u00e4ndigen Dozenten (Zolt\u00e1n Benedek) per E-Mail anfordern.</p>"},{"location":"hazi/git-github-github-classroom/","title":"Git, GitHub, GitHub Classroom","text":"<p>A t\u00e1rgy keret\u00e9ben nem c\u00e9lunk a Git \u00e9s GitHub r\u00e9szletes megismer\u00e9se, csak a legsz\u00fcks\u00e9gesebb l\u00e9p\u00e9sekre szor\u00edtkozunk, valamint a legfontosabb parancsokat haszn\u00e1ljuk ahhoz, hogy a h\u00e1zi feladat(ok) kiindul\u00e1si programv\u00e1z\u00e1t hallgat\u00f3k\u00e9nt egy dedik\u00e1lt GitHub repository-b\u00f3l le tudjuk t\u00f6lteni, illetve a k\u00e9sz munk\u00e1t GitHubra fel tudjuk t\u00f6lteni.</p>"},{"location":"hazi/git-github-github-classroom/#git","title":"Git","text":"<p>A Git egy sok szolg\u00e1ltat\u00e1ssal rendelkez\u0151, rendk\u00edv\u00fcl n\u00e9pszer\u0171 \u00e9s elterjedt, ingyenesen let\u00f6lthet\u0151 \u00e9s telep\u00edthet\u0151, elosztottan is haszn\u00e1lhat\u00f3 verzi\u00f3kezel\u0151 rendszer. A k\u00f6zpontos\u00edtott rendszerekhez k\u00e9pest (TFS, CVS, SVN) a GIT eset\u00e9ben nem egyetlen k\u00f6zponti repository-ba dolgoznak a fejleszt\u0151k, hanem mindenki egy saj\u00e1t lok\u00e1lis repository p\u00e9ld\u00e1nnyal rendelkezik.</p> <p>Egy Git repository (becenev\u00e9n rep\u00f3) nem m\u00e1s, mint egy k\u00f6z\u00f6ns\u00e9ges k\u00f6nyvt\u00e1r a f\u00e1jlrendszerben, benne \u00e1llom\u00e1nyokkal (pl. forr\u00e1sk\u00f3d) \u00e9s alk\u00f6nyvt\u00e1rakkal, illetve egy \".git\" alk\u00f6nyvt\u00e1rral, melyben minden, a verzi\u00f3kezel\u00e9shez kapcsol\u00f3d\u00f3 extra inform\u00e1ci\u00f3 megtal\u00e1lhat\u00f3.</p> <p>A Git alap\u00fa munkafolyamat legfontosabb l\u00e9p\u00e9sei - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel - a k\u00f6vetkez\u0151k (felt\u00e9ve, hogy l\u00e9tezik egy k\u00f6zponti repository, ahol a verzi\u00f3kezelt k\u00f3d adott v\u00e1ltozata m\u00e1r el\u00e9rhet\u0151):</p> <ol> <li>A fejleszt\u0151 kl\u00f3nozza (<code>clone</code>) az adott k\u00f6zponti repository-t, melynek sor\u00e1n egy azzal megegyez\u0151 helyi repository j\u00f6n l\u00e9tre a saj\u00e1t sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n. Ezt a m\u0171veletet el\u00e9g egyszer elv\u00e9gezni.</li> <li>A fejleszt\u0151 a helyi repository-hoz tartoz\u00f3 munkak\u00f6nyvt\u00e1rban (working directory) v\u00e1ltoztat\u00e1sokat v\u00e9gez a k\u00f3don: \u00faj f\u00e1jlokat vesz fel, megl\u00e9v\u0151ket m\u00f3dos\u00edt \u00e9s t\u00f6r\u00f6l.</li> <li>Ha elk\u00e9sz\u00fcl egy \u00e9rdemi r\u00e9szfeladat, akkor a fejleszt\u0151 a v\u00e1ltoztat\u00e1sokat <code>commit</code>-olja a sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n lev\u0151 helyi repository-ba. Ennek sor\u00e1n a commit-ot c\u00e9lszer\u0171 egy a v\u00e1ltoztat\u00e1sok jelleg\u00e9t j\u00f3l \u00f6sszefoglal\u00f3 megjegyz\u00e9ssel ell\u00e1tni.</li> <li>A helyi repository-b\u00f3l egy <code>push</code> m\u0171velettel a fejleszt\u0151 fel\u00f6lti a v\u00e1ltoz\u00e1sokat a k\u00f6zponti repository-ba, ahol \u00edgy v\u00e1ltoztat\u00e1sai m\u00e1sok sz\u00e1m\u00e1ra is l\u00e1that\u00f3v\u00e1 v\u00e1lnak.</li> </ol> <p>Minden egyes commit tulajdonk\u00e9ppen egy id\u0151b\u00e9lyeggel, a fejleszt\u0151 felhaszn\u00e1l\u00f3nev\u00e9vel \u00e9s e-mail c\u00edm\u00e9vel ell\u00e1tott k\u00f3dot \u00e9rint\u0151 v\u00e1ltoz\u00e1shalmaz. A repositoryban ezek \"egym\u00e1sut\u00e1nis\u00e1g\u00e1b\u00f3l\" \u00e1ll \u00f6ssze a teljes verzi\u00f3t\u00f6rt\u00e9net. Mivel a legt\u00f6bb esetben a fejleszt\u0151k csapatban dolgoznak, id\u0151nk\u00e9nt sz\u00fcks\u00e9g van arra, hogy m\u00e1sok \u00e1ltal a k\u00f6zponti repository-ba <code>push</code>-olt v\u00e1ltoztat\u00e1sokat a fejleszt\u0151k a saj\u00e1t lok\u00e1lis repository-jukba let\u00f6lts\u00e9k \u00e9s belemerge-elj\u00e9k: erre szolg\u00e1l a <code>pull</code> m\u0171velet. Fontos szab\u00e1ly, hogy <code>push</code>-olni csak akkor lehet a k\u00f6zponti repository-ba (a Git csak akkor engedi), ha el\u0151tte m\u00e1sok v\u00e1ltoztat\u00e1sait a saj\u00e1t lok\u00e1lis repository-nkba egy <code>pull</code> m\u0171velettel el\u0151tte belemerge-elt\u00fck. A Szoftvertechnik\u00e1k t\u00e1rgy keret\u00e9ben a <code>pull</code> m\u0171veletet nem kell haszn\u00e1lni, mert mindenki \u00f6n\u00e1ll\u00f3an, saj\u00e1t repository-ba dolgozik. Megjegyz\u00e9s: ha esetleg a GitHub fel\u00fclet\u00e9n k\u00f6zvetlen v\u00e1ltoztatunk f\u00e1jlokon (vagy t\u00f6bb clone-ban is dolgozunk), akkor sz\u00fcks\u00e9g van a <code>pull</code> haszn\u00e1lat\u00e1ra ez esetben is. A fentieken t\u00falmen\u0151en a Git sz\u00e1mos tov\u00e1bbi szolg\u00e1ltat\u00e1st biztos\u00edt (pl. teljes verzi\u00f3t\u00f6rt\u00e9net megtekint\u00e9se minden f\u00e1jlra, commit t\u00f6rt\u00e9net megtekint\u00e9se, tetsz\u0151leges m\u00faltbeli verzi\u00f3ra vissza\u00e1ll\u00e1s, \u00e1gak kezel\u00e9se stb.).</p>"},{"location":"hazi/git-github-github-classroom/#github","title":"GitHub","text":"<p>A GitHub egy online el\u00e9rhet\u0151 website \u00e9s szolg\u00e1ltat\u00e1s (https://github.com), mely teljes k\u00f6r\u0171 Git szolg\u00e1ltat\u00e1st biztos\u00edt. Mindezt r\u00e1ad\u00e1sul \u2013 legal\u00e1bbis publikus, vagyis mindenki sz\u00e1m\u00e1ra hozz\u00e1f\u00e9rhet\u0151 repositoryk vonatkoz\u00e1s\u00e1ban \u2013 teljesen ingyenesen biztos\u00edtja. Napjainkra a GitHub v\u00e1lt a k\u00f6z\u00f6ss\u00e9gi k\u00f3d (verzi\u00f3kezelt) t\u00e1rol\u00e1s\u00e1nak els\u0151 sz\u00e1m\u00fa platformj\u00e1v\u00e1, a legt\u00f6bb ny\u00edlt forr\u00e1sk\u00f3d\u00fa projekt \u201eotthon\u00e1v\u00e1\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#github-classroom","title":"GitHub Classroom","text":"<p>A GitHub Classroom egy ingyenesen el\u00e9rhet\u0151 GitHub-bal integr\u00e1lt szolg\u00e1ltat\u00e1s, mely t\u00f6bbek k\u00f6z\u00f6tt oktat\u00e1si int\u00e9zm\u00e9nyek sz\u00e1m\u00e1ra lehet\u0151v\u00e9 teszi \u00f6n\u00e1ll\u00f3 tanul\u00f3i feladatokhoz tartoz\u00f3, tanul\u00f3nk\u00e9nt egyedi GitHub repository-k l\u00e9trehoz\u00e1s\u00e1t, ez\u00e1ltal a kiindul\u00e1si k\u00f3d tanul\u00f3k sz\u00e1m\u00e1ra t\u00f6rt\u00e9n\u0151 \u201ekioszt\u00e1s\u00e1t\u201d, valamint az elk\u00e9sz\u00fclt feladatok \u201ebeszed\u00e9s\u00e9t\u201d.</p>"},{"location":"hazi/git-github-github-classroom/#git-github-es-github-classroom-a-targy-kontextusaban","title":"Git, GitHub \u00e9s GitHub Classroom a t\u00e1rgy kontextus\u00e1ban","text":"<p>A t\u00e1rgy keret\u00e9ben a GitHub Classroom seg\u00edts\u00e9g\u00e9vel kap minden hallgat\u00f3 minden h\u00e1zi feladat\u00e1hoz egy dedik\u00e1lt, a GitHub-on hostolt repository-t, mely a megfelel\u0151 kiindul\u00e1si k\u00f6rnyezettel (kiindul\u00f3 Visual Studio solution-\u00f6k) inicializ\u00e1l\u00e1sra ker\u00fcl. Mindenkinek a sz\u00e1m\u00e1ra dedik\u00e1lt repository-t kell a saj\u00e1t g\u00e9p\u00e9re <code>clone</code>-oznia, ebbe a v\u00e1ltoztat\u00e1sait <code>commit</code>-olni, \u00e9s a hat\u00e1rid\u0151ig az elk\u00e9sz\u00fclt megold\u00e1s\u00e1t <code>push</code>-olni (hogy GitHub-on is el\u00e9rhet\u0151 legyen a megold\u00e1s). A pontos l\u00e9p\u00e9sekre r\u00f6videsen visszat\u00e9r\u00fcnk.</p>"},{"location":"hazi/git-github-github-classroom/#visual-studio-es-a-git","title":"Visual Studio \u00e9s a Git","text":"<p>A Git egy elosztott verzi\u00f3kezel\u0151 rendszer. Ahhoz, hogy a saj\u00e1t g\u00e9p\u00fcnk\u00f6n dolgozni tudjunk vele, a Git-nek telep\u00edtve kell lennie. K\u00e9tf\u00e9le m\u00f3don tudjuk haszn\u00e1lni:</p> <ul> <li>A Git \u00f6nmag\u00e1ban is telep\u00edthet\u0151, \u00e9s parancssorb\u00f3l is ki tudjuk adni a sz\u00fcks\u00e9ges <code>clone</code>, <code>commit</code>, <code>push</code> stb. parancsokat.</li> <li>Haszn\u00e1lhatunk a parancsok kiad\u00e1s\u00e1ra egy grafikus fel\u00fclettel rendelkez\u0151 eszk\u00f6zt. Ilyenek pl. a GitHub Desktop, a GitExtensions, vagy maga a Visual Studio is (mely integr\u00e1lt grafikus Git szolg\u00e1ltat\u00e1sokat is biztos\u00edt).</li> </ul> <p>A k\u00e9t megk\u00f6zel\u00edt\u00e9st a mindennapokban kombin\u00e1ltan szoktuk haszn\u00e1lni. Egy repo lekl\u00f3noz\u00e1sa sokszor parancssorb\u00f3l a legegyszer\u0171bb/leggyorsabb. A v\u00e1ltoz\u00e1sok commit-ol\u00e1s\u00e1ra, a k\u00f6zponti repositoryval val\u00f3 szinkroniz\u00e1ci\u00f3ra (push, pull), a verzi\u00f3t\u00f6rt\u00e9nek megjelen\u00edt\u00e9s\u00e9re m\u00e1r c\u00e9lszer\u0171bb egy grafikus eszk\u00f6zt haszn\u00e1lni, k\u00fcl\u00f6n\u00f6sen akkor, ha m\u00e9g kev\u00e9sb\u00e9 vagyunk rutinosak. A t\u00e1rgy keret\u00e9ben a kl\u00f3noz\u00e1sra a parancssor vagy a Visual Studio, az egy\u00e9b parancsok kiad\u00e1s\u00e1ra a Visual Studio javasolt. A git haszn\u00e1latr\u00f3l (a h\u00e1zi feladatok kontextus\u00e1ban) itt tal\u00e1lhat\u00f3 b\u0151vebb le\u00edr\u00e1s.</p>"},{"location":"hazi/git-github-github-classroom/#git-telepitese","title":"Git telep\u00edt\u00e9se","text":"<p>Amennyiben a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre nincs m\u00e9g a Git telep\u00edtve, \u00e9s szeretn\u00e9nk azt parancssorb\u00f3l is haszn\u00e1lni, akkor innen telep\u00edthet\u0151 Windows oper\u00e1ci\u00f3s rendszerre: https://git-scm.com/download/win. Egy\u00e9b oper\u00e1ci\u00f3s rendszerek eset\u00e9n pedig innen \u00e9rdemes indulni: https://git-scm.com/downloads.</p> <p>Git Credential Manager telep\u00edt\u00e9se</p> <p>A GitHub m\u00e1r egy ideje nem t\u00e1mogatja az egyszer\u0171 felhaszn\u00e1l\u00f3n\u00e9v/jelsz\u00f3 alap\u00fa hiteles\u00edt\u00e9st. Ha git parancssorban a login sor\u00e1n \"Support for password authentication was removed.\" hiba\u00fczenetet kapunk, ez az oka. K\u00e9t megold\u00e1s is l\u00e9tezik a probl\u00e9ma megold\u00e1s\u00e1ra: </p> <ul> <li>A legegyszer\u0171bb megold\u00e1s a \"Git Credential Manager\" telep\u00edt\u00e9se. Ezt fel lehet telep\u00edten a git telep\u00edt\u00e9se sor\u00e1n (csak be kell pip\u00e1lni a telep\u00edt\u0151ben), de k\u00fcl\u00f6n is telep\u00edthet\u0151 innen. A telep\u00edt\u00e9st k\u00f6vet\u0151en nincs teend\u0151nk vele, a git automatikusan haszn\u00e1lni fogja, \u00e9s egy b\u00f6ng\u00e9sz\u0151 alap\u00fa (\u00fan. OAuth) hiteles\u00edt\u00e9si folyamaton vezeti v\u00e9gig a felhaszn\u00e1l\u00f3t, ill. plusz k\u00e9nyelmi funkci\u00f3k\u00e9nt meg is jegyzi a hiteles\u00edt\u00e9si adatokat.</li> <li>A m\u00e1sik megold\u00e1s a PAT (Personal Access Token) haszn\u00e1lata, err\u0151l pl. itt lehet olvasni.</li> </ul>"},{"location":"hazi/hf-folyamat/","title":"H\u00e1zi feladat munkafolyamat \u00e9s a Git/GitHub haszn\u00e1lata","text":"<p>Ha m\u00e9g nem olvastad, c\u00e9lszer\u0171 itt kezdeni: Git, GitHub, GitHub Classroom</p>"},{"location":"hazi/hf-folyamat/#lepesek","title":"L\u00e9p\u00e9sek","text":"<p>Az egyes h\u00e1zi feladatok kiindul\u00f3 keret\u00e9t GitHub/GitHub Classroom seg\u00edts\u00e9g\u00e9vel publik\u00e1ljuk. Az \u00edgy publik\u00e1lt h\u00e1zi feladatok kiindul\u00f3 k\u00f6rnyezet let\u00f6lt\u00e9s\u00e9nek \u00e9s a megold\u00e1s bead\u00e1s\u00e1nak l\u00e9p\u00e9sei a k\u00f6vetkez\u0151k:</p> <ol> <li> Az elindul\u00e1ssal ne v\u00e1rd meg a hat\u00e1rid\u0151 k\u00f6zeledt\u00e9t, legal\u00e1bb a saj\u00e1t repository l\u00e9trehoz\u00e1s\u00e1ig juss el miel\u0151bb. \u00cdgy, ha b\u00e1rmi elakad\u00e1s lenne, m\u00e9g id\u0151ben tudunk seg\u00edteni.</li> <li>Regisztr\u00e1lj egy GitHub accountot (https://github.com/), ha m\u00e9g nem regisztr\u00e1lt\u00e1l, \u00e9s l\u00e9pj be vele GitHub-ra.</li> <li>A feladathoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, Moodle-ben ker\u00fclnek meghirdet\u00e9sre fokozatosan a f\u00e9l\u00e9v folyam\u00e1n. A form\u00e1tuma a k\u00f6vetkez\u0151h\u00f6z hasonl\u00f3: https://classroom.github.com/abcdefgh. Ha a hivatkoz\u00e1sra kattintva hib\u00e1t kapsz (\"There was a problem authenticating with GitHub, please try again.\"), copy-paste-tel m\u00e1sold be k\u00f6zvetlen\u00fcl a b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba a c\u00edmet.</li> <li>Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat.</li> <li>L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept this assignment\"). Kattints a gombra.</li> <li>V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A GitHub nem mindig friss\u00edti az oldalt mag\u00e1t\u00f3l, c\u00e9lszer\u0171 az oldal id\u0151nk\u00e9nti k\u00e9zi friss\u00edt\u00e9s\u00e9vel pr\u00f3b\u00e1lkozni (pl. F5 billenty\u0171). Ha elk\u00e9sz\u00fclt a repository, az oldal ki\u00edrja az \u00faj repository url-j\u00e9t, amin kattintva a repository-ra lehet navig\u00e1lni (ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2024-username).  De nem is felt\u00e9tlen sz\u00fcks\u00e9ges az url elment\u00e9se, a GitHub nyit\u00f3oldal\u00e1n (https://github.com/) baloldalt a saj\u00e1t repository-k k\u00f6zt b\u00e1rmikor meg lehet k\u00e9s\u0151bb is tal\u00e1lni.</li> <li>Kl\u00f3nozd le a repository-t (ennek mik\u00e9ntj\u00e9re r\u00f6videsen visszat\u00e9r\u00fcnk). Ebben tal\u00e1lni fogsz egy keretet, vagy kiindul\u00f3 k\u00f3dot. Ezen dolgozz, ezt v\u00e1ltoztasd. Az alap\u00e9rtelmezett git \u00e1gon/branchen dolgozz (ha ez nem mond semmit, nem baj: ez csak azoknak sz\u00f3l, akik a git haszn\u00e1lat\u00e1ban j\u00e1rtasak \u00e9s t\u00f6bb \u00e1gon szoktak dolgozni).</li> <li> A kiindul\u00f3 projektben van egy .github/workflows mappa, ennek tartalm\u00e1t tilos megv\u00e1ltoztatni, t\u00f6r\u00f6lni stb.</li> <li> A munka sor\u00e1n a kiindul\u00e1si rep\u00f3ban lev\u0151 solutionben/projektben kell dolgozni, \u00faj projektet/solutiont ne hozz l\u00e9tre.</li> <li> A repository gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dod, csupa nagybet\u0171vel. A f\u00e1jlban csak ez a hat karakter legyen, semmi m\u00e1s.</li> <li>Oldd meg a feladatot. Pushold a hat\u00e1rid\u0151ig. Az alap\u00e9rtelmezett \"Main\" \u00e1gon kell dolgozni k\u00f6zvetlen\u00fcl, nincsenek pull requestek. Ak\u00e1rh\u00e1ny commitod lehet, a legutols\u00f3 \u00e1llapotot fogjuk n\u00e9zni.</li> <li>Az eredm\u00e9nyek Moodle-ben ker\u00fclnek meghirdet\u00e9sre (a nyit\u00f3oldalon kapcsol\u00f3d\u00f3 h\u00e1zi feladat oldal\u00e1t Moodle-ben megnyitva az oldal alj\u00e1n a \"Visszajelz\u00e9s\" szekci\u00f3ban l\u00e1that\u00f3). Eredm\u00e9nyek az adott feladatra vonatkoz\u00f3 hat\u00e1rid\u0151t k\u00f6vet\u0151 p\u00e1r napon bel\u00fcl v\u00e1rhat\u00f3k.</li> <li>A h\u00e1zi feladatot k\u00fcl\u00f6n explicit beadni nem kell, csak legyen fent GitHub-on hat\u00e1rid\u0151re a megold\u00e1s.</li> <li> Amikor a h\u00e1zi feladatod beadottnak tekinted,  c\u00e9lszer\u0171 ellen\u0151rizni a b\u00f6ng\u00e9sz\u0151ben a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st push-olt\u00e1l-e, \u00e9s hogy a neptun.txt val\u00f3ban ki van-e t\u00f6ltve.</li> </ol> <p>A fenti l\u00e9p\u00e9sek kapcs\u00e1n k\u00e9t k\u00e9rd\u00e9s v\u00e1r m\u00e9g megv\u00e1laszol\u00e1sra:</p> <ul> <li>Hogyan kl\u00f3nozzuk (clone) a rep\u00f3nkat (mely a h\u00e1zi feladat kiindul\u00f3 keret\u00e9t tartalmazza)?</li> <li>Hogyan commit-\u00e1ljunk \u00e9s push-oljunk GitHub-ra?</li> </ul> <p>Ezek nagy r\u00e9sz\u00e9t Szoftvertechnol\u00f3gia t\u00e1rgyb\u00f3l m\u00e1r tanultad a k\u00e9pz\u00e9s sor\u00e1n. De ha esetleg nem eml\u00e9kszel ennek minden r\u00e9szleteire, vagy ha szeretn\u00e9l megismerkedni azzal, hogyan tudod ezeket nem csak parancssorb\u00f3l, hanem Visual Studio-b\u00f3l haszn\u00e1lni, akkor mindenk\u00e9ppen olvasd el az al\u00e1bbiakat. R\u00f6viden mindenre kit\u00e9r\u00fcnk a git haszn\u00e1lata kapcs\u00e1n, amire a h\u00e1zi feladatok megold\u00e1sa sor\u00e1n sz\u00fcks\u00e9g lehet (m\u00e9g azok is meg tudj\u00e1k oldani a h\u00e1zi feladatot, akik git-et nem tanultak, \u00e9s \u00edgy kapcsol\u00f3dnak be a t\u00e1rgyba).</p> <p>Amennyiben a git login sor\u00e1n \"Support for password authentication was removed\" hiba\u00fczenetet kapsz, a git telep\u00edt\u00e9s\u00e9t ismertet\u0151 oldal alj\u00e1n a Git Credential Manager-r\u0151l sz\u00f3l\u00f3 szakaszt \u00e9rdemes elolvasni.</p>"},{"location":"hazi/hf-folyamat/#github-repository-klonozasa","title":"GitHub repository kl\u00f3noz\u00e1sa","text":"<p>K\u00e9t lehet\u0151s\u00e9get n\u00e9z\u00fcnk meg al\u00e1bb:</p> <ul> <li>Kl\u00f3noz\u00e1s a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studioban (vagy ak\u00e1r egyb\u0151l Visual Studio-b\u00f3l indulva)</li> <li>Kl\u00f3noz\u00e1s parancssorb\u00f3l</li> </ul>"},{"location":"hazi/hf-folyamat/#clone-a-github-webes-feluleterol-indulva-visual-studio-ban","title":"Clone a GitHub webes fel\u00fclet\u00e9r\u0151l indulva Visual Studio-ban","text":"<p>Egy (h\u00e1zi feladathoz tartoz\u00f3) repository kl\u00f3noz\u00e1sra sz\u00e1mos m\u00f3d van, egy lehet\u0151s\u00e9g a k\u00f6vetkez\u0151. Nyissuk meg az elk\u00e9sz\u00fclt repository online oldal\u00e1t, melyre t\u00f6bb m\u00f3don eljuthatunk. Lehet\u0151s\u00e9gek pl.:</p> <ul> <li>A repo l\u00e9trehoz\u00e1sakor megjelenik a GitHub fel\u00fcleten az url, csak kattintani kell rajta.</li> <li>A GitHub nyit\u00f3oldalon (https://github.com) - ha be vagyunk l\u00e9pve - list\u00e1z\u00f3dnak baloldalt azon repository-k, melyekhez van hozz\u00e1f\u00e9r\u00e9s\u00fcnk, csak kattintsunk a megfelel\u0151n.</li> <li>Amikor elk\u00e9sz\u00fcl a rep\u00f3nk (a GitHub classroom feladat elfogad\u00e1sa sor\u00e1n), e-mail \u00e9rtes\u00edt\u00e9st is kapunk r\u00f3la, ebben is megtal\u00e1lhat\u00f3 a link.</li> </ul> <p>Az oldal k\u00e9pe nagyj\u00e1b\u00f3l megfelel a k\u00f6vetkez\u0151nek (az mindenk\u00e9ppen k\u00fcl\u00f6nbs\u00e9g, hogy a rep\u00f3 url v\u00e9g\u00e9n mindenkin\u00e9l a saj\u00e1t felhaszn\u00e1l\u00f3neve szerepel):</p> <p></p> <p>Kattintsunk a z\u00f6ld sz\u00edn\u0171 Code gombon, majd a leny\u00edl\u00f3 men\u00fcben az \"Open in Visual Studio\" linkre:</p> <p></p> <p>A b\u00f6ng\u00e9sz\u0151nk ekkor j\u00f3 es\u00e9llyel feldob egy ablakot (pl. a Chrome/Edge eset\u00e9ben a c\u00edmsor alatt) melyben egy k\u00fcl\u00f6n gombkattint\u00e1ssal (Open\u2026) tudjuk ind\u00edtani a Visual Studio-t. A felk\u00edn\u00e1lt lehet\u0151s\u00e9gnek lehet, kiss\u00e9 fura a neve, ha \"Microsoft Visual Studio Web Protocol Handler Selector\" n\u00e9ven hivatkozik r\u00e1, v\u00e1lasszuk/enged\u00e9lyezz\u00fck ki b\u00e1tran. Illetve, itt c\u00e9lszer\u0171 az \"Always allow github.com to open links ...\" vagy hasonl\u00f3 sz\u00f6veg\u0171 jel\u00f6l\u0151n\u00e9gyzetet is pip\u00e1lni. Ha minden j\u00f3l megy, a Visual Studio elindul, \u00e9s indul\u00e1s ut\u00e1n feldob egy ablakot, melyben a \"Repository location\" ki is van t\u00f6ltve a repository-nk URL-j\u00e9vel. A Path alatt adjuk meg, hogy hova szeretn\u00e9nk a h\u00e1tt\u00e9rt\u00e1runkon clone-ozni, majd kattintsunk a Clone gombra:</p> <p></p> <p>Alternat\u00edv kl\u00f3noz\u00e1si lehet\u0151s\u00e9g Visual Studioban</p> <p>Ha nem m\u0171k\u00f6dik a b\u00f6ng\u00e9sz\u0151ablakban az \"Open in Visual Studio\" vagy \"Microsoft Visual Studio Web Protocol Handler Selector\" hivatkoz\u00e1s, akkor indulhatunk egyb\u0151l a Visual Studio-b\u00f3l is. Csak ind\u00edtsuk el a Visual Studio-t, \u00e9s a startup ablakban v\u00e1lasszuk jobboldalt a \"Clone Repository\" gombot (vagy a startup ablakot \u00e1tugorva v\u00e1lasszuk ki a \"Git/Clone Repository men\u00fct\" a VS f\u0151ablak\u00e1ban), melynek hat\u00e1s\u00e1ra a fenti ablak jelenik meg, a Repository URL-be pedig \u00edrjuk be a rep\u00f3nk URL-j\u00e9t. A Clone-ra kattintva n\u00e9h\u00e1ny m\u00e1sodperc alatt a repository a megadott c\u00e9lmapp\u00e1ba kl\u00f3noz\u00f3dik.</p> <p>A kl\u00f3noz\u00e1st k\u00f6vet\u0151en pl. Windows Explorer-ben meg tudjuk tekinteni a l\u00e9trehozott mapp\u00e1kat \u00e9s f\u00e1jlokat:</p> <p></p> <p>Ebb\u0151l j\u00f3l l\u00e1that\u00f3, hogy egy Git repository nem m\u00e1s, mint mapp\u00e1k \u00e9s f\u00e1jlok gy\u0171jtem\u00e9nye, valamint egy a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 .git mappa, mely (n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve) az egyes f\u00e1jlok verzi\u00f3t\u00f6rt\u00e9net\u00e9t tartalmazza. A munka megkezd\u00e9s\u00e9hez csak meg kell nyissuk az adott h\u00e1zi feladathoz tartoz\u00f3 .sln kiterjeszt\u00e9s\u0171 solution f\u00e1jlt (pl. duplakatt Windows Explorerben).</p> <p>Az els\u0151 h\u00e1zi feladat speci\u00e1lis (k\u00e9t solution is van)!</p> <p>Az els\u0151 h\u00e1zi feladat kiv\u00e9telesen k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll, melyekhez elt\u00e9r\u0151 solution tartozik. Az els\u0151h\u00f6z a Feladat1 mapp\u00e1ban tal\u00e1lhat\u00f3 MusicApp.sln f\u00e1jlt, a m\u00e1sodikhoz a Feladat2-ben tal\u00e1lhat\u00f3 Shapes.sln-t kell megnyitni. A megnyit\u00e1st megtehetj\u00fck Explorerb\u0151l, az adott .sln f\u00e1jlon dupl\u00e1n kattintva. Ugyanakkor van erre m\u00e1s m\u00f3d is: amennyiben Visual Studio-ban a Git gy\u00f6k\u00e9rmapp\u00e1t nyitottuk meg (a Clone-t k\u00f6vet\u0151en is ez a helyzet \u00e1llt el\u0151) a Solution Explorer n\u00e9zet fejl\u00e9c\u00e9ben \"Switch View\" gombot lenyomva a Solution Explorer list\u00e1zza a Git gy\u00f6k\u00e9rmappa alatti solution-\u00f6ket, \u00e9s ezek b\u00e1rmelyik\u00e9n dupl\u00e1n kattintva az adott solution megny\u00edlik:</p> <p></p>"},{"location":"hazi/hf-folyamat/#clone-parancssorbol","title":"Clone parancssorb\u00f3l","text":"<p>Alternat\u00edv lehet\u0151s\u00e9g a parancssor haszn\u00e1lata. Parancssorban navig\u00e1ljunk abba a mapp\u00e1ba, ahov\u00e1 a forr\u00e1sk\u00f3dot ki szeretn\u00e9nk clone-ozni, \u00e9s itt adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone &lt;repo url&gt;</code> , ahol a <code>&lt;repo url&gt;</code> a repositorynk c\u00edme (pl. b\u00f6ng\u00e9sz\u0151 c\u00edms\u00e1vj\u00e1b\u00f3l bem\u00e1solva, ehhez hasonl\u00f3: https://github.com/bmeviauab00/hazi1-2024-myusername). A parancs lefut\u00e1sa ut\u00e1n egy a repository nev\u00e9nek megfelel\u0151 alk\u00f6nyvt\u00e1rban tal\u00e1ljuk az \u00faj helyi rep\u00f3nkat.</p> <p>Parancssori git</p> <p>Ne f\u00e9lj\u00fcnk a parancssori git-et haszn\u00e1lni, egy repository clone-oz\u00e1s\u00e1nak tulajdonk\u00e9ppen ez a legegyszer\u0171bb m\u00f3dja.</p> <p>Amennyiben a parancs futtat\u00e1sa sor\u00e1n azt tapasztaljuk, hogy a git parancsot nem ismeri fel a k\u00f6rnyezet, annak oka val\u00f3sz\u00edn\u0171leg az, hogy nem telep\u00edtett\u00fcnk m\u00e9g a parancssori gitet a g\u00e9p\u00fcnkre. Err\u0151l b\u0151vebben itt.</p>"},{"location":"hazi/hf-folyamat/#napi-git-munka-visual-studio-segitsegevel-commit-push","title":"Napi Git munka Visual Studio seg\u00edts\u00e9g\u00e9vel (commit, push)","text":"<p>Miut\u00e1n lekl\u00f3noztuk az adott h\u00e1zi feladathoz tartoz\u00f3 GitHub repository-t a sz\u00e1m\u00edt\u00f3g\u00e9p\u00fcnkre, \u00e9s ennek sor\u00e1n l\u00e9trej\u00f6tt a lok\u00e1lis Git repository-nk, a benne lev\u0151 .sln f\u00e1jlokat Visual Studioban megnyitva pont \u00fagy dolgozunk \u2013 vesz\u00fcnk fel \u00faj f\u00e1jlokat, m\u00f3dos\u00edtunk/t\u00f6rl\u00fcnk megl\u00e9v\u0151ket \u2013 mintha a f\u00e1jlok nem is tartozn\u00e1nak semmif\u00e9le Git rep\u00f3hoz. Ugyanakkor, legk\u00e9s\u0151bb a feladat bead\u00e1sakor a v\u00e1ltoztat\u00e1sainkat commit-olni kell, majd push-olni GitHub-ra. A munka sor\u00e1n ak\u00e1rh\u00e1nyszor commit-\u00e1lhatjuk/push-olhatjuk az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat: a h\u00e1zi feladat ellen\u0151rz\u00e9sekor a hat\u00e1rid\u0151 pillanat\u00e1ban a GitHub-on tal\u00e1lhat\u00f3 \u00e1llapot ker\u00fcl elb\u00edr\u00e1l\u00e1sra, teljesen mindegy, h\u00e1ny commit tartozik hozz\u00e1. A commit \u00e9s push m\u0171veletek v\u00e9grehajt\u00e1s\u00e1hoz a Visual Studio \"Git\" men\u00fcj\u00e9ben lev\u0151 parancsokat haszn\u00e1ljuk.</p>"},{"location":"hazi/hf-folyamat/#commit","title":"Commit","text":"<p>Az el\u0151z\u0151 commit \u00f3ta eszk\u00f6z\u00f6lt v\u00e1ltoztat\u00e1sok megtekint\u00e9s\u00e9hez v\u00e1lasszuk ki a \"View\\Git Changes\" men\u00fct. Ennek hat\u00e1s\u00e1ra megjelenik a \"Git Changes\" n\u00e9zet a v\u00e1ltoz\u00e1sok list\u00e1j\u00e1val:</p> <p></p> <p>A v\u00e1ltoztat\u00e1sok commit-\u00e1l\u00e1s\u00e1hoz \u00edrjunk a fenti sz\u00f6vegmez\u0151be egy a v\u00e1ltoztat\u00e1sokra jellemz\u0151 egy-k\u00e9t soros le\u00edr\u00e1st (pl. \"V\u00e9gs\u0151 megold\u00e1s\", \"Az xyz hiba jav\u00edt\u00e1sa\" stb.). A lehet\u0151s\u00e9geink ezt k\u00f6vet\u0151en a k\u00f6vetkez\u0151k:</p> <ul> <li>\"Commit All\" gomb: Csak helyben commit-olja a v\u00e1ltoztat\u00e1sokat (a k\u00f6zponti Git rep\u00f3ban mindaddig nem jelenik meg a commit, am\u00edg egy k\u00fcl\u00f6n Push paranccsal fel nem \"toljuk\").</li> <li>\"Commit All and Push\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit, majd ut\u00e1na push. Ha a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lni is szeretn\u00e9nk a GitHub-on lev\u0151 k\u00f6zponti rep\u00f3ba, akkor haszn\u00e1ljuk b\u00e1tran parancsot. A h\u00e1zi feladatok tekintet\u00e9ben c\u00e9lszer\u0171 is ezt haszn\u00e1lni, mert ekkor nincs sz\u00fcks\u00e9g a commit-ot k\u00f6vet\u0151en k\u00fcl\u00f6n push m\u0171veletre. Megjegyz\u00e9s: ha a parancs az \"Unable to push to the remote repository because your local branch is behind the remote branch\" hib\u00e1val z\u00e1rul, el\u0151bb pull-oljuk, majd ism\u00e9telj\u00fck meg a push-t. Erre m\u00e9g al\u00e1bb visszat\u00e9r\u00fcnk.</li> <li>\"Commit All and Sync\", mely a \"Commit All\" gomb melletti ny\u00edl lenyit\u00e1s\u00e1val \u00e9rhet\u0151 el. Hat\u00e1sa: commit ut\u00e1n pull (leszedi a saj\u00e1t helyi rep\u00f3nkba m\u00e1sok esetleges v\u00e1ltoztat\u00e1sait a k\u00f6zponti rep\u00f3b\u00f3l), majd push. \u00cdgy a k\u00f6zponti rep\u00f3ban lev\u0151 esetleges v\u00e1ltoz\u00e1sokat lehozza a helyi rep\u00f3nkba, az ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sainkat egyb\u0151l publik\u00e1lja is ide.</li> </ul> <p>Note</p> <p>A git commit-ot mindig meg kell el\u0151zze egy \u00fan. stage l\u00e9p\u00e9s, mely sor\u00e1n kiv\u00e1lasztjuk azokat a helyi v\u00e1ltoztat\u00e1sokat, melyeket a k\u00f6vetkez\u0151 commit-ba be k\u00edv\u00e1nunk tenni. Ez az \u00fan. staging area ter\u00fcletre teszi az \u00e1ltalunk kiv\u00e1lasztott v\u00e1ltoz\u00e1sokat (a f\u00e1jlrendszerben nem mozgat semmif\u00e9le f\u00e1jlt, ez csak a git a bels\u0151 nyilv\u00e1ntart\u00e1s\u00e1ban jelenik meg). Ez az\u00e9rt j\u00f3, mert plusz rugalmass\u00e1got biztos\u00edt, hiszen nem biztos, mindig minden v\u00e1ltoztat\u00e1st bele k\u00edv\u00e1nunk tenni a k\u00f6vetkez\u0151 commit-ba. A fenti \"Commit all\" stb. parancsok nev\u00e9ben nem v\u00e9letlen van benne az \"all\": ezek a sz\u00ednfalak m\u00f6g\u00f6tt a commit el\u0151tt egy megfelel\u0151 git paranccsal valamennyi v\u00e1ltoz\u00e1st a git staging area-ra tesznek, \u00edgy ezt nek\u00fcnk nem kell k\u00fcl\u00f6n megtenn\u00fcnk.</p>"},{"location":"hazi/hf-folyamat/#push-pull","title":"Push, Pull","text":"<p>A commit m\u0171velet csak a helyi repository-ban \"\u00e9rv\u00e9nyes\u00edti\" a v\u00e1ltoztat\u00e1sokat. Ezt k\u00f6vet\u0151en a v\u00e1ltoztat\u00e1sokat a GitHub k\u00f6zponti repository-nkba fel kell t\u00f6lteni a push m\u0171velettel. Erre a l\u00e9p\u00e9sre csak akkor van sz\u00fcks\u00e9g, ha a commit sor\u00e1n nem haszn\u00e1ltuk a \"Commit All and Push\" vagy \"Commit All and Sync\" parancsokat. A push m\u0171velet VS-ben a \"Git/Push\" men\u00fc seg\u00edt\u00e9s\u00e9vel ind\u00edthat\u00f3.  Ha t\u00f6bben dolgozunk, a k\u00f6zponti repository-ban lehetnek m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok (vagy ak\u00e1r olyanok, melyeket mi magunk push-oltunk egy m\u00e1sik lok\u00e1lis clone-b\u00f3l, vagy ha a GitHub online fel\u00fclet\u00e9n eszk\u00f6z\u00f6lt\u00fcnk a k\u00f3don v\u00e1ltoz\u00e1sokat). Ezeket a pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni (Git/Pull men\u00fc). A h\u00e1zi feladat vonatkoz\u00e1s\u00e1ban ezt nem haszn\u00e1ljuk, hiszen mindenki saj\u00e1t dedik\u00e1lt k\u00f6zponti repositoryval rendelkezik, melyben egyed\u00fcl dolgozik (kiv\u00e9ve, ha esetleg valaki a GitHub fel\u00fclet\u00e9nek seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztatott a k\u00f3don, akkor ezt egy pull-lal tudja a helyi rep\u00f3j\u00e1ba lehozni).</p> <p>Note</p> <p>A push csak akkor hajthat\u00f3 v\u00e9gre, ha a k\u00f6zponti rep\u00f3ban nincs olyan v\u00e1ltoz\u00e1s, melyet m\u00e9g a pull paranccsal nem hoztunk le \u00e9s merge-elt\u00fcnk a saj\u00e1t lok\u00e1lis rep\u00f3nkba. Ha ez nincs \u00edgy, egy ehhez hasonl\u00f3 hiba\u00fczenet kapunk: \"Unable to push to the remote repository because your local branch is behind the remote branch\". Ekkor pull-oljunk, ut\u00e1na ism\u00e9telj\u00fck meg a pusht.</p> <p>Note</p> <p>A pull m\u0171velet csak akkor hajthat\u00f3 v\u00e9gre, ha nincs olyan v\u00e1ltoztat\u00e1sunk helyben, melyeket m\u00e9g nem commit\u00e1ltunk. Ha van ilyen, akkor azokat vagy commit\u00e1ljuk (vagy ha ezt nem akarjuk megtenni m\u00e9g, akkor stash-elj\u00fck a pull idej\u00e9re).</p> <p>Tip</p> <p>A Pull \u00e9s Push parancsok a \u201eGit Changes\u201d (View/Git Changes men\u00fc jelen\u00edti meg) panel tetej\u00e9n el\u00e9rhet\u0151 le \u00e9s fel nyilakkal is v\u00e9grehajthat\u00f3k:</p> <p></p>"},{"location":"hazi/hf-folyamat/#git-history","title":"Git history","text":"<p>A Git egy v\u00e1ltoz\u00e1sk\u00f6vet\u0151 rendszer. A v\u00e1ltoz\u00e1s egys\u00e9ge a commit (melyben tetsz\u0151leges sz\u00e1m\u00fa f\u00e1jlt \u00e9rint\u0151 v\u00e1ltoz\u00e1s lehet), a Git historyban a commitok egym\u00e1sut\u00e1nis\u00e1g\u00e1t l\u00e1thatjuk. A f\u00e1jlokat \u00e9rint\u0151 v\u00e1ltoz\u00e1sokon t\u00falmen\u0151en minden commithoz tartozik egy egyedi azonos\u00edt\u00f3 (commit hash), id\u0151b\u00e9lyeg, illetve egy szerz\u0151. A szerz\u0151 felhaszn\u00e1l\u00f3, aki a v\u00e1ltoz\u00e1sokat eszk\u00f6z\u00f6lte (val\u00f3j\u00e1ban van k\u00fcl\u00f6n Author \u00e9s Commiter, de a kett\u0151 \u00e1ltal\u00e1ban ugyanaz). Visual Studioban a historyt a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni, de a history term\u00e9szetesen a GitHub online fel\u00fclet\u00e9n is megjelen\u00edthet\u0151. A Visual Studioban a \"Git Repository\" n\u00e9zetet a View/Git Repository men\u00fcvel tudjuk megjelen\u00edteni.</p> <ul> <li>Outgoing commits: Megmutatja, hogy milyen, a lok\u00e1lis repository-nkba m\u00e1r l\u00e9tez\u0151, de a k\u00f6zponti rep\u00f3ba m\u00e9g nem push-olt commitok vannak. Ezeket a Push m\u0171velettel tudjuk felt\u00f6lteni.</li> <li>Incoming commits: Megmutatja, hogy a k\u00f6zponti repository-ban milyen m\u00e1sok \u00e1ltal pusholt, hozz\u00e1nk m\u00e9g le nem t\u00f6lt\u00f6tt commitok vannak. Ezek akkor jelennek meg, ha a Fetch paranccsal lehozzuk a helyi rep\u00f3ba (ez m\u00e9g nem merge-el). Ezeket a Pull m\u0171velettel tudjuk a helyi rep\u00f3nkba merge-elni. A fetch parancsot ritk\u00e1n haszn\u00e1ljuk: \u00e1ltal\u00e1ban a pullt haszn\u00e1ljuk mag\u00e1ban, ami egy fetch + merge (v\u00e1ltoz\u00e1sok merge-el\u00e9se a helyi rep\u00f3ba) kombin\u00e1ci\u00f3ja.</li> </ul> <p>P\u00e9lda:</p> <p></p> <p>Tip</p> <p>Am\u00edg nem vagyunk rutinosak a Visual Studio Git szolg\u00e1ltat\u00e1sainak haszn\u00e1lat\u00e1ban, a push-t k\u00f6vet\u0151en (legk\u00e9s\u0151bb akkor, amikor a h\u00e1zi feladatot beadottnak tekintj\u00fck) c\u00e9lszer\u0171 ellen\u0151rizni a GitHub webes fel\u00fclet\u00e9n a repository-ban a f\u00e1jlokra val\u00f3 r\u00e1pillant\u00e1ssal, hogy val\u00f3ban minden v\u00e1ltoztat\u00e1st felt\u00f6lt\u00f6tt\u00fcnk-e.</p>"},{"location":"hazi/hf-folyamat/#egyeb-iranyelvek","title":"Egy\u00e9b ir\u00e1nyelvek","text":"<p>A Git commit \u00e9s push sor\u00e1n megfigyelhetj\u00fck, hogy a solution-jeink k\u00f6ztes \u00e9s kimeneti \u00e1llom\u00e1nyai (.dll, .exe stb. f\u00e1jlok) nem ker\u00fclnek bele a commitba, \u00e9s \u00edgy nem ker\u00fclnek fel GitHubra sem. Ez \u00edgy is van j\u00f3l, ezen \u00e1llom\u00e1nyok b\u00e1rmikor reproduk\u00e1lhat\u00f3k, a verzi\u00f3kezel\u0151 rendszernek nem feladata ezek t\u00e1rol\u00e1sa, csak felesleges \u00e9s zavar\u00f3 helyfoglal\u00f3k lenn\u00e9nek. Felmer\u00fcl a k\u00e9rd\u00e9s, honnan tudja a Git, hogy mely \u00e1llom\u00e1nyokat sz\u00fcks\u00e9ges figyelmen k\u00edv\u00fcl hagyni a commit sor\u00e1n. Erre szolg\u00e1l a repository-ban (tipikusan annak gy\u00f6k\u00e9rmapp\u00e1j\u00e1ban) tal\u00e1lhat\u00f3 .gitignore f\u00e1jl, mely felsorolja azon mapp\u00e1kat, f\u00e1jlkiterjeszt\u00e9seket, illetve egyedi f\u00e1jlokat, melyeket a commit sor\u00e1n figyelmen k\u00edv\u00fcl szeretn\u00e9nk hagyni. A .gitignore f\u00e1jl tartalma teljes eg\u00e9sz\u00e9ben a kez\u00fcnk al\u00e1 tartozik, szabadon szerkeszthet\u0151/commit\u00e1lhat\u00f3/pusholhat\u00f3. A t\u00e1rgy keret\u00e9ben minden kiindul\u00f3 rep\u00f3nak r\u00e9sze egy .gitignore f\u00e1jl, ne v\u00e1ltoztassuk a tartalm\u00e1t! \u00cdgy a commit/push sor\u00e1n a kimeneti \u00e1llom\u00e1nyok a h\u00e1zi feladatok eset\u00e9ben sem ker\u00fclnek fel GitHub-ra, \u00e9s egy \u00edgy is van rendj\u00e9n.</p> <p>A f\u00e9l\u00e9vben a feladatok megold\u00e1sa sor\u00e1n az egyes oszt\u00e1lyok, interf\u00e9szek stb. forr\u00e1sk\u00f3dj\u00e1t k\u00fcl\u00f6n f\u00e1jlba kell tenni, vagyis egy C# forr\u00e1sf\u00e1jlban egy oszt\u00e1ly/interf\u00e9sz/stb. defin\u00edci\u00f3ja legyen.</p>"},{"location":"hazi/hf-folyamat/#git-hasznalata-parancssorbol","title":"Git haszn\u00e1lata parancssorb\u00f3l","text":"<p>B\u00e1r sokan \u00f3dzkodnak a git parancssori alkalmaz\u00e1s\u00e1t\u00f3l, az egyszer\u0171bb m\u0171veleteket gyakran gyorsabban v\u00e9gre tudjuk hajtani parancssorb\u00f3l, mint a GUI fel\u00fcleteken t\u00f6rt\u00e9n\u0151 kattintgat\u00e1sokkal. Az al\u00e1bbiakban egy egyszer\u0171 l\u00e9p\u00e9ssorozattal illusztr\u00e1ljuk ezt. Ezeket a t\u00e1rgy keret\u00e9ben nem kell tudni, de hosszabb t\u00e1von mindenk\u00e9ppen hasznos (\u00e9s az ipar\u00e1gban elv\u00e1r\u00e1s is) az ismeret\u00fck.</p> <ol> <li> <p>Repository clone (ezt csak egyszer)</p> <p><code>git clone https://github.com/bmeviauab00/hazi1-2022-myusername</code></p> </li> <li> <p>V\u00e1ltoztat\u00e1sok v\u00e9grehajt\u00e1sa a helyi rep\u00f3ban (f\u00e1jlrendszerben, fejleszt\u0151eszk\u00f6zben).</p> </li> <li> <p>V\u00e1ltoztat\u00e1sok megtekint\u00e9se, mutatja melyek az \u00faj/t\u00f6r\u00f6lt/m\u00f3dosult f\u00e1jlok (nem k\u00f6telez\u0151, csak ha k\u00edv\u00e1ncsiak vagyunk r\u00e1)*</p> <p><code>git status</code></p> </li> <li> <p>Minden v\u00e1ltoztat\u00e1s felt\u00e9tele a staging area-ra</p> <p><code>git add -A</code></p> <p>Ha ezt k\u00f6vet\u0151en ism\u00e9t kiadjuk <code>git status</code> parancsot (nem k\u00f6telez\u0151), l\u00e1tjuk, hogy minden v\u00e1ltoz\u00e1s stage-elve van.</p> </li> <li> <p>Commit</p> <p><code>git commit -m \"megjegyz\u00e9s a commithoz\"</code></p> </li> <li> <p>Push</p> <p><code>git push</code></p> </li> </ol> <p>Megjegyz\u00e9sek:</p> <ul> <li>Ha t\u00f6bben is dolgozunk az adott git \u00e1gon, akkor a 6. push el\u0151tt sz\u00fcks\u00e9g lehet/van egy <code>git pull</code>-ra, hogy m\u00e1sok v\u00e1ltoztat\u00e1sai megjelenjenek a mi helyi rep\u00f3nkban (en\u00e9lk\u00fcl nem fogunk tudni push-olni). A pull-nak c\u00e9lszer\u0171 lehet megadni a <code>--rebase</code> opci\u00f3t is, hogy ne sz\u00fclessen a merge-hez egy plusz merge commit, ennek magyar\u00e1zat\u00e1ra itt nem t\u00e9r\u00fcnk ki.</li> <li> <p>Mint kor\u00e1bban eml\u00edtett\u00fck, a commit sor\u00e1n a commithoz hozz\u00e1rendel\u0151dik egy felhaszn\u00e1l\u00f3n\u00e9v \u00e9s e-mail c\u00edm. Ha ezek nincsenek a git sz\u00e1m\u00e1ra bekonfigur\u00e1lva, akkor a git a commit sor\u00e1n ezt hiba\u00fczenetben jelzi. Ekkor az al\u00e1bbi parancsokkal - \u00e9rtelemszer\u0171en a saj\u00e1t felhaszn\u00e1l\u00f3nev\u00fcnket \u00e9s e-mail c\u00edm\u00fcnket megadva - tudjuk ezeket a git glob\u00e1lis konfigur\u00e1ci\u00f3j\u00e1ban be\u00e1ll\u00edtani (ezt csak egyszer kell megtenni):</p> <pre><code>git config --global user.email \"you@example.com\"\ngit config --global user.name \"myusername\"\n</code></pre> </li> <li> <p>Windows parancssorban \u00f6sszevonhatunk t\u00f6bb parancsot is egy sorba, pl. egy l\u00e9p\u00e9sben minden v\u00e1ltoz\u00e1sra stage/commit/push:</p> <p><code>git add -A &amp; git commit -m \"All tests run\" &amp; git push</code></p> <p>Powershell haszn\u00e1latakor a <code>&amp;</code> helyett <code>;</code>-t kell szepar\u00e1tork\u00e9nt haszn\u00e1lni.</p> </li> </ul>"},{"location":"hazi/imsc-liftsystem/","title":"IMSc. HF - Liftrendszer","text":""},{"location":"hazi/imsc-liftsystem/#bevezetes","title":"Bevezet\u00e9s","text":"<p>A h\u00e1zi feladatban egy konzol alap\u00fa alkalmaz\u00e1st kell elk\u00e9sz\u00edteni, mely egy liftrendszert szimul\u00e1l, az Observer tervez\u00e9si mint\u00e1ra \u00e9p\u00edtve.</p> <p>A megval\u00f3s\u00edt\u00e1s\u00e9rt 7 IMSc pont szerezhet\u0151.</p> <p>Az h\u00e1zi feladat az Observer \u00e9s Adapter tervez\u00e9si minta ismeret\u00e9re \u00e9p\u00edt (l\u00e1sd kapcsol\u00f3d\u00f3 tervez\u00e9si mint\u00e1k el\u0151ad\u00e1sanyag). </p> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s. Ez egy konzolos alkalmaz\u00e1s, ak\u00e1r Linux/Mac k\u00f6rnyezetben is megval\u00f3s\u00edthat\u00f3.</p>"},{"location":"hazi/imsc-liftsystem/#a-beadas-menete","title":"A bead\u00e1s menete","text":"<ul> <li>Az alapfolyamat megegyezik a kor\u00e1bbiakkal. GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod (a t\u00e1rgy nyit\u00f3oldal\u00e1n a \"GitHub classroom hivatkoz\u00e1sok a h\u00e1zi feladatokhoz\" hivatkoz\u00e1sra kattintva megjelen\u0151 oldalon l\u00e1that\u00f3). Fontos, hogy a megfelel\u0151, ezen h\u00e1zi feladathoz tartoz\u00f3 megh\u00edv\u00f3 URL-t haszn\u00e1ld (minden h\u00e1zi feladathoz m\u00e1s URL tartozik). Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n commit-old \u00e9s push-old a megold\u00e1sod.</li> <li> Ehhez a feladathoz \u00e9rdemi el\u0151ellen\u0151rz\u0151 nem tartozik: minden push ut\u00e1n lefut ugyan, de csak a neptun.txt kit\u00f6lt\u00f6tts\u00e9g\u00e9t ellen\u0151rzi. Az \u00e9rdemi ellen\u0151rz\u00e9st a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a laborvezet\u0151k teszik majd meg.</li> </ul>"},{"location":"hazi/imsc-liftsystem/#1-feladat-liftrendszer-alapok","title":"1. feladat - Liftrendszer alapok","text":"<p>K\u00e9sz\u00edts egy <code>Lift</code> oszt\u00e1lyt, mely egy emeletes h\u00e1z felvon\u00f3j\u00e1t reprezent\u00e1lja! A k\u00f6vetkez\u0151 tagokkal rendelkezzen:</p> <ul> <li><code>Floor</code> tulajdons\u00e1g: Aktu\u00e1lis emelet. Eg\u00e9sz \u00e9rt\u00e9k.</li> <li><code>TargetFloor</code> tulajdons\u00e1g: C\u00e9l emelet. Eg\u00e9sz \u00e9rt\u00e9k.</li> <li><code>Stairway</code> tulajdons\u00e1g: L\u00e9pcs\u0151h\u00e1z sz\u00e1ma, melyben a lift tal\u00e1lhat\u00f3. Eg\u00e9sz \u00e9rt\u00e9k. Egy l\u00e9pcs\u0151h\u00e1zban egy lift lehet (ezt nem kell valid\u00e1lni az alkalmaz\u00e1sban, de mindig \u00edgy haszn\u00e1ljuk).</li> <li><code>Call</code> m\u0171velet: A lift h\u00edv\u00e1s\u00e1ra szolg\u00e1l, be\u00e1ll\u00edtja a c\u00e9lemeletet a param\u00e9terben magadott \u00e9rt\u00e9kre.</li> <li><code>Step</code> m\u0171velet: A lift egy emelettel t\u00f6rt\u00e9n\u0151 l\u00e9ptet\u00e9s\u00e9re szolg\u00e1l (amennyiben az aktu\u00e1lis \u00e9s c\u00e9lemelet nem egyezik: ha egyezik, nem csin\u00e1l semmit). V\u00e9letlenszer\u0171 esetben - \u00e1tlagosan kb. minden 5. l\u00e9p\u00e9s sor\u00e1n - a lift ideiglenesen beragad: ez azt jelenti, hogy az adott l\u00e9p\u00e9s sor\u00e1n nem v\u00e1lt emeletet a c\u00e9lemelet ir\u00e1ny\u00e1ba.</li> </ul> <p>K\u00e9sz\u00edts egy <code>LiftDoor</code> oszt\u00e1lyt, mely egy liftajt\u00f3t reprezent\u00e1l:</p> <ul> <li>Konstruktor param\u00e9terben lehessen megadni a lift objektumot, melyhez a lift tartozik, valamint azt, hogy az ajt\u00f3 melyik emeleten helyezkedik el.</li> <li>A liftajt\u00f3 kijelz\u0151je mindig a liftj\u00e9nek aktu\u00e1lis emelet\u00e9t mutatja, kiv\u00e9ve, amikor a lift az adott liftajt\u00f3 szintj\u00e9re \u00e9rkezik. Ekkor, ha ez volt a c\u00e9l\u00e1llom\u00e1s, egy 'o' jelenik meg a kijelz\u0151n (jelezve, hogy ny\u00edlik az ajt\u00f3), egy\u00e9bk\u00e9nt egy '*'. </li> <li>A kijelz\u0151h\u00f6z nem kell k\u00fcl\u00f6n oszt\u00e1lyt k\u00e9sz\u00edteni, a megjelen\u00edt\u00e9s\u00e9rt a <code>LiftDoor</code> oszt\u00e1ly felel.</li> <li> <p>Egy adott lifthez tartoz\u00f3 ajt\u00f3k adatai egy oszlopban, egym\u00e1s alatt (emelet sorrendj\u00e9ben) jelenjenek meg. Az 1. oszlopban az 1. l\u00e9pcs\u0151h\u00e1z, 2. oszlopban a 2. l\u00e9pcs\u0151h\u00e1z stb. lift/liftajt\u00f3 adatok jelenjenek meg. Az oszlopok 20-as karaktersz\u00e9less\u00e9g\u0171ek, \u00edgy az 1. oszlop a 20-as, a 2. oszlop a 40-es stb. karakterpoz\u00edci\u00f3ban kezd\u0151dik. Az al\u00e1bbi \u00e1bra illusztr\u00e1lja az elrendez\u00e9st k\u00e9t lift eset\u00e9re (1. lift az els\u0151 l\u00e9pcs\u0151h\u00e1zban, 2. lift a 2. l\u00e9pcs\u0151h\u00e1zban tal\u00e1lhat\u00f3):</p> <p></p> <p>Az \u00e1bra azt is illusztr\u00e1lja, hogy a liftajt\u00f3knak milyen form\u00e1ban kell a kimenetet megjelen\u00edteni (emelet ut\u00e1n kett\u0151spont, majd [ ] k\u00f6z\u00f6tt a kijelz\u0151 \u00e9rt\u00e9ke).</p> </li> <li> <p>A konzolra \u00edr\u00e1s sor\u00e1n a <code>Console.SetCursorPosition</code> m\u0171veletet \u00e9rdemes haszn\u00e1lni az \u00edr\u00e1si poz\u00edci\u00f3 be\u00e1ll\u00edt\u00e1s\u00e1ra.</p> </li> <li>Egyszer\u0171s\u00edt\u00e9s: a <code>Lift</code> oszt\u00e1lynak nem kell tudnia, hogy h\u00e1ny szint tartozik hozz\u00e1, \u00edgy nem sz\u00fcks\u00e9ges erre vonatkoz\u00f3 valid\u00e1ci\u00f3kat sem megval\u00f3s\u00edtani.</li> <li> Kulcsfontoss\u00e1g\u00fa, hogy a <code>Lift</code> oszt\u00e1ly nem tudhatja, milyen m\u00e1s oszt\u00e1lyok \u00e9p\u00edtenek az \u00e1llapot\u00e1ra. Pl. eset\u00fcnkben egyel\u0151re a <code>LiftDoor</code> ilyen (k\u00e9s\u0151bb lesz m\u00e1s is). Vagyis a rendszernek k\u00f6nnyen b\u0151v\u00edthet\u0151nek kell lenni m\u00e1s oszt\u00e1lyokkal, melyek a <code>Lift</code> m\u0171k\u00f6d\u00e9s\u00e9t\u0151l/\u00e1llapot\u00e1t\u00f3l f\u00fcggenek, \u00faj ilyen oszt\u00e1ly bevezet\u00e9sekor a <code>Lift</code> oszt\u00e1lyt nem szabad a k\u00e9s\u0151bbiekben m\u00f3dos\u00edtani. Ennek megfelel\u0151en a <code>Lift</code> - <code>LiftDoor</code> viszony\u00e1t az Observer mint\u00e1ra kell \u00e9p\u00edteni. </li> <li>A j\u00f6v\u0151ben a tov\u00e1bbfejleszt\u00e9s sor\u00e1n lehetnek m\u00e1s <code>Subject</code> oszt\u00e1lyok is, ez\u00e9rt be kell vezetni egy <code>Subject</code> \u0151soszt\u00e1lyt a k\u00f3dduplik\u00e1ci\u00f3 elker\u00fcl\u00e9s\u00e9re (de a h\u00e1zi feladatban csak egy subject lesz).</li> <li> A megold\u00e1s NEM \u00e9p\u00edthet .NET event-ekre (ugyanezen oszt\u00e1lyokkal/interf\u00e9szekkel pl. Java nyelven is megval\u00f3s\u00edthat\u00f3nak kell lennie).</li> </ul> <p>A liftrendszer konfigur\u00e1ci\u00f3 \u00f6ssze\u00e1ll\u00edt\u00e1s\u00e9rt \u00e9s a szimul\u00e1ci\u00f3 futtat\u00e1s\u00e1\u00e9rt egy <code>LiftSystemModel</code> oszt\u00e1ly legyen a felel\u0151s. Ennek forr\u00e1sk\u00f3dj\u00e1t al\u00e1bb megadjuk, ebb\u0151l kell egy p\u00e9ld\u00e1nyt a <code>Main</code> f\u00fcggv\u00e9nyben l\u00e9trehozni, \u00e9s a <code>Run</code> f\u00fcggv\u00e9ny\u00e9t megh\u00edvni:</p> <pre><code>class LiftSystemModel\n{\n    int iterationCount = 0;\n\n    Lift lift1 = new() { Stairway = 1 };\n    Lift lift2 = new() { Stairway = 2 };\n\n    public LiftSystemModel()\n    {\n        var a1 = new LiftDoor(1, lift1);\n        var a2 = new LiftDoor(2, lift1);\n        var a3 = new LiftDoor(3, lift1);\n        var a4 = new LiftDoor(4, lift1);\n        var a5 = new LiftDoor(5, lift1);\n\n        var b1 = new LiftDoor(1, lift2);\n        var b2 = new LiftDoor(2, lift2);\n        var b3 = new LiftDoor(3, lift2);\n        var b4 = new LiftDoor(4, lift2);\n        var b5 = new LiftDoor(5, lift2);\n    }\n\n    public void Run()\n    {\n        while (true)\n        {\n            Step();\n            Thread.Sleep(1000);\n            iterationCount++;\n        }\n    }\n\n    private void Step()\n    {\n        lift1.Step();\n        lift2.Step();\n\n        if (iterationCount == 0)\n            lift1.Call(5);\n        if (iterationCount == 2)\n            lift2.Call(5);\n\n        if (iterationCount == 6)\n            lift1.Call(1);\n        if (iterationCount == 9)\n            lift2.Call(1);\n    }\n\n}\n</code></pre> <p>A fenti k\u00f3d r\u00f6vid magyar\u00e1zata:</p> <ul> <li>A modell k\u00e9t liftet tartalmaz, az egyik az 1., a m\u00e1sik a 2. l\u00e9pcs\u0151h\u00e1zban tal\u00e1lhat\u00f3.</li> <li>A konstruktorban l\u00e9trehozzuk a k\u00e9t lifthez az egyes emeleteken tal\u00e1lhat\u00f3 ajt\u00f3kat (mindk\u00e9t l\u00e9pcs\u0151h\u00e1z 5 emeletes).</li> <li>A <code>Run</code> egy v\u00e9gtelen ciklusban futtatja a szimul\u00e1ci\u00f3t. A <code>Step</code> m\u0171veletben l\u00e9ptet, v\u00e1r egy m\u00e1sodpercet, majd megn\u00f6veli az aktu\u00e1lis iter\u00e1ci\u00f3sz\u00e1mot.</li> <li>A <code>Step</code> h\u00edv\u00f3dik minden iter\u00e1ci\u00f3ban. Ebben l\u00e9ptetj\u00fck mindk\u00e9t liftet, \u00e9s bizonyos iter\u00e1ci\u00f3kban h\u00edvjuk a k\u00e9t liftet az 5. illetve 1. emeletre.</li> </ul> <p>A k\u00f6vetkez\u0151 mozg\u00f3k\u00e9p illusztr\u00e1lja a m\u0171k\u00f6d\u00e9st:  </p>"},{"location":"hazi/imsc-liftsystem/#2-feladat-liftcontroller-osztaly-bevezetese","title":"2. Feladat - LiftController oszt\u00e1ly bevezet\u00e9se","text":"<p>K\u00e9sz\u00edts el egy <code>LiftController</code> oszt\u00e1lyt, mely egy adott liftre vonatkoz\u00f3an folyamatosan meg tudja jelen\u00edteni, mely szinten van \u00e9s mely szintre h\u00edvt\u00e1k utolj\u00e1ra (ez a k\u00f6zponti vez\u00e9rl\u0151terem sz\u00e1m\u00e1ra hasznos).</p> <ul> <li>Konstruktor param\u00e9terben lehessen a lift objektumot megadni, melyhez a <code>LiftController</code> tartozik.</li> <li><code>LiftSystemModel</code> konstruktor\u00e1ban mindk\u00e9t lifthez vegy\u00fcnk fel egy-egy <code>LiftController</code> p\u00e9ld\u00e1nyt.</li> <li> Kulcsfontoss\u00e1g\u00fa, hogy a bevezet\u00e9se sor\u00e1n NE kelljen a <code>Lift</code> oszt\u00e1lyt m\u00f3dos\u00edtani (az Observer mint\u00e1nak k\u00f6sz\u00f6nhet\u0151en).</li> <li><code>LiftController</code>-ek a hozz\u00e1juk tartoz\u00f3 lift oszlop\u00e1ban a liftajt\u00f3k alatt jelen\u00edts\u00e9k meg egy \"-&gt;\" el\u0151tt az aktu\u00e1lis, ut\u00e1na pedig a c\u00e9l emeletet. </li> </ul> <p>A megold\u00e1s illusztr\u00e1l\u00e1sa:</p> <p></p>"},{"location":"hazi/imsc-liftsystem/#3-feladat-meglevo-liftmonitor-osztaly-beillesztese","title":"3. feladat - Megl\u00e9v\u0151 LiftMonitor oszt\u00e1ly beilleszt\u00e9se","text":"<p>A feladat a liftek m\u0171k\u00f6d\u00e9si st\u00e1tusz\u00e1r\u00f3l inform\u00e1ci\u00f3 megjelen\u00edt\u00e9se. Eml\u00e9kezz\u00fcnk: a liftek v\u00e9letlenszer\u0171 id\u0151k\u00f6z\u00f6nk\u00e9nt elakadnak, mint ahogy a kor\u00e1bbi le\u00edr\u00e1sban szerepelt! Minden id\u0151pillanatban tudni szeretn\u00e9nk, hogy egy lift m\u0171k\u00f6dik (st\u00e1tusza \"OK\"), vagy el van akadva (st\u00e1tusza \"stuck\").  Ehhez rendelkez\u00e9sre is \u00e1ll az al\u00e1bbi oszt\u00e1ly:</p> <pre><code>class LiftMonitor\n{\n    int prevFloor;\n    bool isPrevFloorInitialized;\n\n    public void CheckLift(Lift lift)\n    {\n        Console.SetCursorPosition(lift.Stairway * 20, 13);\n        if (lift.Floor == prevFloor &amp;&amp; isPrevFloorInitialized)\n        {\n            Console.Write($\"LiftMonitor: stuck!\");\n        }\n        else\n            Console.Write($\"LiftMonitor: OK    \");\n\n        prevFloor = lift.Floor;\n        isPrevFloorInitialized = true;\n    }\n}\n</code></pre> <p>Vegy\u00fck fel a fenti oszt\u00e1lyt!</p> <p> Ett\u0151l a pillanatt\u00f3l feltessz\u00fck, hogy a fenti oszt\u00e1lyt egy k\u00f6nyvt\u00e1r form\u00e1j\u00e1ban kaptuk meg, \u00edgy forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3!</p> <p>Illessz\u00fck be az Adapter minta seg\u00edts\u00e9g\u00e9vel a fenti oszt\u00e1lyt a megold\u00e1sunkba:</p> <ul> <li>A <code>LiftMonitor</code> oszt\u00e1ly nem m\u00f3dos\u00edthat\u00f3!</li> <li> Kulcsfontoss\u00e1g\u00fa, hogy a beilleszt\u00e9se sor\u00e1n NE kelljen a <code>Lift</code> oszt\u00e1lyt m\u00f3dos\u00edtani (az Observer mint\u00e1nak k\u00f6sz\u00f6nhet\u0151en). Tipp: a <code>Lift</code> akkor is kell \u00e9rtes\u00edtse a megfigyel\u0151it, ha beragad\u00e1s miatt nem v\u00e1ltott szintet, m\u00e1sk\u00fcl\u00f6nben a <code>LiftMonitor</code> nem tudja detekt\u00e1lni a beragad\u00e1st.</li> <li><code>LiftSystemModel</code> konstruktor\u00e1ban mindk\u00e9t lifthez vegy\u00fcnk fel egy-egy monitoroz\u00e1st megval\u00f3s\u00edt\u00f3 objektumot.</li> <li>Csak Object Adapter alap\u00fa megold\u00e1s fogadhat\u00f3 el (Class Adapter nem).</li> </ul> <p>A megold\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek illusztr\u00e1l\u00e1sa:</p> <p></p>"},{"location":"labor/1-model-es-kod-kapcsolata/","title":"1. A modell \u00e9s a k\u00f3d kapcsolata","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja:</p> <ul> <li>Ismerked\u00e9s a hallgat\u00f3kkal/gyakorlatvezet\u0151vel</li> <li>A gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyek pontos\u00edt\u00e1sa</li> <li>Elindul\u00e1s Visual Studio-val \u00e9s .NET alkalmaz\u00e1sok fejleszt\u00e9s\u00e9vel.</li> <li>Egy egyszer\u0171 Hello World .NET alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, C# alapok</li> <li>Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se</li> <li>Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja</li> </ul> Gyakorlatvezet\u0151knek <p>B\u00e1r a hallgat\u00f3k k\u00f6z\u00f6tt biztosan vannak olyanok, akik kor\u00e1bban, a Prog2 (C++) t\u00e1rgy keret\u00e9ben vagy m\u00e1s okb\u00f3l kifoly\u00f3lag m\u00e1r haszn\u00e1lt\u00e1k a Visual Studio k\u00f6rnyezetet, szinte biztosan lesznek olyanok is, akik m\u00e9g nem haszn\u00e1lt\u00e1k, vagy m\u00e1r kev\u00e9sb\u00e9 eml\u00e9keznek r\u00e1. A c\u00e9l jelen esetben a fel\u00fclettel val\u00f3 ismerked\u00e9s, ez\u00e9rt a feladatok megold\u00e1sa sor\u00e1n folyamatosan ismertess\u00fck a haszn\u00e1lt dolgokat (pl. Solution Explorer, F5-futtat\u00e1s, breakpoint haszn\u00e1lat stb.), hogy elk\u00e9sz\u00edts\u00fck \u00e9let\u00fcnk els\u0151 C# alkalmaz\u00e1s\u00e1t.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Visual Studio-b\u00f3l a legfrissebb verzi\u00f3t c\u00e9lszer\u0171 feltenni. A Community Edition, Professional \u00e9s az Enterprise verzi\u00f3 is megfelel. A Community Edition ingyenes, let\u00f6lthet\u0151 a Microsoft honlapj\u00e1r\u00f3l. A Professional fizet\u0151s, de az egyetem hallgat\u00f3i sz\u00e1m\u00e1ra ez is ingyenesen el\u00e9rhet\u0151 (https://azureforeducation.microsoft.com/devtools honlapon, az Azure Dev Tools for Teaching program keret\u00e9ben).</p> <p>Visual Studio Class Diagram t\u00e1mogat\u00e1s</p> <p>Jelen gyakorlat bizonyos feladatain\u00e1l (\u00e9s az els\u0151 h\u00e1zi feladat eset\u00e9ben is) a Visual Studio Class Designer t\u00e1mogat\u00e1s\u00e1t haszn\u00e1ljuk. A Visual Studio nem teszi fel minden esetben a Class Designer komponenst a telep\u00edt\u00e9s sor\u00e1n. Ha nem lehet Class Diagram-ot felvenni a Visual Studio projektbe (mert a Class Diagram nem szerepel a list\u00e1ban az Add New Item parancs sor\u00e1n megjelen\u0151 ablak list\u00e1j\u00e1ban \u2013 err\u0151l a jelen \u00fatmutat\u00f3 k\u00e9s\u0151bbi fejezet\u00e9ben b\u0151vebben), akkor a Class Diagram komponenst ut\u00f3lag kell telep\u00edteni:</p> <ol> <li>Visual Studio telep\u00edt\u0151 ind\u00edt\u00e1sa (pl. a Windows Start men\u00fcben a \u201eVisual Studio Installer\u201d beg\u00e9pel\u00e9s\u00e9vel).</li> <li>A megjelen\u0151 ablakban \u201eIndividual components\u201d f\u00fcl kiv\u00e1laszt\u00e1sa</li> <li> <p>A keres\u0151mez\u0151be \u201eclass designer\u201d beg\u00e9pel\u00e9se, majd gy\u0151z\u0151dj\u00fcnk meg, hogy a sz\u0171rt list\u00e1ban a \u201eClass Designer\u201d elem ki van pip\u00e1lva.</p> <p></p> </li> </ol> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>A gyakorlathoz nem kapcsol\u00f3dik a t\u00e1rgyb\u00f3l el\u0151ad\u00e1s. Ugyanakkor a gyakorlat \u00e9p\u00edt az UML alapismeretekre, illetve az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d egym\u00e1sra t\u00f6rt\u00e9n\u0151 lek\u00e9pez\u00e9s\u00e9nek alapjaira.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlatvezet\u0151 a gyakorlat elej\u00e9n \u00f6sszefoglalja a gyakorlatokra vonatkoz\u00f3 k\u00f6vetelm\u00e9nyeket:</p> <ul> <li>A t\u00e1rgyi adatlapon ezek t\u00f6bbs\u00e9ge megtal\u00e1lhat\u00f3</li> <li>Az otthoni feladatokr\u00f3l inform\u00e1ci\u00f3 a t\u00e1rgy honlapj\u00e1n tal\u00e1lhat\u00f3.</li> </ul> <p>Visual Studio fejleszt\u0151eszk\u00f6zzel, .NET alkalmaz\u00e1sokat fogunk k\u00e9sz\u00edteni C# nyelven. A C#  hasonl\u00edt a Java-hoz, fokozatosan ismerj\u00fck meg a k\u00fcl\u00f6nbs\u00e9geket. A gyakorlat vezetett, gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#1-feladat-hello-world-net-konzol-alkalmazas-elkeszitese","title":"1. Feladat - \u201eHello world\u201d .NET konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se","text":"<p>A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely a konzolra ki\u00edrja a \u201eHello world!\u201d sz\u00f6veget.</p> <p>Az alkalmaz\u00e1st C# nyelven k\u00e9sz\u00edtj\u00fck el. A leford\u00edtott alkalmaz\u00e1s futtat\u00e1s\u00e1t a .NET runtime v\u00e9gzi. A ford\u00edt\u00e1s/futtat\u00e1s elm\u00e9leti h\u00e1tter\u00e9t, valamint a .NET alapjait az els\u0151 el\u0151ad\u00e1s ismerteti.</p> <p>A solution \u00e9s azon bel\u00fcli projekt l\u00e9trehoz\u00e1s\u00e1nak l\u00e9p\u00e9sei Visual Studio 2022 eset\u00e9n:</p> <ol> <li>\u00daj projekt var\u00e1zsl\u00f3 elind\u00edt\u00e1sa, melyre k\u00e9t m\u00f3d is van<ul> <li>Ind\u00edt\u00f3ablak seg\u00edts\u00e9g\u00e9vel<ol> <li>Ind\u00edtsuk el a Visual Studio-t</li> <li>A megjelen\u0151 ind\u00edt\u00f3ablak jobb oldali s\u00e1vj\u00e1ban Create new project</li> </ol> </li> <li>M\u00e1r fut\u00f3 Visual Studio-ban<ol> <li>File / New-Project</li> </ol> </li> </ul> </li> <li> <p>A Create new project var\u00e1zsl\u00f3ban a Console app (\u00e9s NEM a Console app (.NET Framework) sablont v\u00e1lasszuk ki, ebb\u0151l is a C#-osat. Azt, hogy C#-os, a sablon ikonj\u00e1nak bal fels\u0151 sarka jelzi. Ha nem l\u00e1tjuk a list\u00e1ban, r\u00e1 kell keresni/sz\u0171rni. R\u00e1kereshet\u00fcnk a fels\u0151 keres\u0151s\u00e1vban a \u201econsole\u201d be\u00edr\u00e1s\u00e1val. Vagy az alatta lev\u0151 leny\u00edl\u00f3 mez\u0151k seg\u00edts\u00e9g\u00e9vel: az els\u0151ben (nyelvkiv\u00e1laszt\u00f3) \u201eC#\u201d, a harmadikban (projektt\u00edpus kiv\u00e1laszt\u00f3) \u201eConsole\u201d.</p> <p></p> </li> <li> <p>Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon:</p> <ol> <li>Project name: Hello World</li> <li>Location: a laborokban a c:\\work\\ mapp\u00e1ba dolgozzunk, ehhez van \u00edr\u00e1si jogunk. <li>Solution name: Hello World (elvileg ez be is lesz \u00edrva, mire ide\u00e9r\u00fcnk)</li> <li>Place solution and project in the same directory: nincs pipa (de nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge).</li> <li> <p>Next gomb az var\u00e1zsl\u00f3ablak alj\u00e1n, a k\u00f6vetkez\u0151 var\u00e1zsl\u00f3oldalon:</p> <ol> <li>Framework: .NET 8 (Long-term support).</li> <li>A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be (ennek magyar\u00e1zat\u00e1ra mindj\u00e1rt visszat\u00e9r\u00fcnk).</li> </ol> </li> <p>A projekttel egy \u00faj solution is l\u00e9trej\u00f6n, mely strukt\u00far\u00e1ja a Visual Studio Solution Explorer ablak\u00e1ban tekinthet\u0151 \u00e1t. Egy solution t\u00f6bb projectb\u0151l \u00e1llhat, egy project pedig t\u00f6bb f\u00e1jlb\u00f3l. A solution a teljes munkak\u00f6rnyezetet fogja \u00f6ssze (egy <code>.sln</code> kiterjeszt\u00e9s\u0171 f\u00e1jl tartozik hozz\u00e1), m\u00edg egy projekt kimenete egy <code>.exe</code> vagy <code>.dll</code> f\u00e1jl jellemz\u0151en, vagyis egy \u00f6sszetett alkalmaz\u00e1s/rendszer egy komponens\u00e9t \u00e1ll\u00edtja el\u0151. A projektf\u00e1jlok kiterjeszt\u00e9se C# alkalmaz\u00e1sok eset\u00e9n <code>.csproj</code>.</p> <p>A <code>Program.cs</code> f\u00e1jlunk tartalma a k\u00f6vetkez\u0151:</p> Program.cs<pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> <p>Vegy\u00fcnk fel egy <code>Console.ReadKey()</code> sort:</p> <pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171 haszn\u00e1lat\u00e1val).</p> <p>A k\u00f3d fel\u00e9p\u00edt\u00e9se nagyon hasonl\u00edt a Java-hoz, illetve a C++-hoz. Az oszt\u00e1lyaink n\u00e9vterekbe szervezettek. N\u00e9vteret defini\u00e1lni a <code>namespace</code> kulcssz\u00f3val tudunk. N\u00e9vtereket hat\u00f3k\u00f6rbe \u201ehozni\u201d a <code>using</code> kulcssz\u00f3val tudjuk.  pl.:</p> <pre><code>using System.Collections.Generic;\n</code></pre> </li> <li> <p>Egy konzolos C# alkalmaz\u00e1sban az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t egy statikus <code>Main</code> nev\u0171 f\u00fcggv\u00e9ny meg\u00edr\u00e1s\u00e1val adjuk meg. Az oszt\u00e1lyunk neve b\u00e1rmi lehet, a VS egy <code>Program</code> nev\u0171 oszt\u00e1lyt gener\u00e1lt eset\u00fcnkben. A <code>Main</code> f\u00fcggv\u00e9ny param\u00e9terlist\u00e1ja k\u00f6t\u00f6tt: vagy ne adjunk meg param\u00e9tereket, vagy egy <code>string[]</code>-\u00f6t adjunk meg, amiben fut\u00e1s k\u00f6zben megkapjuk az parancssori argumentumokat.</p> </li> <li>.NET-ben a standard ki \u00e9s bemenet kezel\u00e9s\u00e9re a <code>System</code> n\u00e9vt\u00e9r <code>Console</code> oszt\u00e1lya haszn\u00e1land\u00f3. A <code>WriteLine</code> statikus m\u0171velet\u00e9vel egy sort tudunk ki\u00edrni, a <code>ReadKey</code> m\u0171velettel egy billenty\u0171 lenyom\u00e1s\u00e1ra v\u00e1rakozhatunk.</li> </ol> <p>Top level statements, Implicit \u00e9s static usings \u00e9s n\u00e9vterek</p> <p>A projekt l\u00e9trehoz\u00e1sakor kor\u00e1bban bepip\u00e1ltuk a \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet. Ha ezt nem tett\u00fck volna meg, akkor a <code>Program.cs</code> f\u00e1jlunkban mind\u00f6ssze egyetlen \u00e9rdemi sort tal\u00e1ltunk volna:</p> <pre><code>// See https://aka.ms/new-console-template for more information\nConsole.WriteLine(\"Hello World!\");\n</code></pre> <p>Ez  m\u0171k\u00f6d\u00e9s\u00e9ben ekvivalens a fenti <code>Program</code> oszt\u00e1lyt \u00e9s ebben <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 k\u00f3ddal. N\u00e9zz\u00fck, mik teszik ezt lehet\u0151v\u00e9 (ezekr\u0151l pl. itt https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements olvashatunk b\u0151vebben, mindkett\u0151 C# 10 \u00fajdons\u00e1g):</p> <ul> <li>Top level statements. Ennek az a l\u00e9nyege, hogy mindenf\u00e9le oszt\u00e1ly/<code>Main</code> \u00e9s egy\u00e9b  f\u00fcggv\u00e9nydefin\u00edci\u00f3 n\u00e9lk\u00fcl a projektben egyetlen forr\u00e1sf\u00e1jlban k\u00f6zvetlen\u00fcl is \u00edrhatunk k\u00f3dot. Ez esetben ezt a sz\u00ednfalak m\u00f6g\u00f6tt a ford\u00edt\u00f3 berakja egy \u00e1ltalunk nem l\u00e1that\u00f3 oszt\u00e1ly statikus <code>Main</code> f\u00fcggv\u00e9ny\u00e9be. A bevezet\u00e9s\u00e9nek a motiv\u00e1ci\u00f3ja az volt, hogy a nagyon egyszer\u0171, \u201escript\u201d szer\u0171 alkalmaz\u00e1sok eset\u00e9n kevesebb legyen a boilerplate k\u00f3d.</li> <li>Implicit global usings. Annak f\u00fcggv\u00e9ny\u00e9ben, hogy pontosan milyen projektt\u00edpust hoztunk l\u00e9tre, bizonyos alapn\u00e9vterek a sz\u00ednfalak m\u00f6g\u00f6tt automatikusan using-olva lesznek minden forr\u00e1sf\u00e1jlban (ehhez a compiler a global using utas\u00edt\u00e1st haszn\u00e1lja). A l\u00e9nyeg: a fejleszt\u0151knek \u00edgy bizonyos, gyakran haszn\u00e1lt n\u00e9vtereket (pl. <code>System.IO</code>, <code>System.Collections.Generic</code> stb.) nem kell a forr\u00e1sf\u00e1jlonk\u00e9nt using-olni.</li> <li> <p>Static using. Lehet\u0151s\u00e9g\u00fcnk van C#-ban n\u00e9vterek helyett statikus oszt\u00e1lyokat is usingolni, \u00edgy azokat a haszn\u00e1latuk sor\u00e1n nem fontos ki\u00edrni. Gyakori eset erre a <code>Console</code> vagy a <code>Math</code> oszt\u00e1ly usingol\u00e1sa.</p> <pre><code>using static System.Console;\n\nnamespace ConsoleApp12\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine(\"Hello, World!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>F\u00e1jl szint\u0171 n\u00e9vterek. C# 10-ben szint\u00e9n egy egyszer\u0171s\u00edt\u00e9st kapunk a n\u00e9vterek deklar\u00e1l\u00e1sa sor\u00e1n, mert m\u00e1r nem k\u00f6telez\u0151 a kapcsos z\u00e1r\u00f3jeleket kitenni, \u00edgy az adott namespace a teljes f\u00e1jlra \u00e9rv\u00e9nyes lesz pl.:</p> <pre><code>namespace HelloWorld;\n\ninternal class Program\n{\n    // ...\n}\n</code></pre> </li> </ul> <p>Inconsistent visibility vagy inconsistent accessibility hiba</p> <p>A f\u00e9l\u00e9v sor\u00e1n a programoz\u00e1si feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n tal\u00e1lkozhatunk inconsistent visibility-re vagy inconsistent accessibility-re panaszkod\u00f3 ford\u00edt\u00e1si hiba\u00fczenetekkel. A jelens\u00e9g h\u00e1tter\u00e9ben az \u00e1ll, hogy .NET k\u00f6rnyezetben lehet\u0151s\u00e9g van az egyes t\u00edpusok (oszt\u00e1ly, interf\u00e9sz stb.) l\u00e1that\u00f3s\u00e1g\u00e1nak szab\u00e1lyoz\u00e1s\u00e1ra:</p> <ul> <li><code>internal</code> vagy nem adjuk meg a l\u00e1that\u00f3s\u00e1got: a t\u00edpus csak az adott szerelv\u00e9nyen (.exe, .dll)/projekten,  bel\u00fcl l\u00e1that\u00f3</li> <li><code>public</code>: a t\u00edpus m\u00e1s szerelv\u00e9nyek/projektek sz\u00e1m\u00e1ra is l\u00e1that\u00f3</li> </ul> <p>A hiba legegyszer\u0171bben \u00fagy h\u00e1r\u00edthat\u00f3 el, ha minden t\u00edpusunkat publikusnak defini\u00e1ljuk, pl.:</p> <pre><code>public class HardDisk\n{\n    // ...\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#elmeleti-attekintes","title":"Elm\u00e9leti \u00e1ttekint\u00e9s","text":"<p>Az alfejezetek nem tartalmaznak feladatot, a hallgat\u00f3k sz\u00e1m\u00e1ra ismertetik a kapcsol\u00f3d\u00f3 elm\u00e9leti t\u00e9mak\u00f6r\u00f6ket, p\u00e9ld\u00e1kkal illusztr\u00e1lva.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#a-az-uml-osztalydiagram-es-a-kod-kapcsolatanak-elmelete-hallgato","title":"A) Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolat\u00e1nak elm\u00e9lete [hallgat\u00f3]*","text":"<p>Az anyag itt el\u00e9rhet\u0151: Az UML oszt\u00e1lydiagram \u00e9s a k\u00f3d kapcsolata. Ez a t\u00e9mak\u00f6r kor\u00e1bbi f\u00e9l\u00e9vben a Szoftvertechnol\u00f3gia t\u00e1rgy keret\u00e9ben ker\u00fclt ismertet\u00e9sre.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#b-interfesz-es-absztrakt-ososztaly-hallgato","title":"B) Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly [hallgat\u00f3]*","text":"<p>Az anyag itt el\u00e9rhet\u0151: Interf\u00e9sz \u00e9s absztrakt (\u0151s)oszt\u00e1ly.</p> <p>T\u00e9mak\u00f6r\u00f6k:</p> <ul> <li>Absztrakt oszt\u00e1ly fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven</li> <li>Interf\u00e9sz fogalma \u00e9s defini\u00e1l\u00e1sa C# nyelven</li> <li>Absztrakt \u0151s \u00e9s interf\u00e9sz \u00f6sszehasonl\u00edt\u00e1sa</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#2-feladat-az-uml-es-a-kod-kapcsolatanak-szemleltetese","title":"2. Feladat - Az UML \u00e9s a k\u00f3d kapcsolat\u00e1nak szeml\u00e9ltet\u00e9se","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#feladat-leirasa-equipment-inventory","title":"Feladat le\u00edr\u00e1sa - Equipment inventory","text":"<p>Feladat: Egy sz\u00e1m\u00edt\u00f3g\u00e9palkatr\u00e9sz nyilv\u00e1ntart\u00f3 alkalmaz\u00e1s kifejleszt\u00e9s\u00e9vel b\u00edztak meg benn\u00fcnket. B\u0151vebben:</p> <ul> <li>K\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa alkatr\u00e9szeket kell tudni kezelni. Kezdetben a <code>HardDisk</code>, <code>SoundCard</code> \u00e9s <code>LedDisplay</code> t\u00edpusokat kell t\u00e1mogatni, de a rendszer legyen k\u00f6nnyen b\u0151v\u00edthet\u0151 \u00faj t\u00edpusokkal.</li> <li>Az alkatr\u00e9szekhez tartoz\u00f3 adatok: beszerz\u00e9s \u00e9ve, \u00e9letkora (sz\u00e1m\u00edtott), beszerz\u00e9si \u00e1ra \u00e9s aktu\u00e1lis \u00e1ra (sz\u00e1m\u00edtott), de ezeken fel\u00fcl t\u00edpusf\u00fcgg\u0151 adatokat is tartalmazhatnak (pl. a <code>HardDisk</code> eset\u00e9ben a kapacit\u00e1s).</li> <li>Az aktu\u00e1lis \u00e1r f\u00fcgg az alkatr\u00e9sz t\u00edpus\u00e1t\u00f3l, a beszerz\u00e9si \u00e1rt\u00f3l \u00e9s az alkatr\u00e9sz gy\u00e1rt\u00e1si \u00e9v\u00e9t\u0151l. Pl. min\u00e9l \u00f6regebb egy alkatr\u00e9sz, ann\u00e1l nagyobb kedvezm\u00e9nyt adunk r\u00e1, de a kedvezm\u00e9ny m\u00e9rt\u00e9ke f\u00fcgg az alkatr\u00e9sz t\u00edpust\u00f3l is.</li> <li>List\u00e1zni kell tudni a k\u00e9szleten lev\u0151 alkatr\u00e9szeket.</li> <li>A <code>LedDisplay</code> oszt\u00e1lynak k\u00f6telez\u0151en egy <code>DisplayBase</code> oszt\u00e1lyb\u00f3l kell sz\u00e1rmaznia, \u00e9s a <code>DisplayBase</code> oszt\u00e1ly forr\u00e1sk\u00f3dja nem megv\u00e1ltoztathat\u00f3. Jelen p\u00e9ld\u00e1ban ennek nincs sok \u00e9rtelme, a gyakorlatban azonban gyakran tal\u00e1lkozunk hasonl\u00f3 helyzettel, amikor is az \u00e1ltalunk haszn\u00e1lt keretrendszer/platform el\u0151\u00edrja, hogy adott esetben egy-egy be\u00e9p\u00edtett oszt\u00e1lyb\u00f3l kell sz\u00e1rmaztassunk. Tipikusan ez a helyzet, amikor ablakokkal, \u0171rlapokkal, saj\u00e1t vez\u00e9rl\u0151t\u00edpusokkal dolgozunk: ezeket a keretrendszer be\u00e9p\u00edtett oszt\u00e1lyaib\u00f3l kell sz\u00e1rmaztatnunk, \u00e9s a keretrendszer  - pl. Java, .NET - forr\u00e1sk\u00f3dja nem \u00e1ll rendelkez\u00e9s\u00fcnkre (de legal\u00e1bbis biztosan nem akarjuk megv\u00e1ltoztatni). A p\u00e9ld\u00e1nkban a <code>DisplayBase</code>-b\u0151l val\u00f3 sz\u00e1rmaztat\u00e1s el\u0151\u00edr\u00e1s\u00e1val ezt a helyzetet szimul\u00e1ljuk.</li> </ul> <p>A megval\u00f3s\u00edt\u00e1s sor\u00e1n jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9l\u00fcnk: az alkatr\u00e9szeket csak mem\u00f3ri\u00e1ban tarjuk nyilv\u00e1n, a list\u00e1z\u00e1s is a lehet\u0151 legegyszer\u0171bb, egyszer\u0171en csak ki\u00edrjuk a nyilv\u00e1ntartott alkatr\u00e9szek adatait a konzolra.</p> <p>A kezdeti egyeztet\u00e9sek sor\u00e1n a megrendel\u0151nkt\u0151l a k\u00f6vetkez\u0151 inform\u00e1ci\u00f3t kapjuk: egy bels\u0151 munkat\u00e1rsuk m\u00e1r elindult a fejleszt\u00e9ssel, de id\u0151 hi\u00e1ny\u00e1ban csak f\u00e9lk\u00e9sz megold\u00e1sig jutott. A feladatunk r\u00e9sz\u00e9t k\u00e9pezi a f\u00e9lk\u00e9sz megold\u00e1s megismer\u00e9se, illetve ebb\u0151l kiindulva kell a feladatot megval\u00f3s\u00edtani.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#class-diagram","title":"Class Diagram","text":"<p>Nyissuk meg a megrendel\u0151nkt\u0151l kapott forr\u00e1sk\u00f3d solution-j\u00e9t, melyet a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket k\u00f6vetve tudunk megtenni.</p> <p>Ehhez kl\u00f3nozzuk le a kiindul\u00f3 projekt online GitHub rendszerben el\u00e9rhet\u0151 Git repositoryj\u00e1t a <code>C:\\Work</code> mapp\u00e1n bel\u00fcl egy \u00faj saj\u00e1t mapp\u00e1ba: pl.: <code>C:\\Work\\NEPTUN\\lab1</code>. Ebben az \u00faj mapp\u00e1ban nyissunk meg egy command line-t vagy powershellt \u00e9s futtassuk az al\u00e1bbi git parancsot:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git\n</code></pre> <p>Git \u00e9s GitHub</p> <p>A Git-r\u0151l, mint forr\u00e1sk\u00f3dkezel\u0151 rendszerr\u0151l, az els\u0151 h\u00e1zi feladat kontextus\u00e1ban olvashatunk majd b\u0151vebben.</p> <p>Nyissuk meg a lekl\u00f3nozott mapp\u00e1ban tal\u00e1lhat\u00f3 src/EquipmentInventory.sln Visual Studio solutiont.</p> <p>A Solution Explorerben szemmel fussuk \u00e1t a f\u00e1jlokat. Az meg\u00e9rt\u00e9st seg\u00edten\u00e9, ha egy oszt\u00e1lydiagramon megjelen\u00edten\u00e9nk az oszt\u00e1lyok k\u00f6z\u00f6tti kapcsolatokat. Vegy\u00fcnk is fel egy oszt\u00e1lydiagramot a projekt\u00fcnkbe. A Solution Explorerben a projekten (\u00e9s nem a solution-\u00f6n!) jobb gombbal kattintva a felugr\u00f3 men\u00fcben az Add/New Item elemet v\u00e1lasztva, majd a megjelen\u0151 ablakban a Class Diagram elemet v\u00e1lasszuk ki, az ablak alj\u00e1n a diagram nev\u00e9nek a Main.cd-t adjuk meg, \u00e9s OK-zuk le az ablakot.</p> <p>Class Diagram hi\u00e1nyz\u00f3 sablon</p> <p>Ha a Class Diagram elem nem jelenik meg a list\u00e1ban, akkor nincs telep\u00edtve a VS megfelel\u0151 komponense. Err\u0151l jelen dokumentum El\u0151felt\u00e9telek fejezet\u00e9ben olvashatsz b\u0151vebben.</p> <p>Ekkor a Solution Explorerben megjelenik a <code>Main.cd</code> diagramf\u00e1jl, duplakattint\u00e1ssal nyissuk meg. A diagramunk jelenleg \u00fcres. A Solution Explorerb\u0151l drag&amp;drop-pal dobjuk r\u00e1 a .cs forr\u00e1sf\u00e1jlokat a diagramra. Ekkor a VS megn\u00e9zi, milyen oszt\u00e1lyok vannak ezekben a forr\u00e1sf\u00e1jlokban, \u00e9s visszafejti \u0151ket UML oszt\u00e1lyokk\u00e1. Alak\u00edtsuk ki a k\u00f6vetkez\u0151 \u00e1br\u00e1nak megfelel\u0151 elrendez\u00e9st (az oszt\u00e1lyok tagjainak megjelen\u00edt\u00e9s\u00e9t a t\u00e9glalapuk jobb fels\u0151 sark\u00e1ban lev\u0151 duplany\u00edlra kattint\u00e1ssal \u00e9rhetj\u00fck el):</p> <p></p> <p>Az oszt\u00e1lyokhoz tartoz\u00f3 forr\u00e1sk\u00f3dot is megn\u00e9zhetj\u00fck, ak\u00e1r a diagramon a megfelel\u0151 oszt\u00e1lyra dupl\u00e1n kattintva, ak\u00e1r a Solution Explorerb\u0151l a .cs f\u00e1jlokat megnyitva. A k\u00f6vetkez\u0151ket tapasztaljuk:</p> <ul> <li>A <code>SoundCard</code>, <code>HardDisk</code> \u00e9s <code>LedDisplay</code> oszt\u00e1lyok viszonylag j\u00f3l kidolgozottak, rendelkeznek a sz\u00fcks\u00e9ges attrib\u00fatumokkal \u00e9s lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyekkel.</li> <li>Az <code>LedDisplay</code> a k\u00f6vetelm\u00e9nyeknek megfelel\u0151en a <code>DisplayBase</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik.</li> <li>Az <code>EquipmentInventory</code> felel\u0151s ugyan a k\u00e9szleten lev\u0151 alkatr\u00e9szek nyilv\u00e1ntart\u00e1s\u00e1\u00e9rt, de gyakorlatilag semmi nincs ebb\u0151l megval\u00f3s\u00edtva.</li> <li>Tal\u00e1lunk egy <code>IEquipment</code> interf\u00e9szt, <code>GetAge</code> \u00e9s <code>GetPrice</code> m\u0171veletekkel</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#equipmentinventory","title":"EquipmentInventory","text":"<p>\u00c1lljunk neki a megold\u00e1s kidolgoz\u00e1s\u00e1nak. El\u0151sz\u00f6r is az alapkoncepci\u00f3kat fektess\u00fck le. Az <code>EquipmentInventory</code> oszt\u00e1lyban egy heterog\u00e9n kollekci\u00f3ban t\u00e1roljuk a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusokat. Ez a kulcsa az alkatr\u00e9szek egys\u00e9ges kezel\u00e9s\u00e9nek, vagyis annak, hogy a megold\u00e1sunk \u00faj alkatr\u00e9szt\u00edpusokkal k\u00f6nnyen b\u0151v\u00edthet\u0151 legyen.</p> <p>Mint kor\u00e1bban taglaltuk, az egys\u00e9ges kezel\u00e9st vagy k\u00f6z\u00f6s \u0151soszt\u00e1ly, vagy k\u00f6z\u00f6s interf\u00e9sz bevezet\u00e9s\u00e9vel lehet megoldani. Eset\u00fcnkben a k\u00f6z\u00f6s \u0151soszt\u00e1ly (pl. <code>EquipmentBase</code>) \u00fagy t\u0171nik, kiesik, mert ennek bevezet\u00e9s\u00e9vel az <code>LedDisplay</code> oszt\u00e1lynak k\u00e9t \u0151soszt\u00e1lya is lenne: a k\u00f6telez\u0151nek kik\u00f6t\u00f6tt <code>DisplayBase</code>, \u00e9s az \u00e1ltalunk az egys\u00e9ges kezel\u00e9sre bevezetett <code>EquipmentBase</code>. Ez nem lehets\u00e9ges, .NET k\u00f6rnyezetben egy oszt\u00e1lynak csak egy \u0151se lehet. Az a megold\u00e1s pedig, hogy a <code>DisplayBase</code>-t \u00fagy m\u00f3dos\u00edtjuk, hogy \u0151 is az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmazik, a k\u00f6vetelm\u00e9ny\u00fcnknek megfelel\u0151en nem lehets\u00e9ges (kik\u00f6t\u00e9s volt, hogy a forr\u00e1sk\u00f3dja nem m\u00f3dos\u00edthat\u00f3). Marad teh\u00e1t az interf\u00e9sz alap\u00fa megk\u00f6zel\u00edt\u00e9s. Minden bizonnyal az alkalmaz\u00e1s kor\u00e1bbi fejleszt\u0151je is erre a k\u00f6vetkeztet\u00e9sre jutott, ez\u00e9rt is vezette be az <code>IEquipment</code> interf\u00e9szt.</p> <p>Vegy\u00fcnk fel egy <code>IEquipment</code> t\u00edpus\u00fa elemekb\u0151l \u00e1ll\u00f3 generikus list\u00e1t (ne property-t hanem field-et!) az <code>EquipmentInventory</code> oszt\u00e1lyba. A l\u00e1that\u00f3s\u00e1ga \u2013 az egys\u00e9gbez\u00e1r\u00e1sra t\u00f6rekedve \u2013 legyen <code>private</code>. A neve legyen <code>equipment</code> (ne legyen \u201es\u201d a v\u00e9g\u00e9n, angolban az equipment t\u00f6bbes sz\u00e1ma is equipment). A tagv\u00e1ltoz\u00f3 felv\u00e9tel\u00e9hez a Visual Studio Class Details ablak\u00e1t haszn\u00e1ljuk. Ha az ablak nem l\u00e1that\u00f3, a View / Other Windows / Class Details men\u00fc kiv\u00e1laszt\u00e1s\u00e1val jelen\u00edthet\u0151 meg.</p> <p></p> <p>A tagv\u00e1ltoz\u00f3 t\u00edpusa teh\u00e1t <code>List&lt;IEquipment&gt;</code>. A .NET <code>List</code> t\u00edpusa egy dinamikusan ny\u00fajt\u00f3zkod\u00f3 generikus t\u00f6mb (mint Java-ban az <code>ArrayList</code>). A diagramon az <code>EquipmentInventory</code> oszt\u00e1lyra pillantva azt l\u00e1tjuk, hogy csak a tagv\u00e1ltoz\u00f3 neve jelenik meg, a t\u00edpusa nem. A diagram h\u00e1tter\u00e9n jobb gombbal kattintva a Change Members Format men\u00fcb\u0151l a Display Full Signature-t v\u00e1lasszuk ki. Ezt k\u00f6vet\u0151en a diagramon l\u00e1that\u00f3v\u00e1 v\u00e1lik a tagv\u00e1ltoz\u00f3k t\u00edpusa, valamint a m\u0171veletek teljes szignat\u00far\u00e1ja.</p> <p></p> <p>Az <code>EquipmentInventory</code> oszt\u00e1lyon dupl\u00e1n kattintva elnavig\u00e1lhatunk a forr\u00e1sk\u00f3dba, \u00e9s mint l\u00e1that\u00f3, val\u00f3ban egy lista t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k\u00e9nt jelenik meg a k\u00f3dban:</p> <pre><code>class EquipmentInventory\n{\n    private List&lt;IEquipment&gt; equipment;\n</code></pre> <p>Ennek egyr\u00e9szt \u00f6r\u00fcl\u00fcnk, mert a Visual Studio t\u00e1mogatja a round-trip engineering technik\u00e1t: a modellt \u00e9rint\u0151 v\u00e1ltoz\u00e1sokat azonnal \u00e1tvezeti a k\u00f3dba, \u00e9s viszont. M\u00e1sr\u00e9szt a kor\u00e1bbiakban azt taglaltuk, hogy ha egy oszt\u00e1lyban egy gy\u0171jtem\u00e9ny tag van egy m\u00e1sik oszt\u00e1ly elemeib\u0151l, akkor annak az UML modellben egy 1-t\u00f6bb t\u00edpus\u00fa asszoci\u00e1ci\u00f3s kapcsolatk\u00e9nt \u201eillik\u201d megjelennie a k\u00e9t oszt\u00e1ly k\u00f6z\u00f6tt. A modell\u00fcnkben egyel\u0151re nem ezt tapasztaljuk. Szerencs\u00e9re a VS modellez\u0151 fel\u00fclete r\u00e1vehet\u0151, hogy ilyen form\u00e1ban jelen\u00edtse meg ezt a kapcsolatt\u00edpust. Ehhez kattintsunk a diagramon jobb gombbal az equipment tagv\u00e1ltoz\u00f3n, \u00e9s a men\u00fcb\u0151l v\u00e1lasszuk ki a Show as Collection Association elemet. Az <code>IEquipment</code> interf\u00e9szt ezt k\u00f6vet\u0151en mozgassuk ki jobbra, hogy kell\u0151 hely legyen a diagramon az asszoci\u00e1ci\u00f3s kapcsolat \u00e9s a kapcsolaton lev\u0151 szerep (role) adatainak megjelen\u00edt\u00e9s\u00e9re:</p> <p></p> <p>A dupla ny\u00edl v\u00e9gz\u0151d\u00e9s a \u201et\u00f6bbes\u201d oldalon nem szabv\u00e1nyos UML, de ne szomorodjunk el t\u0151le k\u00fcl\u00f6n\u00f6sebben, nincs semmi jelent\u0151s\u00e9ge. Annak mindenk\u00e9ppen \u00f6r\u00fcl\u00fcnk, hogy  a kapcsolatot reprezent\u00e1l\u00f3 ny\u00edl az <code>IEquipment</code> v\u00e9g\u00e9n a szerepben a tagv\u00e1ltoz\u00f3 neve (s\u0151t, m\u00e9g a pontos t\u00edpusa is) fel van t\u00fcntetve.</p> <p>Navig\u00e1ljunk el az <code>EquipmentInventory</code> forr\u00e1sk\u00f3dj\u00e1hoz, \u00e9s \u00edrjuk meg a konstruktor\u00e1t, ami inicializ\u00e1lja az <code>equipment</code> gy\u0171jtem\u00e9nyt!</p> <pre><code>public EquipmentInventory()\n{\n    equipment = new List&lt;IEquipment&gt;();\n}\n</code></pre> <p>Ezut\u00e1n \u00edrjuk meg a <code>ListAll</code> met\u00f3dust, ami ki\u00edrja az elemek \u00e9letkor\u00e1t, \u00e9s az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket:</p> <pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Az elemeken a <code>foreach</code> utas\u00edt\u00e1ssal iter\u00e1lunk v\u00e9gig. A <code>foreach</code> utas\u00edt\u00e1s haszn\u00e1lata sor\u00e1n az <code>in</code> kulcssz\u00f3 ut\u00e1n egy gy\u0171jtem\u00e9nynek kell \u00e1llnia, az <code>in</code> el\u0151tt pedig egy v\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3nak (eset\u00fcnkben <code>IEquipment eq</code>), ahol a t\u00edpus a gy\u0171jtem\u00e9ny elemt\u00edpusa. Minden iter\u00e1ci\u00f3ban ez a v\u00e1ltoz\u00f3 a gy\u0171jtem\u00e9ny iter\u00e1ci\u00f3beli \u00e9rt\u00e9k\u00e9t veszi fel.</p> <p>A <code>Console.WriteLine</code> m\u0171veletnek vagy egy egyszer\u0171 stringet adunk meg, vagy, mint eset\u00fcnkben, egy form\u00e1z\u00e1si stringet. A behelyettes\u00edt\u00e9seket string interpol\u00e1ci\u00f3val oldottuk meg: a behelyettes\u00edtend\u0151 \u00e9rt\u00e9keket <code>{}</code> k\u00f6z\u00f6tt kell megadni. Ha string interpol\u00e1ci\u00f3t haszn\u00e1lunk, a stringnek <code>$</code> jellel kell kezd\u0151dnie.</p> <p>\u00cdrjunk meg egy <code>AddEquipment</code> nev\u0171 f\u00fcggv\u00e9nyt, ami felvesz egy \u00faj eszk\u00f6zt a k\u00e9szletbe:</p> <pre><code>public void AddEquipment(IEquipment eq)\n{\n     equipment.Add(eq);\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#iequipment-megvalositok","title":"IEquipment megval\u00f3s\u00edt\u00f3k","text":"<p>Kor\u00e1bbi d\u00f6nt\u00e9s\u00fcnk \u00e9rtelm\u00e9ben az <code>IEquipment</code> interf\u00e9szt haszn\u00e1ljuk az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9sz t\u00edpusok egys\u00e9ges kezel\u00e9s\u00e9re. Est\u00fcnkben mind a <code>SoundCard</code>, mind a <code>HardDisk</code> oszt\u00e1ly rendelkezik <code>GetAge()</code> \u00e9s <code>GetPrice()</code> met\u00f3dussal, m\u00e9gsem tudjuk \u0151ket egys\u00e9gesen kezelni (pl. k\u00f6z\u00f6s list\u00e1ban t\u00e1rolni). Ahhoz, hogy ezt meg tudjuk tenni, el kell \u00e9rn\u00fcnk, hogy mindk\u00e9t oszt\u00e1ly megval\u00f3s\u00edtsa az <code>IEquipment</code> interf\u00e9szt. M\u00f3dos\u00edtsuk a forr\u00e1sukat:</p> <pre><code>public class SoundCard : IEquipment\n</code></pre> <pre><code>public class HardDisk : IEquipment\n</code></pre> <p>Ezt k\u00f6vet\u0151en a <code>SoundCard</code> \u00e9s <code>HardDisk</code> oszt\u00e1lyban implement\u00e1lnunk kell az <code>IEquipment</code> interf\u00e9szben lev\u0151 met\u00f3dusokat. Azt tapasztaljuk, hogy ezzel nincs most teend\u0151k, a <code>GetPrice</code> \u00e9s <code>GetAge</code> f\u00fcggv\u00e9nyek m\u00e1r meg vannak \u00edrva mindk\u00e9t helyen.</p> <p>Pr\u00f3bak\u00e9ppen a <code>Program.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben hozzunk l\u00e9tre egy <code>EquipmentInventory</code> objektumot, t\u00f6lts\u00fck fel <code>HardDisk</code> \u00e9s <code>SoundCard</code> objektumokkal, majd list\u00e1zzuk a k\u00e9sztelet a konzolra. Ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra!</p> <pre><code>static void Main( string[] args )\n{\n    EquipmentInventory ei = new EquipmentInventory();\n\n    ei.AddEquipment(new HardDisk(2021, 30000, 80));\n    ei.AddEquipment(new HardDisk(2020, 25000, 120));\n    ei.AddEquipment(new HardDisk(2020, 25000, 250));\n\n    ei.AddEquipment(new SoundCard(2021, 8000));\n    ei.AddEquipment(new SoundCard(2020, 7000));\n    ei.AddEquipment(new SoundCard(2020, 6000));\n\n    ei.ListAll();\n}\n</code></pre> <p>Az alkalmaz\u00e1st futtatva azt tapasztaljuk, hogy b\u00e1r megold\u00e1sunk kezdetleges, de m\u0171k\u00f6dik:</p> <p></p> <p>Folytassuk a munk\u00e1t a <code>LedDisplay</code> oszt\u00e1llyal. A <code>DisplayBase</code> \u0151s forr\u00e1sk\u00f3dj\u00e1t a k\u00f6vetelm\u00e9nyek miatt nem m\u00f3dos\u00edthatjuk. De ez semmif\u00e9le probl\u00e9m\u00e1t nem okoz, a <code>LedDisplay</code> oszt\u00e1lyunk fogja az <code>IEquipment</code> interf\u00e9szt implement\u00e1lni, m\u00f3dos\u00edtsuk a k\u00f3dot ennek megfelel\u0151en:</p> <pre><code>public class LedDisplay : DisplayBase, IEquipment\n</code></pre> <p>A <code>LedDisplay</code> oszt\u00e1lyban m\u00e1r meg kell \u00edrni az interf\u00e9szben szerepl\u0151 f\u00fcggv\u00e9nyeket:</p> <pre><code>public double GetPrice()\n{\n    return this.price;\n}\n\npublic int GetAge()\n{\n    return DateTime.Today.Year - this.manufacturingYear;\n}\n</code></pre> <p>B\u0151v\u00edts\u00fck a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnket is, vegy\u00fcnk fel k\u00e9t <code>LedDisplay</code> objektumot a k\u00e9szlet\u00fcnkbe (itt is \u00e9l, hogy ammennyiben nem 2021 az aktu\u00e1lis \u00e9v, az al\u00e1bbi sorokn\u00e1l a 2021-es \u00e9vet \u00edrjuk \u00e1t az aktu\u00e1lis \u00e9vre, a 2020-at pedig enn\u00e9l eggyel kisebb sz\u00e1mra!</p> <pre><code>ei.AddEquipment(new LedDisplay(2020, 80000, 17, 16));\nei.AddEquipment(new LedDisplay (2021, 70000, 17, 12));\n\nei.ListAll();\nConsole.ReadKey();\n</code></pre> <p>Tesztel\u00e9sk\u00e9ppen futtassuk az alkalmaz\u00e1st.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#3-feladat-az-interfesz-es-az-absztrakt-ososztaly-alkalmazastechnikaja","title":"3. Feladat - Az interf\u00e9sz \u00e9s az absztrakt \u0151soszt\u00e1ly alkalmaz\u00e1stechnik\u00e1ja","text":""},{"location":"labor/1-model-es-kod-kapcsolata/#interfesz-problematikaja","title":"Interf\u00e9sz problematik\u00e1ja","text":"<p>\u00c9rt\u00e9kelj\u00fck a jelenlegi, interf\u00e9sz alap\u00fa megold\u00e1sunkat.</p> <p>Az egyik f\u0151 probl\u00e9ma, hogy k\u00f3dunk tele van a karbantarthat\u00f3s\u00e1got \u00e9s b\u0151v\u00edthet\u0151s\u00e9get rombol\u00f3 k\u00f3dduplik\u00e1ci\u00f3val:</p> <ul> <li>A <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagok minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis <code>LedDisplay</code>-t) k\u00f6z\u00f6sek, ezeket \u00faj t\u00edpus bevezet\u00e9sekor is copy-paste technik\u00e1val \u00e1t kell venni.</li> <li>A <code>GetAge</code> f\u00fcggv\u00e9ny implement\u00e1ci\u00f3ja szinten minden alkatr\u00e9sz t\u00edpusban (kiv\u00e9ve a speci\u00e1lis <code>LedDisplay</code>-t) azonos, szint\u00e9n copy-paste-tel \u201eszapor\u00edtand\u00f3\u201d.</li> <li>A konstruktorok <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagokat inicializ\u00e1l\u00f3 sorai szint\u00e9n duplik\u00e1ltak az egyes oszt\u00e1lyokban.</li> </ul> <p>B\u00e1r ez a k\u00f3dduplik\u00e1ci\u00f3 egyel\u0151re nem t\u0171nik jelent\u0151snek, \u00faj alkatr\u00e9sz t\u00edpusok bevezet\u00e9s\u00e9vel egyre ink\u00e1bb elm\u00e9rgesedik a helyzet, jobb id\u0151ben elej\u00e9t venni a j\u00f6v\u0151beli f\u00e1jdalmaknak.</p> <p>A m\u00e1sik probl\u00e9ma abb\u00f3l ad\u00f3dik, hogy az alkatr\u00e9sz adatok list\u00e1z\u00e1sa jelenleg f\u00e1jdalmasan hi\u00e1nyos, nem jelenik meg az alkatr\u00e9sz t\u00edpusa (csak a kora \u00e9s az \u00e1ra). A t\u00edpus megjelen\u00edt\u00e9s\u00e9hez az IEquipment interf\u00e9szt b\u0151v\u00edteni kell, pl. egy <code>GetDescription</code> nev\u0171 m\u0171velet bevezet\u00e9s\u00e9vel.  Vegy\u00fcnk is fel egy <code>GetDescription</code> f\u00fcggv\u00e9nyt az interf\u00e9szbe!</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription();\n}\n</code></pre> <p>Ekkor minden <code>IEquipment</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyban meg kellene val\u00f3s\u00edtani ezt a met\u00f3dust is, ami sok oszt\u00e1ly eset\u00e9n sok munka (valamint egy t\u00f6bbkomponens\u0171, vagyis t\u00f6bb DLL-b\u0151l \u00e1ll\u00f3 alkalmaz\u00e1s eset\u00e9ben, amikor ezek nem egy fejleszt\u0151 c\u00e9g kez\u00e9ben vannak, sokszor nem is megoldhat\u00f3). A Build parancs futtat\u00e1s\u00e1val ellen\u0151rizz\u00fck, hogy a <code>GetDescription</code> felv\u00e9tele ut\u00e1n h\u00e1rom helyen is ford\u00edt\u00e1si hib\u00e1t kapunk.</p> <p>Interf\u00e9szben alap\u00e9rtelmezett implement\u00e1ci\u00f3 megad\u00e1sa</p> <p>\u00c9rdemes tudni, hogy C# 8-t\u00f3l (illetve .NET vagy .NET Core runtime is kell hozz\u00e1, .NET Framework alatt nem t\u00e1mogatott) kezdve interf\u00e9sz m\u0171veleteknek is lehet alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni (default interface methods), \u00edgy a fenti probl\u00e9ma megold\u00e1s\u00e1hoz nincs sz\u00fcks\u00e9g absztrakt oszt\u00e1lyra, de interf\u00e9sznek tov\u00e1bbiakban sem lehet tagv\u00e1ltoz\u00f3ja. B\u0151vebben inform\u00e1ci\u00f3 itt:  default interface methods.</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription() { return \"EquipmentBase\"; }\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#absztrakt-osztaly","title":"Absztrakt oszt\u00e1ly","text":"<p>Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelent egy k\u00f6z\u00f6s absztrakt \u0151s bevezet\u00e9se (kiv\u00e9ve az <code>LedDisplay</code> oszt\u00e1lyt, amire m\u00e9g visszat\u00e9r\u00fcnk). Ebbe fel tudjuk k\u00f6lt\u00f6ztetni a lesz\u00e1rmazottakra k\u00f6z\u00f6s k\u00f3dot, valamint az \u00fajonnan bevezetett <code>GetDescription</code> m\u0171velethez egy alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni. Legyen az \u00faj absztrakt \u0151soszt\u00e1lyunk neve <code>EquipmentBase</code>. K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e a tov\u00e1bbiakban az <code>IEquipment</code> interf\u00e9szre, vagy az teljesen kiv\u00e1lthat\u00f3 az \u00faj <code>EquipmentBase</code> oszt\u00e1llyal. Az <code>IEquipment</code> interf\u00e9szt meg kell tartsuk, mert a LedDisplay oszt\u00e1lyunkat nem tudjuk az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmaztatni: m\u00e1r van egy k\u00f6telez\u0151en el\u0151\u00edrt \u0151soszt\u00e1lya, a <code>DisplayBase</code>: emiatt az EquipmentInventory a tov\u00e1bbfejlesztett megold\u00e1sunkban is <code>IEquipment</code> interf\u00e9szk\u00e9nt hivatkozik az k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szekre.</p> <p>\u00c1lljunk is neki az \u00e1talak\u00edt\u00e1snak. Legyen az oszt\u00e1lydiagramunk az akt\u00edv tabf\u00fcl. A Toolbox-b\u00f3l drag&amp;drop-pal dobjunk fel egy Abstract Class elemet a diagramra, a neve legyen <code>EquipmentBase</code>.</p> <p></p> <p>A k\u00f6vetkez\u0151kben azt kell el\u00e9rj\u00fck, hogy a <code>SoundCard</code> \u00e9s a <code>HardDisk</code> oszt\u00e1lyok sz\u00e1rmazzanak az <code>EquipmentBase</code>-b\u0151l (a <code>LedDisplay</code>-nek m\u00e1r van m\u00e1sik \u0151se, \u00edgy ott ezt nem tudjuk megtenni). Ehhez v\u00e1lasszuk ki az Inheritance kapcsolatot a Toolbox-ban, majd h\u00fazzunk egy-egy vonalat a gyermekoszt\u00e1lyb\u00f3l kiindulva az \u0151soszt\u00e1lyba a <code>SoundCard</code> \u00e9s <code>HardDisk</code> eset\u00e9ben egyar\u00e1nt.</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben alak\u00edtsuk \u00e1t \u00fagy a k\u00f3dot, hogy ne a <code>HardDisk</code> \u00e9s <code>SoundCard</code> val\u00f3s\u00edts\u00e1k meg k\u00fcl\u00f6n-k\u00fcl\u00f6n az <code>IEquipment</code> interf\u00e9szt, hanem a k\u00f6z\u00f6s \u0151s\u00fck, az <code>EquipmentBase</code> egyszer. Ehhez m\u00f3dos\u00edtsuk az EquipmentBase oszt\u00e1lyt \u00fagy, hogy val\u00f3s\u00edtsa meg az interf\u00e9szt (ak\u00e1r a diagramon h\u00fazzunk be egy inheritance kapcsolatot az <code>EquipmentBase</code>-b\u0151l az <code>IEquipment</code>-be, vagy az <code>EquipmentBase</code> forr\u00e1sk\u00f3dj\u00e1t m\u00f3dos\u00edtsuk). A <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokb\u00f3l t\u00f6r\u00f6lj\u00fck az <code>IEquipment</code> megval\u00f3s\u00edt\u00e1s\u00e1t (az \u0151s m\u00e1r implement\u00e1lja).</p> <p>A diagramunk \u00e9s a forr\u00e1sk\u00f3dunk vonatkoz\u00f3 r\u00e9szei ezt k\u00f6vet\u0151en \u00edgy n\u00e9znek ki:</p> <p></p> <pre><code>public abstract class EquipmentBase : IEquipment\n</code></pre> <pre><code>public class HardDisk : EquipmentBase\n</code></pre> <pre><code>public class SoundCard : EquipmentBase\n</code></pre> <p>A k\u00f3dunk m\u00e9g nem fordul, ennek t\u00f6bb oka is van. Az <code>EquipmentBase</code> implement\u00e1lja az <code>IEquipment</code> interf\u00e9szt, de m\u00e9g nincsenek benne implement\u00e1lva az interf\u00e9sz m\u0171veletei. Vagy gener\u00e1ltassuk le a met\u00f3dusokat a smart tag haszn\u00e1lat\u00e1val, vagy g\u00e9pelj\u00fck be a k\u00f6vetkez\u0151 elveknek megfelel\u0151en:</p> <ul> <li>A <code>newPrice</code> \u00e9s <code>yearOfCreation</code> duplik\u00e1lva vannak a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban: mozgassuk (\u00e9s ne m\u00e1soljuk!) \u00e1t ezeket a k\u00f6z\u00f6s <code>EquipmentBase</code> \u0151sbe, \u00e9s <code>protected</code> l\u00e1that\u00f3s\u00e1got adjunk meg.</li> <li>A <code>GetAge</code> m\u0171velet duplik\u00e1lva van a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban, ezekb\u0151l t\u00f6r\u00f6lj\u00fck ki az implement\u00e1ci\u00f3t \u00e9s vigy\u00fck \u00e1t az <code>EquipmentBase</code> oszt\u00e1lyba.</li> <li>A <code>GetPrice</code> m\u0171veletet absztrakt m\u0171veletk\u00e9nt vegy\u00fck fel az \u0151sbe. Ez sz\u00e1nd\u00e9kos tervez\u0151i d\u00f6nt\u00e9s, \u00edgy r\u00e1k\u00e9nyszer\u00edtj\u00fck a lesz\u00e1rmazott oszt\u00e1lyokat, hogy mindenk\u00e9ppen defini\u00e1lj\u00e1k fel\u00fcl ezt a m\u0171veletet.</li> <li>A <code>GetDescription</code> eset\u00e9ben viszont pont ford\u00edtottja a helyzet: ezt virtu\u00e1lisnak defini\u00e1ljuk (\u00e9s nem absztraktnak), vagyis m\u00e1r az \u0151sben is adunk meg implement\u00e1ci\u00f3t. \u00cdgy a lesz\u00e1rmazottak nincsenek r\u00e1k\u00e9nyszer\u00edtve a m\u0171velet fel\u00fcldefini\u00e1l\u00e1s\u00e1ra.</li> </ul> <p>A fentieknek megfelel\u0151 k\u00f3d a k\u00f6vetkez\u0151:</p> <pre><code>public abstract class EquipmentBase : IEquipment\n{\n    protected int yearOfCreation;\n    protected int newPrice;\n\n    public int GetAge()\n    {\n        return DateTime.Today.Year - yearOfCreation;\n    }\n\n    public abstract double GetPrice();\n\n    public virtual string GetDescription()\n    {\n        return \"EquipmentBase\";\n    }\n}\n</code></pre> <p>N\u00e9h\u00e1ny kieg\u00e9sz\u00edt\u0151 gondolat a k\u00f3dr\u00e9szletre vonatkoz\u00f3an:</p> <ul> <li>Az absztrakt oszt\u00e1lyok eset\u00e9ben az <code>abstract</code> kulcssz\u00f3t ki kell \u00edrni a <code>class</code> sz\u00f3 el\u00e9.</li> <li>Az absztrakt m\u0171veletek eset\u00e9ben az <code>abstract</code> kulcssz\u00f3t kell megadni</li> <li>.NET k\u00f6rnyezetben lehet\u0151s\u00e9g\u00fcnk van szab\u00e1lyozni, hogy egy m\u0171velet virtu\u00e1lis-e vagy sem. Ebb\u0151l a szempontb\u00f3l a C++ nyelvhez hasonl\u00edt. Amennyiben egy m\u0171veletet virtu\u00e1liss\u00e1 szeretn\u00e9nk tenni, a <code>virtual</code> kulcssz\u00f3t kell a m\u0171veletre megadni. Eml\u00e9keztet\u0151: akkor defini\u00e1ljunk egy m\u0171veletet virtu\u00e1lisnak, ha a lesz\u00e1rmazottak azt fel\u00fcldefini\u00e1l(hat)j\u00e1k. Csak ekkor garant\u00e1lt, hogy egy \u0151sreferenci\u00e1n megh\u00edvva az adott m\u0171veletet a lesz\u00e1rmazottbeli verzi\u00f3 h\u00edv\u00f3dik meg.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/#leszarmazottak","title":"Lesz\u00e1rmazottak","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben t\u00e9rj\u00fcnk \u00e1t az <code>EquipmentBase</code> lesz\u00e1rmazottakra. C# nyelven az absztrakt \u00e9s virtu\u00e1lis m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor a lesz\u00e1rmazottban meg kell adni az <code>override</code> kulcssz\u00f3t. Els\u0151 l\u00e9p\u00e9sben a <code>GetPrice</code> m\u0171veletet defini\u00e1ljuk fel\u00fcl:</p> HardDisk.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0\n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 5000;\n}\n</code></pre> SoundCard.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0 \n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 2000;\n}\n</code></pre> <p>A k\u00f6vetkez\u0151kben l\u00e9p\u00e9sben a <code>GetDescription</code> m\u0171veletet \u00edrjuk meg a <code>HardDisk</code> \u00e9s <code>SoundCard</code> oszt\u00e1lyokban. Mivel itt az \u0151sbeli virtu\u00e1lis f\u00fcggv\u00e9nyt defini\u00e1ljuk fel\u00fcl, szint\u00e9n meg kell adni az <code>override</code> kulcssz\u00f3t:</p> HardDisk.cs<pre><code>public override string GetDescription()\n{\n    return \"Hard Disk\";\n}\n</code></pre> SoundCard.cs<pre><code>public override string GetDescription()\n{\n    return \"Sound Card\";\n}\n</code></pre> <p>Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt d\u00f6nt\u00f6ttek \u00fagy a C# nyelv tervez\u0151i, hogy a m\u0171veletek fel\u00fcldefini\u00e1l\u00e1sakor egy extra kulcssz\u00f3t kelljen megadni, hasonl\u00f3ra pl. a C++ nyelv eset\u00e9ben nem volt sz\u00fcks\u00e9g. Az ok egyszer\u0171: a k\u00f3d \u00edgy kifejez\u0151bb. A lesz\u00e1rmazottak k\u00f3dj\u00e1t n\u00e9zve az <code>override</code> sz\u00f3 azonnal egy\u00e9rtelm\u0171v\u00e9 teszi, hogy valamelyik \u0151sben ez a m\u0171velet absztrakt vagy virtu\u00e1lis, nem kell valamennyi \u0151s k\u00f3dj\u00e1t ehhez \u00e1ttekinteni.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#leddisplay-ose","title":"LedDisplay \u0151se","text":"<p>A <code>LedDisplay</code> oszt\u00e1lyunk \u0151se meg van k\u00f6tve, annak k\u00f3dja nem m\u00f3dos\u00edthat\u00f3, \u00edgy nem tudjuk az <code>EquipmentBase</code>-b\u0151l sz\u00e1rmaztatni. A <code>GetAge</code> m\u0171veletet \u00edgy nem tudjuk t\u00f6r\u00f6lni, ez a k\u00f3dduplik\u00e1ci\u00f3 itt megmarad (de csak a <code>LedDisplay</code> eset\u00e9ben, ami csak egy oszt\u00e1ly a sok k\u00f6z\u00fcl!).</p> <p>Note</p> <p>Val\u00f3j\u00e1ban egy kis plusz munk\u00e1val ett\u0151l a duplik\u00e1ci\u00f3t\u00f3l is meg tudn\u00e1nk szabadulni. Ehhez valamelyik oszt\u00e1lyban (pl. <code>EquipmentBase</code>) fel kellene venni egy statikus seg\u00e9df\u00fcggv\u00e9nyt, mely param\u00e9terben megkapn\u00e1 a gy\u00e1rt\u00e1si \u00e9vet, \u00e9s visszaadn\u00e1 az \u00e9letkort. Az <code>EquipmentBase.GetAge</code> \u00e9s a <code>LedDisplay.GetAge</code> ezt a seg\u00e9df\u00fcggv\u00e9nyt haszn\u00e1ln\u00e1 kimenete el\u0151\u00e1ll\u00edt\u00e1s\u00e1ra.</p> <p>A <code>LedDisplay</code> oszt\u00e1lyunkban ad\u00f3sak vagyunk m\u00e9g a <code>GetDescription</code> meg\u00edr\u00e1s\u00e1val:</p> LedDisplay.cs<pre><code>public string GetDescription()\n{\n    return \"Led Display\";\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy itt NEM adtuk meg az <code>override</code> kulcssz\u00f3t. Mikor egy interf\u00e9sz f\u00fcggv\u00e9nyt implement\u00e1lunk, az <code>override</code>-ot nem kell/szabad ki\u00edrni.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#getdescription-hasznalata","title":"GetDescription haszn\u00e1lata","text":"<p>M\u00f3dos\u00edtsuk az <code>EquipmentInventory.ListAll</code> m\u0171velet\u00e9t, hogy az elemek le\u00edr\u00e1s\u00e1t is \u00edrja ki a kimenetre:</p> EquipmentInventory.cs<pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Le\u00edr\u00e1s: {eq.GetDescription()}\\t\" +\n            $\"\u00c9letkor: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>\u00cdgy m\u00e1r sokkal informat\u00edvabb kimetet kapunk az alkalmaz\u00e1s futtat\u00e1sakor:</p> <p></p>"},{"location":"labor/1-model-es-kod-kapcsolata/#konstruktor-kodduplikacio","title":"Konstruktor k\u00f3dduplik\u00e1ci\u00f3","text":"<p>A k\u00f3dunkat \u00e1ttekintve m\u00e9g egy helyen tal\u00e1lunk k\u00f3dduplik\u00e1ci\u00f3t. Valamennyi <code>EquipmentBase</code> lesz\u00e1rmazott (<code>HardDisk</code>, <code>SoundCard</code>) konstruktor\u00e1ban ott van ez a k\u00e9t sor:</p> <pre><code> this.yearOfCreation = yearOfCreation;\n this.newPrice = newPrice;\n</code></pre> <p>Ha belegondolunk, ezek a <code>yearOfCreation</code> \u00e9s <code>newPrice</code> tagok az \u0151sben vannak defini\u00e1lva, \u00edgy egy\u00e9bk\u00e9nt is az \u0151 felel\u0151ss\u00e9ge kellene legyen ezek inicializ\u00e1l\u00e1sa. Vegy\u00fcnk is fel egy megfelel\u0151 konstruktort az <code>EquipmentBase</code>-ben:</p> EquipmentBase.cs<pre><code>public EquipmentBase(int yearOfCreation, int newPrice)\n{\n    this.yearOfCreation = yearOfCreation;\n    this.newPrice = newPrice;\n}\n</code></pre> <p>A <code>HardDisk</code> \u00e9s <code>SoundCard</code> lesz\u00e1rmazottak konstruktor\u00e1nak t\u00f6rzs\u00e9b\u0151l vegy\u00fck ki a k\u00e9t tag inicializ\u00e1l\u00e1s\u00e1t, helyette a <code>base</code> kulcssz\u00f3val hivatkozva h\u00edvjuk meg az \u0151s konstruktor\u00e1t:</p> HardDisk.cs<pre><code>public HardDisk(int yearOfCreation, int newPrice, int capacityGB)\n    : base(yearOfCreation, newPrice)\n{\n    this.capacityGB = capacityGB;\n}\n</code></pre> SoundCard.cs<pre><code>public SoundCard(int yearOfCreation, int newPrice)\n    : base(yearOfCreation, newPrice)\n{\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/#ertekeles","title":"\u00c9rt\u00e9kel\u00e9s","text":"<p>Az interf\u00e9sz \u00e9s absztrakt \u0151s egy\u00fcttes haszn\u00e1lat\u00e1val siker\u00fclt a legkevesebb kompromisszummal j\u00e1r\u00f3 megold\u00e1st kidolgoznunk:</p> <ul> <li><code>IEquipment</code> interf\u00e9szk\u00e9nt hivatkozva egys\u00e9gesen tudjuk kezelni az alkatr\u00e9szek valamennyi t\u00edpus\u00e1t, m\u00e9g azokat is, melyekn\u00e9l az \u0151soszt\u00e1ly meg volt k\u00f6tve (puszt\u00e1n absztrakt \u0151s haszn\u00e1lat\u00e1val ezt nem tudtuk volna el\u00e9rni).</li> <li>Az <code>EquipmentBase</code> absztrakt \u0151s bevezet\u00e9s\u00e9vel egy kiv\u00e9telt\u0151l eltekintve a k\u00fcl\u00f6nb\u00f6z\u0151 alkatr\u00e9szt\u00edpusokra k\u00f6z\u00f6s k\u00f3dot fel tudtuk vinni egy k\u00f6z\u00f6s \u0151sbe, \u00edgy el tudtuk ker\u00fclni a k\u00f3dduplik\u00e1ci\u00f3t.</li> <li>Az <code>EquipmentBase</code> absztrakt \u0151s bevezet\u00e9s\u00e9vel alap\u00e9rtelmezett implement\u00e1ci\u00f3t tudunk megadni az \u00fajonnan bevezetett <code>IEquipment</code> m\u0171veletek eset\u00e9ben (pl. <code>GetDescripton</code>), \u00edgy nem vagyunk r\u00e1k\u00e9nyszer\u00edtve, hogy minden <code>IEquipment</code> implement\u00e1ci\u00f3s oszt\u00e1lyban meg kelljen azt adni.</li> </ul> <p>Z\u00e1r\u00e1sk\u00e9ppen vess\u00fcnk egy pillant\u00e1st megold\u00e1sunk UML (szer\u0171) oszt\u00e1lydiagramj\u00e1ra:</p> <p></p> <p>C# 11 - Statikus interf\u00e9szek</p> <p>A C# 11 leg\u00fajabb \u00fajdons\u00e1ga a statikus interf\u00e9sz tagok defini\u00e1l\u00e1sa, amivel olyan tagokat k\u00f6vetelhet\u00fcnk meg az implement\u00e1l\u00f3 oszt\u00e1lyt\u00f3l, amelyek nem az objektum p\u00e9ld\u00e1nyra vonatkoznak, hanem az oszt\u00e1lynak kell egy adott statikus taggal rendelkeznie. B\u0151vebben</p>"},{"location":"labor/1-model-es-kod-kapcsolata/#megjegyzes-opcionalis-hazi-gyakorlo-feladat","title":"Megjegyz\u00e9s - opcion\u00e1lis h\u00e1zi gyakorl\u00f3 feladat","text":"<p>Jelen megold\u00e1sunk nem t\u00e1mogatja az alkatr\u00e9szspecifikus adatok (pl. <code>HardDisk</code> eset\u00e9ben a kapacit\u00e1s) megjelen\u00edt\u00e9s\u00e9t a list\u00e1z\u00e1s sor\u00e1n. Ahhoz, hogy ezt meg tudjuk tenni, az alkatr\u00e9sz adatok form\u00e1zott stringbe \u00edr\u00e1s\u00e1t az <code>EqipmentInventory</code> oszt\u00e1lyb\u00f3l az alkatr\u00e9sz oszt\u00e1lyokba kellene vinni, a k\u00f6vetkez\u0151 elveknek megfelel\u0151en:</p> <ul> <li>Bevezethet\u00fcnk ehhez az <code>IEquipment</code> interf\u00e9szbe egy <code>GetFormattedString</code> m\u0171veletet, mely egy <code>string</code> t\u00edpus\u00fa objektummal t\u00e9r vissza. Alternat\u00edv megold\u00e1s lehet, ha a <code>System.Object ToString()</code> m\u0171velet\u00e9t defini\u00e1ljuk fel\u00fcl. .NET-ben ugyanis minden t\u00edpus implicit m\u00f3don a <code>System.Object</code>-b\u0151l sz\u00e1rmazik, aminek van egy virtu\u00e1lis <code>ToString()</code> m\u0171velete.</li> <li>Az <code>EquipmentBase</code>-ben meg\u00edrjuk a k\u00f6z\u00f6s tagok (le\u00edr\u00e1s, \u00e1r, kor) stringbe form\u00e1z\u00e1s\u00e1t.</li> <li>Amennyiben egy alkatr\u00e9sz t\u00edpusspecifikus adattal is rendelkezik, akkor oszt\u00e1ly\u00e1ban override-oljuk a stringbe form\u00e1z\u00f3 f\u00fcggv\u00e9nyt: ennek a f\u00fcggv\u00e9nynek egyr\u00e9szt meg kell h\u00edvnia az \u0151s v\u00e1ltozat\u00e1t (a <code>base</code> kulcssz\u00f3 haszn\u00e1lat\u00e1val), majd ehhez hozz\u00e1 kell f\u0171zni a saj\u00e1t form\u00e1zott adatait, \u00e9s ezzel a stringgel kell visszat\u00e9rnie.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/","title":"1. Relationship between the model and the code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#the-goal-of-the-exercise","title":"The goal of the exercise","text":"<p>The goal of the exercise:</p> <ul> <li>Getting to know the students/trainer</li> <li>Clarification of the requirements for exercises</li> <li>Getting started with Visual Studio and .NET application development.</li> <li>Building a simple Hello World .NET application, C# basics</li> <li>Illustrating the relationship between UML and code</li> <li>The interface and the abstract primitive class application technique</li> </ul> For teachers <p>While there will certainly be some students who have used the Visual Studio environment before, in Prog2 (C++) or for other reasons, there will almost certainly be others who have not used it or who remember it less. The goal here is to get familiar with the interface, so as you work through the exercises, you will be introduced to the things you use (e.g. Solution Explorer, F5 running, using breakpoints, etc.) to build your first C# application.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#prerequisites","title":"Prerequisites","text":"<p>The tools needed to carry out the exercise:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>The latest version of Visual Studio should be installed. The Community Edition, Professional and Enterprise versions are also suitable. The Community Edition is free and can be downloaded from the Microsoft website. The Professional is paid, but it is also available free of charge to students of the university (on the website, as part of the Azure Dev Tools for Teaching programme).</p> <p>Visual Studio Class Diagram support</p> <p>For some of the exercises in this exercise (and also for the first homework) we will use the Visual Studio Class Designer support. Visual Studio does not always add the Class Designer component during installation. If it is not possible to add a Class Diagram to your Visual Studio project (because the Class Diagram is not listed in the list of the window that appears during the Add New Item command - more on this later in this guide), you will need to install the Class Diagram component later:</p> <ol> <li>Start the Visual Studio installer (e.g. by typing \"Visual Studio Installer\" in the Windows Start menu).</li> <li>In the window that appears, select the \"Individual components\" tab</li> <li> <p>In the search box, type \"class designer\" and then make sure that \"Class Designer\" is unchecked in the filtered list.</p> <p></p> </li> </ol> <p>What you should check out:</p> <ul> <li>The exercise does not include a lecture on the subject. At the same time, the exercise builds on basic UML knowledge and the basics of mapping UML class diagrams to code.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#course-of-exercise","title":"Course of exercise","text":"<p>The trainer will summarise the requirements for the exercises at the beginning of the exercise:</p> <ul> <li>Most of these can be found in the fact sheet</li> <li>Information on homework is available on the subject's website.</li> </ul> <p>Using Visual Studio development tool, we will build .NET applications in C#. C# is similar to Java, we will gradually learn the differences. The tutorial is guided, with instructions from the tutor, and the tasks are done together.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#solution","title":"Solution","text":"Download the finished solution <p> It is essential that you follow the lab guide during the lab, it is forbidden (and pointless) to download the ready-made solution. However, during subsequent self-practice, it can be useful to review the ready-made solution, so we make it available.</p> <p>The solution is available on GitHub. The easiest way to download it is to clone it from the command line to your machine using the <code>git clone</code> command:</p> <p><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo -b solved</code></p> <p>You need to have git installed on your machine, more information here.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#1-task-build-a-hello-world-net-console-application","title":"1. Task - Build a \"Hello world\" .NET console application","text":"<p>The task is to create a C# console application that prints the text \"Hello world!\" to the console.</p> <p>The application is written in C#. The compiled application is run by the .NET runtime. The theoretical background of compiling/running and the basics of .NET are covered in the first lecture.</p> <p>The steps to create a solution and a project within it in Visual Studio 2022:</p> <ol> <li>Start a new project wizard, which can be done in two ways<ul> <li>Using the startup window<ol> <li>Launch Visual Studio</li> <li>In the right-hand sidebar of the launch window that appears Create new project</li> </ol> </li> <li>Already running in Visual Studio<ol> <li>File / New-Project</li> </ol> </li> </ul> </li> <li> <p>In the Create new project wizard, select the Console app (and NOT the Console app (.NET Framework) template, including the C# one. That it is C# is indicated by the top left corner of the template icon. If you don't see it in the list, you have to search/filter for it. You can search for it by typing \"console\" in the top search bar. Or by using the drop-down boxes below: in the first (language selector) \"C#\", in the third (project type selector) \"Console\".</p> <p>Creating a project</p> </li> <li> <p>Next button at the bottom of the wizard window, on the next wizard page:</p> <ol> <li>Project name: Hello World</li> <li>Location: in the labs, work in the c:\\work\\ folder, you have write access to it. <li>Solution name: Hello World (this should be written in by the time we get here)</li> <li>Place solution and project in the same directory: no tick (but not particularly significant).</li> <li> <p>Next button at the bottom of the wizard window, on the next wizard page:</p> <ol> <li>Framework: .NET 8 (Long-term support).</li> <li>Check the \"Do not use top level statements\" checkbox (we'll explain this in a moment).</li> </ol> </li> <p>The project also creates a new solution, whose structure can be viewed in the Visual Studio Solution Explorer window. A solution can consist of several projects, and a project can consist of several files. A solution is a summary of the entire working environment (it includes a file with the extension <code>.sln</code>), while the output of a project is typically a file <code>.exe</code> or <code>.dll</code>, i.e. a component of a complex application/system. The project file extension for C# applications is <code>.csproj</code>.</p> <p>The content of our <code>Program.cs</code> file is as follows:</p> Program.cs<pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> <p>Take a <code>Console.ReadKey()</code> line:</p> <pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Run the application (e.g. using the F5 key).</p> <p>The structure of the code is very similar to Java and C++. Our classes are organised into namespaces. You can define a namespace with the keyword <code>namespace</code>. You can \"scope\" namespaces with the <code>using</code> keyword. e.g:</p> <pre><code>using System.Collections.Generic;\n</code></pre> </li> <li> <p>In a console C# application, you specify the entry point of your application by writing a static function called <code>Main</code>. Our class name can be anything, VS generated a class called <code>Program</code> in our case. The parameter list of the <code>Main</code> function is bound: either no parameters are given, or a <code>string[]</code> is given, in which the command line arguments are given at runtime.</p> </li> <li>in .NET, the <code>Console</code> class of the <code>System</code> namespace is used to handle standard input and output. With the static operation <code>WriteLine</code> you can write a line, with <code>ReadKey</code> you can wait for a key to be pressed.</li> </ol> <p>Top level statements, Implicit and static usings and namespaces</p> <p>When the project was created, we previously checked the \"Do not use top level statements\" checkbox. If we had not done this, we would have found only one meaningful line in our <code>Program.cs</code> file:</p> <pre><code>// See https://aka.ms/new-console-template for more information\nConsole.WriteLine(\"Hello World!\");\n</code></pre> <p>This is functionally equivalent to the code above containing the <code>Program</code> class and its <code>Main</code> function. Let's look at what makes this possible (you can read more about them here https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements, both new in C# 10):</p> <ul> <li>Top level statements. The idea is that you can write code directly in a single source file without any class/<code>Main</code> and other function definitions in the project. In this case, behind the scenes, the compiler puts this into a static <code>Main</code> function of a class we don't see. The motivation for its introduction was to reduce boilerplate code for very simple, \"script-like\" applications.</li> <li>Implicit global usings. Depending on exactly what project type you have created, certain base namespaces will be automatically using behind the scenes in all source files (the compiler uses the global using directive for this). The point is: this way, developers don't have to use certain frequently used namespaces (e.g. <code>System.IO</code>, <code>System.Collections.Generic</code>, etc.) as source files.</li> <li> <p>Static using. It is possible to use static classes instead of namespaces in C#, so it is not important to write them when using them. A common case is the use of the <code>Console</code> or <code>Math</code> class.</p> <pre><code>using static System.Console;\n\nnamespace ConsoleApp12\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine(\"Hello, World!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>File-level namespaces. In C# 10, we also get a simplification when declaring namespaces, because it is no longer mandatory to use brackets, so the given namespace will be valid for the whole file, e.g.:</p> <pre><code>namespace HelloWorld;\n\ninternal class Program\n{\n    // ...\n}\n</code></pre> </li> </ul> <p>Inconsistent visibility or inconsistent accessibility error</p> <p>During the semester, you may encounter translation error messages complaining about inconsistent visibility or inconsistent accessibility when implementing programming tasks. This phenomenon is due to the possibility to control the visibility of each type (class, interface, etc.) in a .NET environment:</p> <ul> <li><code>internal</code> or no visibility is specified: the type is visible only inside the assembly (.exe, .dll)/project</li> <li><code>public</code>: the type is visible to other assemblies/projects</li> </ul> <p>The easiest way to avoid this error is to define all our types as public, e.g.:</p> <pre><code>public class HardDisk\n{\n    // ...\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#theoretical-overview","title":"Theoretical overview","text":"<p>The sub-chapters do not contain exercises, but provide students with an introduction to the related theoretical topics, illustrated with examples.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#a-theory-of-the-relationship-between-the-uml-class-diagram-and-code-student","title":"A) Theory of the relationship between the UML class diagram and code [student]*","text":"<p>The material is available here: The relationship between the UML class diagram and code. The relationship between the UML class diagram and code. This topic was covered in the previous semester in the Software Engineering course.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#b-interface-and-abstract-parent-class-student","title":"B) Interface and abstract (parent) class [student]*","text":"<p>The material is available here: Interface and abstract (base) class.   Interface and abstract (base) class.</p> <p>Topics:</p> <ul> <li>Abstract class concept and definition in C#</li> <li>Interface concepts and definitions in C#</li> <li>Comparison of abstract base class and interface</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#2-task-illustrate-the-relationship-between-uml-and-code","title":"2. Task - Illustrate the relationship between UML and code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#task-description-equipment-inventory","title":"Task description - Equipment inventory","text":"<p>Task: We were asked to develop a computer parts inventory application. Read more:</p> <ul> <li>You need to be able to handle different types of parts. Initially, <code>HardDisk</code>, <code>SoundCard</code> and <code>LedDisplay</code> types should be supported, but the system should be easily extensible to new types.</li> <li>The data related to the parts are: year of purchase, age (calculated), purchase price and current price (calculated), but may also include type-specific data (e.g. capacity for <code>HardDisk</code>).</li> <li>The actual price depends on the type of part, the purchase price and the year of production of the part. For example, the older the part, the bigger the discount, but the discount depends on the part type.</li> <li>You must be able to list the parts in stock.</li> <li>The <code>LedDisplay</code> class must be derived from an <code>DisplayBase</code> class, and the source code of the <code>DisplayBase</code> class cannot be changed. In this example this does not make much sense, but in practice we often encounter similar situations where the framework/platform we are using requires us to derive from a built-in class. Typically, this is the case when working with windows, forms, custom control types: we have to derive them from the framework's built-in classes, and we don't have (or at least certainly don't want to change) the source code of the framework - e.g. Java, .NET. In our example, we simulate this situation by specifying a derivation from <code>DisplayBase</code>.</li> </ul> <p>The implementation is simplified considerably: the parts are only stored in memory, and the listing is as simple as possible, simply by writing the data of the registered parts to the console.</p> <p>During the initial discussions, we receive the following information from the client: an internal staff member has already started the development, but due to lack of time, they have only reached a half-finished solution. Part of our task is to understand the semi-finished solution and to implement the task from there.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#class-diagram","title":"Class Diagram","text":"<p>Let's open the source code solution from our customer, which we can do by following the steps below.</p> <p>To do this, clone the Git repository of the initial project, available online on GitHub, to a new folder of its own within <code>C:\\Work</code>: e.g: <code>C:\\Work\\NEPTUN\\lab1</code>. In this new folder, open a command line or powershell and run the following git command:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git\n</code></pre> <p>Note</p> <p>You will read more about Git as a source code management system in the context of the first homework assignment.</p> <p>Open the Visual Studio solution src/EquipmentInventory.sln in the cloned folder.</p> <p>In Solution Explorer, run through the files by eye. It would help to understand the relationships between classes by displaying them on a class diagram. Let's include a class diagram in our project. In the Solution Explorer, right-click on the project (not the solution!), select Add/New Item from the pop-up menu, then in the window that appears, select Class Diagram, enter Main.cd as the name of the diagram at the bottom of the window, and OK-close the window.</p> <p>Missing Class Diagram template</p> <p>If the Class Diagram item does not appear in the list, then the appropriate component of VS is not installed. You can read more about this in the Prerequisites section of this document.</p> <p>The chart file <code>Main.cd</code> will then appear in Solution Explorer, double-click on it to open it. Our chart is currently empty. From Solution Explorer, drag&amp;drop the .cs source files onto the diagram. VS then looks at what classes are in these source files and decomposes them into UML classes. Build the layout as shown in the following figure (you can display the members of the classes by clicking on the double arrow in the top right corner of their rectangle):</p> <p>Starting class diagram</p> <p>You can also view the source code for the classes, either by double-clicking on the corresponding class on the diagram or by opening the .cs files from Solution Explorer. Here's what we see:</p> <ul> <li>The <code>SoundCard</code>, <code>HardDisk</code> and <code>LedDisplay</code> classes are relatively well developed, with the necessary attributes and query functions.</li> <li>The <code>LedDisplay</code> is derived from the <code>DisplayBase</code> class as required.</li> <li><code>EquipmentInventory</code> is responsible for the inventory of parts in stock, but practically none of this is implemented.</li> <li>We find an interface <code>IEquipment</code> with operations <code>GetAge</code> and <code>GetPrice</code></li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#equipmentinventory","title":"EquipmentInventory","text":"<p>Let's start working on a solution. First, let's lay down the basic concepts. In the <code>EquipmentInventory</code> class, we store a heterogeneous collection of different types of equipment. This is the key to consistent parts management, so that our solution can be easily extended with new parts types.</p> <p>As discussed earlier, unified management can be achieved either by implementing a common base class or a common interface. In our case, the common base class (e.g. <code>EquipmentBase</code>) seems to be dropped, because by introducing it, the <code>LedDisplay</code> class would have two base classes: the mandatory <code>DisplayBase</code>, and the <code>EquipmentBase</code> that we introduce for uniform management. This is not possible, in a .NET environment a class can have only one base class. The solution to modify <code>DisplayBase</code> to be derived from <code>EquipmentBase</code> is not possible according to our requirement (it was a requirement that its source code cannot be modified). This leaves the interface-based approach. This was probably the conclusion of the previous developer of the application, which is why he introduced the <code>IEquipment</code> interface.</p> <p>Add a generic list of items of type <code>IEquipment</code> (not property but field!) to the <code>EquipmentInventory</code> class. Its visibility - in an effort to be unified - should be <code>private</code>. The name should be <code>equipment</code> (no \"s\" at the end, in English the plural of equipment is also equipment). To add a member variable, we use the Visual Studio Class Details window. If the window is not visible, it can be displayed by selecting View / Other Windows / Class Details.</p> <p>Class Details</p> <p>The member variable type is therefore <code>List</code>. The type of .NET <code>List</code> is a dynamically stretching generic array (like <code>ArrayList</code> in Java). Looking at the <code>EquipmentInventory</code> class in the diagram, we see that only the name of the member variable is displayed, not the type. Right-click on the background of the diagram and select Display Full Signature from the Change Members Format menu. The chart will then display the type of member variables and the full signature of the operations.</p> <p>EquipmentInventory</p> <p>By double-clicking on the <code>EquipmentInventory</code> class, you can navigate to the source code, and as you can see, it does indeed appear in the code as a member variable of type list:</p> <pre><code>class EquipmentInventory\n{\n    private List&lt;IEquipment&gt; equipment;\n</code></pre> <p>On the one hand, we're happy about this because Visual Studio supports round-trip engineering: changes to the model are immediately reflected in the code, and vice versa. On the other hand, we have previously discussed that if a class has a collection of members from another class, then it \"fits\" in the UML model as a type 1-more association relation between the two classes. This is not yet the case in our model. Fortunately, the VS modelling interface can be made to display this type of connection in this form. To do this, right-click on the equipment tag variable on the diagram and select Show as Collection Association from the menu. The <code>IEquipment</code> interface should then be moved to the right to allow enough space on the diagram to display the association relationship and the role on the relationship:</p> <p>Collection association</p> <p>The double arrow ending on the \"plural\" side is not standard UML, but don't be too sad about it, it's not important. We are certainly pleased that the arrow representing the relationship at the end of the <code>IEquipment</code> role shows the name (and even the exact type) of the member variable.</p> <p>Navigate to the source code of <code>EquipmentInventory</code> and write the constructor that initializes the <code>equipment</code> collection</p> <pre><code>public EquipmentInventory()\n{\n    equipment = new List&lt;IEquipment&gt;();\n}\n</code></pre> <p>Then write the <code>ListAll</code> method, which prints the age of the elements and their current values:</p> <pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Age: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Iterate through the elements using the <code>foreach</code> statement. When using the <code>foreach</code> statement, the <code>in</code> keyword should be followed by a collection and preceded by a variable declaration (in this case <code>IEquipment eq</code>), where type is the element type of the collection. In each iteration, this variable takes the iteration value of the collection.</p> <p><code>Console.WriteLine</code> is either a simple string or, as in this case, a formatting string. The substitutions are solved by string interpolation: the values to be substituted must be given between <code>`. If string interpolation is used, the string must start with</code>$`.</p> <p>Write a function called <code>AddEquipment</code> that adds a new device to the inventory:</p> <pre><code>public void AddEquipment(IEquipment eq)\n{\n     equipment.Add(eq);\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#iequipment-implementers","title":"IEquipment implementers","text":"<p>We have previously decided to use the <code>IEquipment</code> interface to manage the different component types in a uniform way. In our example, both <code>SoundCard</code> and <code>HardDisk</code> have <code>GetAge()</code> and <code>GetPrice()</code> methods, yet we cannot manage them in a unified way (e.g., store them in a common list). To do this, we need to get both classes to implement the <code>IEquipment</code> interface. Change their source:</p> <pre><code>public class SoundCard : IEquipment\n</code></pre> <pre><code>public class HardDisk : IEquipment\n</code></pre> <p>Then we need to implement the methods in the <code>IEquipment</code> interface in the <code>SoundCard</code> and <code>HardDisk</code> classes. We find that there is nothing to do with this now, the <code>GetPrice</code> and <code>GetAge</code> functions are already written in both places.</p> <p>As a test, in our <code>Main</code> function in <code>Program.cs</code>, create an <code>EquipmentInventory</code> object, populate it with <code>HardDisk</code> and <code>SoundCard</code> objects, and then list the object on the console. If 2021 is not the current year, in the following rows, copy the year 2021 to the current year and the year 2020 to a smaller number!</p> <pre><code>static void Main( string[] args )\n{\n    EquipmentInventory ei = new EquipmentInventory();\n\n    ei.AddEquipment(new HardDisk(2021, 30000, 80));\n    ei.AddEquipment(new HardDisk(2020, 25000, 120));\n    ei.AddEquipment(new HardDisk(2020, 25000, 250));\n\n    ei.AddEquipment(new SoundCard(2021, 8000));\n    ei.AddEquipment(new SoundCard(2020, 7000));\n    ei.AddEquipment(new SoundCard(2020, 6000));\n\n    ei.ListAll();\n}\n</code></pre> <p>Running the application, we find that although our solution is rudimentary, it works:</p> <p>Console output</p> <p>Continue with the <code>LedDisplay</code> class. The <code>DisplayBase</code> base class source code cannot be modified due to requirements. But this doesn't cause any problems, our <code>LedDisplay</code> class will implement the <code>IEquipment</code> interface, so modify the code accordingly:</p> <pre><code>public class LedDisplay : DisplayBase, IEquipment\n</code></pre> <p>In the <code>LedDisplay</code> class, the functions in the interface must already be written:</p> <pre><code>public double GetPrice()\n{\n    return this.price;\n}\n\npublic int GetAge()\n{\n    return DateTime.Today.Year - this.manufacturingYear;\n}\n</code></pre> <p>Let's extend our <code>Main</code> function by adding two <code>LedDisplay</code> objects to our set (again, if 2021 is not the current year, we should rewrite 2021 to the current year in the following lines, and 2020 to a smaller number!</p> <pre><code>ei.AddEquipment(new LedDisplay(2020, 80000, 17, 16));\nei.AddEquipment(new LedDisplay (2021, 70000, 17, 12));\n\nei.ListAll();\nConsole.ReadKey();\n</code></pre> <p>As a test, run the application.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#3-task-application-of-the-interface-and-the-abstract-primitive-class","title":"3. Task - Application of the interface and the abstract primitive class","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#interface-problems","title":"Interface problems","text":"<p>Evaluate our current interface-based solution.</p> <p>One of the main problems is that our code is full of code duplication that destroys maintainability and extensibility:</p> <ul> <li>The <code>yearOfCreation</code> and <code>newPrice</code> tags are common to all part types (except the special <code>LedDisplay</code>), and must be copy-pasted when a new type is introduced.</li> <li>The implementation of the <code>GetAge</code> function is the same for all component types (except for the special <code>LedDisplay</code>), also copy-paste \"propagated\".</li> <li>The lines of the constructors <code>yearOfCreation</code> and <code>newPrice</code> initializing tags are also duplicated in each class.</li> </ul> <p>Although this code duplication does not seem significant at the moment, the situation is getting worse as new component types are introduced, and it is better to prevent future pains in time.</p> <p>The other problem is that the listing of parts data is currently painfully incomplete, with no part type (only age and price). To display the type, the IEquipment interface must be extended, e.g. by introducing an operation called <code>GetDescription</code>.  Let's add a <code>GetDescription</code> function to the interface!</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription();\n}\n</code></pre> <p>Then every class implementing the <code>IEquipment</code> interface would have to implement this method, which is a lot of work for many classes (and often not even feasible for a multi-component application, i.e. one with several DLLs, when they are not in the hands of a single developer). Run the Build command to check that after adding <code>GetDescription</code>, you get compilation errors in three places.</p> <p>Specifying default implementation in interface</p> <p>It is worth knowing that starting from C# 8 (or .NET or .NET Core runtime, not supported under .NET Framework), interface operations can be given default implementation (default interface methods), so to solve the above problem you don't need an abstract class, but interface can no longer have member variables. More information here: default interface methods.</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription() { return \"EquipmentBase\"; }\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#abstract-class","title":"Abstract class","text":"<p>A solution to both problems is the introduction of a common abstract base class (except for the <code>LedDisplay</code> class, which we will come back to). We can move the code common to descendants into it, and provide a default implementation for the newly introduced <code>GetDescription</code> operation. Let our new abstract base class be called <code>EquipmentBase</code>. The question is whether the <code>IEquipment</code> interface is still needed, or whether it can be completely replaced by the new <code>EquipmentBase</code> class. We need to keep the <code>IEquipment</code> interface, because we cannot derive our LedDisplay class from <code>EquipmentBase</code>: it already has a mandatory base class, <code>DisplayBase</code>: for this reason, EquipmentInventory in our enhanced solution also refers to the various components as <code>IEquipment</code> interface.</p> <p>Let's start the transformation. Let our class diagram be the active tab. From the Toolbox, drag&amp;drop an Abstract Class element onto the diagram, name it <code>EquipmentBase</code>.</p> <p>Toolbox - abstract class</p> <p>In the following, we need to make the <code>SoundCard</code> and <code>HardDisk</code> classes derive from <code>EquipmentBase</code> (<code>LedDisplay</code> already has another base class, so we cannot do this there). To do this, select the Inheritance link in the Toolbox, then draw a line from the child class to the base class for both <code>SoundCard</code> and <code>HardDisk</code>.</p> <p>In the next step, let's modify the code so that <code>HardDisk</code> and <code>SoundCard</code> do not implement the <code>IEquipment</code> interface separately, but rather their common base class <code>EquipmentBase</code> implement it once. To do this, modify the EquipmentBase class to implement the interface (either by drawing an inheritance link from <code>EquipmentBase</code> to <code>IEquipment</code> on the diagram, or by modifying the source code of <code>EquipmentBase</code>). Delete the implementation of <code>IEquipment</code> from the <code>HardDisk</code> and <code>SoundCard</code> classes (the base class already implements it).</p> <p>The relevant parts of our diagram and source code will then look like this:</p> <p>EquipmentBase and HardDisk/SoundCard</p> <pre><code>public abstract class EquipmentBase : IEquipment\n</code></pre> <pre><code>public class HardDisk : EquipmentBase\n</code></pre> <pre><code>public class SoundCard : EquipmentBase\n</code></pre> <p>Our code is not yet turning, for several reasons. The <code>EquipmentBase</code> implements the <code>IEquipment</code> interface, but it does not yet implement the interface operations. Either generate the methods using the smart tag, or type them according to the following principles:</p> <ul> <li>The <code>newPrice</code> and <code>yearOfCreation</code> are duplicated in the <code>HardDisk</code> and <code>SoundCard</code> classes: move (not copy!) them to the common <code>EquipmentBase</code> base class and give <code>protected</code> visibility.</li> <li>The <code>GetAge</code> operation is duplicated in the <code>HardDisk</code> and <code>SoundCard</code> classes, delete the implementation from these and move it to the <code>EquipmentBase</code> class.</li> <li>The <code>GetPrice</code> operation is included in the base class as an abstract operation. This is a deliberate design decision, so we force descendant classes to override this operation anyway.</li> <li>In the case of <code>GetDescription</code>, the opposite is true: it is defined as virtual (and not abstract), i.e. we provide an implementation in the base class. This way, descendants are not forced to override the operation.</li> </ul> <p>The code corresponding to the above is:</p> <pre><code>public abstract class EquipmentBase : IEquipment\n{\n    protected int yearOfCreation;\n    protected int newPrice;\n\n    public int GetAge()\n    {\n        return DateTime.Today.Year - yearOfCreation;\n    }\n\n    public abstract double GetPrice();\n\n    public virtual string GetDescription()\n    {\n        return \"EquipmentBase\";\n    }\n}\n</code></pre> <p>Some additional thoughts on the code fragment:</p> <ul> <li>For abstract classes, the keyword <code>abstract</code> must be written before the word <code>class</code>.</li> <li>For abstract operations, the keyword <code>abstract</code> must be specified</li> <li>in a .NET environment, you can control whether an operation is virtual or not. In this respect, it is similar to C++. To make an operation virtual, the keyword <code>virtual</code> must be specified for the operation. Reminder: define an operation as virtual if its descendants overdefine it. Only then is it guaranteed that the descendant version will be called when invoking the given operation on an ancestor reference.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#descendants","title":"Descendants","text":"<p>In the next step, let's move on to the <code>EquipmentBase</code> descendants. When overriding abstract and virtual operations in C#, you must specify the <code>override</code> keyword in the descendant. First, the <code>GetPrice</code> operation is redefined:</p> HardDisk.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0\n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 5000;\n}\n</code></pre> SoundCard.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0 \n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 2000;\n}\n</code></pre> <p>In the next step, the <code>GetDescription</code> operation is written in the <code>HardDisk</code> and <code>SoundCard</code> classes. Since the virtual function of the base class is being overridden here, the <code>override</code> keyword must also be specified:</p> HardDisk.cs<pre><code>public override string GetDescription()\n{\n    return \"Hard Disk\";\n}\n</code></pre> SoundCard.cs<pre><code>public override string GetDescription()\n{\n    return \"Sound Card\";\n}\n</code></pre> <p>One might ask why the designers of the C# language decided to add an extra keyword to the definition of operations, which was not necessary in the case of C++. The reason is simple: the code is more expressive. Looking at the descendant code, the word <code>override</code> immediately makes it clear whether this operation is abstract or virtual in one of the base classes, without having to look at the code of all the ancestors.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#base-class-of-leddisplay","title":"Base class of LedDisplay","text":"<p>The base class of our <code>LedDisplay</code> class is bound, its code cannot be modified, so we cannot derive it from <code>EquipmentBase</code>. We cannot delete the <code>GetAge</code> operation, this code duplication is preserved here (but only for <code>LedDisplay</code>, which is only one class among many!).</p> <p>Note</p> <p>In fact, with a little extra work we could get rid of this duplication. This would require a static helper function in one of the classes (e.g. <code>EquipmentBase</code>), which would get the year of manufacture and return the age. <code>EquipmentBase.GetAge</code> and <code>LedDisplay.GetAge</code> would use this helper function to produce their output.</p> <p>In our <code>LedDisplay</code> class, we are yet to write <code>GetDescription</code>:</p> LedDisplay.cs<pre><code>public string GetDescription()\n{\n    return \"Led Display\";\n}\n</code></pre> <p>Note that we have NOT specified the <code>override</code> keyword here. When an interface function is implemented, <code>override</code> is not required/allowed to be written.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#use-getdescription","title":"Use GetDescription","text":"<p>Modify the <code>EquipmentInventory.ListAll</code> operation to also write the description of the items to the output:</p> EquipmentInventory.cs<pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Description: {eq.GetDescription()}\\t\" +\n            $\"Age: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>This gives a more informative output when the application is run:</p> <p>Console output</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#constructor-code-duplication","title":"Constructor code duplication","text":"<p>Looking at our code, there is one more duplication. All <code>EquipmentBase</code> descendants (<code>HardDisk</code>, <code>SoundCard</code>) have these two lines in their constructor:</p> <pre><code> this.yearOfCreation = yearOfCreation;\n this.newPrice = newPrice;\n</code></pre> <p>If you think about it, these <code>yearOfCreation</code> and <code>newPrice</code> members are defined in the base class, so it should be his responsibility to initialize them anyway. Let's add a corresponding constructor in <code>EquipmentBase</code>:</p> EquipmentBase.cs<pre><code>public EquipmentBase(int yearOfCreation, int newPrice)\n{\n    this.yearOfCreation = yearOfCreation;\n    this.newPrice = newPrice;\n}\n</code></pre> <p>Remove the initialization of the two members from the constructor of the descendants <code>HardDisk</code> and <code>SoundCard</code>, and instead invoke the base class\u2019s constructor by referencing the <code>base</code> keyword:</p> HardDisk.cs<pre><code>public HardDisk(int yearOfCreation, int newPrice, int capacityGB)\n    : base(yearOfCreation, newPrice)\n{\n    this.capacityGB = capacityGB;\n}\n</code></pre> SoundCard.cs<pre><code>public SoundCard(int yearOfCreation, int newPrice)\n    : base(yearOfCreation, newPrice)\n{\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#evaluation","title":"Evaluation","text":"<p>By using a combination of interface and abstract base class, we have managed to develop the solution with the least compromise:</p> <ul> <li>By referring to <code>IEquipment</code> as an interface, we can uniformly handle all types of parts, even those where the base class was bound (using abstract base classes alone would not have achieved this).</li> <li>By introducing the <code>EquipmentBase</code> abstract base class, we were able to put the code common to different part types into a common base, with one exception, thus avoiding code duplication.</li> <li>By introducing the <code>EquipmentBase</code> abstract ancestor, we can specify a default implementation for newly introduced <code>IEquipment</code> operations (e.g. <code>GetDescripton</code>), so we are not forced to specify it in every <code>IEquipment</code> implementation class.</li> </ul> <p>Finally, let's take a look at the UML (like) class diagram of our solution:</p> <p>Ultimate class diagram</p> <p>Static interfaces</p> <p>The latest addition to C# 11 is the definition of static interface members, which allows you to require an implementing class to have members that do not refer to the object instance, but rather the class must have a specific static member. Read more</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_eng/#note-optional-homework-exercise","title":"Note - optional homework exercise","text":"<p>Our solution does not support the display of component specific data (e.g. capacity for <code>HardDisk</code>) during listing. To do this, the writing of component data to a formatted string should be moved from the <code>EqipmentInventory</code> class to the component classes, following the principles below:</p> <ul> <li>To do this, we can introduce an <code>GetFormattedString</code> operation in the <code>IEquipment</code> interface, which returns an object of type <code>string</code>. Alternatively, you can override the ToString()<code>operation of</code>System.Object. indeed, in .NET, all types are implicitly derived from <code>System.Object</code>, which has a virtual <code>ToString()</code> operation.</li> <li>In <code>EquipmentBase</code> we write the formatting of the common tags (description, price, age) into a string.</li> <li>If a component also has type-specific data, then its class overrides the function that formats it into a string: this function must first call its ancestor (using the <code>base</code> keyword), then append its own formatted data to it, and return with this string.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/","title":"1. Beziehung zwischen dem Modell und dem Code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>Das Ziel der \u00dcbung:</p> <ul> <li>Kennenlernen der Studenten/Studentinnen und des \u00dcbungsleiters/ins</li> <li>Kl\u00e4rung der Anforderungen f\u00fcr \u00dcbungen</li> <li>Erste Schritte mit Visual Studio und der Entwicklung von .NET-Anwendungen.</li> <li>Erstellen einer einfachen Hello World .NET-Anwendung, C#-Grundlagen</li> <li>Veranschaulichung der Beziehung zwischen UML und Code</li> <li>Anwendungstechnik der Schnittstelle und der abstrakte Basisklasse </li> </ul> F\u00fcr \u00dcbungsleiter/in <p>Sicherlich gibt es einige Teilnehmer, die Visual Studio bereits in Prog2 (C++) oder aus anderen Gr\u00fcnden verwendet haben, aber es wird auch einige geben, die es noch nicht verwendet haben oder sich weniger daran erinnern. Das Ziel ist in diesem Fall, die Benutzeroberfl\u00e4che kennenzulernen. So w\u00e4hrend der L\u00f6sung der \u00dcbungen, sollten die benutzte Dinge (z. B. Solution Explorer,  Ausf\u00fchren mit F5, Verwenden von Haltepunkten usw.) auch besprochen werden.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Ausf\u00fchrung der \u00dcbung ben\u00f6tigten Werkzeuge:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Es sollte die neueste Version von Visual Studio installiert sein. Die Versionen Community Edition, Professional und Enterprise sind ebenfalls geeignet. Die Community Edition ist kostenlos und kann von der Microsoft-Website heruntergeladen werden. Der Professional ist kostenpflichtig, steht aber auch f\u00fcr Studenten der Universit\u00e4t kostenlos zur Verf\u00fcgung (auf der Website, im Rahmen des Programms Azure Dev Tools for Teaching).</p> <p>Visual Studio Class Diagram support</p> <p>F\u00fcr einige Aufgaben in dieser \u00dcbung (und auch f\u00fcr die erste Hausaufgabe) werden wir die Unterst\u00fctzung des Visual Studio Class Designer nutzen. Visual Studio f\u00fcgt die Komponente Class Designer w\u00e4hrend der Installation nicht immer hinzu. Wenn es nicht m\u00f6glich ist, ein Klassendiagramm zu Ihrem Visual Studio-Projekt hinzuzuf\u00fcgen (weil das Klassendiagramm nicht in der Liste des Fensters aufgef\u00fchrt ist, das w\u00e4hrend des Befehls Neues Element hinzuf\u00fcgen angezeigt wird - mehr dazu sp\u00e4ter in diesem Handbuch), m\u00fcssen Sie die Komponente Klassendiagramm sp\u00e4ter installieren:</p> <ol> <li>Starten Sie das Visual Studio-Installationsprogramm (z. B. durch Eingabe von \"Visual Studio Installer\" im Windows-Startmen\u00fc).</li> <li>W\u00e4hlen Sie in dem nun erscheinenden Fenster die Registerkarte \"Individual components\"</li> <li> <p>Geben Sie in das Suchfeld \"class designer\" ein und vergewissern Sie sich, dass \"Class Designer\" in der gefilterten Liste angekreuzt ist.</p> <p></p> </li> </ol> <p>Was Sie sich ansehen sollten:</p> <ul> <li>Die \u00dcbung beinhaltet keine Vorlesung zu diesem Thema. Gleichzeitig baut die \u00dcbung auf grundlegendem UML-Kenntnisse und den Grundlagen der Abbildung von UML-Klassendiagrammen auf Code.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#verlauf-der-ubung","title":"Verlauf der \u00dcbung","text":"<p>Der/die \u00dcbungsleiter/in fasst die Anforderungen f\u00fcr die \u00dcbungen am Anfang der \u00dcbung zusammen:</p> <ul> <li>Die meisten davon finden Sie in dem Merkblatt</li> <li>Informationen zu den Hausaufgaben finden Sie auf der Website des Fachs.</li> </ul> <p>Mit dem Entwicklungsumgebung Visual Studio werden wir .NET-Anwendungen in C# erstellen. C# ist \u00e4hnlich wie Java, wir lernen stufenweise die Unterschiede. Die Aufgaben werden gemeinsam unter der Leitung des \u00dcbungsleiters/ins durchgef\u00fchrt.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#losung","title":"L\u00f6sung","text":"Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist auf GitHub verf\u00fcgbar. Der einfachste Weg, es herunterzuladen, ist, es von der Kommandozeile aus mit dem Befehl <code>git clone</code> auf Ihren Computer zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo -b solved</code></p> <p>Sie m\u00fcssen Git auf Ihrem Rechner installiert haben, weitere Informationen hier.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#1-aufgabe-erstellen-einer-hello-world-net-konsolenanwendung","title":"1. Aufgabe - Erstellen einer \"Hello World\" .NET-Konsolenanwendung","text":"<p>Die Aufgabe ist die Erstellung einer C#-Konsolenanwendung, die den Text \"Hello world!\" auf der Konsole ausgibt.</p> <p>Die Anwendung wird in C# geschrieben. Die kompilierte Anwendung wird von der .NET-Laufzeitumgebung ausgef\u00fchrt. In der ersten Vorlesung werden die theoretischen Hintergr\u00fcnde des Kompilierens/Ablaufens und die Grundlagen von .NET behandelt.</p> <p>Die Schritte zum Erstellen einer Projektmappe und eines Projekts in Visual Studio 2022:</p> <ol> <li>Starten Sie einen neuen \"Neues Projekt erstellen\" Dialogfeld, was auf zwei Arten geschehen kann<ul> <li>Verwendung des Startfensters<ol> <li>Visual Studio starten</li> <li>In der rechten Seitenleiste des erscheinenden Startfensters Create new project</li> </ol> </li> <li>Bereits in Visual Studio ausgef\u00fchrt<ol> <li>File / New-Project</li> </ol> </li> </ul> </li> <li> <p>W\u00e4hlen Sie im Dialogfeld \"Neues Projekt erstellen\" die Vorlage \" Console app \" (und NICHT die Vorlage \" Console app (.NET Framework)\", einschlie\u00dflich der C#-Vorlage. Dass es sich um C# handelt, ist an der oberen linken Ecke des Vorlagensymbols zu erkennen. Wenn Sie es nicht in der Liste sehen, m\u00fcssen Sie es suchen/filtern. Sie k\u00f6nnen danach suchen, falls Sie in der oberen Suchleiste \"console\" eingeben. Oder verwenden Sie die Dropdown-Felder unten: im ersten (Sprachauswahl) \"C#\", im dritten (Projekttypauswahl) \"Console\".</p> <p></p> </li> <li> <p>Next-Taste am unteren Rand des Dialogfeldes \"Neues Projekt erstellen\", auf der n\u00e4chsten Seite:</p> <ol> <li>Project name: Hello World</li> <li>Location: In den Labors arbeiten wir im Ordner c:\\work\\&lt;IhreName&gt;, auf den Sie Schreibrechte haben.</li> <li>Solution name: Hello World (dies sollte bis zu unserer Ankunft hier eingeschrieben sein)</li> <li>Place solution and project in the same directory: kein H\u00e4kchen (aber nicht besonders wichtig).</li> </ol> </li> <li> <p>Next-Taste am unteren Rand des Dialogfeldes \"Neues Projekt erstellen\", auf der n\u00e4chsten Seite:</p> <ol> <li>Framework: .NET 8 (Langfristige Unterst\u00fctzung).</li> <li>Aktivieren Sie das Kontrollk\u00e4stchen \"Do not use top level statements\" (wir werden dies gleich erkl\u00e4ren).</li> </ol> </li> </ol> <p>Das Projekt erstellt auch eine neue Projektmappe, deren Struktur im Visual Studio Solution Explorer-Fenster angezeigt werden kann. Eine L\u00f6sung kann aus mehreren Projekten bestehen, und ein Projekt kann aus mehreren Dateien bestehen. Ein Solution ist eine Zusammenfassung der gesamten Arbeitsumgebung (sie hat die Dateierweiterung <code>.sln</code> ), w\u00e4hrend die Ausgabe eines Projekts typischerweise eine Datei <code>.exe</code> oder <code>.dll</code> ist, d. h. eine Komponente einer komplexen Anwendung/eines komplexen Systems. Projektdateierweiterung f\u00fcr C#-Anwendungen <code>.csproj</code>.</p> <p>Der Inhalt unserer Datei <code>Program.cs</code> ist die folgende:</p> Program.cs<pre><code>namespace HelloWorld\n{\n    internal class  Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> <p>Nehmen wir eine <code>Console.ReadKey()</code> Zeile aus: </p> <pre><code>namespace HelloWorld\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li> <p>F\u00fchren wir die Anwendung aus (z. B. mit der Taste F5 ).</p> <p>Die Struktur des Codes ist sehr \u00e4hnlich zu Java und C++. Unsere Klassen sind in Namespaces organisiert. Sie k\u00f6nnen einen Namespace mit dem Schl\u00fcsselwort <code>namespace</code> definieren. Wir k\u00f6nnen Namespaces mit dem Schl\u00fcsselwort <code>using</code> \"ins Geltungsbereich bringen\". z.B.:</p> <pre><code>using System.Collections.Generic;\n</code></pre> </li> <li> <p>In einer C#-Konsolenanwendung wird der Eintrittspunkt der Anwendung mit einer statischen Funktion namens <code>Main</code> gegeben. Unser Klassenname kann beliebig sein, in unserem Fall hat VS eine Klasse namens <code>Program</code> erzeugt. Die Parameterliste der Funktion <code>Main</code> ist gebunden: entweder werden keine Parameter angegeben, oder es wird ein <code>string[]</code>angegeben, in dem die Befehlszeilenargumente zur Laufzeit angegeben werden.</p> </li> <li>in .NET wird die Klasse <code>Console</code> aus dem Namensraum <code>System</code> verwendet, um die Standardeingabe und -ausgabe zu verarbeiten. Mit der statischen Aktion <code>WriteLine</code> k\u00f6nnen Sie eine Zeile drucken, mit <code>ReadKey</code> k\u00f6nnen Sie auf das Dr\u00fccken einer Taste warten.</li> </ol> <p>Top-Level-Anweisungen, implizite und statische Verwendungen und Namespaces</p> <p>Bei der Projekterstellung haben wir zuvor das Kontrollk\u00e4stchen \"Do not use top level statements\" aktiviert. Falls wir dies nicht getan h\u00e4tten, h\u00e4tten wir in unserer Datei <code>Program.cs</code> nur eine einzige Zeile mit Inhalt gefunden:</p> <pre><code>// siehe https://aka.ms/new-console-template f\u00fcr weitere Informationen\nConsole.WriteLine(\"Hello World!\");\n</code></pre> <p>Es ist funktionell \u00e4quivalent zu dem obigen Code, der die Klasse <code>Program</code> und ihre Funktion <code>Main</code> enth\u00e4lt. Schauen wir uns an, was dies m\u00f6glich macht (Sie k\u00f6nnen hier mehr dar\u00fcber lesen https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements, beide neu in C# 10):</p> <ul> <li>Top level statements. Die Idee ist, dass man Code direkt in einer einzigen Quelldatei schreiben kann, ohne dass Klassen/<code>Main</code> und andere Funktionsdefinitionen im Projekt vorhanden sind. In diesem Fall setzt der Compiler dies hinter den Kulissen in eine statische <code>Main</code>-Funktion einer Klasse, die wir nicht sehen. Die Motivation f\u00fcr seine Einf\u00fchrung war die Reduzierung von \"Boilerplate\"-Code f\u00fcr sehr einfache, \"skriptartige\" Anwendungen.</li> <li>Implicit global usings. Je nachdem, welchen Projekttyp Sie erstellt haben, werden bestimmte Basis-Namensr\u00e4ume automatisch im Hintergrund in allen Quelldateien verwendet (der Compiler verwendet dazu die global using-Direktive). Der Punkt ist: Auf diese Weise m\u00fcssen Entwickler bestimmte h\u00e4ufig verwendete Namespaces (z.B. <code>System.IO</code>, <code>System.Collections.Generic</code>, etc.) nicht als Quelldateien verwenden.</li> <li> <p>Static using. Es ist m\u00f6glich, statische Klassen statt Namespaces in C# mit <code>using</code> zu verwenden, so es nicht wichtig ist, diese auszuschreiben, wenn sie verwendet werden. Ein h\u00e4ufiger Fall ist die Verwendung der Klasse \"Console\" oder \"Math\".</p> <pre><code>using static System.Console;\n\nnamensraum ConsoleApp12\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            WriteLine(\"Hello World!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>Namensr\u00e4ume auf Dateiebene. In C# 10 gibt es auch eine Vereinfachung bei der Deklaration von Namespaces, da es nicht mehr zwingend erforderlich ist, Klammern zu verwenden, so dass der angegebene Namespace f\u00fcr die ganze Datei g\u00fcltig ist, z.B:</p> <pre><code>namespace HelloWorld;\n\ninternal class Program\n{\n    // ...\n}\n</code></pre> </li> </ul> <p>Inconsistent visibility oder inconsistent accessibility Fehler</p> <p>W\u00e4hrend des Semesters k\u00f6nnen Sie bei der Durchf\u00fchrung von Programmieraufgaben auf \u00dcbersetzungsfehlermeldungen sto\u00dfen, die sich \u00fcber inconsistent visibility oder inconsistent accessibility beschweren. Dieses Ph\u00e4nomen ist auf die M\u00f6glichkeit zur\u00fcckzuf\u00fchren, die Sichtbarkeit der einzelnen Typen (Klassen, Schnittstellen usw.) in einer .NET-Umgebung zu steuern:</p> <ul> <li><code>internal</code> oder keine Sichtbarkeit angeben: der Typ ist nur in der angegebenen Assembly (.exe, .dll)/dem angegebenen Projekt sichtbar</li> <li><code>public</code>: der Typ ist auch f\u00fcr andere Assemblys/Projekte sichtbar</li> </ul> <p>Der einfachste Weg, diesen Fehler zu vermeiden, ist, alle unsere Typen als \u00f6ffentlich zu definieren, z.B.:</p> <pre><code>public class HardDisk\n{\n    // ...\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#theoretischer-uberblick","title":"Theoretischer \u00dcberblick","text":"<p>Die Unterkapitel enthalten keine \u00dcbungen, sondern bieten den Studierenden eine mit Beispielen illustrierte Einf\u00fchrung in die entsprechenden theoretischen Themen.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#a-theorie-der-beziehung-zwischen-dem-uml-klassendiagramm-und-dem-code-student","title":"A) Theorie der Beziehung zwischen dem UML-Klassendiagramm und dem Code [Student]*","text":"<p>Das Material ist hier verf\u00fcgbar: Die Beziehung zwischen dem UML-Klassendiagramm und dem Code Dieses Thema wurde im vorangegangenen Semester in der Vorlesung Softwaretechnologien behandelt.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#b-schnittstelle-und-abstrakte-basisklasse-student","title":"B) Schnittstelle und abstrakte (Basis)Klasse [Student]*","text":"<p>Das Material ist hier verf\u00fcgbar:  Schnittstelle und abstrakte (angestammte) Klasse.</p> <p>Themen:</p> <ul> <li>Konzept und Definition abstrakter Klassen in C#</li> <li>Schnittstellenkonzepte und -definitionen in C#</li> <li>Vergleich von abstraktem Basisklasse und Schnittstelle</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#2-aufgabe-veranschaulichen-der-beziehung-zwischen-uml-und-code","title":"2. Aufgabe - Veranschaulichen der Beziehung zwischen UML und Code","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#aufgabenbeschreibung-equipment-inventory","title":"Aufgabenbeschreibung - Equipment inventory","text":"<p>Aufgabe: Wir haben die Aufgabe bekommen, eine Computerteilregister-Anwendung zu entwickeln. Lesen Sie mehr:</p> <ul> <li>Es soll f\u00e4hig sein, verschiedene Arten von Teilen zu behandeln. Anf\u00e4nglich sollten die Typen <code>HardDisk</code>, <code>SoundCard</code> und <code>LedDisplay</code> unterst\u00fctzt werden, aber das System sollte leicht auf neue Typen erweiterbar sein.</li> <li>Daten der Teilen: Kaufsjahr, Alter (berechnet), Kaufspreis und aktueller Preis (berechnet), kann aber auch typspezifische Daten enthalten (z. B. Kapazit\u00e4t f\u00fcr <code>HardDisk</code> ).</li> <li>Der aktueller Preis h\u00e4ngt von der Art des Teils, dem Einkaufspreis und dem Produktionsjahr des Teils ab. Je \u00e4lter das Teil ist, desto h\u00f6her ist der Preisnachlass, aber der Preisnachlass h\u00e4ngt von der Art des Teils ab.</li> <li>Es soll f\u00e4hig sein, die speicherte Teilen aufzulisten.</li> <li>Die Klasse <code>LedDisplay</code> muss von einer Klasse <code>DisplayBase</code> abgeleitet sein, und der Quellcode der Klasse <code>DisplayBase</code> darf nicht ver\u00e4ndert werden. In diesem Beispiel hat dies nicht viel Sinn, aber in der Praxis treffen wir oft auf \u00e4hnliche Situationen, in denen das von uns verwendete Framework/die Plattform verlangt, dass wir von einer eingebauten Klasse ableiten. Typischerweise ist dies der Fall, wenn wir mit Fenstern, Formularen oder benutzerdefinierten Steuerelementen arbeiten: Wir m\u00fcssen sie von den eingebauten Klassen des Frameworks ableiten, und wir haben den Quellcode des Frameworks nicht (oder wollen ihn zumindest nicht \u00e4ndern) - z.B. Java, .NET. In unserem Beispiel simulieren wir diese Situation, indem wir eine Ableitung von <code>DisplayBase</code>verlangen.</li> </ul> <p>Die Implementierung ist erheblich vereinfacht: Die Teile werden nur im Speicher abgelegt, und die Auflistung ist so einfach wie m\u00f6glich, einfach die Daten der registrierten Teile werden auf die Konsole geschrieben.</p> <p>Bei den ersten Gespr\u00e4chen erhalten wir vom Kunden folgende Information: Ein interner Mitarbeiter hat bereits mit der Entwicklung begonnen, ist aber aus Zeitmangel nur zu einer halbfertigen L\u00f6sung gekommen. Ein Teil unserer Aufgabe besteht darin, die halbfertige L\u00f6sung zu verstehen und die Aufgabe von dort aus umzusetzen.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#klassendiagramm","title":"Klassendiagramm","text":"<p>\u00d6ffnen wir die Quellcode-L\u00f6sung unseres Kunden source code mit dem Ausf\u00fchren der nachstehenden Schritte.</p> <p>Klonen wir das Git-Repository des urspr\u00fcnglichen Projekts, das online auf GitHub verf\u00fcgbar ist, in einen eigenen Ordner innerhalb des Ordners <code>C:\\Work</code>: z. B.: <code>C:\\Work\\NEPTUN\\lab1</code>. \u00d6ffnen wir in diesem neuen Ordner eine Befehlszeile oder Powershell und f\u00fchren wir den folgenden git-Befehl aus:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-modellkod-kiindulo.git\n</code></pre> <p>Git und GitHub</p> <p>Sie werden mehr \u00fcber Git als Quellcode-Verwaltungssystem im Rahmen der ersten Hausaufgabe erfahren.</p> <p>\u00d6ffnen wir die Visual Studio Solution src/EquipmentInventory.sln im geklonten Ordner.</p> <p>Blicken wir die Dateien im Solution Explorer lurz \u00fcber. Es w\u00e4re hilfreich, die Beziehungen zwischen den Klassen in einem Klassendiagramm darzustellen, um sie zu verstehen. Wir wollen ein Klassendiagramm in unser Projekt einf\u00fcgen. Klicken wir im Solution Explorer mit der rechten Maustaste auf das Projekt (nicht auf das Solution!), und w\u00e4hlen wir im Popup-Men\u00fc die Option Add/New Item. Dann w\u00e4hlen wir in dem erscheinenden Fenster die Option Class Diagram, geben wir am unten im Fenster Main.cd als der Namen des Diagramms ein, und schlie\u00dfen wir das Fenster mit OK.</p> <p>Fehlende Class Diagram-Vorlage</p> <p>Wenn das Element Class Diagram nicht in der Liste erscheint, ist die entsprechende Komponente von VS nicht installiert. Weitere Informationen hierzu finden Sie im Abschnitt Voraussetzungen in diesem Dokument.</p> <p>Die Diagrammdatei <code>Main.cd</code> wird dann im  Solution Explorer angezeigt. Doppelklicken wir darauf, um sie zu \u00f6ffnen. Unseres Diagramm ist derzeit leer. Ziehen wir die .cs-Quelldateien aus Solution Explorer mit drag&amp;drop auf das Diagramm. VS pr\u00fcft dann, welche Klassen in diesen Quelldateien enthalten sind, und zerlegt sie in UML-Klassen. Erstellen wir das Layout wie in der folgenden Abbildung gezeigt (man kann die Mitglieder der Klassen anzeigen, falls man auf den Doppelpfeil in der oberen rechten Ecke ihres Rechtecks klickt):</p> <p></p> <p>Wir k\u00f6nnen auch den Quellcode der Klassen anschauen, falls wir entweder auf die entsprechende Klasse im Diagramm doppelklicken oder die .cs-Dateien im  Solution Explorer \u00f6ffnen. Wir werden die Folgenden erfahren:</p> <ul> <li>Die Klassen <code>SoundCard</code>, <code>HardDisk</code> und <code>LedDisplay</code> sind relativ gut entwickelt und verf\u00fcgen \u00fcber die notwendigen Attribute und Abfragefunktionen.</li> <li><code>LedDisplay</code> wird bei Bedarf von <code>DisplayBase</code> abgeleitet.</li> <li>Obwohl <code>EquipmentInventory</code> f\u00fcr die Register der auf Lager befindlichen Teile verantwortlich ist, wird praktisch nichts davon umgesetzt.</li> <li>Wir finden eine Schnittstelle <code>IEquipment</code>, mit <code>GetAge</code> und <code>GetPrice</code> Funktionen.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#equipmentinventory","title":"EquipmentInventory","text":"<p>Lassen wir uns an der L\u00f6sung arbeiten. Lassen wir uns zuerst die grundlegenden Konzepte festlegen. In der Klasse <code>EquipmentInventory</code> speichern wir eine heterogene Sammlung verschiedener Teiltypen. Dies ist der Schl\u00fcssel zu einer konsistenten Teilverwaltung, so dass unsere L\u00f6sung problemlos mit neuen Teiltypen erweitert werden kann.</p> <p>Wie fr\u00fcher erw\u00e4hnt, kann eine einheitliche Verwaltung entweder durch die Implementierung einer gemeinsamen Basisklasse oder einer gemeinsamen Schnittstelle erreicht werden. In unserem Fall scheint die gemeinsame Basisklasse (z. B. <code>EquipmentBase</code>) eliminiert zu werden, denn durch ihre Einf\u00fchrung h\u00e4tte die Klasse <code>LedDisplay</code> zwei Basisklassen: <code>DisplayBase</code>, die obligatorisch ist, und <code>EquipmentBase</code>, die wir zur einheitlichen Verwaltung einf\u00fchren. Dies ist nicht m\u00f6glich, in einer .NET-Umgebung kann eine Klasse nur einen Vorg\u00e4nger haben. Die L\u00f6sung, <code>DisplayBase</code>so zu \u00e4ndern, dass es von <code>EquipmentBase</code>stammt, ist nach unseren Anforderungen nicht m\u00f6glich (es war eine Anforderung, dass der Quellcode nicht ge\u00e4ndert werden durfte). Es bleibt also der schnittstellenbasierte Ansatz. Dies ist sicherlich die Schlussfolgerung des vorherigen Entwicklers der Anwendung, weshalb er die Schnittstelle <code>IEquipment</code> eingef\u00fchrt hat.</p> <p>F\u00fcgen wir eine generische Liste von Elementen des Typs <code>IEquipment</code> (keine Eigenschaft, sondern ein Feld!) zur Klasse <code>EquipmentInventory</code> hinzu. Ihre Sichtbarkeit sollte - in dem Bem\u00fchen um Integration - <code>private</code>sein. Der Name sollte <code>equipment</code> sein (ohne \"s\" am Ende, im Englisch ist der Plural von equipment auch equipment). Um eine Membervariable hinzuzuf\u00fcgen, verwenden wir das Class Details Fenster von Visual Studio. Wenn das Fenster nicht sichtbar ist, kann es durch Auswahl von View / Other Windows / Class Details angezeigt werden.</p> <p></p> <p>Der Typ der Mitgliedsvariablen ist <code>List&lt;IEquipment&gt;</code>. Der .NET-Typ <code>List</code> ist ein dynamisch dehnbares generisches Array (wie <code>ArrayList</code>in Java). Falls wir auf die Klasse <code>EquipmentInventory</code> im Diagramm blicken, so siehen wir, dass nur der Name der Mitgliedsvariablen angezeigt wird, nicht aber der Typ. Klicken wit mit der rechten Maustaste auf den Hintergrund des Diagramms und w\u00e4hlen wir im Change Members Format Men\u00fc  die Option Display Full Signature. Das Diagramm zeigt dann den Typ der Mitgliedsvariablen und die vollst\u00e4ndige Signatur der Operationen.</p> <p></p> <p>Wenn wir auf die Klasse <code>EquipmentInventory</code> doppelklicken, k\u00f6nnen wir zum Quellcode navigieren, und wie wir sehen k\u00f6nnen, erscheint sie im Code tats\u00e4chlich als Mitgliedsvariable vom Typ Liste:</p> <pre><code>class EquipmentInventory\n{\n    private List&lt;IEquipment&gt; equipment;\n</code></pre> <p>Einerseits freuen wir uns dar\u00fcber, weil Visual Studio Round-Trip-Engineering unterst\u00fctzt: \u00c4nderungen am Modell spiegeln sich sofort im Code wider und umgekehrt. Andererseits haben wir bereits dar\u00fcber gesprochen, dass eine Klasse, die eine Sammlung von Mitgliedern einer anderen Klasse hat, sollte in das UML-Modell als eine Assoziationsbeziehung vom Typ 1-mehr zwischen den beiden Klassen erscheinen. Dies ist noch nicht der Fall in unserem Modell. Gl\u00fccklicherweise kann die VS-Modellierungsschnittstelle dazu gebracht werden, diese Art von Verbindung in dieser Form anzuzeigen. Klicken wir dazu im Diagramm mit der rechten Maustaste auf die Membervariable equipment und w\u00e4hlen wir im Men\u00fc die Option Show as Collection Association aus. Die Schnittstelle <code>IEquipment</code> sollte dann nach rechts verschoben werden, damit im Diagramm gen\u00fcgend Platz f\u00fcr die Darstellung der Assoziationsverbindung und der Rolle der Verbindung bleibt:</p> <p></p> <p>Der Doppelpfeil, der auf der \"Mehr\"-Seite endet, entspricht nicht dem UML-Standard, aber sei man nicht zu traurig dar\u00fcber, es ist nicht wichtig. Wir freuen uns dar\u00fcber, dass der Name (und sogar der genaue Typ) der Mitgliedsvariablen am <code>IEquipment</code> Ende der die Beziehung darstellende Pfeil in der Rolle anzeigt ist.</p> <p>Navigieren wir zum Quellcode von <code>EquipmentInventory</code> und schreiben wir den Konstruktor, der die Sammlung <code>equipment</code> initialisiert!</p> <pre><code>public EquipmentInventory()\n{\n    equipment = new List&lt;IEquipment&gt;();\n}\n</code></pre> <p>Schreiben wir dann die Methode <code>ListAll</code>, die das Alter der Elemente und ihren aktuellen Preis ausgibt:</p> <pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine($\"Alter: {eq.GetAge()}\\t\u00c9rt\u00e9ke: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Mit dem Befehl <code>foreach</code> durchlaufen wir die Elemente. Bei der Verwendung des Befehls <code>foreach</code> sollte <code>in</code> von einer Sammlung gefolgt werden, und <code>in</code> sollte eine Variablendeklaration (in diesem Fall <code>IEquipment eq</code>) vorangestellt werden, wo type der Elementtyp der Sammlung ist. Bei jeder Iteration nimmt diese Variable den Iterationswert der Sammlung an.</p> <p>Der Operation <code>Console.WriteLine</code> wird entweder eine einfache Zeichenfolge oder, wie in unserem Fall, eine Formatierungszeichenfolge \u00fcbergeben. Die Ersetzungen werden durch String-Interpolation gel\u00f6st: Die zu ersetzenden Werte m\u00fcssen zwischen <code>{}</code> angegeben werden. Bei der String-Interpolation muss der String mit <code>$</code> beginnen.</p> <p>Schreiben wir eine Funktion mit der Bezeichnung <code>AddEquipment</code>, die ein neues Ger\u00e4t zu der Menge hinzuf\u00fcgt:</p> <pre><code>public void AddEquipment(IEquipment eq)\n{\n     equipment.Add(eq);\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#verwirklichern-von-iequipment","title":"Verwirklichern von IEquipment","text":"<p>Wir haben entschieden, die Schnittstelle <code>IEquipment</code> zu verwenden, um die verschiedenen Komponententypen einheitlich zu verwalten. In unserem Fall haben sowohl die Klassen <code>SoundCard</code> als auch <code>HardDisk</code> die Methoden <code>GetAge()</code> und <code>GetPrice()</code>, aber wir k\u00f6nnen sie nicht einheitlich verwalten (z. B. in einer gemeinsamen Liste speichern). Zu diesem Zweck m\u00fcssen wir beide Klassen dazu bringen, die Schnittstelle <code>IEquipment</code> zu implementieren. \u00c4ndern Sie ihr Quellcode:</p> <pre><code>public class SoundCard : IEquipment\n</code></pre> <pre><code>public class HardDisk : IEquipment\n</code></pre> <p>Dann m\u00fcssen wir die Methoden der Schnittstelle <code>IEquipment</code> in den Klassen <code>SoundCard</code> und <code>HardDisk</code> implementieren. Wir stellen fest, dass es damit nichts mehr zu tun gibt, die Funktionen <code>GetPrice</code> und <code>GetAge</code> sind bereits an beiden Stellen geschrieben.</p> <p>Erstellen wir testweise ein Objekt <code>EquipmentInventory</code> in unserer <code>Main</code> Funktion in <code>Program.cs</code>, f\u00fcllen wir es mit den Objekten <code>HardDisk</code> und <code>SoundCard</code> auf, und listen wir das Objekt dann in der Konsole aus. Wenn 2021 nicht das aktuelle Jahr ist, schreiben wir in den folgenden Zeilen das Jahr 2021 auf das aktuelle Jahr und das Jahr 2020 auf eine mit eins kleinere Zahl um!</p> <pre><code>static void Main( string[] args )\n{\n    EquipmentInventory ei = new EquipmentInventory();\n\n    ei.AddEquipment(new HardDisk(2021, 30000, 80));\n    ei.AddEquipment(new HardDisk(2020, 25000, 120));\n    ei.AddEquipment(new HardDisk(2020, 25000, 250));\n\n    ei.AddEquipment(new SoundCard(2021, 8000));\n    ei.AddEquipment(new SoundCard(2020, 7000));\n    ei.AddEquipment(new SoundCard(2020, 6000));\n\n    ei.ListAll();\n}\n</code></pre> <p>Wenn wir die Anwendung ausf\u00fchren, stellen wir fest, dass unsere L\u00f6sung zwar anf\u00e4nglich ist, aber funktioniert:</p> <p></p> <p>Arbeiten wir weiter mit der Klasse <code>LedDisplay</code>.  Der Quellcode von <code>DisplayBase</code> kann aufgrund der Anforderungen nicht ge\u00e4ndert werden. Aber das ist kein Problem, unsere Klasse <code>LedDisplay</code> wird die Schnittstelle <code>IEquipment</code> implementieren, lassen wir uns den Code entsprechend \u00e4ndern:</p> <pre><code>public class LedDisplay : DisplayBase, IEquipment\n</code></pre> <p>In der Klasse <code>LedDisplay</code> m\u00fcssen die Funktionen der Schnittstelle bereits geschrieben sein:</p> <pre><code>public double GetPrice()\n{\n    return this.price;\n}\n\npublic int GetAge()\n{\n    return DateTime.Today.Year - this.manufacturingYear;\n}\n</code></pre> <p>Erweitern wir unsere <code>Main</code> Funktion, f\u00fcgen wir zwei <code>LedDisplay</code> Objekte zu unserer Liste hinzu (auch hier gilt: Wenn 2021 nicht das aktuelle Jahr ist, schreiben wir in den folgenden Zeilen das Jahr 2021 auf das aktuelle Jahr und das Jahr 2020 auf eine mit eins kleinere Zahl um!)</p> <pre><code>ei.AddEquipment(new LedDisplay(2020, 80000, 17, 16));\nei.AddEquipment(new LedDisplay (2021, 70000, 17, 12));\n\nei.ListAll();\nConsole.ReadKey();\n</code></pre> <p>F\u00fchren wir die Anwendung testweise aus.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#3-aufgabe-anwendung-der-schnittstelle-und-der-abstrakten-basisklasse","title":"3. Aufgabe - Anwendung der Schnittstelle und der abstrakten Basisklasse","text":""},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#schnittstellenprobleme","title":"Schnittstellenprobleme","text":"<p>Bewerten wir unsere aktuelle schnittstellenbasierte L\u00f6sung.</p> <p>Eines der Hauptprobleme ist, dass unser Code mit Code-Duplikationen voll ist, die die Wartbarkeit und Erweiterbarkeit zerst\u00f6ren:</p> <ul> <li>Die Mitglieder <code>yearOfCreation</code> und <code>newPrice</code> gelten f\u00fcr alle Komponententypen (mit Ausnahme des speziellen <code>LedDisplay</code>) und m\u00fcssen immer mit copy-paste hinzugef\u00fcgt werden, wenn ein neuer Typ eingef\u00fchrt wird.</li> <li>Die Implementierungsebene der Funktion <code>GetAge</code> ist f\u00fcr alle Komponententypen (mit Ausnahme der speziellen <code>LedDisplay</code>) gleich, auch mit copy-paste wird \"vermehrt\".</li> <li>Die Zeilen in den Konstruktoren, die die Mitglieder <code>yearOfCreation</code> und <code>newPrice</code> initialisieren, werden ebenfalls in jeder Klasse dupliziert.</li> </ul> <p>Auch wenn diese Codeduplizierung im Moment noch unbedeutend zu sein scheint, wird die Situation mit der Einf\u00fchrung neuer Komponententypen immer schlechter, und es ist besser, k\u00fcnftigen Problemen rechtzeitig vorzubeugen.</p> <p>Ein weiteres Problem besteht darin, dass die Auflistung der Teiledaten derzeit schmerzlich unvollst\u00e4ndig ist, da es keine Teileart gibt (nur Alter und Preis). Um den Typ anzuzeigen, muss die Schnittstelle IEquipment erweitert werden, z. B. durch Einf\u00fchrung einer Operation namens <code>GetDescription</code>.   F\u00fcgen wir der Schnittstelle eine Funktion <code>GetDescription</code> hinzu!</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription();\n}\n</code></pre> <p>Dann m\u00fcsste jede Klasse, die die Schnittstelle <code>IEquipment</code> implementiert, diese Methode implementieren, was f\u00fcr viele Klassen eine Menge Arbeit bedeutet (und f\u00fcr eine Mehrkomponenten-Anwendung, d.h. eine Anwendung, die aus mehreren DLLs besteht, oft gar nicht machbar ist, wenn sie nicht in den H\u00e4nden eines einzigen Entwicklers liegen). F\u00fchren wir den Befehl Build aus, um zu \u00fcberpr\u00fcfen, ob Sie nach dem Hinzuf\u00fcgen von <code>GetDescription</code> an drei Stellen \u00dcbersetzungsfehler erhalten.</p> <p>Standardimplementierung in der Schnittstelle festlegen</p> <p>Es ist wichtig zu wissen, dass ab C# 8 (genauer .NET oder .NET Core Runtime ist auch n\u00f6tig, es ist unter .NET Framework nicht unterst\u00fctzt ) Schnittstellenoperationen eine Standardimplementierung erhalten k\u00f6nnen (default interface methods), so dass wir zur L\u00f6sung des obigen Problems keine abstrakte Klasse ben\u00f6tigen, aber die Schnittstelle kann keine Mitgliedsvariablen mehr haben. Weitere Informationen finden Sie hier: default interface methods.</p> <pre><code>public interface IEquipment\n{\n    double GetPrice();\n    int GetAge();\n    string GetDescription() { return \"EquipmentBase\"; }\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#abstrakte-klasse","title":"Abstrakte Klasse","text":"<p>Eine L\u00f6sung f\u00fcr beide Probleme ist die Einf\u00fchrung eines gemeinsamen abstrakten Vorfahres (mit Ausnahme der Klasse <code>LedDisplay</code>, auf die wir noch zur\u00fcckkommen werden). Wir k\u00f6nnen den Code, der allen Nachkommen gemeinsam ist, dorthin verschieben und eine Standardimplementierung f\u00fcr die neu eingef\u00fchrte Operation <code>GetDescription</code> bereitstellen. Nennen wir unsere neue abstrakte Basisklasse <code>EquipmentBase</code>. Die Frage ist, ob die Schnittstelle <code>IEquipment</code> noch ben\u00f6tigt wird oder ob sie vollst\u00e4ndig durch die neue Klasse <code>EquipmentBase</code> ersetzt werden kann. Wir m\u00fcssen die Schnittstelle <code>IEquipment</code> beibehalten, weil wir unsere Klasse LedDisplay nicht von <code>EquipmentBase</code>ableiten k\u00f6nnen: Sie hat bereits eine obligatorische Basisklasse, <code>DisplayBase</code>, deshalb bezieht sich EquipmentInventory in unserer erweiterten L\u00f6sung auf die verschiedenen Komponenten als Schnittstelle <code>IEquipment</code>. </p> <p>Beginnen wir mit der Umwandlung. Unser Klassendiagramm soll die aktive Registerkarte sein. Ziehen wir aus der Toolbox mit drag&amp;drop ein  Abstract Class Element auf das Diagramm und benennen wir es <code>EquipmentBase</code>.</p> <p></p> <p>Im Folgenden m\u00fcssen wir die Klassen <code>SoundCard</code> und <code>HardDisk</code> von <code>EquipmentBase</code>ableiten ( <code>LedDisplay</code>hat bereits einen anderen Vorfahren, so dass wir dies dort nicht tun k\u00f6nnen). W\u00e4hlen wir dazu die Verkn\u00fcpfung Inheritance in der Toolbox und ziehen wir dann eine Linie von der Kindklasse zur Basisklasse sowohl f\u00fcr <code>SoundCard</code> als auch f\u00fcr <code>HardDisk</code>. </p> <p>Im n\u00e4chsten Schritt \u00e4ndern wir den Code so, dass <code>HardDisk</code> und <code>SoundCard</code> die Schnittstelle <code>IEquipment</code> nicht separat implementieren, sondern ihr gemeinsamer Vorfahre <code>EquipmentBase</code> dies tut. \u00c4ndern wir dazu die Klasse <code>EquipmentBase</code> so, dass sie die Schnittstelle implementiert (entweder durch Einf\u00fcgen eines inheritance Beziehung von <code>EquipmentBase</code>zu <code>IEquipment</code>im Diagramm oder durch \u00c4ndern des Quellcodes von <code>EquipmentBase</code> ). Entfernen wir die Implementierung von <code>IEquipment</code> aus den Klassen <code>HardDisk</code> und <code>SoundCard</code> (der Vorg\u00e4nger implementiert sie bereits).</p> <p>Die relevanten Teile unseres Diagramms und des Quellcodes sehen dann wie folgt aus:</p> <p></p> <pre><code>public abstract class EquipmentBase : IEquipment\n</code></pre> <pre><code>public class HardDisk : EquipmentBase\n</code></pre> <pre><code>public class SoundCard : EquipmentBase\n</code></pre> <p>Unser Code kann aus mehreren Gr\u00fcnden noch nicht kompiliert werden.  <code>EquipmentBase</code> implementiert die Schnittstelle <code>IEquipment</code>, aber sie implementiert noch nicht die Operationen der Schnittstelle. Erzeugen wir die Methoden entweder mit Hilfe des Smarttags oder geben wir sie nach den folgenden Grunds\u00e4tzen ein:</p> <ul> <li>Die Mitglieder <code>newPrice</code> und <code>yearOfCreation</code> sind in den Klassen <code>HardDisk</code> und <code>SoundCard</code> dupliziert: verschieben (nicht kopieren!) wir sie in den gemeinsamen Vorfahren <code>EquipmentBase</code> und geben wir <code>protected</code> Sichtbarkeit.</li> <li>Die Operation <code>GetAge</code> wird in den Klassen <code>HardDisk</code> und <code>SoundCard</code> dupliziert, l\u00f6schen wir die Implementierung aus diesen Klassen und verschieben wir sie in die Klasse <code>EquipmentBase</code>. </li> <li>Die Operation <code>GetPrice</code> wird als abstrakte Operation in den Vorg\u00e4nger aufgenommen. Dies ist eine bewusste Design-Entscheidung, so dass wir nachkommende Klassen zwingen, diesen Vorgang trotzdem zu \u00fcberschreiben.</li> <li>F\u00fcr <code>GetDescription</code> gilt das Gegenteil: Wir definieren es als virtuell (und nicht abstrakt), d. h. wir geben eine Implementierung im Vorg\u00e4nger an. Auf diese Weise sind die Nachkommen nicht gezwungen, den Vorgang au\u00dfer Kraft zu setzen.</li> </ul> <p>Der entsprechende Code lautet:</p> <pre><code>public abstract class EquipmentBase : IEquipment\n{\n    protected int yearOfCreation;\n    protected int newPrice;\n\n    public int GetAge()\n    {\n        return DateTime.Today.Year - yearOfCreation;\n    }\n\n    public abstract double GetPrice();\n\n    public virtual string GetDescription()\n    {\n        r\u00fcckgabe \"EquipmentBase\";\n    }\n}\n</code></pre> <p>Einige zus\u00e4tzliche Gedanken zum Codefragment:</p> <ul> <li>Bei abstrakten Klassen muss das Schl\u00fcsselwort \"abstrakt\" vor das Wort \"Klasse\" geschrieben werden.</li> <li>F\u00fcr abstrakte Operationen muss das Schl\u00fcsselwort <code>abstract</code> angegeben werden.</li> <li>In .NET-Umgebung kann man steuern, ob ein Vorgang virtuell ist oder nicht. In dieser Hinsicht ist es \u00e4hnlich wie C++. Wenn man eine Operation virtuell machen will, muss man das Schl\u00fcsselwort <code>virtual</code> f\u00fcr die Operation angeben. Zur Erinnerung: Man definiert eine Operation als virtuell, wenn ihre Nachkommen sie \u00fcberdefinieren. Nur dann ist gew\u00e4hrleistet, dass die Nachfolgeversion aufgerufen wird, wenn die angegebene Operation auf einen Vorg\u00e4ngerverweis angewendet wird.</li> </ul>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#nachkommenschaft","title":"Nachkommenschaft","text":"<p>Im n\u00e4chsten Schritt gehen wir zu den Nachkommen von <code>EquipmentBase</code> \u00fcber. Wenn abstrakte und virtuelle Operationen in C# \u00fcberschrieben werden, muss das Schl\u00fcsselwort <code>override</code> im Nachfahren angegeben werden. Zuerst wird die Methode <code>GetPrice</code> neu definiert:</p> HardDisk.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0\n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 5000;\n}\n</code></pre> SoundCard.cs<pre><code>public override double GetPrice()\n{\n    return yearOfCreation &lt; (DateTime.Today.Year - 4)\n        ? 0 \n        : newPrice - (DateTime.Today.Year - yearOfCreation) * 2000;\n}\n</code></pre> <p>Im n\u00e4chsten Schritt werden wir die Operation <code>GetDescription</code> in die Klassen <code>HardDisk</code> und <code>SoundCard</code> schreiben. Da wir hier die virtuelle Vorg\u00e4ngerfunktion umdefinieren, m\u00fcssen wir auch das Schl\u00fcsselwort <code>override</code> angeben:</p> HardDisk.cs<pre><code>public override string GetDescription()\n{\n    return \"Hard Disk\";\n}\n</code></pre> SoundCard.cs<pre><code>public override string GetDescription()\n{\n    return \"Sound Card\";\n}\n</code></pre> <p>Man k\u00f6nnte sich fragen, warum die Entwickler der Sprache C# beschlossen haben, der Definition von Operationen ein zus\u00e4tzliches Schl\u00fcsselwort hinzuzuf\u00fcgen, was im Fall von C++ nicht notwendig war. Der Grund daf\u00fcr ist einfach: Der Code ist aussagekr\u00e4ftiger. Wenn man sich den Code der Nachkommen ansieht, macht das Wort <code>override</code> sofort klar, dass diese Operation in einem der Vorfahren abstrakt oder virtuell ist, ohne dass man sich den Code aller Vorfahren ansehen muss.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#vorfahre-von-leddisplay","title":"Vorfahre von LedDisplay","text":"<p>Die Basisklasse unserer <code>LedDisplay</code> Klasse ist gebunden, ihr Code kann nicht ge\u00e4ndert werden, daher k\u00f6nnen wir sie nicht von <code>EquipmentBase</code>ableiten. Wir k\u00f6nnen die Funktion <code>GetAge</code> nicht l\u00f6schen, diese Code-Duplizierung bleibt hier erhalten (aber nur f\u00fcr <code>LedDisplay</code>, die nur eine Klasse unter vielen ist!).</p> <p>Note</p> <p>Mit ein wenig zus\u00e4tzlicher Arbeit k\u00f6nnten wir diese Doppelung beseitigen. Dazu m\u00fcsste eine statische Hilfsfunktion in eine der Klassen aufgenommen werden (z. B. <code>EquipmentBase</code>) , die das Produktionsjahr ermittelt und das Alter zur\u00fcckgibt.  <code>EquipmentBase.GetAge</code> und <code>LedDisplay.GetAge</code> w\u00fcrden diese Hilfsfunktion f\u00fcr ihre Ausgabe verwenden.</p> <p>In unserer Klasse <code>LedDisplay</code> m\u00fcssen wir noch <code>GetDescription</code> schreiben:</p> LedDisplay.cs<pre><code>public string GetDescription()\n{\n    return \"Led Display\";\n}\n</code></pre> <p>Beachten wir, dass das Schl\u00fcsselwort <code>override</code> hier NICHT angegeben ist. Wenn eine Schnittstellenfunktion implementiert ist, muss/darf <code>override</code>nicht ausgeschrieben werden.</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#getdescription-verwenden","title":"GetDescription verwenden","text":"<p>\u00c4ndern wir die Operation <code>EquipmentInventory.ListAll</code>, um auch die Beschreibung der Elemente in die Ausgabe zu schreiben:</p> EquipmentInventory.cs<pre><code>public void ListAll()\n{\n    foreach (IEquipment eq in equipment)\n    {\n        Console.WriteLine(\"$Description: {eq.GetDescription()}\\t\" +\n            $\"Alter: {eq.GetAge()}\\tValue: {eq.GetPrice()}\");\n    }\n}\n</code></pre> <p>Dies f\u00fchrt zu einer informativeren Ausgabe, wenn die Anwendung ausgef\u00fchrt wird:</p> <p></p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#duplizierung-von-konstruktorcode","title":"Duplizierung von Konstruktorcode","text":"<p>Ein Blick auf unseren Code zeigt, dass es eine weitere Duplikation gibt. Alle Nachfahren von <code>EquipmentBase</code> (<code>HardDisk</code>, <code>SoundCard</code>) haben diese beiden Zeilen in ihrem Konstruktor:</p> <pre><code> this.yearOfCreation = yearOfCreation;\n this.newPrice = newPrice;\n</code></pre> <p>Wenn wir nachdenken, werden diese <code>yearOfCreation</code> und <code>newPrice</code> Mitglieder im Vorfahren definiert, also sollte es seine Verantwortung sein, sie zu initialisieren. F\u00fcgen wir einen entsprechenden Konstruktor in <code>EquipmentBase</code>hinzu:</p> EquipmentBase.cs<pre><code>public EquipmentBase(int Erstellungsjahr, int neuerPreis)\n{\n    this.yearOfCreation = yearOfCreation;\n    this.newPrice = newPrice;\n}\n</code></pre> <p>Entfernen wir die Initialisierung der beiden Mitglieder aus dem Konstruktor der Nachfahren <code>HardDisk</code> und <code>SoundCard</code> und rufen wir stattdessen den Konstruktor des Vorfahren auf, indem wir auf das Schl\u00fcsselwort <code>base</code> verweisen:</p> HardDisk.cs<pre><code>public HardDisk(int yearOfCreation, int newPrice, int capacityGB)\n    : base(yearOfCreation, newPrice)\n{\n    this.capacityGB = capacityGB;\n}\n</code></pre> SoundCard.cs<pre><code>public SoundCard(int yearOfCreation, int newPrice)\n    : base(yearOfCreation, newPrice)\n{\n}\n</code></pre>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#bewertung","title":"Bewertung","text":"<p>Durch die Verwendung einer Kombination aus Schnittstelle und abstrakter Basisklasse ist es uns gelungen, die L\u00f6sung mit dem geringsten Kompromiss zu entwickeln:</p> <ul> <li><code>IEquipment</code> als Schnittstelle k\u00f6nnen wir alle Arten von Teilen einheitlich behandeln, auch solche, bei denen die Basisklasse gebunden war (mit abstrakter Basisklasse allein h\u00e4tten wir dies nicht erreichen k\u00f6nnen).</li> <li>Durch die Einf\u00fchrung der abstrakten Basisklasse <code>EquipmentBase</code> konnten wir den Code, der in den verschiedenen Komponententypen gemeinsam ist, mit einer Ausnahme in einen gemeinsamen Basisklasse bringen und so Code-Duplikationen vermeiden.</li> <li>Durch die Einf\u00fchrung des abstrakten Vorg\u00e4ngers <code>EquipmentBase</code> k\u00f6nnen wir eine Standardimplementierung f\u00fcr neu eingef\u00fchrte <code>IEquipment</code> Operationen (z.B. <code>GetDescripton</code>) angeben, so dass wir nicht gezwungen sind, diese in jeder <code>IEquipment</code> Implementierungsklasse anzugeben.</li> </ul> <p>Werfen wir abschlie\u00dfend noch einen Blick auf das UML-Klassendiagramm unserer L\u00f6sung:</p> <p></p> <p>C# 11 - Statische Schnittstellen</p> <p>Die neueste Funktion von C# 11 ist die Definition von statischen Schnittstellenmitgliedern, die es Ihnen erm\u00f6glicht, von einer implementierenden Klasse zu verlangen, dass sie Mitglieder hat, die sich nicht auf die Objektinstanz beziehen, sondern die Klasse muss \u00fcber ein bestimmtes statisches Mitglied verf\u00fcgen. Mehr lesen</p>"},{"location":"labor/1-model-es-kod-kapcsolata/index_ger/#hinweis-fakultative-hausaufgabe","title":"Hinweis - fakultative Hausaufgabe","text":"<p>Unsere L\u00f6sung unterst\u00fctzt nicht die Anzeige von komponentenspezifischen Daten (z.B. Kapazit\u00e4t f\u00fcr <code>HardDisk</code> ) w\u00e4hrend der Auflistung. Zu diesem Zweck sollte das Schreiben von Komponentendaten in eine formatierte Zeichenkette von der Klasse <code>EqipmentInventory</code> in die Komponentenklassen verlagert werden, und zwar nach den folgenden Grunds\u00e4tzen:</p> <ul> <li>Sie k\u00f6nnen eine <code>GetFormattedString</code> Operation in die <code>IEquipment</code> Schnittstelle einf\u00fchren, die ein Objekt vom Typ <code>string</code> zur\u00fcckgibt. Alternativ kann die Operation <code>System.Object ToString()</code> au\u00dfer Kraft gesetzt werden. In .NET sind alle Typen implizit von <code>System.Object</code>abgeleitet, das \u00fcber eine virtuelle Operation <code>ToString()</code> verf\u00fcgt.</li> <li>In <code>EquipmentBase</code>schreiben Sie die Formatierung der gemensamen Mitglieder (Beschreibung, Preis, Alter) in Strings.</li> <li>Wenn eine Komponente auch typspezifische Daten hat, dann \u00fcberschreibt ihre Klasse die Funktion, die sie in eine Zeichenkette formatiert: Diese Funktion muss zuerst ihren Vorg\u00e4nger aufrufen (mit dem Schl\u00fcsselwort <code>base</code> ), dann ihre eigenen formatierten Daten an sie anh\u00e4ngen und mit dieser Zeichenkette zur\u00fcckkehren.</li> </ul>"},{"location":"labor/2-nyelvi-eszkozok/","title":"2. Nyelvi eszk\u00f6z\u00f6k","text":""},{"location":"labor/2-nyelvi-eszkozok/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat sor\u00e1n a hallgat\u00f3k megismerkednek a legfontosabb modern, a .NET k\u00f6rnyezetben is rendelkez\u00e9sre \u00e1ll\u00f3 nyelvi eszk\u00f6z\u00f6kkel. Felt\u00e9telezz\u00fck, hogy a hallgat\u00f3 a kor\u00e1bbi tanulm\u00e1nyai sor\u00e1n elsaj\u00e1t\u00edtotta az objektum-orient\u00e1lt szeml\u00e9letm\u00f3dot, \u00e9s tiszt\u00e1ban van az objektum-orient\u00e1lt alapfogalmakkal. Jelen gyakorlat sor\u00e1n azokra a .NET-es nyelvi elemekre koncentr\u00e1lunk, amelyek t\u00falmutatnak az \u00e1ltal\u00e1nos objektum-orient\u00e1lt szeml\u00e9leten, ugyanakkor nagyban hozz\u00e1j\u00e1rulnak a j\u00f3l \u00e1tl\u00e1that\u00f3 \u00e9s k\u00f6nnyen karbantarthat\u00f3 k\u00f3d elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezek a k\u00f6vetkez\u0151k:</p> <ul> <li>Tulajdons\u00e1g (property)</li> <li>Deleg\u00e1t (delegate, met\u00f3dusreferencia)</li> <li>Esem\u00e9ny (event)</li> <li>Attrib\u00fatum (attribute)</li> <li>Lambda kifejez\u00e9s (lambda expression)</li> <li>Generikus t\u00edpus (generic type)</li> <li>N\u00e9h\u00e1ny tov\u00e1bbi nyelvi konstrukci\u00f3</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: a 2. el\u0151ad\u00e1s \u00e9s a 3. el\u0151ad\u00e1s eleje \u2013 Nyelvi eszk\u00f6z\u00f6k.</p>"},{"location":"labor/2-nyelvi-eszkozok/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Gyakorlat Linuxon vagy macOS alatt</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de az elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is m\u00e1s fejleszt\u0151eszk\u00f6z\u00f6kkel (pl. VS Code, Rider, Visual Studio for Mac), vagy ak\u00e1r egy sz\u00f6vegszerkeszt\u0151vel \u00e9s CLI (parancssori) eszk\u00f6z\u00f6kkel. Ezt az teszi lehet\u0151v\u00e9, hogy a p\u00e9ld\u00e1k egy egyszer\u0171 Console alkalmaz\u00e1s kontextus\u00e1ban ker\u00fclnek ismertet\u00e9sre (nincsenek Windows specifikus elemek),  a .NET SDK pedig t\u00e1mogatott Linuxon \u00e9s macOS alatt. Hello World Linuxon</p>"},{"location":"labor/2-nyelvi-eszkozok/#bevezeto","title":"Bevezet\u0151","text":"<p>Kitekint\u0151 r\u00e9szek</p> <p>Jelen \u00fatmutat\u00f3 t\u00f6bb helyen is b\u0151v\u00edtett ismeretanyagot, illetve extra magyar\u00e1zatot ad meg jelen megjegyz\u00e9ssel egyez\u0151 sz\u00ednnel keretezett \u00e9s ugyanilyen ikonnal ell\u00e1tott form\u00e1ban. Ezek hasznos kitekint\u00e9sek, de nem k\u00e9pezik az alap tananyag r\u00e9sz\u00e9t.</p>"},{"location":"labor/2-nyelvi-eszkozok/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-nyelvieszkozok-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/2-nyelvi-eszkozok/#0-feladat-var-kulcsszo-implicit-tipusu-lokalis-valtozok-implicitly-typed-local-variables","title":"0. Feladat - var kulcssz\u00f3 - Implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3k (implicitly typed local variables)","text":"<p>Egy egyszer\u0171, bemeleg\u00edt\u0151 feladattal kezd\u00fcnk. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l.</p> <ol> <li>Hozzunk l\u00e9tre egy \u00faj C# konzolos alkalmaz\u00e1st. .NET alap\u00fat (vagyis ne .NET Framework-\u00f6set):<ul> <li>Erre az els\u0151 gyakorlat alkalm\u00e1val l\u00e1ttunk p\u00e9ld\u00e1t, le\u00edr\u00e1sa annak \u00fatmutat\u00f3j\u00e1ban szerepel.</li> <li>A \"Do not use top level statements\" jel\u00f6l\u0151n\u00e9gyzetet pip\u00e1ljuk be a projekt l\u00e9trehoz\u00e1s sor\u00e1n.</li> </ul> </li> <li>Adjunk hozz\u00e1 egy \u00faj oszt\u00e1lyt az alkalmaz\u00e1sunkhoz <code>Person</code> n\u00e9ven.     (\u00daj oszt\u00e1ly hozz\u00e1ad\u00e1s\u00e1hoz a Solution Explorerben kattintsunk jobb eg\u00e9rgombbal a projekt f\u00e1jlra \u00e9s v\u00e1lasszuk az Add / Class men\u00fcpontot. Az el\u0151ugr\u00f3 ablakban a l\u00e9trehozand\u00f3 f\u00e1jl nev\u00e9t m\u00f3dos\u00edtsuk <code>Person.cs</code>-re, majd nyomjuk meg az Add gombot.)</li> <li> <p>Tegy\u00fck az oszt\u00e1lyt publikuss\u00e1. Ehhez az oszt\u00e1ly neve el\u00e9 be kell \u00edrni a <code>public</code> kulcssz\u00f3t. Erre a m\u00f3dos\u00edt\u00e1sra itt val\u00f3j\u00e1ban m\u00e9g nem volna sz\u00fcks\u00e9g, ugyanakkor egy k\u00e9s\u0151bbi feladat m\u00e1r egy publikus oszt\u00e1lyt fog ig\u00e9nyelni.</p> <pre><code>public class Person\n{\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj oszt\u00e1lyunkat.</p> <pre><code>static void Main(string[] args)\n{\n    Person p = new Person();\n}\n</code></pre> </li> <li> <p>A lok\u00e1lis v\u00e1ltoz\u00f3k t\u00edpus\u00e1nak explicit megad\u00e1sa helyett haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t is:</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n}\n</code></pre> <p>Ezt implicitly typed local variables-nek, magyarul implicit t\u00edpus\u00fa lok\u00e1lis v\u00e1ltoz\u00f3-nak nevezz\u00fck. Ilyenkor a ford\u00edt\u00f3 a kontextusb\u00f3l, az egyenl\u0151s\u00e9gjel jobb oldal\u00e1b\u00f3l megpr\u00f3b\u00e1lja kital\u00e1lni a v\u00e1ltoz\u00f3 t\u00edpus\u00e1t, fenti esetben ez egy <code>Person</code> lesz. Fontos, hogy ett\u0151l a nyelv m\u00e9g statikusan tipusos marad (teh\u00e1t nem \u00fagy m\u0171k\u00f6dik mint a JavaScript-es <code>var</code> kulcssz\u00f3), mert a <code>p</code> v\u00e1ltoz\u00f3 t\u00edpusa a k\u00e9s\u0151bbiekben nem v\u00e1ltozhat meg, ez csak egy egyszer\u0171 szintaktikai \u00e9des\u00edt\u0151szer annek \u00e9rdek\u00e9ben, hogy t\u00f6m\u00f6rebben tudjunk lok\u00e1lis v\u00e1ltoz\u00f3kat defini\u00e1lni (ne kelljen a t\u00edpust \"dupl\u00e1n\", az <code>=</code> bal \u00e9s jobb oldal\u00e1n is megadni).</p> <p>Target-typed <code>new</code> expressions</p> <p>Egy m\u00e1sik megk\u00f6zel\u00edt\u00e9s lehet a a C# 9-ben megjelent Target-typed <code>new</code> expressions, ahol a new oper\u00e1tor eset\u00e9n hagyhat\u00f3 el a t\u00edpus, ha az a ford\u00edt\u00f3 \u00e1ltal kital\u00e1lhat\u00f3 a kontextusb\u00f3l (pl.: \u00e9rt\u00e9kad\u00e1s bal oldala, param\u00e9ter t\u00edpusa stb.). A fenti <code>Person</code> konstruktorunk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9zne ki:</p> <pre><code>Person p = new();\n</code></pre> <p>Ennek a megk\u00f6zel\u00edt\u00e9snek az el\u0151nye a <code>var</code>-ral szemben, hogy tagv\u00e1ltoz\u00f3k eset\u00e9ben is alkalmazhat\u00f3.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#1-feladat-tulajdonsag-property","title":"1. Feladat \u2013 Tulajdons\u00e1g (property)","text":"<p>A tulajdons\u00e1gok seg\u00edts\u00e9g\u00e9vel tipikusan (de mint l\u00e1tni fogjuk, nem kiz\u00e1r\u00f3lagosan) oszt\u00e1lyok tagv\u00e1ltoz\u00f3ihoz f\u00e9rhet\u00fcnk hozz\u00e1 szintaktika tekintet\u00e9ben hasonl\u00f3 m\u00f3don, mintha egy hagyom\u00e1nyos tagv\u00e1ltoz\u00f3t \u00e9rn\u00e9nk el. A hozz\u00e1f\u00e9r\u00e9s sor\u00e1n azonban lehet\u0151s\u00e9g\u00fcnk van arra, hogy az egyszer\u0171 \u00e9rt\u00e9k lek\u00e9rdez\u00e9s vagy be\u00e1ll\u00edt\u00e1s helyett met\u00f3dusszer\u0171en implement\u00e1ljuk a v\u00e1ltoz\u00f3 el\u00e9r\u00e9s\u00e9nek a m\u00f3dj\u00e1t, s\u0151t k\u00fcl\u00f6n k\u00fcl\u00f6n is meghat\u00e1rozhatjuk a lek\u00e9rdez\u00e9s \u00e9s a be\u00e1ll\u00edt\u00e1s l\u00e1that\u00f3s\u00e1g\u00e1t.</p>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsag-szintaktikaja","title":"Tulajdons\u00e1g szintaktik\u00e1ja","text":"<p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban egy <code>Person</code> nev\u0171 oszt\u00e1lyt fogunk elk\u00e9sz\u00edteni, mely egy szem\u00e9lyt reprezent\u00e1l. K\u00e9t tagv\u00e1ltoz\u00f3ja van, <code>name</code> \u00e9s <code>age</code>. A tagv\u00e1ltoz\u00f3khoz k\u00f6zvetlen\u00fcl nem f\u00e9rhet\u00fcnk hozz\u00e1 (mivel priv\u00e1tok), csak a <code>Name</code>, illetve <code>Age</code> publikus tulajdons\u00e1gokon kereszt\u00fcl kezelhetj\u00fck \u0151ket. A p\u00e9lda j\u00f3l szeml\u00e9lteti, hogy a .NET-es tulajdons\u00e1gok egy\u00e9rtelm\u0171en megfelelnek a C++-b\u00f3l \u00e9s Java-b\u00f3l m\u00e1r j\u00f3l ismert <code>SetX(\u2026)</code> illetve <code>GetX()</code> t\u00edpus\u00fa met\u00f3dusoknak, csak itt ez a megold\u00e1s egys\u00e9gbez\u00e1rtabb m\u00f3don nyelvi szinten t\u00e1mogatott.</p> <ol> <li> <p>Az el\u0151z\u0151 feladatban bevezetett <code>Person</code> oszt\u00e1lyon bel\u00fcl hozzunk l\u00e9tre egy <code>int</code> t\u00edpus\u00fa <code>age</code> nev\u0171 tagv\u00e1ltoz\u00f3t \u00e9s egy ezt el\u00e9rhet\u0151v\u00e9 tev\u0151 <code>Age</code> tulajdons\u00e1got.</p> <pre><code>public class Person\n{\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set { age = value; }\n    }\n}\n</code></pre> <p>Visual Studio snippetek</p> <p>A laboron ugyan a gyakorl\u00e1s kedv\u00e9\u00e9rt k\u00e9zzel g\u00e9pelt\u00fck be a teljes tulajdons\u00e1got, de a Visual Studio-ban a gyakran el\u0151fordul\u00f3 k\u00f3dr\u00e9szletek l\u00e9trehoz\u00e1s\u00e1ra \u00fagynevezett code snippetek \u00e1llnak rendelkez\u00e9s\u00fcnkre, melyekkel a gyakori nyelvi konstrukci\u00f3kat tudjuk sablonszer\u0171en felhaszn\u00e1lni. A fenti property k\u00f3dr\u00e9szletet a <code>propfull</code> snippettel tudjuk el\u0151csalni. G\u00e9pelj\u00fck be a snippet nev\u00e9t (<code>propfull</code>), majd addig nyomjuk a Tab billenty\u0171t am\u00edg a snippet nem aktiv\u00e1l\u00f3dik (tipikusan 2x).</p> <p>Eml\u00edt\u00e9sre m\u00e9lt\u00f3 egy\u00e9b snippetek a teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl:</p> <ul> <li><code>ctor</code>: konstruktor</li> <li><code>for</code>: for ciklus</li> <li><code>foreach</code>: foreach ciklus</li> <li><code>prop</code>: auto property (l\u00e1sd k\u00e9s\u0151bb)</li> <li><code>switch</code>: switch utas\u00edt\u00e1s</li> <li><code>cw</code>: Console.WriteLine</li> </ul> <p>Ilyen snippeteket egy\u00e9bk\u00e9nt mi is k\u00e9sz\u00edthet\u00fcnk.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9t, hogy kipr\u00f3b\u00e1lhassuk az \u00faj tulajdons\u00e1gunkat.</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n    p.Age = 17;\n    p.Age++;\n    Console.WriteLine(p.Age);\n}\n</code></pre> </li> <li> <p>Futtassuk a programunkat (F5)</p> <p>L\u00e1thatjuk, hogy a tulajdons\u00e1g a tagv\u00e1ltoz\u00f3khoz hasonl\u00f3an haszn\u00e1lhat\u00f3. A tulajdons\u00e1g lek\u00e9rdez\u00e9se eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>get</code> r\u00e9sz fog lefutni, \u00e9s a tulajdons\u00e1g \u00e9rt\u00e9ke a return \u00e1ltal visszaadott \u00e9rt\u00e9k lesz. A tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sa eset\u00e9n a tulajdons\u00e1gban defini\u00e1lt <code>set</code> r\u00e9sz fog lefutni, \u00e9s a speci\u00e1lis <code>value</code> v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke ebben a szakaszban megfelel a tulajdons\u00e1gnak \u00e9rt\u00e9k\u00fcl adott kifejez\u00e9ssel.</p> <p>Figyelj\u00fck meg a fenti megold\u00e1sban azt, hogy milyen eleg\u00e1nsan tudjuk egy \u00e9vvel megemelni az ember \u00e9letkor\u00e1t. Java, vagy C++ k\u00f3dban egy hasonl\u00f3 m\u0171veletet a <code>p.setAge(p.getAge() + 1)</code> form\u00e1ban \u00edrhattunk volna le, amely jelent\u0151sen k\u00f6r\u00fclm\u00e9nyesebb \u00e9s nehezen olvashat\u00f3bb szintaktika a fentin\u00e9l. A tulajdons\u00e1gok haszn\u00e1lat\u00e1nak legf\u0151bb hozad\u00e9ka, hogy k\u00f3dunk szintaktikailag tiszt\u00e1bb lesz, az \u00e9rt\u00e9kad\u00e1sok/lek\u00e9rdez\u00e9sek pedig az esetek t\u00f6bbs\u00e9g\u00e9ben j\u00f3l elv\u00e1lnak a t\u00e9nyleges f\u00fcggv\u00e9nyh\u00edv\u00e1sokt\u00f3l.</p> </li> <li> <p>Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a programunk val\u00f3ban elv\u00e9gzi a <code>get</code> \u00e9s <code>set</code> r\u00e9szek h\u00edv\u00e1s\u00e1t. Ehhez helyezz\u00fcnk t\u00f6r\u00e9spontokat (breakpoint) a getter \u00e9s setter blokkok belsej\u00e9be a k\u00f3dszerkeszt\u0151 bal sz\u00e9l\u00e9n l\u00e1that\u00f3 sz\u00fcrke s\u00e1vra kattintva.</p> </li> <li> <p>Futtassuk a programot l\u00e9p\u00e9sr\u0151l l\u00e9p\u00e9sre. Ehhez a programot F5 helyett az F11 billenty\u0171vel ind\u00edtsuk, majd az F11 tov\u00e1bbi megnyom\u00e1saival engedj\u00fck sorr\u00f3l sorra a v\u00e9grehajt\u00e1st.</p> <p>L\u00e1thatjuk, hogy a programunk val\u00f3ban minden egyes alkalommal megh\u00edvja a gettert, amikor \u00e9rt\u00e9klek\u00e9rdez\u00e9s, illetve a settert, amikor \u00e9rt\u00e9kbe\u00e1ll\u00edt\u00e1s t\u00f6rt\u00e9nik.</p> </li> <li> <p>A setter f\u00fcggv\u00e9nyek egyik fontos funkci\u00f3ja, hogy lehet\u0151s\u00e9get k\u00edn\u00e1lnak az \u00e9rt\u00e9kvalid\u00e1ci\u00f3ra. Eg\u00e9sz\u00edts\u00fck ki ennek szellem\u00e9ben az <code>Age</code> tulajdons\u00e1g setter-\u00e9t.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\n        age = value; \n    }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy m\u00edg az egyszer\u0171 getter \u00e9s setter eset\u00e9ben az \u00e9rt\u00e9klek\u00e9rdez\u00e9st/be\u00e1ll\u00edt\u00e1st egy sorban tartjuk, addig komplexebb t\u00f6rzs eset\u00e9n m\u00e1r t\u00f6bb sorra t\u00f6rdelj\u00fck.</p> </li> <li> <p>Az alkalmaz\u00e1s tesztel\u00e9s\u00e9hez rendelj\u00fcnk hozz\u00e1 negat\u00edv \u00e9rt\u00e9ket az \u00e9letkorhoz a <code>Program</code> oszt\u00e1ly <code>Main</code> f\u00fcggv\u00e9ny\u00e9ben.</p> <pre><code>p.Age = -2;\n</code></pre> </li> <li> <p>Futtassuk a programot, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy az ellen\u0151rz\u00e9s helyesen m\u0171k\u00f6dik, majd h\u00e1r\u00edtsuk el a hib\u00e1t azzal, hogy pozit\u00edvra cser\u00e9lj\u00fck a be\u00e1ll\u00edtott \u00e9letkort.</p> <pre><code>p.Age = 2;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#autoimplementalt-tulajdonsag-auto-implemented-property","title":"Autoimplement\u00e1lt tulajdons\u00e1g (auto-implemented property)","text":"<p>A mindennapi munk\u00e1nk sor\u00e1n tal\u00e1lkozhatunk a tulajdons\u00e1goknak egy sokkal t\u00f6m\u00f6rebb szintaktik\u00e1j\u00e1val is. Ez a szintaktika akkor alkalmazhat\u00f3, ha egy olyan tulajdons\u00e1got szeretn\u00e9nk l\u00e9trehozni, melyben:</p> <ul> <li>nem szeretn\u00e9nk semmilyen kieg\u00e9sz\u00edt\u0151 logik\u00e1val ell\u00e1tni a getter \u00e9s setter met\u00f3dusokat,</li> <li>nincs sz\u00fcks\u00e9g\u00fcnk a priv\u00e1t tagv\u00e1ltoz\u00f3 k\u00f6zvetlen el\u00e9r\u00e9s\u00e9re.</li> </ul> <p>Erre n\u00e9zz\u00fcnk a k\u00f6vetkez\u0151kben p\u00e9ld\u00e1t.</p> <ol> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Person</code> oszt\u00e1lyunkat egy ilyen, \u00fan. \u201eautoimplement\u00e1lt\u201d tulajdons\u00e1ggal (auto-implemented property). K\u00e9sz\u00edts\u00fcnk egy <code>string</code> t\u00edpus\u00fa <code>Name</code> nev\u0171 tulajdons\u00e1got.</p> <pre><code>public string Name { get; set; }\n</code></pre> <p>A szintaktikai k\u00fcl\u00f6nbs\u00e9g a kor\u00e1bbiakhoz k\u00e9pest: a get \u00e9s a set \u00e1gnak sem adtunk implement\u00e1ci\u00f3t (nincsenek kapcsos z\u00e1r\u00f3jelek). Autoimplemet\u00e1lt tulajdons\u00e1g eset\u00e9n a ford\u00edt\u00f3 egy rejtett, k\u00f3db\u00f3l nem el\u00e9rhet\u0151 v\u00e1ltoz\u00f3t gener\u00e1l az oszt\u00e1lyba, mely a tulajdons\u00e1g aktu\u00e1lis \u00e9rt\u00e9k\u00e9nek t\u00e1rol\u00e1s\u00e1ra szolg\u00e1l. Hangs\u00falyozand\u00f3, hogy ez nem a kor\u00e1bban bevezetett <code>name</code> tagv\u00e1ltoz\u00f3t \u00e1ll\u00edtja \u00e9s k\u00e9rdezi le (az ki is t\u00f6r\u00f6lhetn\u00e9nk), hanem egy rejtett, \u00faj v\u00e1ltoz\u00f3n dolgozik!</p> </li> <li> <p>Most ellen\u0151rizz\u00fck a m\u0171k\u00f6d\u00e9s\u00e9t a <code>Main</code> f\u00fcggv\u00e9ny kieg\u00e9sz\u00edt\u00e9s\u00e9vel.</p> <pre><code>static void Main(string[] args)\n{\n    // ...\n    p.Name = \"Luke\";\n    // ...\n    Console.WriteLine(p.Name);\n}\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#alapertelmezett-ertek-default-value","title":"Alap\u00e9rtelmezett \u00e9rt\u00e9k (default value)","text":"<p>Az autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9ben megadhat\u00f3 a kezdeti \u00e9rt\u00e9k\u00fck is a deklar\u00e1ci\u00f3 sor\u00e1n.</p> <ol> <li> <p>Adjunk kiindul\u00f3 \u00e9rt\u00e9ket a <code>Name</code> tulajdons\u00e1gnak.</p> <pre><code>public string Name { get; set; } = \"anonymous\";\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsagok-lathatosaga","title":"Tulajdons\u00e1gok l\u00e1that\u00f3s\u00e1ga","text":"<p>A tulajdons\u00e1gok nagy el\u0151nye a teljesen szabad implement\u00e1ci\u00f3 mellett, hogy a getter \u00e9s a setter l\u00e1that\u00f3s\u00e1g\u00e1t k\u00fcl\u00f6n k\u00fcl\u00f6n is lehet \u00e1ll\u00edtani.</p> <ol> <li> <p>\u00c1ll\u00edtsuk a <code>Name</code> tulajdons\u00e1g setter\u00e9nek a l\u00e1that\u00f3s\u00e1g\u00e1t priv\u00e1tra.</p> <pre><code>public string Name { get; private set; }\n</code></pre> <p>Ilyenkor a <code>Program</code> oszt\u00e1lyban ford\u00edt\u00e1si hib\u00e1t kapunk a <code>p.Name = \"Luke\";</code> utas\u00edt\u00e1sra. Az alapvet\u0151 szab\u00e1ly az, hogy a getter \u00e9s a setter \u00f6r\u00f6kli a property l\u00e1that\u00f3s\u00e1g\u00e1t, mely tov\u00e1bb sz\u0171k\u00edthet\u0151, de nem laz\u00edthat\u00f3. A l\u00e1that\u00f3s\u00e1g szab\u00e1lyoz\u00e1sa autoimplement\u00e1lt \u00e9s nem autoimplement\u00e1lt tulajdons\u00e1gok eset\u00e9n is haszn\u00e1lhat\u00f3.</p> </li> <li> <p>\u00c1ll\u00edtsuk vissza a l\u00e1that\u00f3s\u00e1got (t\u00e1vol\u00edtsuk el a <code>private</code> kulcssz\u00f3t a <code>Name</code> tulajdons\u00e1g settere el\u0151l), hogy megsz\u0171nj\u00f6n a ford\u00edt\u00e1si hiba.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#csak-olvashato-tulajdonsag-readonly-property","title":"Csak olvashat\u00f3 tulajdons\u00e1g (readonly property)","text":"<p>A setter elhagyhat\u00f3, \u00edgy egy olyan tulajdons\u00e1got kapunk, mely csak olvashat\u00f3. Autoimplement\u00e1lt tulajdons\u00e1g eset\u00e9n ennek is adhat\u00f3 kezd\u0151\u00e9rt\u00e9k: erre csak konstruktorban, vagy alap\u00e9rtelmezett \u00e9rt\u00e9kkel val\u00f3 ell\u00e1t\u00e1ssal (l\u00e1sd fent) van lehet\u0151s\u00e9g, ellent\u00e9tben a priv\u00e1t setterrel rendelkez\u0151 tulajdons\u00e1gokkal, melyek settere b\u00e1rmely, az oszt\u00e1lyban tal\u00e1lhat\u00f3 tagf\u00fcggv\u00e9nyb\u0151l h\u00edvhat\u00f3.</p> <p>Csak olvashat\u00f3 tulajdons\u00e1g defini\u00e1l\u00e1s\u00e1t a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletek illusztr\u00e1lj\u00e1k (a k\u00f3dunkba NE vezess\u00fck be):</p> <p>a) Autoimplement\u00e1lt eset</p> <pre><code>public string Name { get; }\n</code></pre> <p>b) Nem autoimplement\u00e1lt eset</p> <pre><code>private string name;\n...\npublic string Name { get {return name; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#szamitott-ertek-calculated-value","title":"Sz\u00e1m\u00edtott \u00e9rt\u00e9k (calculated value)","text":"<p>A csak getterrel rendelkez\u0151 tulajdons\u00e1goknak van m\u00e9g egy haszn\u00e1lati m\u00f3dja. Valamilyen sz\u00e1m\u00edtott \u00e9rt\u00e9k meghat\u00e1roz\u00e1s\u00e1ra is haszn\u00e1lhat\u00f3, mely mindig kisz\u00e1mol egy megadott logika alapj\u00e1n egy \u00e9rt\u00e9ket, de a \"csak olvashat\u00f3 tulajdons\u00e1g\"-gal szemben nincs m\u00f6g\u00f6tte k\u00f6zvetlen\u00fcl a tulajdons\u00e1ghoz tartoz\u00f3 adattag. Ezt a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet illusztr\u00e1lja (a k\u00f3dunkba NE vezess\u00fck be):</p> <pre><code>public int AgeInDogYear { get { return Age * 7; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#2-feladat-delegat-delegate-metodusreferencia","title":"2. Feladat \u2013 Deleg\u00e1t (delegate, met\u00f3dusreferencia)","text":"<p>Forduljon a k\u00f3d!</p> <p>A tov\u00e1bbi feladatok \u00e9p\u00edteni fognak az el\u0151z\u0151 feladatok v\u00e9geredm\u00e9nyeire. Ha programod nem fordul le, vagy nem megfelel\u0151en m\u0171k\u00f6dik, jelezd ezt a gyakorlatvezet\u0151dnek a feladatok v\u00e9g\u00e9n, \u00e9s seg\u00edt elh\u00e1r\u00edtani a hib\u00e1t.</p> <p>A deleg\u00e1tok t\u00edpusos met\u00f3dusreferenci\u00e1kat jelentenek .NET-ben, a C/C++ f\u00fcggv\u00e9nypointerek modern megfelel\u0151i. Egy deleg\u00e1t seg\u00edts\u00e9g\u00e9vel egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t defini\u00e1lhatunk, amellyel met\u00f3dusokra tudunk mutatni/hivatkozni. Nem ak\u00e1rmilyenre, hanem - a C++ f\u00fcggv\u00e9nypointerekkel anal\u00f3g m\u00f3don - olyanokra, amely t\u00edpusa (param\u00e9terlist\u00e1ja \u00e9s visszat\u00e9r\u00e9si \u00e9rt\u00e9ke) megfelel a deleg\u00e1t t\u00edpus\u00e1nak. A deleg\u00e1t v\u00e1ltoz\u00f3 \"megh\u00edv\u00e1s\u00e1val\" az \u00e9rt\u00e9k\u00fcl adott (beregisztr\u00e1lt) met\u00f3dus automatikusan megh\u00edv\u00f3dik. A deleg\u00e1tok haszn\u00e1lat\u00e1nak egyik el\u0151nye az, hogy fut\u00e1si id\u0151ben d\u00f6nthetj\u00fck el, hogy t\u00f6bb met\u00f3dus k\u00f6z\u00fcl \u00e9ppen melyiket szeretn\u00e9nk megh\u00edvni.</p> <p>N\u00e9h\u00e1ny p\u00e9lda deleg\u00e1tok haszn\u00e1lat\u00e1ra:</p> <ul> <li>egy univerz\u00e1lis sorrendez\u0151 f\u00fcggv\u00e9nynek  param\u00e9terk\u00e9nt az elemek \u00f6sszehasonl\u00edt\u00e1s\u00e1t v\u00e9gz\u0151 f\u00fcggv\u00e9ny \u00e1tad\u00e1sa,</li> <li>egy \u00e1ltal\u00e1nos gy\u0171jtem\u00e9nyen univerz\u00e1lis sz\u0171r\u00e9si logika megval\u00f3s\u00edt\u00e1sa, melynek param\u00e9terben egy deleg\u00e1t form\u00e1j\u00e1ban adjuk \u00e1t azt a f\u00fcggv\u00e9nyt, amely eld\u00f6nti, hogy egy elemet bele kell-e venni a sz\u0171rt list\u00e1ba,</li> <li>a publish-subscribe minta megval\u00f3s\u00edt\u00e1sa, amikor bizonyos objektumok m\u00e1s objektumokat \u00e9rtes\u00edtenek bizonyos magukkal kapcsolatos esem\u00e9nyek bek\u00f6vetkez\u00e9s\u00e9r\u0151l.</li> </ul> <p>A k\u00f6vetkez\u0151 p\u00e9ld\u00e1nkban lehet\u0151v\u00e9 tessz\u00fck, hogy a kor\u00e1bban l\u00e9trehozott <code>Person</code> oszt\u00e1ly objektumai szabadon \u00e9rtes\u00edthess\u00e9k m\u00e1s oszt\u00e1lyok objektumait arr\u00f3l, ha egy szem\u00e9ly \u00e9letkora megv\u00e1ltozott. Ennek \u00e9rdek\u00e9ben bevezet\u00fcnk egy deleg\u00e1t t\u00edpust (<code>AgeChangingDelegate</code>), mely param\u00e9terlist\u00e1j\u00e1ban \u00e1t tudja adni az ember\u00fcnk \u00e9letkor\u00e1nak aktu\u00e1lis, illetve \u00faj \u00e9rt\u00e9k\u00e9t. Ezt k\u00f6vet\u0151en l\u00e9trehozunk egy publikus <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban, mely lehet\u0151v\u00e9 teszi, hogy egy k\u00fcls\u0151 f\u00e9l megadhassa azt a f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl az adott <code>Person</code> p\u00e9ld\u00e1ny v\u00e1ltoz\u00e1sair\u00f3l \u00e9rtes\u00edt\u00e9st k\u00e9r.</p> <ol> <li> <p>Hozzunk l\u00e9tre egy \u00faj deleg\u00e1t t\u00edpust, mely <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171, \u00e9s k\u00e9t darab <code>int</code> param\u00e9tert elv\u00e1r\u00f3 f\u00fcggv\u00e9nyre tud hivatkozni. Figyelj\u00fcnk r\u00e1, hogy az \u00faj t\u00edpust a <code>Person</code> oszt\u00e1ly el\u0151tt, k\u00f6zvetlen\u00fcl a n\u00e9vt\u00e9r scope-j\u00e1ban defini\u00e1ljuk!</p> <pre><code>namespace PropertyDemo\n{\n    public delegate void AgeChangingDelegate(int oldAge, int newAge);\n\n    public class Person\n    {\n        // ...\n</code></pre> <p>Az <code>AgeChangingDelegate</code> egy t\u00edpus (figyelj\u00fck a VS sz\u00ednez\u00e9s\u00e9t is), mely b\u00e1rhol szerepelhet, ahol t\u00edpus \u00e1llhat (pl. lehet l\u00e9trehozni ez alapj\u00e1n tagv\u00e1ltoz\u00f3t, lok\u00e1lis v\u00e1ltoz\u00f3t, f\u00fcggv\u00e9ny param\u00e9tert stb.).</p> </li> <li> <p>Tegy\u00fck lehet\u0151v\u00e9, hogy a <code>Person</code> objektumai r\u00e1mutathassanak tetsz\u0151leges, a fenti szignat\u00far\u00e1nak megfelel\u0151 f\u00fcggv\u00e9nyre. Ehhez hozzunk l\u00e9tre egy <code>AgeChangingDelegate</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3t a <code>Person</code> oszt\u00e1lyban!</p> <pre><code>public class Person\n{\n    public AgeChangingDelegate AgeChanging;\n</code></pre> <p>Ez \u00edgy most mennyire objektumorient\u00e1lt?</p> <p>A publikus tagv\u00e1ltoz\u00f3k\u00e9nt l\u00e9trehozott met\u00f3dusreferencia val\u00f3j\u00e1ban (egyel\u0151re) s\u00e9rti az objektumorint\u00e1lt egys\u00e9gbez\u00e1r\u00e1si/inform\u00e1ci\u00f3rejt\u00e9si elveket. Erre k\u00e9s\u0151bb visszat\u00e9r\u00fcnk m\u00e9g.</p> </li> <li> <p>H\u00edvjuk meg a f\u00fcggv\u00e9nyt minden alkalommal, amikor az ember\u00fcnk kora megv\u00e1ltozik. Ehhez eg\u00e9sz\u00edts\u00fck ki az <code>Age</code> tulajdons\u00e1g setter\u00e9t a k\u00f6vetkez\u0151kkel.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"\u00c9rv\u00e9nytelen \u00e9letkor!\");\n        if (AgeChanging != null)\n            AgeChanging(age, value);\n        age = value; \n    }\n}\n</code></pre> <p>A  fenti k\u00f3dr\u00e9szlet sz\u00e1mos fontos szab\u00e1lyt demonstr\u00e1l:</p> <ul> <li>A valid\u00e1ci\u00f3s logika \u00e1ltal\u00e1ban megel\u0151zi az \u00e9rtes\u00edt\u00e9si logik\u00e1t.</li> <li>Az \u00e9rtes\u00edt\u00e9si logika jelleg\u00e9t\u0151l f\u00fcgg, hogy az \u00e9rt\u00e9kad\u00e1s el\u0151tt, vagy ut\u00e1n futtatjuk le (ebben az esetben, mivel a \"changing\" sz\u00f3 egy folyamatban l\u00e9v\u0151 dologra utal, az \u00e9rtes\u00edt\u00e9s megel\u0151zi az \u00e9rt\u00e9kad\u00e1st, a bek\u00f6vetkez\u00e9st m\u00falt id\u0151 jelezni: \"changed\")</li> <li>Fel kell k\u00e9sz\u00fcln\u00fcnk r\u00e1, hogy a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3hoz m\u00e9g senki nem rendelt \u00e9rt\u00e9ket (nincs egy subscriber/el\u0151fizet\u0151 sem). Ilyen esetekben a megh\u00edv\u00e1suk kiv\u00e9telt okozna, ez\u00e9rt megh\u00edv\u00e1s el\u0151tt mindig ellen\u0151rizni kell, hogy a tagv\u00e1ltoz\u00f3 \u00e9rt\u00e9ke <code>null</code>-e.</li> <li>Az esem\u00e9ny els\u00fct\u00e9sekor a <code>null</code> vizsg\u00e1latot \u00e9s az esem\u00e9ny els\u00fct\u00e9st eleg\u00e1nsabb, t\u00f6m\u00f6rebb, \u00e9s sz\u00e1lbiztosabb form\u00e1ban is meg tudjuk tenni a \"<code>?.</code>\" null-conditional oper\u00e1torral (C# 6-t\u00f3l):</li> </ul> <pre><code>if (AgeChanging != null)\n    AgeChanging(age, value);\n</code></pre> <p>helyett</p> <pre><code>AgeChanging?.Invoke(age, value);\n</code></pre> <p>Ez csak akkor s\u00fcti el az esem\u00e9nyt, ha nem <code>null</code>, egy\u00e9bk\u00e9nt semmit nem csin\u00e1l.</p> </li> <li> <p>Ha szigor\u00faan n\u00e9zz\u00fck, akkor csak akkor kellene els\u00fctni az esem\u00e9nyt, ha a kor val\u00f3ban v\u00e1ltozik is, vagyis a property set \u00e1g\u00e1ban meg kellene vizsg\u00e1lni, az \u00faj \u00e9rt\u00e9k egyezik-e a r\u00e9givel. Megold\u00e1s lehet, ha a setter els\u0151 sor\u00e1ban azonnal visszat\u00e9r\u00fcnk, ha az \u00faj \u00e9rt\u00e9k egyezik a r\u00e9givel:</p> <pre><code>if (age == value) \n    return;\n\u2026\n</code></pre> </li> <li> <p>K\u00e9sz vagyunk a <code>Person</code> oszt\u00e1ly k\u00f3dj\u00e1val. T\u00e9rj\u00fcnk \u00e1t az el\u0151fizet\u0151re! Ehhez mindenek el\u0151tt a <code>Program</code> oszt\u00e1lyt kell kieg\u00e9sz\u00edten\u00fcnk egy \u00fajabb f\u00fcggv\u00e9nnyel.</p> <pre><code>class Program\n{\n    // ...\n\n    private static void PersonAgeChanging(int oldAge, int newAge)\n    {\n        Console.WriteLine(oldAge + \" =&gt; \" + newAge);\n    }\n}\n</code></pre> <p>Tipp</p> <p>Fokozottan \u00fcgyelj\u00fcnk r\u00e1, hogy az \u00faj f\u00fcggv\u00e9ny a megfelel\u0151 scope-ba ker\u00fclj\u00f6n! M\u00edg a delegate t\u00edpust az oszt\u00e1lyon k\u00edv\u00fclre (de namespace-en bel\u00fclre) helyezt\u00fck el, a f\u00fcggv\u00e9nyt az oszt\u00e1lyon bel\u00fclre helyezz\u00fck!</p> </li> <li> <p>V\u00e9gezet\u00fcl iratkozzunk fel a v\u00e1ltoz\u00e1sk\u00f6vet\u00e9sre a <code>Main</code> f\u00fcggv\u00e9nyben!</p> <pre><code>static void Main(string[] args)\n{\n  Person p = new Person();\n  p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\n  // ...\n</code></pre> </li> <li> <p>Futtassuk a programot!</p> <p>Pl. az <code>AgeChanging?.Invoke(age, value);</code> sorra t\u00f6r\u00e9spontot helyezve, az alkalmaz\u00e1st debuggolva futtatva, \u00e9s a k\u00f3dot l\u00e9ptetve figyelj\u00fck meg, hogy az esem\u00e9ny minden egyes setter fut\u00e1skor, \u00edgy az els\u0151 \u00e9rt\u00e9kad\u00e1skor \u00e9s az inkrement\u00e1l\u00e1s sor\u00e1n egyar\u00e1nt lefut.</p> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> f\u00fcggv\u00e9nyt t\u00f6bbsz\u00f6ri feliratkoz\u00e1ssal (a <code>+=</code> oper\u00e1torral lehet \u00faj feliratkoz\u00f3t felvenni a megl\u00e9v\u0151k mell\u00e9), majd futtassuk a programot.</p> <pre><code>p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += PersonAgeChanging; // T\u00f6m\u00f6rebb szintaktika\n</code></pre> <p>L\u00e1that\u00f3an minden egyes \u00e9rt\u00e9kv\u00e1ltoz\u00e1skor mind a h\u00e1rom beregisztr\u00e1lt/\u201efeliratkozott\u201d f\u00fcggv\u00e9ny lefut. Ez az\u00e9rt lehets\u00e9ges, mert a delegate t\u00edpus\u00fa tagv\u00e1ltoz\u00f3k val\u00f3j\u00e1ban nem csup\u00e1n egy f\u00fcggv\u00e9nyreferenci\u00e1t, hanem egy f\u00fcggv\u00e9nyreferencia-list\u00e1t tartalmaznak (\u00e9s tartanak karban).</p> <p>Figyelj\u00fck meg a fenti harmadik sorban, hogy a f\u00fcggv\u00e9nyreferenci\u00e1kat az el\u0151sz\u00f6r l\u00e1tottn\u00e1l t\u00f6m\u00f6rebb szintaxissal is le\u00edrhatjuk: csak a f\u00fcggv\u00e9ny nev\u00e9t adjuk meg a <code>+=</code> oper\u00e1tor ut\u00e1n, a <code>new AgeChangingDelegate(...)</code> n\u00e9lk\u00fcl. Ett\u0151l f\u00fcggetlen\u00fcl ekkor is egy <code>AgeChangingDelegate</code> objektum fogja becsomagolni a <code>PersonAgeChanging</code> f\u00fcggv\u00e9nyeket a sz\u00ednfalak m\u00f6g\u00f6tt. A  gyakorlatban ezt a t\u00f6m\u00f6rebb szintaktik\u00e1t szoktuk haszn\u00e1lni.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki a leiratkoz\u00e1st is (szabadon v\u00e1lasztott ponton), majd futtassuk a programot.</p> <pre><code>p.AgeChanging -= PersonAgeChanging;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#3-feladat-esemeny-event","title":"3. Feladat \u2013 Esem\u00e9ny (event)","text":"<p>Ahogyan a tulajdons\u00e1gok a getter \u00e9s setter met\u00f3dusoknak, addig a fent l\u00e1tott delegate mechanizmus a Java-b\u00f3l ismert Event Listener-eknek k\u00edn\u00e1lj\u00e1k egy a szintaktika tekintet\u00e9ben letisztultabb alternat\u00edv\u00e1j\u00e1t. A fenti megold\u00e1sunk azonban egyel\u0151re m\u00e9g s\u00falyosan s\u00e9rt p\u00e1r OO elvet (egys\u00e9gbez\u00e1r\u00e1s, inform\u00e1ci\u00f3rejt\u00e9s). Ezt az al\u00e1bbi k\u00e9t p\u00e9ld\u00e1val tudjuk demonstr\u00e1lni.</p> <ol> <li> <p>Az esem\u00e9nyt val\u00f3j\u00e1ban k\u00edv\u00fclr\u0151l (m\u00e1s oszt\u00e1lyok m\u0171veleteib\u0151l) is ki tudjuk v\u00e1ltani. Ez szerencs\u00e9tlen, hiszen \u00edgy az esem\u00e9ny hamis m\u00f3don akkor is kiv\u00e1lthat\u00f3,  r\u00e1ad\u00e1sul val\u00f3tlan adatokkal, amikor az a gyakorlatban be sem k\u00f6vetkezett, becsapva az \u00f6sszes el\u0151fizet\u0151t. Ennek demonstr\u00e1l\u00e1s\u00e1ra sz\u00farjuk be a k\u00f6vetkez\u0151 sort a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re.</p> <pre><code>p.AgeChanging(67, 12);\n</code></pre> <p>Itt a <code>p</code> <code>Person</code> objektum vonatkoz\u00e1s\u00e1ban egy val\u00f3tlan \u00e9letkorv\u00e1ltoz\u00e1s esem\u00e9nyt v\u00e1ltottunk ki, becsapva minden el\u0151fizet\u0151t. A j\u00f3 megold\u00e1s az lenne, ha az esem\u00e9nyt csak a <code>Person</code> oszt\u00e1ly m\u0171veletei tudn\u00e1k kiv\u00e1ltani.</p> </li> <li> <p>Egy m\u00e1sik probl\u00e9ma a k\u00f6vetkez\u0151. B\u00e1r a <code>+=</code> \u00e9s a <code>-=</code> tekintettel vannak a list\u00e1ba feliratkozott t\u00f6bbi f\u00fcggv\u00e9nyre, val\u00f3j\u00e1ban az <code>=</code> oper\u00e1torral b\u00e1rmikor fel\u00fcl\u00edrhatjuk (kit\u00f6r\u00f6lhetj\u00fck) m\u00e1sok feliratkoz\u00e1sait. Pr\u00f3b\u00e1ljuk ki ezt is, a k\u00f6vetkez\u0151 sor besz\u00far\u00e1s\u00e1val (k\u00f6zvetlen\u00fcl a fel \u00e9s leiratkoz\u00e1sok ut\u00e1n sz\u00farjuk be).</p> <pre><code>p.AgeChanging = null;\n</code></pre> </li> <li> <p>L\u00e1ssuk el az <code>event</code> kulcssz\u00f3val az <code>AgeChanging</code> tagv\u00e1ltoz\u00f3t <code>Person.cs</code>-ben!</p> Person.cs<pre><code>public event AgeChangingDelegate AgeChanging;\n</code></pre> <p>Az <code>event</code> kulcssz\u00f3 feladata val\u00f3j\u00e1ban az, hogy a fenti k\u00e9t probl\u00e9m\u00e1t kiz\u00e1rva visszak\u00e9nyszer\u00edtse programunkat az objektumorient\u00e1lt mederbe.</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk meg leford\u00edtani a programot. L\u00e1tni fogjuk, hogy a ford\u00edt\u00f3 a kor\u00e1bbi kih\u00e1g\u00e1sainkat most m\u00e1r ford\u00edt\u00e1si hibak\u00e9nt kezeli.</p> <p></p> </li> <li> <p>T\u00e1vol\u00edtsuk el a h\u00e1rom hib\u00e1s k\u00f3dsort (figyelj\u00fck meg, hogy m\u00e1r az els\u0151 k\u00f6zvetlen \u00e9rt\u00e9kad\u00e1s is hib\u00e1nak min\u0151s\u00fcl), majd ford\u00edtsuk le \u00e9s futtassuk az alkalmaz\u00e1sunkat!</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/#4-feladat-attributumok","title":"4. Feladat \u2013 Attrib\u00fatumok","text":""},{"location":"labor/2-nyelvi-eszkozok/#sorositas-testreszabasa-attributummal","title":"Soros\u00edt\u00e1s testreszab\u00e1sa attrib\u00fatummal","text":"<p>Az attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel deklarat\u00edv m\u00f3don metaadatokkal l\u00e1thatjuk el forr\u00e1sk\u00f3dunkat. Az attrib\u00fatum is tulajdonk\u00e9ppen egy oszt\u00e1ly, melyet hozz\u00e1k\u00f6t\u00fcnk a program egy megadott elem\u00e9hez (t\u00edpushoz, oszt\u00e1lyhoz, interf\u00e9szhez, met\u00f3dushoz stb.). Ezeket a metainform\u00e1ci\u00f3kat a program fut\u00e1sa k\u00f6zben b\u00e1rki (ak\u00e1r mi magunk is) kiolvashatja az \u00fagynevezett reflection mechanizmus seg\u00edts\u00e9g\u00e9vel. Az attrib\u00fatumok a Java annot\u00e1ci\u00f3k .NET-beli megfelel\u0151inek is tekinthet\u0151k.</p> <p>property vs. attrib\u00fatum vs. static</p> <p>Felmer\u00fcl a k\u00e9rd\u00e9s, hogy milyen oszt\u00e1lyjellemz\u0151k ker\u00fcljenek tulajdons\u00e1gokba \u00e9s melyek attrib\u00fatumokba egy oszt\u00e1ly eset\u00e9ben. A tulajdons\u00e1gok mag\u00e1ra az objektum p\u00e9ld\u00e1nyra vonatkoznak, m\u00edg az attrib\u00fatum az azt le\u00edr\u00f3 oszt\u00e1lyra (vagy annak valamilyen tagj\u00e1ra).</p> <p>Ilyen szempontb\u00f3l az attrib\u00fatumok k\u00f6zelebb \u00e1llnak a statikus tulajdons\u00e1gokhoz, m\u00e9gis megfontoland\u00f3, hogy egy adott adatot statikus tagk\u00e9nt vagy attrib\u00fatumk\u00e9nt defini\u00e1ln\u00e1nk. Attrib\u00fatummal sokkal deklarat\u00edvabb a le\u00edr\u00e1s, \u00e9s nem szennyezz\u00fck olyan r\u00e9szletekkel a k\u00f3dot, melyeknek nem kellene az oszt\u00e1ly publikus interf\u00e9sz\u00e9n megjelennie.</p> <p>A NET sz\u00e1mos be\u00e9p\u00edtett attrib\u00fatumot defini\u00e1l, melyek funkci\u00f3ja a legk\u00fcl\u00f6nb\u00f6z\u0151bb f\u00e9le lehet. A k\u00f6vetkez\u0151 p\u00e9ld\u00e1ban haszn\u00e1lt attrib\u00fatumok p\u00e9ld\u00e1ul az XML soros\u00edt\u00f3val k\u00f6z\u00f6lnek k\u00fcl\u00f6nb\u00f6z\u0151 metainform\u00e1ci\u00f3kat.</p> <ol> <li> <p>Sz\u00farjuk be a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a k\u00f6vetkez\u0151 k\u00f3dr\u00e9szletet, majd futtassuk a programunkat!</p> <pre><code>var serializer = new XmlSerializer(typeof(Person));\nvar stream = new FileStream(\"person.txt\", FileMode.Create);\nserializer.Serialize(stream, p);\nstream.Close();\nProcess.Start(new ProcessStartInfo\n{\n    FileName = \"person.txt\",\n    UseShellExecute = true,\n});\n</code></pre> <p>A fenti p\u00e9ld\u00e1b\u00f3l az utols\u00f3 <code>Process.Start</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s nem a soros\u00edt\u00f3 logika r\u00e9sze, csup\u00e1n egy frapp\u00e1ns megold\u00e1s arra, hogy a Windows alap\u00e9rtelmezett sz\u00f6vegf\u00e1jl n\u00e9zeget\u0151j\u00e9vel megnyissuk a keletkezett adat\u00e1llom\u00e1nyt. Ezt kipr\u00f3b\u00e1lhatjuk, de a haszn\u00e1lt .NET runtime-t\u00f3l \u00e9s az oper\u00e1ci\u00f3s rendszer\u00fcnkt\u0151l f\u00fcgg, t\u00e1mogatott-e. Ha nem, fut\u00e1s k\u00f6zben hib\u00e1t kapunk. Ez esetben hagyjuk kikommentezve, \u00e9s a <code>person.txt</code> f\u00e1jlt a f\u00e1jlrendszerben megkeresve k\u00e9zzel nyissuk meg (a Visual Studio mapp\u00e1nkban a *\\bin\\Debug\\* alatt tal\u00e1lhat\u00f3 az .exe alkalmaz\u00e1sunk mellett). <li> <p>N\u00e9zz\u00fck meg a keletkezett f\u00e1jl szerkezet\u00e9t. Figyelj\u00fck meg, hogy minden tulajdons\u00e1g a nev\u00e9nek megfelel\u0151 XML elemre lett lek\u00e9pezve.</p> </li> <li> <p>.NET attrib\u00fatumok seg\u00edts\u00e9g\u00e9vel olyan metaadatokkal l\u00e1thatjuk el a <code>Person</code> oszt\u00e1lyunkat, melyek k\u00f6zvetlen\u00fcl m\u00f3dos\u00edtj\u00e1k a soros\u00edt\u00f3 viselked\u00e9s\u00e9t. Az <code>XmlRoot</code> attrib\u00fatum lehet\u0151s\u00e9get k\u00edn\u00e1l a gy\u00f6k\u00e9relem \u00e1tnevez\u00e9s\u00e9re. Helyezz\u00fck el a <code>Person</code> oszt\u00e1ly f\u00f6l\u00e9!</p> <pre><code>[XmlRoot(\"Szem\u00e9ly\")]\npublic class Person \n{\n    // ...\n}\n</code></pre> </li> <li> <p>Az <code>XmlAttribute</code> attrib\u00fatum jelzi a soros\u00edt\u00f3 sz\u00e1m\u00e1ra, hogy a jel\u00f6lt tulajdons\u00e1got ne xml elemre, hanem xml attrib\u00fatumra k\u00e9pezze le. L\u00e1ssuk el ezzel az <code>Age</code> tulajdons\u00e1got (\u00e9s ne a tagv\u00e1ltoz\u00f3t!)!</p> <pre><code>[XmlAttribute(\"Kor\")]\npublic int Age\n</code></pre> </li> <li> <p>Az <code>XmlIgnore</code> attrib\u00fatum jelzi a soros\u00edt\u00f3nak, hogy a jel\u00f6lt tulajdons\u00e1g teljesen elhagyand\u00f3 az eredm\u00e9nyb\u0151l. Pr\u00f3b\u00e1ljuk ki a <code>Name</code> tulajdons\u00e1g f\u00f6l\u00f6tt.</p> <pre><code>[XmlIgnore]\npublic string Name { get; set; }\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1sunkat! Hasonl\u00edtsuk \u00f6ssze az eredm\u00e9nyt a kor\u00e1bbiakkal.</p> </li>"},{"location":"labor/2-nyelvi-eszkozok/#5-feladat-delegat-2","title":"5. Feladat \u2013 Deleg\u00e1t 2.","text":"<p>A 2. \u00e9s 3. feladatokban a deleg\u00e1tokkal esem\u00e9ny alap\u00fa \u00fczenetk\u00fcld\u00e9st val\u00f3s\u00edtottunk meg. A deleg\u00e1tok haszn\u00e1lat\u00e1nak m\u00e1sik tipikus eset\u00e9ben a f\u00fcggv\u00e9nyreferenci\u00e1kat arra haszn\u00e1ljuk, hogy egy algoritmus vagy \u00f6sszetettebb m\u0171velet sz\u00e1m\u00e1ra egy el\u0151re nem defini\u00e1lt l\u00e9p\u00e9s implement\u00e1ci\u00f3j\u00e1t \u00e1tadjuk.</p> <p>A be\u00e9p\u00edtett generikus lista oszt\u00e1ly (<code>List&lt;T&gt;</code>) <code>FindAll</code> f\u00fcggv\u00e9nye p\u00e9ld\u00e1ul k\u00e9pes arra, hogy visszaadjon egy \u00faj list\u00e1ban minden olyan elemet, mely egy adott felt\u00e9telnek eleget tesz. A konkr\u00e9t sz\u0171r\u00e9si felt\u00e9telt egy f\u00fcggv\u00e9ny, pontosabban delegate form\u00e1j\u00e1ban adhatjuk meg param\u00e9terben (ez a <code>FindAll</code> minden elemre megh\u00edvja), mely igazat ad minden olyan elemre, amit az eredm\u00e9nylist\u00e1ban szeretn\u00e9nk l\u00e1tni. A f\u00fcggv\u00e9ny param\u00e9ter\u00e9nek a t\u00edpusa a k\u00f6vetkez\u0151 el\u0151re defini\u00e1lt delegate t\u00edpus (nem kell beg\u00e9pelni/l\u00e9trehozni, hiszen m\u00e1r l\u00e9tezik):</p> <pre><code>public delegate bool Predicate&lt;T&gt;(T obj)\n</code></pre> <p>Note</p> <p>A fenti teljes defin\u00edci\u00f3 megjelen\u00edt\u00e9s\u00e9hez csak g\u00e9pelj\u00fck be valahova, pl. a <code>Main</code> f\u00fcggv\u00e9ny v\u00e9g\u00e9re a <code>Predicate</code> t\u00edpusnevet, kattintsunk rajta eg\u00e9rrel, \u00e9s az F12 billenty\u0171vel navig\u00e1ljunk el a defin\u00edci\u00f3j\u00e1hoz.</p> <p>Vagyis bemenetk\u00e9nt egy olyan t\u00edpus\u00fa v\u00e1ltoz\u00f3t v\u00e1r, mint a listaelemek t\u00edpusa, kimenetk\u00e9nt pedig egy logikai (bool) \u00e9rt\u00e9ket. A fentiek demonstr\u00e1l\u00e1s\u00e1ra kieg\u00e9sz\u00edtj\u00fck a kor\u00e1bbi programunkat egy sz\u0171r\u00e9ssel, mely a list\u00e1b\u00f3l csak a p\u00e1ratlan elemeket fogja megtartani.</p> <ol> <li> <p>Val\u00f3s\u00edtsunk meg egy olyan sz\u0171r\u0151f\u00fcggv\u00e9nyt az alkalmaz\u00e1sunkban, amely a p\u00e1ratlan sz\u00e1mokat adja vissza:</p> <pre><code>private static bool MyFilter(int n)\n{\n    return n % 2 == 1;\n}\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a kor\u00e1bban \u00edrt k\u00f3dunkat a sz\u0171r\u0151 f\u00fcggv\u00e9ny\u00fcnk haszn\u00e1lat\u00e1val:</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nlist = list.FindAll(MyFilter);\n\nforeach (int n in list)\n{\n    Console.WriteLine($\"Value: {n}\");\n}\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st. Figyelj\u00fck meg, hogy a konzolon val\u00f3ban csak a p\u00e1ratlan sz\u00e1mok jelennek meg.</p> </li> <li>\u00c9rdekess\u00e9gk\u00e9nt elhelyezhet\u00fcnk egy t\u00f6r\u00e9spontot (breakpoint) a <code>MyFilter</code> f\u00fcggv\u00e9ny\u00fcnk belsej\u00e9ben, \u00e9s megfigyelhetj\u00fck, hogy a f\u00fcggv\u00e9ny val\u00f3ban minden egyes listaelemre k\u00fcl\u00f6n-k\u00fcl\u00f6n megh\u00edv\u00f3dik.</li> </ol> <p>Collection initializer szintaxis</p> <p>Minden <code>Add</code> met\u00f3dussal rendelkez\u0151, az <code>IEnumerable</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyra (tipikusan kollekci\u00f3k) a collection initializer szintaxis az al\u00e1bbi m\u00f3don:</p> <pre><code>var list = new List&lt;int&gt;() { 1, 2, 3 };\n</code></pre> <p>C# 12-t\u0151l kezdve m\u00e9g egyszer\u0171bb szintaxis (\u00fan. collection expression) is haszn\u00e1lhat\u00f3 egy gy\u0171jtem\u00e9ny inicializ\u00e1l\u00e1s\u00e1ra, ha v\u00e1ltoz\u00f3 t\u00edpus\u00e1ra a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni, hogy gy\u0171jetm\u00e9nyr\u0151l van sz\u00f3. Pl.:</p> <pre><code>List&lt;int&gt; list = [1, 2, 3];\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/#6-feladat-lambda-kifejezesek","title":"6. Feladat \u2013 Lambda kifejez\u00e9sek","text":"<p>Az \u00e9rintett t\u00e9mak\u00f6r\u00f6k az el\u0151ad\u00e1sanyagban r\u00e9szletesen szerepelnek, itt nem ism\u00e9telj\u00fck meg \u0151ket L\u00e1sd \u201eEl\u0151ad\u00e1s 02 - Nyelvi eszk\u00f6z\u00f6k.pdf\u201d dokumentum \"Lambda expression (lambda kifejez\u00e9s)\" fejezete. A kulcselem a <code>=&gt;</code> (lambda oper\u00e1tor), mely seg\u00edts\u00e9g\u00e9vel lambda kifejez\u00e9sek, vagyis n\u00e9vtelen f\u00fcggv\u00e9nyek defini\u00e1l\u00e1s\u00e1ra van lehet\u0151s\u00e9g.</p> <p><code>Action \u00e9s Func</code></p> <p>A .NET be\u00e9p\u00edtett <code>Func</code> \u00e9s <code>Action</code> generikus delegate t\u00edpusokra itt id\u0151 hi\u00e1ny\u00e1ban nem t\u00e9r\u00fcnk ki. Ett\u0151l m\u00e9g beletartoznak az alapanyagba!</p> <p>Az el\u0151z\u0151, 5. feladatot oldjuk meg a k\u00f6vetkez\u0151k\u00e9ppen: ne adjunk meg k\u00fcl\u00f6n sz\u0171r\u0151f\u00fcggv\u00e9nyt, hanem a sz\u0171r\u00e9si logik\u00e1t egy lambda kifejez\u00e9s form\u00e1j\u00e1ban adjuk meg a <code>FindAll</code> m\u0171veletnek.</p> <p>Ehhez mind\u00f6ssze egy sort kell megv\u00e1ltoztatni:</p> <pre><code>list = list.FindAll((int n) =&gt; { return n % 2 == 1; });\n</code></pre> <p>Egy n\u00e9v n\u00e9lk\u00fcli f\u00fcggv\u00e9nyt defini\u00e1ltunk \u00e9s adtunk \u00e1t a <code>FindAll</code> m\u0171veletnek:</p> <ul> <li>ez egy lambda kifejez\u00e9s,</li> <li>a <code>=&gt;</code> bal oldal\u00e1n megadtuk a m\u0171velet param\u00e9tereket (itt csak egy volt),</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n adtuk meg a m\u0171velet t\u00f6rzs\u00e9t (ugyanaz, mint a kor\u00e1bbi <code>MyFilter</code> t\u00f6rzse).</li> </ul> <p>A fenti sort j\u00f3val egyszer\u0171bb \u00e9s \u00e1ttekinthet\u0151bb form\u00e1ba is \u00edrhatjuk:</p> <pre><code>list = list.FindAll(n =&gt; n % 2 == 1);\n</code></pre> <p>A k\u00f6vetkez\u0151 egyszer\u0171s\u00edt\u00e9seket eszk\u00f6z\u00f6lt\u00fck:</p> <ul> <li>a param\u00e9ter t\u00edpus\u00e1t nem \u00edrtuk ki: a ford\u00edt\u00f3 ki tudja k\u00f6vetkeztetni a <code>FindAll</code> delegate param\u00e9teram\u00e9ter\u00e9nek t\u00edpus\u00e1b\u00f3l, mely a kor\u00e1bban vizsg\u00e1lt <code>Predicate</code>.</li> <li>a param\u00e9ter k\u00f6r\u00fcli z\u00e1r\u00f3jelet elhagyhattuk (mert csak egy param\u00e9ter van)</li> <li>a <code>=&gt;</code> jobb oldal\u00e1n elhagyhattuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code>-t (mert egyetlen kifejez\u00e9sb\u0151l \u00e1llt a f\u00fcggv\u00e9ny t\u00f6rzse, mellyel a f\u00fcggv\u00e9ny visszat\u00e9r).</li> </ul>"},{"location":"labor/2-nyelvi-eszkozok/#7-tovabbi-nyelvi-konstrukciok","title":"7. Tov\u00e1bbi nyelvi konstrukci\u00f3k","text":"<p>Az al\u00e1bbiakban kitekint\u00fcnk n\u00e9h\u00e1ny olyan C# nyelvi elemre, melyek a napi programoz\u00e1si feladatok sor\u00e1n egyre gyakrabban haszn\u00e1latosak. A gyakorlat sor\u00e1n j\u00f3 es\u00e9llyel m\u00e1r nem marad id\u0151 ezek \u00e1ttekint\u00e9s\u00e9re.</p>"},{"location":"labor/2-nyelvi-eszkozok/#kifejezestorzsu-tagok-expression-bodied-members","title":"Kifejez\u00e9st\u00f6rzs\u0171 tagok (Expression-bodied members)","text":"<p>Id\u0151nk\u00e9nt olyan r\u00f6vid f\u00fcggv\u00e9nyeket, illetve tulajdons\u00e1gok eset\u00e9n kifejezetten gyakran olyan r\u00f6vid get/set/init defin\u00edci\u00f3kat \u00edrunk, melyek egyetlen kifejez\u00e9sb\u0151l \u00e1llnak. Ez esetben a f\u00fcggv\u00e9ny, illetve tulajdons\u00e1g eset\u00e9n a get/set/init t\u00f6rzse megadhat\u00f3 \u00fan. kifejez\u00e9st\u00f6rzs\u0171 tagok (expression-bodied members) szintaktik\u00e1val is, a <code>=&gt;</code> alkalmaz\u00e1s\u00e1val. Ez akkor is megtehet\u0151, ha az adott kontextusban van visszat\u00e9r\u00e9si \u00e9rt\u00e9k (return utas\u00edt\u00e1s), ak\u00e1r nincs.</p> <p>A p\u00e9ld\u00e1kban l\u00e1tni fogjuk, hogy a kifejez\u00e9stest\u0171 tagok alkalmaz\u00e1sa nem t\u00f6bb, mint egy kisebb szintaktikai \"csavar\" annak \u00e9rdek\u00e9ben, hogy ilyen egyszer\u0171 esetekben min\u00e9l kevesebb k\u00f6r\u00edt\u0151 k\u00f3dot kelljen \u00edrni.</p> <p>N\u00e9zz\u00fcnk el\u0151sz\u00f6r egy f\u00fcggv\u00e9ny p\u00e9ld\u00e1t (feltessz\u00fck, hogy az oszt\u00e1lyban van egy <code>Age</code> tagv\u00e1ltoz\u00f3 vagy tulajdons\u00e1g):</p> <p><pre><code>public int GetAgeInDogYear() =&gt; Age * 7; \npublic void DisplayName() =&gt; Console.WriteLine(ToString());\n</code></pre> Mint l\u00e1that\u00f3, elhagytuk a {} z\u00e1r\u00f3jeleket \u00e9s a <code>return</code> utas\u00edt\u00e1st, \u00edgy t\u00f6m\u00f6rebb a szintaktika.</p> <p>Fontos</p> <p>B\u00e1r itt is a <code>=&gt;</code> tokent haszn\u00e1ljuk, ennek semmi k\u00f6ze nincs a kor\u00e1bban t\u00e1rgyalt lambda kifejez\u00e9sekhez: egyszer\u0171en csak arr\u00f3l van sz\u00f3, hogy ugyanazt a <code>=&gt;</code> tokent (szimb\u00f3lump\u00e1rt) k\u00e9t teljesen elt\u00e9r\u0151 dologra haszn\u00e1lja a C# nyelv.</p> <p>P\u00e9lda tulajdons\u00e1g getter megad\u00e1s\u00e1ra:</p> <pre><code>public int AgeInDogYear { get =&gt; Age * 7; }\n</code></pre> <p>S\u0151t, ha csak getterje van a tulajdons\u00e1gnak, a <code>get</code> kulcssz\u00f3t \u00e9s a kapcsos z\u00e1r\u00f3jeleket is lehagyhatjuk.</p> <pre><code>public int AgeInDogYear =&gt; Age * 7;\n</code></pre> <p>Ezt az k\u00fcl\u00f6nb\u00f6zteti meg a kor\u00e1bban l\u00e1tott f\u00fcggv\u00e9nyek hasonl\u00f3 szintaktik\u00e1j\u00e1t\u00f3l, hogy itt nem \u00edrtuk ki a kerek z\u00e1r\u00f3jeleket.</p> <p>Note</p> <p>A Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1nak magyar ford\u00edt\u00e1s\u00e1ban az \"expression-bodied members\" nem \"kifejez\u00e9st\u00f6rzs\u0171\", hanem \"kifejez\u00e9stest\u0171\" tagk\u00e9nt szerepel. K\u00f6sz\u00f6nj\u00fck sz\u00e9pen, de a f\u00fcggv\u00e9nyeknek sokkal ink\u00e1bb t\u00f6rzse, mint teste van a magyar terminol\u00f3gi\u00e1ban, \u00edgy ezt nem vessz\u00fck \u00e1t...</p>"},{"location":"labor/2-nyelvi-eszkozok/#objektuminicializalo-object-initializer","title":"Objektuminicializ\u00e1l\u00f3 (Object initializer)","text":"<p>A publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k inicializ\u00e1l\u00e1sa \u00e9s a konstruktorh\u00edv\u00e1s kombin\u00e1lhat\u00f3 egy \u00fagynevezett objektuminicializ\u00e1l\u00f3 (object initializer) szintaxis seg\u00edts\u00e9g\u00e9vel. Ennek alkalmaz\u00e1sa sor\u00e1n a konstruktorh\u00edv\u00e1s ut\u00e1n kapcsos z\u00e1r\u00f3jelekkel blokkot nyitunk, ahol a publikus tulajdons\u00e1gok/tagv\u00e1ltoz\u00f3k \u00e9rt\u00e9ke adhat\u00f3 meg, az al\u00e1bbi szintaktik\u00e1val.</p> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Luke\",\n};\n</code></pre> <p>Az tulajdons\u00e1gok/tagok inicializ\u00e1l\u00e1sa a konstruktor lefut\u00e1sa ut\u00e1n t\u00f6rt\u00e9nik (amennyiben tartozik az oszt\u00e1lyhoz konstruktor). Ez a szintaktika az\u00e9rt is el\u0151ny\u00f6s, mert egy kifejez\u00e9snek sz\u00e1m\u00edt (azon h\u00e1rommal szemben, mintha l\u00e9trehozn\u00e1nk egy inicializ\u00e1latlan, <code>Person</code> objektumot, \u00e9s k\u00e9t tov\u00e1bbi l\u00e9p\u00e9sben adn\u00e1nk \u00e9rt\u00e9ket az <code>Age</code> \u00e9s <code>Name</code> tagoknak). \u00cdgy ak\u00e1r k\u00f6zvetlen\u00fcl f\u00fcggv\u00e9nyh\u00edv\u00e1s param\u00e9terek\u00e9nt \u00e1tadhat\u00f3 egy inicializ\u00e1lt objektum, an\u00e9lk\u00fcl, hogy k\u00fcl\u00f6n v\u00e1ltoz\u00f3t kellene deklar\u00e1lni.</p> <pre><code>void Foo(Person p)\n{\n    // do something with p\n}\n</code></pre> <pre><code>Foo(new Person() { Age = 17, Name = \"Luke\" });\n</code></pre> <p>A szintaxis r\u00e1ad\u00e1sul copy-paste bar\u00e1t, mert ahogy a fenti p\u00e9ld\u00e1kban is l\u00e1tszik, hogy nem sz\u00e1m\u00edt, hogy az utols\u00f3 tulajdons\u00e1g megad\u00e1sa ut\u00e1n van-e vessz\u0151, vagy nincs.</p>"},{"location":"labor/2-nyelvi-eszkozok/#tulajdonsagok-init-only-setter","title":"Tulajdons\u00e1gok - Init only setter","text":"<p>Az el\u0151z\u0151 pontban l\u00e9v\u0151 objektuminicializ\u00e1l\u00f3 szintaxis nagyon k\u00e9nyelmes, viszont azt k\u00f6veteli meg a tulajdons\u00e1gt\u00f3l, hogy publikus legyen. Ha azt akarjuk, hogy egy tulajdons\u00e1g \u00e9rt\u00e9ke csak az objektum l\u00e9trehoz\u00e1sakor legyen megadhat\u00f3, ahhoz konstruktor param\u00e9tert kell bevezess\u00fcnk, \u00e9s egy csak olvashat\u00f3 (csak getterrel rendelkez\u0151) tulajdons\u00e1gnak kell azt \u00e9rt\u00e9k\u00fcl adjuk. Erre a probl\u00e9m\u00e1ra ad egyszer\u0171bb megold\u00e1st az \u00fan. Init only setter szintaxis, ahol olyan \"settert\" tudunk k\u00e9sz\u00edteni az <code>init</code> kulcssz\u00f3val, mely \u00e1ll\u00edt\u00e1sa  csak a konstruktorban \u00e9s az el\u0151z\u0151 fejezetben ismertetett objektuminicializ\u00e1l\u00f3 szintaxis alkalmaz\u00e1sa sor\u00e1n enged\u00e9lyezett, ezt k\u00f6vet\u0151en m\u00e1r nem.</p> <pre><code>public string Name { get; init; }\n</code></pre> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Luke\",\n};\n\np.Name = \"Test\"; // build hiba, ut\u00f3lag nem megv\u00e1ltoztathat\u00f3\n</code></pre> <p>Tov\u00e1bb\u00e1 lehet\u0151s\u00e9g\u00fcnk van az init only setter k\u00f6telez\u0151s\u00e9g\u00e9t is be\u00e1ll\u00edtani a tulajdons\u00e1gon alkalmazott <code>required</code> kulcssz\u00f3val. Ekkor a tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t mindenk\u00e9ppen meg kell adni az objektuminicializ\u00e1l\u00f3 szintaxisban, k\u00fcl\u00f6nben ford\u00edt\u00e1si hib\u00e1t kapunk.</p> <pre><code>public required string Name { get; init; }\n</code></pre> <p>Ez az\u00e9rt is hasznos, mert ha egy\u00e9bk\u00e9nt is szeretn\u00e9nk tulajdons\u00e1gokat publik\u00e1lni az oszt\u00e1lyb\u00f3l, \u00e9s egy\u00e9bk\u00e9nt is szeretn\u00e9nk t\u00e1mogatni az objektum inicializ\u00e1l\u00f3 szintaxist, akkor \u00edgy meg tudjuk sp\u00f3rolni a k\u00f6telez\u0151 konstruktor param\u00e9tereket.</p>"},{"location":"labor/2-nyelvi-eszkozok/#8-feladat-generikus-osztalyok","title":"8. Feladat \u2013 Generikus oszt\u00e1lyok","text":"<p>Megjegyz\u00e9s: erre a feladatra j\u00f3 es\u00e9llyel nem marad id\u0151. Ez esetben c\u00e9lszer\u0171 a feladatot gyakorl\u00e1sk\u00e9ppen otthon elv\u00e9gezni.</p> <p>A .NET generikus oszt\u00e1lyai hasonl\u00edtanak C++ nyelv template oszt\u00e1lyaihoz, de k\u00f6zelebb \u00e1llnak a Java-ban m\u00e1r megismert generikus oszt\u00e1lyokhoz. A seg\u00edts\u00e9g\u00fckkel \u00e1ltal\u00e1nos (t\u00f6bb t\u00edpusra is m\u0171k\u00f6d\u0151), de ugyanakkor t\u00edpusbiztos oszt\u00e1lyokat hozhatunk l\u00e9tre. Generikus oszt\u00e1lyok n\u00e9lk\u00fcl, ha \u00e1ltal\u00e1nosan szeretn\u00e9nk kezelni egy probl\u00e9m\u00e1t, akkor <code>object</code> t\u00edpus\u00fa adatokat haszn\u00e1lunk (mert .NET-ben minden oszt\u00e1ly az <code>object</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik). Ez a helyzet p\u00e9ld\u00e1ul az <code>ArrayList</code>-tel is, ami egy \u00e1ltal\u00e1nos c\u00e9l\u00fa gy\u0171jtem\u00e9ny, tetsz\u0151leges, <code>object</code> t\u00edpus\u00fa elemek t\u00e1rol\u00e1s\u00e1ra alkalmas. L\u00e1ssunk egy p\u00e9ld\u00e1t az <code>ArrayList</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>var list = new ArrayList();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    // Castolni kell, k\u00fcl\u00f6nben nem fordul\n    int i = (int)list[n];\n    Console.WriteLine($\"Value: {i}\");\n}\n</code></pre> <p>A fenti megold\u00e1ssal a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k ad\u00f3dnak:</p> <ul> <li>Az <code>ArrayList</code> minden egyes elemet <code>object</code>-k\u00e9nt t\u00e1rol.</li> <li>Amikor hozz\u00e1 szeretn\u00e9nk f\u00e9rni a lista egy elem\u00e9hez, mindig a megfelel\u0151 t\u00edpus\u00fav\u00e1 kell cast-olni.</li> <li>Nem t\u00edpusbiztos. A fenti p\u00e9ld\u00e1ban semmi nem akad\u00e1lyoz meg abban (\u00e9s semmilyen hiba\u00fczenet sem jelzi), hogy az <code>int</code> t\u00edpus\u00fa adatok mell\u00e9  besz\u00farjunk a list\u00e1ba egy m\u00e1sik t\u00edpus\u00fa objektumot. Ilyenkor csak a lista bej\u00e1r\u00e1sa sor\u00e1n kapn\u00e1nk hib\u00e1t, amikor a nem <code>int</code> t\u00edpust <code>int</code> t\u00edpus\u00fara pr\u00f3b\u00e1lunk castolni. Generikus gy\u0171jtem\u00e9nyek haszn\u00e1latakor az ilyen hib\u00e1k m\u00e1r a ford\u00edt\u00e1s sor\u00e1n kider\u00fclnek.</li> <li>\u00c9rt\u00e9k t\u00edpus\u00fa adatok t\u00e1rol\u00e1sakor a lista lassabban m\u0171k\u00f6dik, mert az \u00e9rt\u00e9k t\u00edpust el\u0151sz\u00f6r be kell dobozolni (boxing), hogy az <code>object</code>-k\u00e9nt (azaz referencia t\u00edpusk\u00e9nt) t\u00e1rolhat\u00f3 legyen.</li> </ul> <p>A fenti probl\u00e9ma megold\u00e1sa egy generikus lista haszn\u00e1lat\u00e1val a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki (a gyakorlat sor\u00e1n csak a kiemelt sort m\u00f3dos\u00edtsuk a kor\u00e1bban beg\u00e9pelt p\u00e9ld\u00e1ban):</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    int i = list[n]; // Nem kell cast-olni\n    Console.WriteLine($\"Value: {i}\");\n}\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/","title":"2. Sprachliche Mittel","text":""},{"location":"labor/2-nyelvi-eszkozok/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>W\u00e4hrend der \u00dcbung lernen die Studenten die wichtigsten modernen Sprachelementen kennen, die auch in der .NET-Umgebung verf\u00fcgbar sind. Es wird vorausgesetzt, dass der/die Student/in den objektorientierten Ansatz in seinem/ihrem bisherigen Studium beherrscht und mit den grundlegenden Konzepten der Objektorientierung vertraut ist. In dieser \u00dcbung werden wir uns auf die Sprachelemente in .NET konzentrieren, die \u00fcber den allgemeinen objektorientierten Ansatz hinausgehen, aber wesentlich zur Erstellung von transparentem und wartbarem Code beitragen. Diese sind:</p> <ul> <li>Eigenschaft (property)</li> <li>Delegat (delegate, Methodenreferenz)</li> <li>Ereignis (event)</li> <li>Attribut (attribute)</li> <li>Lambda-Ausdruck (lambda expression)</li> <li>Generischer Typ (generic type)</li> <li>Einige zus\u00e4tzliche Sprachkonstruktionen</li> </ul> <p>Zugeh\u00f6rige Vorlesungen: Vorlesung 2 und Anfang der Vorlesung 3 - Sprachliche Mittel.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Durchf\u00fchrung der \u00dcbung ben\u00f6tigten Werkzeuge:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>\u00dcbung unter Linux oder macOS</p> <p>Das \u00dcbungsmaterial ist grunds\u00e4tzlich f\u00fcr Windows und Visual Studio gedacht, kann aber auch auf anderen Betriebssystemen mit anderen Entwicklungswerkzeugen (z.B. VS Code, Rider, Visual Studio f\u00fcr Mac) oder sogar mit einem Texteditor und CLI (Kommandozeilen)-Tools durchgef\u00fchrt werden. Dies wird dadurch erm\u00f6glicht, dass die Beispiele im Kontext einer einfachen Konsolenanwendung pr\u00e4sentiert werden (keine Windows-spezifischen Elemente) und das .NET SDK auf Linux und macOS unterst\u00fctzt wird. Hello World unter Linuxon</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Ausblick</p> <p>Dieser Leitfaden enth\u00e4lt an mehreren Stellen zus\u00e4tzliche Informationen und Erkl\u00e4rungen, die in derselben Farbe wie dieser Hinweis und mit demselben Symbol umrahmt sind. Dies sind n\u00fctzliche Erkenntnisse, die jedoch nicht Teil des Kernlehrmaterial sind.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#losung","title":"L\u00f6sung","text":"Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist auf GitHub [hier] verf\u00fcgbar (https://github.com/bmeviauab00/lab-nyelvieszkozok-megoldas). Der einfachste Weg, es herunterzuladen, ist, es von der Kommandozeile aus mit dem Befehl <code>git clone</code> auf Ihren Computer zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-nyelvieszkozok-megoldas</code></p> <p>Sie m\u00fcssen Git auf Ihrem Computer installiert haben, weitere Informationen hier.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#0-aufgabe-schlusselwort-var-implizit-typisierte-lokale-variablen-implicitly-typed-local-variables","title":"0. Aufgabe - Schl\u00fcsselwort var - Implizit typisierte lokale Variablen  (implicitly typed local variables)","text":"<p>Wir beginnen mit einer einfachen Aufw\u00e4rm\u00fcbung. Im folgenden Beispiel erstellen wir eine Klasse namens <code>Person</code>, die eine Person darstellt.</p> <ol> <li>Erstellen wir eine neue C#-Konsolenanwendung. .NET-Basis (d.h. nicht.NET Framework):<ul> <li>Ein Beispiel daf\u00fcr haben wir in der ersten \u00dcbung gesehen, die im Leitfaden beschrieben wird.</li> <li>Das Kontrollk\u00e4stchen \"Do not use top level statements\" ist bei der Projekterstellung aktiviert.</li> </ul> </li> <li>F\u00fcgen wir eine neue Klasse mit dem Namen <code>Person</code> zu unserer Anwendung hinzu.     (Um eine neue Klasse im Solution Explorer hinzuzuf\u00fcgen, klicken wir mit der rechten Maustaste auf die Projektdatei und w\u00e4hlen wir Add / Class. \u00c4ndern wir den Namen der zu erstellenden Datei im erscheinenden Fenster auf <code>Person.cs</code>und klicken wir auf Add.)</li> <li> <p>Lassen wir uns die Klasse \u00f6ffentlich machen. Dazu m\u00fcssen wir das Schl\u00fcsselwort <code>public</code> vor dem Klassennamen eingeben. Diese \u00c4nderung w\u00e4re hier eigentlich nicht n\u00f6tig, aber eine sp\u00e4tere Aufgabe wird eine \u00f6ffentliche Klasse erfordern.</p> <pre><code>public class Person\n{\n}\n</code></pre> </li> <li> <p>Erg\u00e4nzen wir die Funktion <code>Main</code> in der Datei <code>Program.cs</code>, um unsere neue Klasse zu testen.</p> <pre><code>static void Main(string[] args)\n{\n    Person p = new Person();\n}\n</code></pre> </li> <li> <p>Anstatt den Typ der lokalen Variablen explizit anzugeben, k\u00f6nnen wir das Schl\u00fcsselwort <code>var</code> verwenden:</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n}\n</code></pre> <p>Dies wird als implicitly typed local variables bezeichnet, auf Deutsch implizit typisierte lokale Variablen genannt. In diesem Fall versucht der Compiler, den Typ der Variablen aus dem Kontext, aus der rechten Seite des Gleichheitszeichens zu erkennen. In diesem Fall ist es <code>Person</code>.  Es ist wichtig anzumerken, dass die Sprache dadurch statisch typisiert bleibt (es funktioniert also nicht wie das JavaScript-Schl\u00fcsselwort <code>var</code> ), da der Typ der <code>p</code> -Variable sp\u00e4ter nicht mehr ge\u00e4ndert werden kann. Es ist nur ein einfaches syntaktisches Bonbon, um die Definition lokaler Variablen kompakter zu machen (keine Notwendigkeit, den Typ \"zweimal\" anzugeben, auf der linken und auf der rechten Seite von <code>=</code> ).</p> <p>Target-typed <code>new</code> expressions</p> <p>Ein weiterer Ansatz k\u00f6nnte die Target-typed <code>new</code> expressions in C# 9 sein, wo der Typ f\u00fcr den neuen Operator weggelassen werden kann, wenn er vom Compiler aus dem Kontext erkannt werden kann (z.B.: linke Seite eines Wertes, Typ eines Parameters, etc.). Unser obiger <code>Person</code> -Konstruktor w\u00fcrde wie folgt aussehen:</p> <pre><code>Person p = new();\n</code></pre> <p>Der Vorteil dieses Ansatzes gegen\u00fcber <code>var</code> ist, dass er auch f\u00fcr Membervariablen verwendet werden kann.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#1-aufgabe-eigenschaft-property","title":"1. Aufgabe - Eigenschaft (property)","text":"<p>Eigenschaften erlauben uns typischerweise (aber nicht ausschlie\u00dflich, wie wir noch sehen werden) den Zugriff auf Membervariablen von Klassen auf eine syntaktisch \u00e4hnliche Weise wie den Zugriff auf eine traditionelle Membervariable. Beim Zugriff haben wir jedoch die M\u00f6glichkeit, anstelle einer einfachen Wertabfrage oder Einstellung eine methoden\u00e4hnliche Art des Zugriffs auf die Variable zu implementieren, und wir k\u00f6nnen sogar die Sichtbarkeit der Abfrage und der Einstellung separat definieren.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#syntax-von-eigenschaften","title":"Syntax von Eigenschaften","text":"<p>Im folgenden Beispiel erstellen wir eine Klasse namens <code>Person</code>, die eine Person darstellt. Sie hat zwei Mitgliedsvariablen, <code>name</code> und <code>age</code>. Auf Mitgliedsvariablen kann nicht direkt zugegriffen werden (da sie privat sind), sie k\u00f6nnen nur \u00fcber die \u00f6ffentlichen Eigenschaften <code>Name</code> und <code>Age</code> verwaltet werden. Das Beispiel veranschaulicht, dass die .NET-Eigenschaften eindeutig den aus C++ und Java bekannten  Methoden <code>SetX(\u2026)</code> und <code>GetX()</code> entsprechen, aber die sind auf einheitlichere Weise, auf Sprachebene unterst\u00fctzt.</p> <ol> <li> <p>Erstellen wir in der Klasse <code>Person</code>, die in der vorherigen Aufgabe erstellt war, eine Membervariable des Typs <code>int</code> mit dem Namen <code>age</code> und eine Eigenschaft <code>Age</code>, die sie verf\u00fcgbar macht.</p> <pre><code>public class Person\n{\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set { age = value; }\n    }\n}\n</code></pre> <p>Visual Studio Snippets</p> <p>Obwohl wir die gesamte Eigenschaft im Labor zu \u00dcbungszwecken manuell eingegeben haben, stellt Visual Studio Code Snippets zur Verf\u00fcgung, um h\u00e4ufig vorkommende Codeteile zu erstellen, mit denen wir allgemeine Sprachkonstrukte als Vorlagen verwenden k\u00f6nnen. Der obige Eigenschaftscodeschnipsel kann mit dem Schnipsel <code>propfull</code> abgerufen werden. Geben Sie den Namen des Schnipsels ein (<code>propfull</code>) und dr\u00fccken Sie dann die Tab -Taste, bis der Schnipsel aktiviert ist (normalerweise 2x).</p> <p>Weitere erw\u00e4hnenswerte Schnipseln sind unter anderem:</p> <ul> <li><code>ctor</code>: Konstruktor</li> <li><code>for</code>: f\u00fcr Zyklus</li> <li><code>foreach</code>: foreach-Schleife</li> <li><code>prop</code>: automatische Eigenschaft (siehe sp\u00e4ter)</li> <li><code>switch</code>: Schaltbefehl</li> <li><code>cw</code>: Console.WriteLine</li> </ul> <p>Wir k\u00f6nnen solche Schnipseln herstellen.</p> </li> <li> <p>Ergn\u00e4nzen wir die Funktion <code>Main</code> in der Datei <code>Program.cs</code>, um unsere neue Eigenschaft zu testen.</p> <pre><code>static void Main(string[] args)\n{\n    var p = new Person();\n    p.Age = 17;\n    p.Age++;\n    Console.WriteLine(p.Age);\n}\n</code></pre> </li> <li> <p>F\u00fchren wir unseren Programm aus (F5)</p> <p>Wir sehen, dass die Eigenschaft auf \u00e4hnliche Weise wie die Mitgliedsvariablen verwendet werden kann. Wenn die Eigenschaft abgefragt wird, wird der in der Eigenschaft definierte Teil <code>get</code> ausgef\u00fchrt und der Wert der Eigenschaft ist der durch return zur\u00fcckgegebene Wert. Wenn die Eigenschaft gesetzt ist, wird der in der Eigenschaft definierte Abschnitt <code>set</code> ausgef\u00fchrt, und der Wert der speziellen Variablen <code>value</code> in diesem Abschnitt entspricht dem als Eigenschaftswert angegebenen Ausdruck.</p> <p>Beachten wir in der obigen L\u00f6sung, wie elegant wir ein Jahr zum Alter einer Person hinzuf\u00fcgen k\u00f6nnen. In Java- oder C++-Code h\u00e4tte ein \u00e4hnlicher Vorgang in der Form <code>p.setAge(p.getAge() + 1)</code> geschrieben werden k\u00f6nnen, was eine wesentlich umst\u00e4ndlichere und schwieriger zu lesende Syntax ist als die Obige. Der Hauptvorteil der Verwendung von Eigenschaften besteht darin, dass unser Code syntaktisch sauberer ist und Wertzuweisungen/-abfragen in den meisten F\u00e4llen gut von tats\u00e4chlichen Funktionsaufrufen getrennt sind.</p> </li> <li> <p>\u00dcberpr\u00fcfen wir, dass unser Programm wirklich <code>get</code> und <code>set</code> aufruft. Dazu setzen wir Haltepunkte (breakpoints) innerhalb der Getter- und Setter-Bl\u00f6cke, dazu klicken wir auf den grauen Balken am linken Rand des Code-Editors.</p> </li> <li> <p>F\u00fchren wir das Programm Schritt f\u00fcr Schritt aus. Starten wir dazu das Programm mit F11 statt F5, und dr\u00fccken wir dann erneut F11, um es Zeile f\u00fcr Zeile ablaufen zu lassen.</p> <p>Wir sehen, dass unser Programm tats\u00e4chlich jedes Mal den Getter aufruft, wenn ein Wert abgefragt wird, und den Setter, wenn ein Wert gesetzt wird.</p> </li> <li> <p>Ein wichtiges Merkmal von Setter-Funktionen ist, dass sie die M\u00f6glichkeit der Wert\u00fcberpr\u00fcfung bieten. F\u00fcgen wir in diesem Sinne dem Setter der Eigenschaft <code>Age</code> etwas hinzu.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"Ung\u00fcltiges Alter!\");\n        age = value; \n    }\n}\n</code></pre> <p>Beachten wir, dass bei einfachen Gettern und Settern die Abfrage bzw. das Setzen von Werten in einer Zeile erfolgt, w\u00e4hrend sie bei komplexeren Stammdaten auf mehrere Zeilen aufgeteilt wird.</p> </li> <li> <p>Um die Anwendung zu testen, ordnen wir dem Alter einen negativen Wert in der Funktion <code>Main</code> der Klasse <code>Program</code> zu.</p> <pre><code>p.Age = -2;\n</code></pre> </li> <li> <p>F\u00fchren wir das Programm aus, um es zu testen, ob die Pr\u00fcfung korrekt funktioniert, und korrigieren wir dann den Fehler, \u00e4ndern wir das eingestellte Alter auf positiv.</p> <pre><code>p.Age = 2;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#auto-implementierte-eigenschaft-auto-implemented-property","title":"Auto-implementierte Eigenschaft (auto-implemented property)","text":"<p>In unserer t\u00e4glichen Arbeit begegnen wir auch einer viel kompakteren Syntax von Eigenschaften. Diese Syntax kann verwendet werden, wenn wir eine Eigenschaft erstellen m\u00f6chten, in der:</p> <ul> <li>wir wollen keine zus\u00e4tzliche Logik zu den Getter- und Setter-Methoden hinzuf\u00fcgen,</li> <li>m\u00fcssen wir nicht direkt auf die private Mitgliedsvariable zugreifen.</li> </ul> <p>Nachfolgend ein Beispiel daf\u00fcr.</p> <ol> <li> <p>F\u00fcgen wir eine solche automatisch implementierte Eigenschaft (auto-implemented property) zu unserer Klasse <code>Person</code> hinzu. Erstellen wir eine Eigenschaft vom Typ <code>string</code> mit dem Namen <code>Name</code>. </p> <pre><code>public string Name { get; set; }\n</code></pre> <p>Der syntaktische Unterschied zu den vorherigen ist, dass weder der get- noch der set-Zweig implementiert wurden (keine Klammern). Im Falle einer automatisch implementierten Eigenschaft erzeugt der Compiler eine versteckte Variable in der Klasse, auf die vom Code aus nicht zugegriffen werden kann und die zum Speichern des aktuellen Werts der Eigenschaft verwendet wird. Es sollte betont werden, dass dies nicht die zuvor eingef\u00fchrte <code>name</code> Mitgliedsvariable (die gel\u00f6scht werden k\u00f6nnte) anh\u00e4lt und abfragt, sondern auf eine versteckte, neue Variable wirkt!</p> </li> <li> <p>\u00dcberpr\u00fcfen wir nun ihre Funktionalit\u00e4t, und erg\u00e4nzen wir die Funktion <code>Main</code>.</p> <pre><code>static void Main(string[] args)\n{\n    // ...\n    p.Name = \"Lukas\";\n    // ...\n    Console.WriteLine(p.Name);\n}\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#standardwert-default-value","title":"Standardwert (default value)","text":"<p>F\u00fcr automatisch implementierte Eigenschaften k\u00f6nnen wir bei der Deklaration auch deren Anfangswert angeben.</p> <ol> <li> <p>Geben wir der Eigenschaft <code>Name</code> einen Anfangswert.</p> <pre><code>public string Name { get; set; } = \"anonymous\";\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#sichtbarkeit-von-eigenschaften","title":"Sichtbarkeit von Eigenschaften","text":"<p>Ein gro\u00dfer Vorteil der Eigenschaften, neben der v\u00f6llig freien Implementierung, ist, dass die Sichtbarkeit des Getters und des Setters getrennt eingestellt werden kann.</p> <ol> <li> <p>Setzen wir die Sichtbarkeit des Setters der Eigenschaft <code>Name</code> auf privat.</p> <pre><code>public string Name { get; private set; }\n</code></pre> <p>In diesem Fall wird ein \u00dcbersetzungsfehler in der Klasse <code>Program</code> f\u00fcr die Richtlinie <code>p.Name = \"Luke\";</code> zur\u00fcckgegeben. Die Grundregel ist, dass Getter und Setter die Sichtbarkeit der Eigenschaft erben, die weiter eingeschr\u00e4nkt, aber nicht gelockert werden kann. Die Sichtbarkeitskontrolle kann sowohl f\u00fcr autoimplementierte als auch f\u00fcr nicht autoimplementierte Eigenschaften verwendet werden.</p> </li> <li> <p>Stellen wir die Sichtbarkeit wieder her (entfernen wir das Schl\u00fcsselwort <code>private</code> aus dem Property Setter <code>Name</code> ), um den \u00dcbersetzungsfehler zu vermeiden.</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#nur-lese-eigenschaft-readonly-property","title":"Nur-Lese-Eigenschaft (readonly property)","text":"<p>Der Setter kann weggelassen werden, um eine schreibgesch\u00fctzte Eigenschaft zu erhalten. F\u00fcr eine automatisch implementierte Eigenschaft kann auch ein Anfangswert angegeben werden: Dies ist nur in einem Konstruktor oder durch Angabe eines Standardwerts (siehe oben) m\u00f6glich, im Gegensatz zu Eigenschaften mit einem privaten Setter, deren Setter von jeder Mitgliedsfunktion der Klasse aufgerufen werden kann.</p> <p>Die Definition einer schreibgesch\u00fctzten Eigenschaft wird in den folgenden Codeschnipseln veranschaulicht (implementieren wir sie NICHT in unserem Code):</p> <p>a) Autoimplementierter Fall</p> <pre><code>public string Name { get; }\n</code></pre> <p>b) Nicht automatisch implementierter Fall</p> <pre><code>private string name;\n...\npublic string Name { get {return name; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#berechneter-wert-calculated-value","title":"Berechneter Wert (calculated value)","text":"<p>Eigenschaften mit nur Getter haben eine andere Verwendung. Sie kann auch verwendet werden, um einen berechneten Wert zu ermitteln, der immer einen Wert auf der Grundlage einer bestimmten Logik berechnet, aber im Gegensatz zur \"Nur-Lese-Eigenschaft\" verf\u00fcgt sie nicht \u00fcber ein Datenelement direkt hinter ihr. Dies wird im folgenden Codeschnipsel veranschaulicht (\u00fcbernehmen wir ihn NICHT in unserem Code):</p> <pre><code>public int AgeInDogYear { get { return Age * 7; } }\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#2-aufgabe-delegat-delegate-methodenreferenz","title":"2. Aufgabe - Delegat (delegate, Methodenreferenz)","text":"<p>Stellen wir sicher, dass der Code kompilierbar ist!</p> <p>Die folgenden \u00dcbungen bauen auf den Ergebnissen der vorherigen \u00dcbungen auf. Wenn Ihr Programm nicht abst\u00fcrzt oder nicht richtig funktioniert, melden Sie dies Ihrem/er \u00dcbungsleiter/in am Ende der Aufgaben, damit er/sie Ihnen bei der Behebung des Problems helfen kann.</p> <p>Delegate sind Methodenreferenzen in .NET, das moderne \u00c4quivalent zu C/C++-Funktionszeigern. Ein Delegat ist eine M\u00f6glichkeit, einen Variablentyp zu definieren, der verwendet werden kann, um auf Methoden zu verweisen. Nicht irgendein Zeiger, sondern - \u00e4hnlich wie bei C++-Funktionszeigern - solche, deren Typ (Parameterliste und R\u00fcckgabewert) dem Typ des Delegaten entspricht. Durch das \"Aufrufen\" der Delegatvariable wird die als Wert angegebene (registrierte) Methode automatisch aufgerufen. Ein Vorteil der Verwendung von Delegaten ist, dass wir zur Laufzeit entscheiden k\u00f6nnen, welche von mehreren Methoden wir aufrufen m\u00f6chten.</p> <p>Einige Beispiele f\u00fcr den Einsatz von Delegaten:</p> <ul> <li>die Funktion, die die Elemente vergleicht, als Parameter an eine universelle Ordnungsfunktion \u00fcbergeben,</li> <li>ist die Implementierung einer universellen Filterlogik f\u00fcr eine allgemeine Sammlung, bei der eine Funktion als Delegat in einem Parameter \u00fcbergeben wird, um zu entscheiden, ob ein Element in die gefilterte Liste aufgenommen werden soll,</li> <li>Implementierung des Publish-Subscribe-Musters, bei dem bestimmte Objekte andere Objekte \u00fcber sich selbst betreffender Ereignisse informieren.</li> </ul> <p>Im folgenden Beispiel werden wir Objekten der zuvor erstellten Klasse <code>Person</code> erlauben, Objekte anderer Klassen frei zu benachrichtigen, wenn sich das Alter einer Person ge\u00e4ndert hat. Zu diesem Zweck f\u00fchren wir einen Delegatentyp (<code>AgeChangingDelegate</code>) ein, der den aktuellen und neuen Wert des Alters der Person in seiner Parameterliste \u00fcbergeben kann. Als N\u00e4chstes erstellen wir eine \u00f6ffentliche Mitgliedsvariable des Typs <code>AgeChangingDelegate</code> in der Klasse <code>Person</code>, die es einer externen Partei erm\u00f6glicht, die Funktion anzugeben, \u00fcber die sie die Benachrichtigung \u00fcber \u00c4nderungen an der Instanz <code>Person</code> anfordern wird.</p> <ol> <li> <p>Erstellen wir einen neuen Delegatentyp, der auf solche Funktionen verweisen kann, die <code>void</code> zur\u00fcckgeben und  zwei <code>int</code> Parameter annehmen. \u00dcberpr\u00fcfen wir, dass der neue Typ vor der Klasse <code>Person</code> definiert ist, direkt im G\u00fcltigkeitsbereich des Namespaces!</p> <pre><code>namespace PropertyDemo\n{\n    public delegate void AgeChangingDelegate(int oldAge, int newAge);\n\n    public class Person\n    {\n        // ...\n</code></pre> <p><code>AgeChangingDelegate</code> ist ein Typ (man beachte auch die VS-F\u00e4rbung), der \u00fcberall dort verwendet werden kann, wo ein Typ gesetzt werden kann (z.B. kann man eine Membervariable, eine lokale Variable, einen Funktionsparameter, etc. auf dieser Basis erstellen).</p> </li> <li> <p>Erm\u00f6glichen wir Objekten in <code>Person</code>, auf jede Funktion zu zeigen, die der obigen Signatur entspricht. Erstellen wir dazu eine Membervariable vom Typ <code>AgeChangingDelegate</code> in der Klasse <code>Person</code>! </p> <pre><code>public class Person\n{\n    public AgeChangingDelegate AgeChanging;\n</code></pre> <p>Wie objektorientiert ist das?</p> <p>Die Methodenreferenz, die als \u00f6ffentliche Membervariable erstellt wurde, verst\u00f6\u00dft (vorerst) gegen die Grunds\u00e4tze der objektorientierten Einheitsbegrenzung/Informationsverschleierung. Wir werden sp\u00e4ter darauf zur\u00fcckkommen.</p> </li> <li> <p>Rufen wir die Funktion jedes Mal auf, wenn sich das Alter unseres Person \u00e4ndert. Dazu f\u00fcgen wir dem Setter der Eigenschaft <code>Age</code> Folgendes hinzu.</p> <pre><code>public int Age\n{\n    get { return age; }\n    set \n    {\n        if (value &lt; 0)\n            throw new ArgumentException(\"Ung\u00fcltiges Alter!\");\n        if (AgeChanging != null)\n            AgeChanging(age, value);\n        age = value; \n    }\n}\n</code></pre> <p>Die obige Codezeile veranschaulichen mehrere wichtige Regeln:</p> <ul> <li>Die Validierungslogik geht in der Regel der Meldungslogik voraus.</li> <li>Es h\u00e4ngt von der Art der Meldelogik ab, ob sie vor oder nach der Auswertung ausgef\u00fchrt wird (in diesem Fall, da sich das Wort \"changing\" auf etwas in Arbeit befindliches bezieht, geht die Meldung der Auswertung voraus, das Vorkommen wird durch die Vergangenheitsform angezeigt: \"changed\")</li> <li>Beachten wir, dass noch niemand der Mitgliedsvariablen vom Typ Delegat einen Wert zugewiesen hat (kein Abonnent/Teilnehmer). In solchen F\u00e4llen w\u00fcrde der Aufruf zu einer Ausnahme f\u00fchren. \u00dcberpr\u00fcfen wir daher immer, ob die Mitgliedsvariable <code>null</code> ist, bevor wir sie aufrufen.</li> <li>Wenn das Ereignis ausgel\u00f6st wird, k\u00f6nnen wir auch die \u00dcberpr\u00fcfung von <code>null</code> und die Ausl\u00f6sung des Ereignisses auf elegantere, kompaktere und thread-sichere Weise mit dem \"<code>?.</code>\" Null-Bedingungs-Operator durchf\u00fchren (C# 6 und h\u00f6her):</li> </ul> <p>statt</p> <pre><code>if (AgeChanging != null)\n    AgeChanging(age, value);\n</code></pre> <p>k\u00f6nnen wir</p> <pre><code>AgeChanging?.Invoke(age, value);\n</code></pre> <p>schreiben.</p> <p>Das Ereignis wird nur ausgel\u00f6st, wenn es nicht <code>null</code> ist, ansonsten geschieht nichts.</p> </li> <li> <p>Genauer gesehen, sollte das Ereignis nur ausgel\u00f6st werden, wenn sich das Alter tats\u00e4chlich \u00e4ndert, d. h. die Verzweigung der Eigenschaft set sollte pr\u00fcfen, ob der neue Wert mit dem alten \u00fcbereinstimmt. Eine L\u00f6sung k\u00f6nnte darin bestehen, in der ersten Zeile des Setters sofort zur\u00fcckzukehren, wenn der neue Wert mit dem alten \u00fcbereinstimmt:</p> <pre><code>if (age == value) \n    return;\n\u2026\n</code></pre> </li> <li> <p>Wir sind fertig mit dem Code f\u00fcr die Klasse <code>Person</code>.  Kommen wir zum Abonnenten! Als erstes m\u00fcssen wir der Klasse <code>Program</code> eine neue Funktion hinzuf\u00fcgen.</p> <pre><code>class Program\n{\n    // ...\n\n    private static void PersonAgeChanging(int oldAge, int newAge)\n    {\n        Console.WriteLine(oldAge + \" =&gt; \" + newAge);\n    }\n}\n</code></pre> <p>Tipp</p> <p>\u00dcberpr\u00fcfen Sie, dass die neue Funktion im richtigen Bereich platziert ist! W\u00e4hrend der Delegatentyp au\u00dferhalb der Klasse (aber innerhalb des Namespace) platziert ist, befindet sich die Funktion innerhalb der Klasse!</p> </li> <li> <p>Melden wir uns schlie\u00dflich f\u00fcr die \u00c4nderungsverfolgung in der Funktion <code>Main</code> an!</p> <pre><code>static void Main(string[] args)\n{\n  Person p = new Person();\n  p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\n  // ...\n</code></pre> </li> <li> <p>Starten wir das Programm!</p> <p>Wenn wir z. B. einen Haltepunkt in der Zeile <code>AgeChanging?.Invoke(age, value);</code> setzen, die Anwendung debuggen und den Code schrittweise ausf\u00fchrem, k\u00f6nnen wir feststellen, dass das Ereignis bei jedem Setter-Durchlauf ausgef\u00fchrt wird, sowohl bei der ersten Wertzuweisung als auch beim Inkrement.</p> </li> <li> <p>F\u00fcgen wir der Funktion <code>Main</code> mehrere Abonnenten hinzu (mit dem Operator <code>+=</code> k\u00f6nnen wir neue Abonnenten zu den bereits vorhandenen hinzuf\u00fcgen) und f\u00fchren wir das Programm dann aus.</p> <pre><code>p.AgeChanging = new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += new AgeChangingDelegate(PersonAgeChanging);\np.AgeChanging += PersonAgeChanging; // Kompaktere Syntax\n</code></pre> <p>Es ist zu erkennen, dass alle drei registrierten/\"abonnierten\" Funktionen bei jeder Wert\u00e4nderung ausgef\u00fchrt werden. Dies ist m\u00f6glich, weil die Mitgliedsvariablen des Delegatentyps nicht nur eine Funktionsreferenz, sondern eine Funktionsreferenzliste enthalten (und pflegen).</p> <p>Beachten wir in der dritten Zeile oben, dass wir Funktionsreferenzen mit einer kompakteren Syntax schreiben k\u00f6nnen, als wir sie beim ersten Mal gesehen haben: Geben wir einfach den Namen der Funktion nach dem <code>+=</code> Operator an, ohne das <code>new AgeChangingDelegate(...)</code>.  Unabh\u00e4ngig davon wird ein <code>AgeChangingDelegate</code> -Objekt die <code>PersonAgeChanging</code> -Funktionen hinter den Kulissen umh\u00fcllen. In der Praxis verwenden wir diese kompaktere Syntax.</p> </li> <li> <p>Versuchen wir auch, uns abzumelden (an einem Punkt unserer Wahl) und starten wir dann das Programm.</p> <pre><code>p.AgeChanging -= PersonAgeChanging;\n</code></pre> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#3-aufgabe-ereignis-event","title":"3. Aufgabe - Ereignis (event)","text":"<p>So wie Eigenschaften eine syntaktisch schlankere Alternative zu Getter- und Setter-Methoden sind, bietet der oben beschriebene Delegat-Mechanismus eine schlankere Alternative zu den aus Java bekannten Event Listenern. Allerdings verst\u00f6\u00dft unsere obige L\u00f6sung immer noch erheblich gegen einige OO-Prinzipien (Einheiteneinschr\u00e4nkung, Verbergen von Informationen). Wir k\u00f6nnen dies anhand der folgenden zwei Beispiele veranschaulichen.</p> <ol> <li> <p>Das Ereignis kann auch von au\u00dfen ausgel\u00f6st werden (durch die Operationen anderer Klassen). Das ist ungl\u00fccklich, denn so kann das Ereignis f\u00e4lschlicherweise ausgel\u00f6st werden, auch wenn es in Wirklichkeit nicht eingetreten ist, und alle Teilnehmer werden get\u00e4uscht. Um dies zu demonstrieren, f\u00fcgen wir die folgende Zeile am Ende der Funktion <code>Main</code> ein.</p> <pre><code>p.AgeChanging(67, 12);\n</code></pre> <p>Hier haben wir ein gef\u00e4lschtes Alters\u00e4nderungsereignis f\u00fcr das Objekt <code>p</code> <code>Person</code> ausgel\u00f6st und damit alle Abonnenten get\u00e4uscht. Eine gute L\u00f6sung w\u00e4re, wenn das Ereignis nur durch Aktionen der Klasse <code>Person</code> ausgel\u00f6st werden k\u00f6nnte.</p> </li> <li> <p>Ein weiteres Problem ist das folgende. W\u00e4hrend <code>+=</code> und <code>-=</code> andere Funktionen, die die Liste abonniert haben, respektieren, k\u00f6nnen wir die Abonnements anderer jederzeit mit dem Operator <code>=</code> \u00fcberschreiben (l\u00f6schen). Versuchen wir dies, indem wir die folgende Zeile einf\u00fcgen (direkt nach den An- und Abmeldungen).</p> <pre><code>p.AgeChanging = null;\n</code></pre> </li> <li> <p>F\u00fcgen wir das Schl\u00fcsselwort <code>event</code> zur <code>AgeChanging</code> Member-Variable <code>Person.cs</code>hinzu!</p> Person.cs<pre><code>public event AgeChangingDelegate AgeChanging;\n</code></pre> <p>Das Schl\u00fcsselwort <code>event</code> ist eigentlich dazu gedacht, unser Programm zur\u00fcck auf den objektorientierten Weg zu zwingen und die beiden oben genannten Probleme auszuschlie\u00dfen.</p> </li> <li> <p>Lassen wir uns versuchen, das Programm zu \u00fcbersetzen. wir werden sehen, dass der \u00dcbersetzer unsere fr\u00fcheren \u00dcbertretungen jetzt als \u00dcbersetzungsfehler behandelt.</p> <p></p> </li> <li> <p>Entfernen wir die drei fehlerhaften Codezeilen (beachten wir, dass die erste direkte Wertzuweisung bereits ein Fehler ist), kompilieren wir dann und f\u00fchren wir unsere Anwendung aus!</p> </li> </ol>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#4-aufgabe-attribute","title":"4. Aufgabe - Attribute","text":""},{"location":"labor/2-nyelvi-eszkozok/index_ger/#anpassen-der-serialisierung-nach-attribut","title":"Anpassen der Serialisierung nach Attribut","text":"<p>Attribute sind ein deklarativer Weg, um Metadaten f\u00fcr Ihren Quellcode bereitzustellen. Ein Attribut ist eigentlich eine Klasse, die an ein bestimmtes Element des Programms (Typ, Klasse, Schnittstelle, Methode usw.) angeh\u00e4ngt ist. Diese Metainformationen k\u00f6nnen von jedem (auch von uns selbst) gelesen werden, w\u00e4hrend das Programm l\u00e4uft, und zwar \u00fcber einen Mechanismus, der Reflection genannt wird. Die Attribute k\u00f6nnen auch als das .NET-\u00c4quivalent zu den Java-Annotationen betrachtet werden.</p> <p>property vs. attribute vs. static</p> <p>Es stellt sich die Frage, welche Klasseneigenschaften in properties und welche in attributes einer Klasse untergebracht werden sollten. Eigenschaften beziehen sich auf die Objektinstanz selbst, w\u00e4hrend sich ein Attribut auf die Klasse (oder ein Mitglied der Klasse) bezieht, die das Objekt beschreibt.</p> <p>In dieser Hinsicht sind Attribute n\u00e4her an statischen Eigenschaften, aber es lohnt sich immer noch eine \u00dcberlegung, ob man ein bestimmtes Datenelement als statisches Mitglied oder als Attribut definiert. Mit einem Attribut ist die Beschreibung deklarativer, und wir verschmutzen den Code nicht mit Details, die nicht in der \u00f6ffentlichen Schnittstelle der Klasse erscheinen sollten.</p> <p>.NET definiert viele eingebaute Attribute, die eine gro\u00dfe Vielfalt an Funktionen haben k\u00f6nnen. Die im folgenden Beispiel verwendeten Attribute kommunizieren beispielsweise verschiedene Metainformationen mit dem XML-Serialisierer.</p> <ol> <li> <p>F\u00fcgen wir den folgenden Zeilen am Ende der Funktion <code>Main</code> ein und f\u00fchren wir dann unser Programm aus!</p> <pre><code>var serializer = new XmlSerializer(typeof(Person));\nvar stream = new FileStream(\"person.txt\", FileMode.Create);\nserializer.Serialize(stream, p);\nstream.Close();\nProcess.Start(new ProcessStartInfo\n{\n    FileName = \"person.txt\",\n    UseShellExecute = true,\n});\n</code></pre> <p>Der letzte Funktionsaufruf <code>Process.Start</code> im obigen Beispiel ist nicht Teil der Serialisierungslogik, sondern lediglich sondern nur eine kluge Methode, um die resultierende Datendatei mit dem Windows-Standardtextdateibetrachter zu \u00f6ffnen. Wir k\u00f6nnen dies versuchen, aber es h\u00e4ngt davon ab, welche .NET-Laufzeitumgebung wir verwenden und ob diese von unserem Betriebssystem unterst\u00fctzt wird. Ist dies nicht der Fall, erhalten wir bei der Ausf\u00fchrung eine Fehlermeldung. In diesem Fall lassen wir es unkommentiert und \u00f6ffnen wir die Datei <code>person.txt</code> manuell im Dateisystem (sie befindet sich in unserem Visual Studio Ordner unter \\bin\\Debug\\ neben unserer .exe Anwendung). <li> <p>Schauen wir uns die Struktur der resultierenden Datei an. Beachten wir, dass jede Eigenschaft auf das XML-Element abgebildet wird, das ihrem Namen entspricht.</p> </li> <li> <p>.NET-Attribute erm\u00f6glichen es uns, unsere Klasse <code>Person</code> mit Metadaten zu versehen, die das Verhalten der Serialisierung direkt ver\u00e4ndern. Das Attribut <code>XmlRoot</code> bietet die M\u00f6glichkeit, das Wurzelelement umzubenennen. Platzieren wir es \u00fcber der Klasse <code>Person</code>! </p> <pre><code>[XmlRoot(\"deutsche Person\")]\npublic class Person \n{\n    // ...\n}\n</code></pre> </li> <li> <p>Das <code>XmlAttribute</code> -Attribut zeigt dem Serialisier an, dass die markierte Eigenschaft auf ein xml-Attribut und nicht auf ein xml-Element abgebildet werden soll. Machen wir daraus die Eigenschaft <code>Age</code> (und nicht die Member-Variable!)!</p> <pre><code>[XmlAttribute(\"Alter\")]\npublic int Age\n</code></pre> </li> <li> <p>Das Attribut <code>XmlIgnore</code> zeigt dem Serialiser an, dass die markierte Eigenschaft vollst\u00e4ndig aus dem Ergebnis ausgelassen werden soll. Versuchen wir es \u00fcber die Eigenschaft <code>Name</code>. </p> <pre><code>[XmlIgnore]\npublic string Name { get; set; }\n</code></pre> </li> <li> <p>F\u00fchren wir unsere App aus! Vergleichen wir die Ergebnisse mit den vorherigen Ergebnissen.</p> </li>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#5-aufgabe-delegaten-2","title":"5. Aufgabe - Delegaten 2.","text":"<p>In den Aufgaben 2 und 3 haben wir ereignisbasierte Nachrichten\u00fcbermittlung mit Delegaten implementiert. Als einer anderen typischen Verwendung von Delegaten ist ihre Verwendung als Funktionsreferenzen, um eine Implementierung eines undefinierten Schritts an einen Algorithmus oder eine komplexere Operation zu \u00fcbergeben.</p> <p>Zum Beispiel kann die eingebaute generische Listenklasse (<code>List&lt;T&gt;</code>) mit der Funktion <code>FindAll</code> eine neue Liste mit allen Elementen zur\u00fcckgeben, die eine bestimmte Bedingung erf\u00fcllen. Die spezifische Filterbedingung kann als Funktion angegeben werden, genauer gesagt als Delegate-Parameter (dies ruft <code>FindAll</code> f\u00fcr jedes Element auf), der f\u00fcr jedes Element, das wir in der Ergebnisliste sehen wollen, true zur\u00fcckgibt. Der Typ des Funktionsparameters ist der folgende vordefinierte Delegatentyp (er muss nicht eingegeben/erstellt werden, er existiert bereits):</p> <pre><code>public delegate bool Predicate&lt;T&gt;(T obj)\n</code></pre> <p>Note</p> <p>Um die vollst\u00e4ndige Definition oben anzuzeigen, geben Sie einfach <code>Predicate</code> irgendwo ein, z. B. am Ende der Funktion <code>Main</code>, klicken Sie mit der Maus darauf, und verwenden Sie F12, um zur Definition zu navigieren.</p> <p>Das hei\u00dft, sie nimmt als Eingabe eine Variable des gleichen Typs wie der Typ des Listenelements und als Ausgabe einen logischen (booleschen) Wert. Um dies zu veranschaulichen, f\u00fcgen wir unserem vorherigen Programm einen Filter hinzu, der nur die ungeraden Eintr\u00e4ge in der Liste beh\u00e4lt.</p> <ol> <li> <p>Stellen wir in unserer Anwendung eine Filterfunktion bereit, die ungerade Zahlen zur\u00fcckgibt:</p> <pre><code>private static bool MyFilter(int n)\n{\n    return n % 2 == 1;\n}\n</code></pre> </li> <li> <p>Vervollst\u00e4ndigen wir den Code, den wir zuvor geschrieben haben, mit unserer Filterfunktion:</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nlist = list.FindAll(MyFilter);\n\nforeach (int n in list)\n{\n    Console.WriteLine($\"Wert: {n}\");\n}\n</code></pre> </li> <li> <p>F\u00fchren wir die Anwendung aus. Beachten wir, dass in der Konsole nur ungerade Zahlen angezeigt werden.</p> </li> <li>Als Kuriosit\u00e4t k\u00f6nnen wir einen Haltepunkt innerhalb unserer Funktion <code>MyFilter</code> setzen und beobachten, dass die Funktion tats\u00e4chlich f\u00fcr jedes Listenelement einzeln aufgerufen wird.</li> </ol> <p>Collection initializer syntax</p> <p>F\u00fcr alle Klassen (typischerweise Sammlungen) mit der Methode <code>Add</code>, die die Schnittstelle <code>IEnumerable</code> implementieren, lautet die Syntax f\u00fcr die Sammlungsinitialisierung wie folgt:</p> <pre><code>var list = new List&lt;int&gt;() { 1, 2, 3 };\n</code></pre> <p>Ab C# 12 kann eine noch einfachere Syntax (sogenannte collection expression) verwendet werden, um eine Sammlung zu initialisieren, wenn der Compiler aus dem Typ der Variablen schlie\u00dfen kann, dass es sich um eine Sammlung handelt. Z.B.:</p> <pre><code>List&lt;int&gt; list = [1, 2, 3];\n</code></pre>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#6-aufgabe-lambda-begriffe","title":"6. Aufgabe - Lambda-Begriffe","text":"<p>Die entsprechenden Themen werden in dem Vorlesungsmaterial ausf\u00fchrlich behandelt, sie werden hier nicht wiederholt. Siehe das Kapitel \"Lambda-Ausdruck\" im Dokument \"Vorlesung 02 - Sprachwerkzeuge.pdf\". Das Schl\u00fcsselelement ist <code>=&gt;</code> (Lambda-Operator), das die Definition von Lambda-Ausdr\u00fccken, d. h. anonymen Funktionen, erm\u00f6glicht.</p> <p><code>Action und Func</code></p> <p>Die in .NET eingebauten generischen Delegatentypen <code>Func</code> und <code>Action</code> werden hier aus Zeitgr\u00fcnden nicht behandelt. Sie sind immer noch Teil des grundlegende Kenntnisse!</p> <p>Die vorherige Aufgabe 5 wird wie folgt gel\u00f6st: Geben wir keine separate Filterfunktion an, sondern spezifizieren wir die Filterlogik in Form eines Lambda-Ausdrucks f\u00fcr die Operation <code>FindAll</code>. </p> <p>Wir brauchen nur eine Zeile zu \u00e4ndern:</p> <pre><code>list = list.FindAll((int n) =&gt; { return n % 2 == 1; });\n</code></pre> <p>Eine unbenannte Funktion wird definiert und an die Funtkion <code>FindAll</code> \u00fcbergeben:</p> <ul> <li>dies ist ein Lambda-Term,</li> <li>auf der linken Seite von <code>=&gt;</code> haben wir die Parameter der Operation angegeben (hier gab es nur einen),</li> <li>auf der rechten Seite von <code>=&gt;</code> haben wir der Stamm der Operation angegeben (die gleiche wie der Stamm der vorherigen <code>MyFilter</code> ).</li> </ul> <p>Die obige Zeile kann in einer viel einfacheren und klareren Form geschrieben werden:</p> <pre><code>list = list.FindAll(n =&gt; n % 2 == 1);\n</code></pre> <p>Es wurden die folgenden Vereinfachungen vorgenommen:</p> <ul> <li>wird der Typ des Parameters nicht geschrieben: der Compiler kann ihn aus dem Typ des Delegatenparameters von <code>FindAll</code> ableiten, der <code>Predicate</code>ist.</li> <li>die Klammern um den Parameter k\u00f6nnen weggelassen werden (da es nur einen Parameter gibt)</li> <li>auf der rechten Seite von <code>=&gt;</code> k\u00f6nnten wir die Klammern und <code>return</code> weglassen (weil es nur einen Ausdruck im Funktionsrumpf gab, der von der Funktion zur\u00fcckgegeben wird).</li> </ul>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#7-andere-sprachkonstruktionen","title":"7. Andere Sprachkonstruktionen","text":"<p>Im Folgenden werfen wir einen Blick auf einige der C#-Sprachelemente, die bei allt\u00e4glichen Programmieraufgaben immer h\u00e4ufiger verwendet werden. W\u00e4hrend der \u00dcbung kann es sein, dass keine Zeit bleibt, diese zu \u00fcberpr\u00fcfen.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#ausdruckskorpermember-expression-bodied-members","title":"Ausdrucksk\u00f6rpermember (Expression-bodied members)","text":"<p>Manchmal schreiben wir kurze Funktionen oder, im Falle von Eigenschaften, sehr oft kurze get/set/init-Definitionen, die aus einem einzigen Ausdruck bestehen. In diesem Fall kann der get/set/init-Stamm einer Funktion oder Eigenschaft unter Verwendung der Syntax f\u00fcr sogenannten Ausdrucksk\u00f6rpermember (expression-bodied members) angegeben werden, unter <code>=&gt;</code>.  Dies kann unabh\u00e4ngig davon geschehen, ob es im Kontext einen R\u00fcckgabewert (Return-Anweisung) gibt oder nicht.</p> <p>In den Beispielen werden wir sehen, dass die Verwendung von Ausdrucks-Tags nichts weiter als eine kleine syntaktische \"Wendung\" ist, um die Notwendigkeit zu minimieren, so viel umgebenden Code wie m\u00f6glich in solch einfachen F\u00e4llen zu schreiben.</p> <p>Schauen wir uns zun\u00e4chst ein Funktionsbeispiel an (angenommen, die Klasse hat eine Mitgliedsvariable oder eine Eigenschaft <code>Age</code> ):</p> <p><pre><code>public int GetAgeInDogYear() =&gt; Age * 7; \npublic void DisplayName() =&gt; Console.WriteLine(ToString());\n</code></pre> Wie wir sehen k\u00f6nnen, haben wir die Klammern und die Anweisung <code>return</code> entfernt, so dass die Syntax kompakter ist.</p> <p>Wichtig</p> <p>Obwohl hier das Token <code>=&gt;</code> verwendet wird, hat dies nichts mit den zuvor besprochenen Lambda-Ausdr\u00fccken zu tun: Es ist einfach so, dass dasselbe <code>=&gt;</code> Token (Symbolpaar) von C# f\u00fcr zwei v\u00f6llig unterschiedliche Dinge verwendet wird.</p> <p>Beispiel f\u00fcr die Angabe eines Property Getters:</p> <pre><code>public int AgeInDogYear { get =&gt; Age * 7; }\n</code></pre> <p>Wenn wir nur einen Getter f\u00fcr die Eigenschaft haben, k\u00f6nnen wir sogar das Schl\u00fcsselwort <code>get</code> und die Klammern weglassen.</p> <pre><code>public int AgeInDogYear =&gt; Age * 7;\n</code></pre> <p>Der Unterschied zur \u00e4hnlichen Syntax der bisherigen Funktionen ist, dass wir die geschweifte Klammern nicht ausgeschrieben haben.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#objektinitialisierer-object-initializer","title":"Objektinitialisierer (Object initializer)","text":"<p>Die Initialisierung von \u00f6ffentlichen Eigenschaften/Mitgliedsvariablen und der Aufruf des Konstruktors k\u00f6nnen mit einer Syntax kombiniert werden, die als Objektinitialisierung bezeichnet wird. Dazu wird nach dem Konstruktoraufruf ein Block mit geschweifte Klammern ge\u00f6ffnet, in dem der Wert der \u00f6ffentlichen Eigenschaften/Mitgliedsvariablen unter Verwendung der folgenden Syntax angegeben werden kann.</p> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Lukas\",\n};\n</code></pre> <p>Eigenschaften/Mitglieder werden initialisiert, nachdem der Konstruktor ausgef\u00fchrt wurde (wenn die Klasse einen Konstruktor hat). Diese Syntax ist auch deshalb vorteilhaft, weil sie als ein Ausdruck z\u00e4hlt (im Gegensatz zu drei Ausdr\u00fccken, wenn wir ein nicht initialisiertes Objekt <code>Person</code> erstellen und dann in zwei weiteren Schritten Werte an <code>Age</code> und <code>Name</code> \u00fcbergeben). Auf diese Weise k\u00f6nnen wir ein initialisiertes Objekt direkt als Parameter f\u00fcr einen Funktionsaufruf \u00fcbergeben, ohne eine separate Variable deklarieren zu m\u00fcssen.</p> <pre><code>void Foo(Person p)\n{\n    // etwas mit p machen\n}\n</code></pre> <pre><code>Foo(new Person() { Age = 17, Name = \"Lukas\" });\n</code></pre> <p>Die Syntax ist auch zum Kopieren und Einf\u00fcgen geeignet, denn wie wir in den obigen Beispielen sehen k\u00f6nnen, spielt es keine Rolle, ob nach der letzten Eigenschaft ein Komma steht oder nicht.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#eigenschaften-init-only-setter","title":"Eigenschaften - Init only setter","text":"<p>Die Syntax f\u00fcr die Objektinitialisierung im vorigen Abschnitt ist sehr praktisch, erfordert aber, dass die Eigenschaft \u00f6ffentlich ist. Wenn wir m\u00f6chten, dass eine Eigenschaft nur bei der Erstellung des Objekts auf einen Wert gesetzt wird, m\u00fcssen wir einen Konstruktorparameter einf\u00fchren und ihn auf eine Nur-Lesbare-Eigenschaft (Getter-Only) setzen. Eine einfachere L\u00f6sung f\u00fcr dieses Problem ist die so genannte Init only setter-Syntax, bei der wir mit dem Schl\u00fcsselwort <code>init</code> einen \"Setter\" erstellen k\u00f6nnen, der nur im Konstruktor und in der im vorigen Kapitel beschriebenen Syntax f\u00fcr die Objektinitialisierung gesetzt werden darf, nicht aber danach.</p> <pre><code>public string Name { get; init; }\n</code></pre> <pre><code>var p = new Person()\n{\n    Age = 17,\n    Name = \"Lukas\",\n};\n\np.Name = \"Test\"; // Erstellungsfehler, kann nicht nachtr\u00e4glich ge\u00e4ndert werden\n</code></pre> <p>Wir k\u00f6nnen auch den init only setter als obligatorisch festlegen, indem wir das Schl\u00fcsselwort <code>required</code> f\u00fcr die Eigenschaft verwenden. In diesem Fall muss der Wert der Eigenschaft in der Syntax der Objektinitialisierung angegeben werden, da sonst ein \u00dcbersetzungsfehler auftritt.</p> <pre><code>public required string Name { get; init; }\n</code></pre> <p>Dies ist auch deshalb n\u00fctzlich, weil wir die obligatorischen Konstruktorparameter speichern k\u00f6nnen, wenn wir die Eigenschaften der Klasse ohnehin ver\u00f6ffentlichen und die Syntax der Objektinitialisierung unterst\u00fctzen wollen.</p>"},{"location":"labor/2-nyelvi-eszkozok/index_ger/#8-aufgabe-generische-klassen","title":"8. Aufgabe - Generische Klassen","text":"<p>Hinweis: Die Zeit f\u00fcr diese \u00dcbung reicht wahrscheinlich nicht aus. In diesem Fall ist es ratsam, die \u00dcbung zu Hause zu machen.</p> <p>Generische Klassen in .NET \u00e4hneln den Template-Klassen in C++, sind aber n\u00e4her an den bereits bekannten generischen Klassen in Java. Sie k\u00f6nnen verwendet werden, um generische (Multi-Typ), aber typsichere Klassen zu erstellen. Wenn wir ohne generische Klassen ein Problem allgemein behandeln wollen, verwenden wir Daten des Typs <code>object</code> (da in .NET alle Klassen von der Klasse <code>object</code> abgeleitet sind). Dies ist z. B. bei <code>ArrayList</code>der Fall, einer Allzwecksammlung zum Speichern beliebiger Elemente des Typs <code>object</code>.  Schauen wir uns ein Beispiel f\u00fcr die Verwendung von <code>ArrayList</code> an:</p> <pre><code>var list = new ArrayList();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    //cast ist n\u00f6tig, sonder es kann nicht kompiliert werden\n    int i = (int)list[n];\n    Console.WriteLine($\"Wert: {i}\");\n}\n</code></pre> <p>Bei der obigen L\u00f6sung ergeben sich folgende Probleme:</p> <ul> <li><code>ArrayList</code> speichert jedes Element als <code>object</code>.</li> <li>Wenn wir auf ein Element in der Liste zugreifen wollen, m\u00fcssen wir es immer in den richtigen Typ umwandeln.</li> <li>Nicht typsicher. Im obigen Beispiel hindert wir nichts (und keine Fehlermeldung) daran, ein Objekt eines anderen Typs in die Liste neben dem Typ <code>int</code> einzuf\u00fcgen. In diesem Fall w\u00fcrden wir nur dann einen Fehler erhalten, wenn wir versuchen, den Typ, der nicht <code>int</code> ist, auf <code>int</code> zu \u00fcbertragen. Bei der Verwendung generischer Sammlungen werden solche Fehler w\u00e4hrend der \u00dcbersetzung erkannt.</li> <li>Bei der Speicherung von Daten des Typs \"Wert\" ist die Liste langsamer, da der Typ \"Wert\" zun\u00e4chst in eine Box eingeschlossen werden muss, um als <code>object</code>(d. h. als Referenztyp) gespeichert werden zu k\u00f6nnen.</li> </ul> <p>Die L\u00f6sung des obigen Problems unter Verwendung einer allgemeinen Liste sieht wie folgt aus (in der \u00dcbung wird nur die hervorgehobene Zeile im zuvor eingegebenen Beispiel ge\u00e4ndert):</p> <pre><code>var list = new List&lt;int&gt;();\nlist.Add(1);\nlist.Add(2);\nlist.Add(3);\nfor (int n = 0; n &lt; list.Count; n++)\n{\n    int i = list[n]; // Kein cast erforderlich\n    Console.WriteLine($\"Wert: {i}\");\n}\n</code></pre>"},{"location":"labor/3-felhasznaloi-felulet/","title":"3. A felhaszn\u00e1l\u00f3i fel\u00fclet kialak\u00edt\u00e1sa","text":""},{"location":"labor/3-felhasznaloi-felulet/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja megismerkedni a vastagkliens alkalmaz\u00e1sok fejleszt\u00e9s\u00e9nek alapjaival a deklarat\u00edv XAML fel\u00fcletle\u00edr\u00f3 technol\u00f3gi\u00e1n kereszt\u00fcl. Az itt tanult alapok az \u00f6sszes XAML dialektusra (WinUI, WPF, UWP, Xamarin.Forms, MAUI) igazak lesznek, vagy nagyon hasonl\u00f3an lehet \u0151ket alkalmazni, mi viszont a mai \u00f3r\u00e1n specifikusan a WinAppSDK / WinUI 3 keretrendszeren kereszt\u00fcl fogjuk haszn\u00e1lni a XAML-t.</p>"},{"location":"labor/3-felhasznaloi-felulet/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul> <p>A sz\u00fcks\u00e9ges fejleszt\u0151k\u00f6rnyezetr\u0151l itt tal\u00e1lhat\u00f3 le\u00edr\u00e1s.</p> <p>Fejleszt\u0151k\u00f6rnyezet WinUI3 fejleszt\u00e9shez</p> <p>A kor\u00e1bbi laborokhoz k\u00e9pest plusz komponensek telep\u00edt\u00e9se sz\u00fcks\u00e9ges. A fenti oldal eml\u00edti, hogy sz\u00fcks\u00e9g van a \".NET desktop development\" Visual Studio Workload telep\u00edt\u00e9s\u00e9re, valamint ugyanitt az oldal alj\u00e1n van egy \"WinUI t\u00e1mogat\u00e1s\" fejezet, az itt megadott l\u00e9p\u00e9seket is mindenk\u00e9ppen meg kell tenni!</p>"},{"location":"labor/3-felhasznaloi-felulet/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el a <code>megoldas</code> \u00e1gon. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre a <code>megoldas</code> \u00e1gat:</p> <p><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/3-felhasznaloi-felulet/#kiindulo-projekt","title":"Kiindul\u00f3 projekt","text":"<p>Az els\u0151 feladatban kialak\u00edtjuk a k\u00f6rnyezetet, amelyben a tov\u00e1bbiakban a XAML nyelv \u00e9s a WinUI keretrendszer m\u0171k\u00f6d\u00e9s\u00e9t vizsg\u00e1ljuk. A kiindul\u00f3 projektet a Visual Studi\u00f3val is legener\u00e1lhatn\u00e1nk (WinUI 3 projekt, Blank App, Packaged (WinUI 3 in Desktop) t\u00edpus), de az \u00f3ra g\u00f6rd\u00fcl\u00e9kenys\u00e9ge \u00e9rdek\u00e9ben az el\u0151re elk\u00e9sz\u00edtett projektet fogjuk haszn\u00e1lni.</p> <p>A projektet a k\u00f6vetkez\u0151 parancs kiad\u00e1s\u00e1val tudjuk lekl\u00f3nozni a g\u00e9p\u00fcnkre:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo.git\n</code></pre> <p>Nyissuk meg a <code>HelloXaml.sln</code>-t.</p> <p>Tekints\u00fck \u00e1t milyen f\u00e1jlokat tartalmaz a projekt:</p> <ul> <li>App<ul> <li>K\u00e9t f\u00e1jl <code>App.xaml</code> \u00e9s <code>App.xaml.cs</code>(k\u00e9s\u0151bb tiszt\u00e1zzuk, k\u00e9t f\u00e1jl tartozik hozz\u00e1)</li> <li>Alkalmaz\u00e1s bel\u00e9p\u00e9si pontja: <code>OnLaunched</code> fel\u00fcldefini\u00e1lt met\u00f3dus az <code>App.xaml.cs</code>-ben</li> <li>Eset\u00fcnkben itt inicializ\u00e1ljuk az alkalmaz\u00e1s egyetlen ablak\u00e1t a <code>MainWindow</code>-t</li> </ul> </li> <li>MainWindow<ul> <li>Alkalmaz\u00e1sunk f\u0151ablak\u00e1hoz tartoz\u00f3 .xaml \u00e9s .xaml.cs f\u00e1jlok.</li> </ul> </li> </ul> Tov\u00e1bbi solution elemek <p>A kiindul\u00f3 VS solution a k\u00f6vetkez\u0151 elemeket tartalmazza m\u00e9g:</p> <ul> <li>Dependencies<ul> <li>Frameworks<ul> <li><code>Microsoft.AspNetCore.App</code>: .NET SDK metapackage (Microsoft .NET \u00e9s SDK alapcsomagokat hivatkozza be)</li> <li>Windows specifikus .NET SDK</li> </ul> </li> <li>Packages<ul> <li>Windows SDK Build Tools</li> <li>WindowsAppSDK</li> </ul> </li> </ul> </li> <li>Assets<ul> <li>Alkalmaz\u00e1s log\u00f3i</li> </ul> </li> <li>app.manifest, Package.appxmanifest<ul> <li>Az alkalmaz\u00e1s metaadatait tartalmaz\u00f3 XML \u00e1llom\u00e1ny, melyben t\u00f6bbek k\u00f6z\u00f6tt megadhatjuk a log\u00f3kat, vagy pl. Androidhoz hasonl\u00f3an itt kell jogot k\u00e9rj\u00fcnk a biztons\u00e1gkritikus rendszerer\u0151forr\u00e1sokhoz.</li> </ul> </li> </ul> <p>Futtassuk az alkalmaz\u00e1st!</p>"},{"location":"labor/3-felhasznaloi-felulet/#xaml-bevezetes","title":"XAML bevezet\u00e9s","text":"<p>A fel\u00fclet le\u00edr\u00e1s\u00e1t egy XML alap\u00fa le\u00edr\u00f3 nyelvben, XAML-ben (ejtsd: zem\u00f6l) fogjuk megadni.</p> <p>Grafikus designer fel\u00fclet</p> <p>Bizonyos XAML dialektusok eset\u00e9ben (pl.: WPF) rendelkez\u00e9s\u00fcnkre \u00e1ll grafikus designer eszk\u00f6z is a fel\u00fclet kialak\u00edt\u00e1s\u00e1hoz, de az \u00e1ltal\u00e1ban kev\u00e9sb\u00e9 hat\u00e9kony XAML le\u00edr\u00e1st szokott gener\u00e1lni. R\u00e1ad\u00e1sul m\u00e1r a Visual Studio is t\u00e1mogatja a Hot Reload m\u0171k\u00f6d\u00e9st XAML esetben, \u00edgy nem sz\u00fcks\u00e9ges le\u00e1ll\u00edtani az alkalmaz\u00e1st a XAML szerkeszt\u00e9se k\u00f6zben, a v\u00e1ltoztat\u00e1sokat pedig azonnal l\u00e1thatjuk a fut\u00f3 alkalmaz\u00e1sban. Ez\u00e9rt WinUI eset\u00e9ben m\u00e1r nem is kapunk designer t\u00e1mogat\u00e1st a Visual Studioban. A tapasztalatok alapj\u00e1n vannak limit\u00e1ci\u00f3i, \"nagyobb\" l\u00e9pt\u00e9k\u0171 v\u00e1ltoztat\u00e1sok eset\u00e9n sz\u00fcks\u00e9g van az alkalmaz\u00e1s \u00fajraind\u00edt\u00e1s\u00e1ra.</p>"},{"location":"labor/3-felhasznaloi-felulet/#xaml-nyelvi-alapok","title":"XAML nyelvi alapok","text":"<p>A XAML nyelv:</p> <ul> <li>Objektump\u00e9ld\u00e1nyos\u00edt\u00f3 nyelv</li> <li>Szabv\u00e1nyos XML</li> <li>XML elemek/tagek: objektumokat p\u00e9ld\u00e1nyos\u00edtanak, melyek oszt\u00e1lyai szabv\u00e1nyos .NET oszt\u00e1lyok</li> <li>XML attrib\u00fatumok: tulajdons\u00e1gokat (dependency property-ket) \u00e1ll\u00edtanak be</li> <li>Deklarat\u00edv</li> </ul> <p>N\u00e9zz\u00fck meg, milyen XAML-t gener\u00e1lt a projekt sablon (<code>MainWindow.xaml</code>). L\u00e1thatjuk, hogy a XAML-ben minden vez\u00e9rl\u0151h\u00f6z l\u00e9trehozott egy XML elemet/taget. A vez\u00e9rl\u0151k tagjein pedig be vannak \u00e1ll\u00edtva a vez\u00e9rl\u0151 tulajdons\u00e1gai. Pl. <code>HorizontalAlignment</code>: igaz\u00edt\u00e1s a kont\u00e9neren (eset\u00fcnkben ablakon) bel\u00fcl. Vez\u00e9rl\u0151k tartalmazhatnak m\u00e1s vez\u00e9rl\u0151ket, \u00edgy vez\u00e9rl\u0151kb\u0151l \u00e1ll\u00f3 fa j\u00f6n l\u00e9tre.</p> <p>N\u00e9zz\u00fck meg r\u00e9szletesebben a <code>MainWindow.xaml</code>-t:</p> <ul> <li>Gy\u00f6k\u00e9r tagen n\u00e9vterek: meghat\u00e1rozz\u00e1k, hogy az XML-ben milyen tageket \u00e9s attrib\u00fatumokat haszn\u00e1lhatunk<ul> <li>Alap\u00e9rtelmezett n\u00e9vt\u00e9r: XAML elemek/vez\u00e9rl\u0151k (pl. <code>Button</code>, <code>TextBox</code> stb.) n\u00e9vtere</li> <li><code>x</code> n\u00e9vt\u00e9r: XAML parser n\u00e9vtere (pl.: <code>x:Class</code>, <code>x:Name</code>)</li> <li>Egy\u00e9b tetsz\u0151leges n\u00e9vterek hivatkozhat\u00f3k</li> </ul> </li> <li><code>Window</code> gy\u00f6k\u00e9r tag<ul> <li>Az ablakunk/oldalunk alapj\u00e1n egy .NET oszt\u00e1ly j\u00f6n l\u00e9tre, mely a <code>Window</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik.</li> <li>A lesz\u00e1rmaztatott oszt\u00e1lyunk nev\u00e9t az <code>x:Class</code> attrib\u00fatum hat\u00e1rozza meg: az <code>x:Class=\"HelloXaml.MainWindow\"</code> alapj\u00e1n egy <code>HelloXaml</code> n\u00e9vt\u00e9rben egy <code>MainWindow</code> nev\u0171 oszt\u00e1ly lesz.</li> <li>Ez egy partial class, az oszt\u00e1ly \"m\u00e1sik fele\" az ablakhoz/oldalhoz tartoz\u00f3 \u00fan. a code-behind f\u00e1jlban (<code>MainWindow.xaml.cs</code>) tal\u00e1lhat\u00f3. L\u00e1sd k\u00f6vetkez\u0151 pont.</li> </ul> </li> <li>Code-behind f\u00e1jl (<code>MainWindow.xaml.cs</code>):<ul> <li>A partial classunk m\u00e1sik \"fele\": ellen\u0151rizz\u00fck, hogy itt az oszt\u00e1ly neve \u00e9s n\u00e9vtere megegyezik a .xaml f\u00e1jlban megadottal (partial class!).</li> <li>Esem\u00e9nykezel\u0151 \u00e9s seg\u00e9df\u00fcggv\u00e9nyeket tessz\u00fck ide (t\u00f6bbek k\u00f6z\u00f6tt).</li> <li><code>this.InitializeComponent();</code>: a konstruktorban mindig meg kell h\u00edvni, ez olvassa majd be fut\u00e1s k\u00f6zben a XAML-t, ez p\u00e9ld\u00e1nyos\u00edtja, inicializ\u00e1lja az ablak/oldal tartalm\u00e1t (vagyis a XAML-f\u00e1jlban megadott vez\u00e9rl\u0151ket az ott meghat\u00e1rozott tulajdons\u00e1gokkal).</li> </ul> </li> </ul> <p>T\u00f6r\u00f6lj\u00fck ki a <code>Window</code> tartalm\u00e1t \u00e9s a code-behind f\u00e1jlb\u00f3l az esem\u00e9nykezel\u0151t (<code>myButton_Click</code> f\u00fcggv\u00e9ny). Most k\u00e9zzel fogunk XAML-t \u00edrni \u00e9s ezzel a fel\u00fcletet kialak\u00edtani. Vegy\u00fcnk fel egy <code>Grid</code>-et a <code>Window</code>-ba, mellyel a k\u00e9s\u0151bbiekben egy t\u00e1bl\u00e1zatos elrendez\u00e9st (layout) fogunk tudunk kialak\u00edtani:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;Window\n    x:Class=\"HelloXaml.MainWindow\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloXaml\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"&gt;\n\n    &lt;Grid&gt;\n\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> <p>Futtassuk az alkalmaz\u00e1st (pl. az F5 billenty\u0171vel). A <code>Grid</code> most kit\u00f6lti a teljes ablakot, a sz\u00edne megegyezik az ablak h\u00e1tt\u00e9rsz\u00edn\u00e9vel, ez\u00e9rt szemmel nem tudjuk megk\u00fcl\u00f6nb\u00f6ztetni.</p> <p>A k\u00f6vetkez\u0151 feladatok sor\u00e1n hagyjuk futni az alkalmaz\u00e1st, hogy azonnal l\u00e1thassuk a fel\u00fcleten eszk\u00f6z\u00f6lt m\u00f3dos\u00edt\u00e1sainkat.</p> <p>Hot Reload limit\u00e1ci\u00f3k</p> <p>Tartsuk szem el\u0151tt a Hot Reload limit\u00e1ci\u00f3it: ha egy v\u00e1ltoz\u00e1sunk nem akar a fut\u00f3 alkalmaz\u00e1s fel\u00fclet\u00e9n megjelenni, akkor ind\u00edtsuk majd \u00fajra az alkalmaz\u00e1st!</p>"},{"location":"labor/3-felhasznaloi-felulet/#objektum-peldanyok-es-tulajdonsagaik","title":"Objektum p\u00e9ld\u00e1nyok \u00e9s tulajdons\u00e1gaik","text":"<p>Most azt n\u00e9zz\u00fck meg, hogyan tudunk XAML alapokon objektumokat p\u00e9ld\u00e1nyos\u00edtani \u00e9s ezen objektumok tulajdons\u00e1gait be\u00e1ll\u00edtani.</p> <p>Vegy\u00fcnk fel a <code>Grid</code> belsej\u00e9be egy <code>Button</code>-t. A <code>Content</code> tulajdons\u00e1ggal adhatjuk meg a gomb sz\u00f6veg\u00e9t, pontosabban a tartalm\u00e1t.</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Ez azon a helyen, ahol deklar\u00e1ltuk, fut\u00e1s k\u00f6zben l\u00e9trehoz egy <code>Button</code> objektumot, \u00e9s a <code>Content</code> tulajdons\u00e1g\u00e1t a \"Hello WinUI App!\" sz\u00f6vegre \u00e1ll\u00edtja. Ezt megtehett\u00fck volna a code-behind f\u00e1jlban C# nyelven is k\u00f6vetkez\u0151k\u00e9ppen (de ez kev\u00e9sb\u00e9 olvashat\u00f3 k\u00f3dot eredm\u00e9nyezne):</p> <pre><code>// Pl. a konstruktor v\u00e9g\u00e9re be\u00edrva:\n\nButton b = new Button();\nb.Content = \"Hello WinUI App!\";\nrootGrid.Children.Add(b); \n// Az el\u0151z\u0151 a sorhoz XAML f\u00e1jlban a Gridnek meg kellene adni az x:Name=\"rootGrid\" \n// attrib\u00fatumot, hogy rootGrid n\u00e9ven el\u00e9rhet\u0151 legyen a code-behind f\u00e1jlban\n</code></pre> <p> Ez a p\u00e9lda nagyon j\u00f3l szeml\u00e9lteti, hogy a XAML alapvet\u0151en egy objektump\u00e9ld\u00e1nyos\u00edt\u00f3 nyelv, \u00e9s t\u00e1mogatja objektumok tulajdons\u00e1gainak be\u00e1ll\u00edt\u00e1s\u00e1t.</p> <p>A <code>Content</code> tulajdons\u00e1g k\u00fcl\u00f6nleges, nem csak XML attrib\u00fatumban lehet megadni, hanem tagen (XML elemen) bel\u00fcl is.</p> <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre> <p>S\u0151t! A gombra nem csak feliratot rakhatunk, hanem tetsz\u0151leges m\u00e1s elemet. Pl. rakjunk bele egy piros k\u00f6rt. A k\u00f6r 10 pixel sz\u00e9les, 10 pixel magas, a sz\u00edn (<code>Fill</code>) pedig piros.</p> <pre><code>&lt;Button&gt;\n    &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n&lt;/Button&gt;\n</code></pre> <p>Ezt kor\u00e1bbi .NET UI technol\u00f3gi\u00e1k eset\u00e9ben (pl. Windows Forms) nem lett volna ilyen egyszer\u0171 megval\u00f3s\u00edtani.</p> <p>Legyen most a piros k\u00f6r mellett a Record felirat (hogy \u00e9rtelme is legyen a piros k\u00f6r\u00f6s gombnak). A gombnak csak egy gyereke lehet, ez\u00e9rt egy layout vez\u00e9rl\u0151be (pl. egy <code>StackPanel</code>-be) kell beraknunk a k\u00f6rt \u00e9s a sz\u00f6veget (<code>TextBlock</code>). Adjunk egy bal oldali marg\u00f3t is a <code>TextBlock</code>-nak, hogy ne \u00e9rjenek \u00f6ssze.</p> <pre><code>&lt;Button&gt;\n    &lt;StackPanel Orientation=\"Horizontal\"&gt;\n        &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n        &lt;TextBlock Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n    &lt;/StackPanel&gt;\n&lt;/Button&gt;\n</code></pre> <p>A <code>StackPanel</code> egy egyszer\u0171, vez\u00e9rl\u0151k elrendez\u00e9s\u00e9re szolg\u00e1l\u00f3 layout panel:  a tartalmazott vez\u00e9rl\u0151ket <code>Horizontal</code> <code>Orientation</code> megad\u00e1sa eset\u00e9n egym\u00e1s mell\u00e9, <code>Vertical</code> <code>Orientation</code> eset\u00e9n egym\u00e1s al\u00e1 helyezi el. \u00cdgy a p\u00e9ld\u00e1nkban egyszer\u0171en egym\u00e1s mell\u00e9 teszi a k\u00e9t vez\u00e9rl\u0151t.</p> <p>Az eredm\u00e9ny a k\u00f6vetkez\u0151:</p> <p></p> <p>XAML vektorgrafikus vez\u00e9rl\u0151k</p> <p>L\u00e9nyeges, hogy a XAML vez\u00e9rl\u0151k nagy r\u00e9sze vektorgrafikus. Ez a gomb ugyanolyan \u00e9lesen fog kin\u00e9zni (nem tapasztalunk \"pixelesed\u00e9st\") b\u00e1rmilyen b\u00e1rmilyen DPI  ill. nagy\u00edt\u00e1s mellett n\u00e9zz\u00fck.</p> <p>A XAML-ben p\u00e9ld\u00e1nyos\u00edtott vez\u00e9rl\u0151k tulajdons\u00e1gainak megad\u00e1s\u00e1ra h\u00e1rom lehet\u0151s\u00e9g van (ezeket r\u00e9szben haszn\u00e1ltuk is m\u00e1r):</p> <ul> <li>Property ATTRIBUTE syntax</li> <li>Property ELEMENT syntax</li> <li>Property CONTENT syntax</li> </ul> <p>Tekints\u00fck \u00e1t most r\u00e9szletesebben ezeket a lehet\u0151s\u00e9geket:</p> <ol> <li> <p>Property ATTRIBUTE syntax.  M\u00e1r alkalmaztuk, m\u00e9gpedig a legels\u0151 p\u00e9ld\u00e1nkban:</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Az elnevez\u00e9s onnan ered, hogy a tulajdons\u00e1got XML attrib\u00fatum form\u00e1j\u00e1ban adjuk meg. Seg\u00edts\u00e9g\u00e9vel - mivel XML attrib\u00fatum csak string lehet! - csak sztring form\u00e1ban megadott egyszer\u0171 sz\u00e1m/sztring/stb. \u00e9rt\u00e9k, ill. code-behind f\u00e1jlban defini\u00e1lt tagv\u00e1ltoz\u00f3, esem\u00e9nykezel\u0151 \u00e9rhet\u0151 el. De t\u00edpuskonverterek seg\u00edts\u00e9g\u00e9vel \"\u00f6sszetett\" objektumok is megadhat\u00f3k. Err\u0151l sok sz\u00f3 nem lesz, de a be\u00e9p\u00edtett t\u00edpuskonvertereket sokszor haszn\u00e1ljuk, gyakorlatilag \"\u00f6szt\u00f6n\u00f6sen\". P\u00e9lda:</p> <p>Vegy\u00fcnk fel a <code>Grid</code>-re egy h\u00e1tt\u00e9rsz\u00ednt:</p> <pre><code>&lt;Grid Background=\"Azure\"&gt;\n</code></pre> <p>Vagy megadhatjuk hex\u00e1ban is:</p> <pre><code>&lt;Grid Background=\"#FFF0FFFF\"&gt;\n</code></pre> <p>A marg\u00f3 (<code>Margin</code>) is egy \u00f6sszetett \u00e9rt\u00e9k, a hozz\u00e1 tartoz\u00f3 t\u00edpuskonveter vessz\u0151vel (vagy sz\u00f3k\u00f6zzel) elv\u00e1lasztva v\u00e1rja a n\u00e9gy oldalra vonatkoz\u00f3 \u00e9rt\u00e9keket (bal, fent, jobb, lent). M\u00e1r haszn\u00e1ltuk is a <code>Record</code> felirat\u00fa TextBlockunk eset\u00e9ben. Megjegyz\u00e9s: marg\u00f3nak egyetlen sz\u00e1m is megadhat\u00f3, akkor mind a n\u00e9gy oldalra ugyanazt fogja alkalmazni.</p> </li> <li> <p>Property ELEMENT syntax. Seg\u00edts\u00e9g\u00e9vel egy tulajdons\u00e1got t\u00edpuskonverterek n\u00e9lk\u00fcl tudjuk egy \u00f6sszetett m\u00f3don p\u00e9ld\u00e1nyos\u00edtott/felparam\u00e9terezett objektumra \u00e1ll\u00edtani. N\u00e9zz\u00fck egy p\u00e9ld\u00e1n kereszt\u00fcl.</p> <ul> <li>A fenti p\u00e9ld\u00e1ban <code>Background</code> tulajdons\u00e1g be\u00e1ll\u00edt\u00e1sakor az <code>Azure</code> val\u00f3j\u00e1ban egy <code>SolidColorBrush</code>-t hoz l\u00e9tre, melynek a sz\u00edn\u00e9t vil\u00e1gosk\u00e9kre \u00e1ll\u00edtja. Ezt t\u00edpuskonverter alkalmaz\u00e1sa n\u00e9lk\u00fcl az al\u00e1bbi m\u00f3don lehet megadni:</li> </ul> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush Color=\"Azure\" /&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p>Ez a <code>Grid</code> <code>Background</code> tulajdons\u00e1g\u00e1t \u00e1ll\u00edtja be a megadott <code>SolidColorBrush</code>-ra. Ez az \u00fan. \"property element syntax\" alap\u00fa tulajdons\u00e1gmegad\u00e1s.</p> <ul> <li>A n\u00e9v onnan ered, hogy a tulajdons\u00e1got egy XML elem (\u00e9s pl. nem XML attrib\u00fatum) form\u00e1j\u00e1ban adjuk meg.</li> <li> Itt a <code>&lt;Grid.Background&gt;</code> elem nem objektump\u00e9ld\u00e1nyt hoz l\u00e9tre, hanem az adott (eset\u00fcnkben <code>Background</code>) property \u00e9rt\u00e9k\u00e9t \u00e1ll\u00edtja be a megfelel\u0151 objektum p\u00e9ld\u00e1ny\u00e1ra (eset\u00fcnkben egy <code>SolidColorBrush</code>-ra). Ezt az XML elem nev\u00e9ben lev\u0151 pont alapj\u00e1n lehet tudni.</li> <li>Ez \"terjeng\u0151sebb\" forma tulajdons\u00e1g megad\u00e1s\u00e1ra, de teljes rugalmass\u00e1got biztos\u00edt. </li> </ul> <p>Cser\u00e9lj\u00fck le a <code>SolidColorBrush</code>-t egy sz\u00edn\u00e1tmenetes <code>Brush</code>-ra (<code>LinearGradientBrush</code>):</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;LinearGradientBrush&gt;\n            &lt;LinearGradientBrush.GradientStops&gt;\n                &lt;GradientStop Color=\"Black\" Offset=\"0\" /&gt;\n                &lt;GradientStop Color=\"White\" Offset=\"1\" /&gt;\n            &lt;/LinearGradientBrush.GradientStops&gt;\n        &lt;/LinearGradientBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p><code>LinearGradientBrush</code>-ra nincs t\u00edpuskonverter, ezt csak az element syntax seg\u00edts\u00e9g\u00e9vel tudtuk megadni!</p> <p>K\u00e9rd\u00e9s, hogyan lehets\u00e9ges az, hogy a <code>Grid</code> vez\u00e9rl\u0151 <code>Background</code> tulajdons\u00e1g\u00e1nak <code>SolidColorBrush</code> \u00e9s <code>LinearGradientBrush</code> t\u00edpus\u00fa ecsetet is meg tudtunk adni? A v\u00e1lasz nagyon egyszer\u0171, a polimorfizmus teszi ezt lehet\u0151v\u00e9:</p> <ul> <li>A <code>SolidColorBrush</code> \u00e9s <code>LinearGradientBrush</code> oszt\u00e1lyok a be\u00e9p\u00edtett <code>Brush</code> oszt\u00e1ly lesz\u00e1rmazottai.</li> <li>A <code>Background</code> tulajdons\u00e1g egy <code>Brush</code> t\u00edpus\u00fa property, \u00edgy a polimorfizmus miatt b\u00e1rmely lesz\u00e1rmazottj\u00e1t lehet haszn\u00e1lni.</li> </ul> Note <ul> <li>A fenti p\u00e9ld\u00e1kban a <code>Color</code> (sz\u00edn) megad\u00e1s\u00e1n\u00e1l pl. a <code>Color=\"Azure\"</code> esetben az <code>Azure</code> sz\u00f3b\u00f3l is t\u00edpuskonverter k\u00e9sz\u00edt k\u00e9k <code>Color</code> p\u00e9ld\u00e1nyt. \u00cdgy n\u00e9zne a kor\u00e1bbi, <code>SolidColorBrush</code> alap\u00fa p\u00e9ld\u00e1nk teljesen kifejtve: <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush&gt;\n            &lt;SolidColorBrush.Color&gt;\n                &lt;Color&gt;#FFF0FFFF&lt;/Color&gt;\n            &lt;/SolidColorBrush.Color&gt;\n        &lt;/SolidColorBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre></li> <li>Ahol t\u00e1mogatott, \u00e9rdemes kihaszn\u00e1lni a t\u00edpuskonvertereket, \u00e9s attribute syntaxot haszn\u00e1lni, hogy ne legyen terjeng\u0151s a XAML le\u00edr\u00e1sunk.</li> <li>\u00c9rt\u00e9kt\u00edpusokn\u00e1l (<code>struct</code>), mint amilyen a <code>Color</code> is, m\u00e1r az objektum p\u00e9ld\u00e1nyos\u00edt\u00e1sakor (\"konstruktor id\u0151ben\") kell megadni az \u00e9rt\u00e9ket, ez\u00e9rt itt nem lehet a propertyket k\u00fcl\u00f6n \u00e1ll\u00edtgatni, musz\u00e1j t\u00edpuskonverterre b\u00edzni magunkat.</li> </ul> </li> <li> <p>Property CONTENT syntax. Annak \u00e9rdek\u00e9ben, hogy jobban meg\u00e9rts\u00fck, n\u00e9zz\u00fck meg, milyen h\u00e1romf\u00e9le m\u00f3don tudjuk be\u00e1ll\u00edtani egy gomb <code>Content</code> tulajdons\u00e1g\u00e1t valamilyen sz\u00f6vegre (ezt laboron nem kell megtenni, el\u00e9g, ha jelen \u00fatmutat\u00f3ban n\u00e9zz\u00fck k\u00f6z\u00f6sen):</p> <ul> <li>Property attribute syntax (m\u00e1r haszn\u00e1ltuk):     <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre></li> <li>\u00c1ll\u00edtsuk be az el\u0151z\u0151 pontban tanult property element syntax alapj\u00e1n:    <pre><code>&lt;Button&gt;\n    &lt;Button.Content&gt;\n    Hello WinUI App!\n    &lt;/Button.Content&gt;\n&lt;/Button&gt;\n</code></pre></li> <li>Minden vez\u00e9rl\u0151 meghat\u00e1rozhat mag\u00e1r\u00f3l egy kit\u00fcntetett \"Content\" tulajdons\u00e1got, melyn\u00e9l nem kell ki\u00edrni a nyit\u00f3 \u00e9s csuk\u00f3 tag-eket. Vagyis az el\u0151z\u0151 p\u00e9ld\u00e1ban alkalmazott <code>&lt;Button.Content&gt;</code> nyit\u00f3 \u00e9s z\u00e1r\u00f3 tag-ek enn\u00e9l az egy tulajdons\u00e1gn\u00e1l elhagyhat\u00f3k:    <pre><code>&lt;Button&gt;\n    Hello WinUI App!\n&lt;/Button&gt;\n</code></pre>    Vagy egy sorba \u00edrva:    <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre>    Ez ismer\u0151s, l\u00e1ttuk a bevezet\u0151 p\u00e9ld\u00e1nkban: ez az \u00fan. Property CONTENT syntax alap\u00fa tulajdons\u00e1gmegad\u00e1s. Az elnevez\u00e9s is sugallja, hogy ezt az egy tulajdons\u00e1got a vez\u00e9rl\u0151 \"tartalmi\" r\u00e9sz\u00e9ben, contentj\u00e9ben is megadhatjuk. Nem minden vez\u00e9rl\u0151 eset\u00e9ben <code>Content</code> ezen kit\u00fcntetett tulajdons\u00e1g neve:  <code>StackPanel</code>-n\u00e9l \u00e9s <code>Grid</code>-n\u00e9l <code>Children</code> a neve. Eml\u00e9kezz\u00fcnk vissza, ill. n\u00e9zz\u00fck meg a k\u00f3dot: ezeket m\u00e1r haszn\u00e1ltuk is:  ugyanakkor, nem \u00edrtuk ki a <code>StackPanel.Children</code>, ill. <code>Grid.Children</code> XML elemeket a <code>StackPanel</code>, ill. <code>Grid</code> belsej\u00e9nek megad\u00e1sakor (de megtehett\u00fck volna!)</li> </ul> </li> </ol> <p>\u00cdrjuk vissza a <code>Grid</code> h\u00e1tter\u00e9t valami szimpatikusan egyszer\u0171re, vagy t\u00f6r\u00f6lj\u00fck ki a h\u00e1tt\u00e9rsz\u00edn megad\u00e1s\u00e1t.</p>"},{"location":"labor/3-felhasznaloi-felulet/#esemenykezeles","title":"Esem\u00e9nykezel\u00e9s","text":"<p>A XAML applik\u00e1ci\u00f3k esem\u00e9nyvez\u00e9relt alkalmaz\u00e1sok. Minden felhaszn\u00e1l\u00f3i interakci\u00f3r\u00f3l esem\u00e9nyek seg\u00edts\u00e9g\u00e9vel \u00e9rtes\u00fcl\u00fcnk, ezek hat\u00e1s\u00e1ra friss\u00edthetj\u00fck a fel\u00fcletet.</p> <p>Most kezelj\u00fck le a gombon t\u00f6rt\u00e9n\u0151 kattint\u00e1st.</p> <p>El\u0151k\u00e9sz\u00edt\u0151 l\u00e9p\u00e9sk\u00e9nt adjunk nevet a <code>TextBlock</code> vez\u00e9rl\u0151nknek, hogy a code-behind f\u00e1jlb\u00f3l hivatkozni tudjunk majd r\u00e1 a k\u00e9s\u0151bbiekben:</p> <pre><code>&lt;TextBlock x:Name=\"recordTextBlock\" Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n</code></pre> <p>Az <code>x:Name</code> a XAML parsernek sz\u00f3l, \u00e9s ezen a n\u00e9ven fog l\u00e9trehozni egy tagv\u00e1ltoz\u00f3t az oszt\u00e1lyunkban, mely az adott vez\u00e9rl\u0151 referenci\u00e1j\u00e1t tartalmazza.  Gondoljuk \u00e1t: mivel tagv\u00e1ltoz\u00f3 lesz, a code-behind f\u00e1jlban el tudjuk \u00e9rni, hiszen az egy \"partial r\u00e9sze\" ugyanazon oszt\u00e1lynak!</p> <p>Elnevezett vez\u00e9rl\u0151k</p> <p>Ne adjunk nevet azoknak a vez\u00e9rl\u0151knek, melyekre nem akarunk hivatkozni. (Szoktassuk magunkat arra, hogy csak arra hivatkozunk k\u00f6zvetlen\u00fcl, amire nagyon musz\u00e1j. Ebben az adatk\u00f6t\u00e9s is seg\u00edt majd.)</p> <p>Kiv\u00e9tel: Ha nagyon bonyolult a vez\u00e9rl\u0151hierarchi\u00e1nk, seg\u00edthetnek a nevek a k\u00f3d \u00e1tl\u00e1that\u00f3bb\u00e1 t\u00e9tel\u00e9ben, mivel a Live Visual Tree ablakban megjelennek, illetve a gener\u00e1lt esem\u00e9nykezel\u0151-nevek is ehhez igazodnak.</p> <p>Kezelj\u00fck le a gomb <code>Click</code> esem\u00e9ny\u00e9t, majd pr\u00f3b\u00e1ljuk ki a k\u00f3dot.</p> MainWindow.xaml-be<pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> MainWindow.xaml.cs-be<pre><code>private void RecordButton_Click(object sender, RoutedEventArgs e)\n{\n    recordTextBlock.Text = \"Recording...\";\n}\n</code></pre> <p>Esem\u00e9nykezel\u0151k l\u00e9trehoz\u00e1sa</p> <p>Ha az esem\u00e9nykezel\u0151kn\u00e9l nem a New Event Handler-t v\u00e1lasztjuk, hanem be\u00edrjuk k\u00e9zzel a k\u00edv\u00e1nt nevet, majd F12-t nyomunk, vagy a jobb gomb / Go to Definition-t v\u00e1lasztjuk, az esem\u00e9nykezel\u0151 legener\u00e1l\u00e1sra ker\u00fcl a code-behind f\u00e1jlban.</p> <p>Az esem\u00e9nykezel\u0151nek k\u00e9t param\u00e9tere van: a k\u00fcld\u0151 objektum (<code>object sender</code>) \u00e9s az esem\u00e9ny param\u00e9tereit/k\u00f6r\u00fclm\u00e9nyeit tartalmaz\u00f3 param\u00e9ter (<code>EventArgs e</code>). N\u00e9zz\u00fck ezeket r\u00e9szletesebben:</p> <ul> <li><code>object sender</code>: Az esem\u00e9ny kiv\u00e1lt\u00f3ja. Eset\u00fcnkben ez maga a gomb, <code>Button</code>-ra kasztolva haszn\u00e1lhatn\u00e1nk is. Ritk\u00e1n haszn\u00e1ljuk ez a param\u00e9tert.</li> <li>A m\u00e1sodik param\u00e9ter mindig <code>EventArgs</code> t\u00edpus\u00fa, vagy annak lesz\u00e1rmazottja (ez az esem\u00e9ny t\u00edpus\u00e1t\u00f3l f\u00fcgg), melyben az esem\u00e9ny param\u00e9tereit kapjuk meg. A <code>Click</code> esem\u00e9ny eset\u00e9ben ez <code>RoutedEventArgs</code> t\u00edpus\u00fa.</li> </ul> <p>Esem\u00e9nyargumentumok</p> <p>N\u00e9h\u00e1ny esem\u00e9nyargumentum t\u00edpus:</p> <ul> <li><code>RoutedEventArgs</code>: pl. a <code>Click</code> esem\u00e9ny est\u00e9ben haszn\u00e1land\u00f3, ahogy a p\u00e9ld\u00e1nkban is volt. Az <code>OriginalSource</code> tulajdons\u00e1gban megkapjuk azt a vez\u00e9rl\u0151t, melyn\u00e9l el\u0151sz\u00f6r kiv\u00e1lt\u00f3dott az esem\u00e9ny.<ul> <li>Megjegyz\u00e9s: a fenti esetben ez maga a gomb, de ha pl. egy eg\u00e9rlenyom\u00e1s esem\u00e9nyt (nem a <code>Click</code>, hanem <code>PointerPressed</code>) kezeln\u00e9nk pl. a <code>StackPanel</code>-en, akkor lehet, hogy az egyik gyerekelem\u00e9t kapn\u00e1nk meg, ha arra kattintottak.</li> </ul> </li> <li><code>KeyRoutedEventArgs</code>: pl. <code>KeyDown</code> (billenty\u0171 lenyom\u00e1sa) esem\u00e9ny eset\u00e9ben megkapjuk benne a lenyomott billenty\u0171t.</li> <li><code>PointerRoutedEventArgs</code>: pl. <code>PointerPressed</code> (eg\u00e9r/toll lenyom\u00e1sa) esem\u00e9ny eset\u00e9ben haszn\u00e1ljuk, rajta kereszt\u00fcl lek\u00e9rdezhet\u0151k - t\u00f6bbek k\u00f6z\u00f6tt - a kattint\u00e1s koordin\u00e1t\u00e1i.</li> </ul> <p>A XAML esem\u00e9nykezel\u0151k teljes eg\u00e9sz\u00e9ben a C# nyelv esem\u00e9nyeire \u00e9p\u00fclnek (<code>event</code> kulcssz\u00f3, l\u00e1sd el\u0151z\u0151 gyakorlat):</p> <p>Pl. a</p> <pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> <p>erre k\u00e9pz\u0151dik le:</p> <pre><code>Button b = new Button();\nb.Click += RecordButton_Click;\n</code></pre>"},{"location":"labor/3-felhasznaloi-felulet/#layout-elrendezes","title":"Layout, elrendez\u00e9s","text":"<p>A vez\u00e9rl\u0151k elrendez\u00e9s\u00e9t k\u00e9t dolog hat\u00e1rozza meg:</p> <ol> <li>Layout (panel) vez\u00e9rl\u0151k \u00e9s kapcsolhat\u00f3 tulajdons\u00e1gaik (attached property)</li> <li>Sz\u00fcl\u0151 vez\u00e9rl\u0151n bel\u00fcli \u00e1ltal\u00e1nos poz\u00edci\u00f3 tulajdons\u00e1gok (pl. marg\u00f3, igaz\u00edt\u00e1s f\u00fcgg\u0151legesen vagy v\u00edzszintesen)</li> </ol> <p>Be\u00e9p\u00edtett layout vez\u00e9rl\u0151k p\u00e9ld\u00e1ul:</p> <ul> <li><code>StackPanel</code>: elemek egym\u00e1s alatt vagy mellett</li> <li><code>Grid</code>: defini\u00e1lhatunk egy r\u00e1csot, melyhez igazodnak az elemek</li> <li><code>Canvas</code>: explicit poz\u00edcion\u00e1lhat\u00f3k az elemek az X \u00e9s Y koordin\u00e1t\u00e1juk megad\u00e1s\u00e1val</li> <li><code>RelativePanel</code>: elemek egym\u00e1shoz k\u00e9pesti viszony\u00e1t hat\u00e1rozhatjuk meg k\u00e9nyszerekkel</li> </ul> <p>A <code>Grid</code>-et fogjuk kipr\u00f3b\u00e1lni (\u00e1ltal\u00e1ban ezt haszn\u00e1ljuk az ablakunk/oldalunk alapelrendez\u00e9s\u00e9nek kialak\u00edt\u00e1s\u00e1ra). Egy olyan fel\u00fcletet k\u00e9sz\u00edt\u00fcnk el, melyen szem\u00e9lyeket lehet egy list\u00e1ba felvenni, nev\u00fck \u00e9s \u00e9letkoruk megad\u00e1s\u00e1val. A k\u00f6vetkez\u0151 elrendez\u00e9s kialak\u00edt\u00e1sa a v\u00e9gs\u0151 c\u00e9lunk:</p> <p></p> <p>P\u00e1r l\u00e9nyeges viselked\u00e9sbeli megk\u00f6t\u00e9s:</p> <ul> <li>Az ablak \u00e1tm\u00e9retez\u00e9sekor az \u0171rlap fix sz\u00e9less\u00e9g\u0171 legyen, \u00e9s maradjon k\u00f6z\u00e9pre igaz\u00edtva.</li> <li>Az Age sorban a + gombbal n\u00f6velhet\u0151, a - gombbal cs\u00f6kkenthet\u0151 az \u00e9letkor.</li> <li>Az Add gombbal a fent meghat\u00e1rozott adatokkal felveszi a szem\u00e9lyt az als\u00f3 list\u00e1ba (az \u00e1br\u00e1n az als\u00f3 list\u00e1ban k\u00e9t szem\u00e9ly adatai l\u00e1that\u00f3k).</li> </ul> <p>Defini\u00e1ljunk a gy\u00f6k\u00e9r <code>Grid</code>-en 4 sort \u00e9s 2 oszlopot. Az els\u0151 oszlop\u00e1ba ker\u00fcljenek a c\u00edmk\u00e9k, a m\u00e1sodik oszlopba pedig a beviteli mez\u0151k. A megl\u00e9v\u0151 gombunkat is rakjuk a 3. sorba, \u00e9s \u00edrjuk \u00e1t a tartalm\u00e1t Add-ra, a k\u00f6r helyett pedig vegy\u00fcnk fel egy <code>SymbolIcon</code>-t. A 4. sorban pedig list\u00e1t helyezz\u00fcnk el, ami 2 oszlopot is foglaljon el.</p> <pre><code>&lt;Grid x:Name=\"rootGrid\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbName\"/&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\" /&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\"/&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>A sor- \u00e9s oszlopdefin\u00edci\u00f3k eset\u00e9ben megadhatjuk, hogy az adott sor vegye fel a tartalm\u00e1nak a m\u00e9ret\u00e9t (<code>Auto</code>), vagy t\u00f6ltse ki a marad\u00e9k helyet (<code>*</code>), de ak\u00e1r fix sz\u00e9less\u00e9get is megadhatn\u00e1nk pixelben (<code>Width</code> tulajdons\u00e1g). Ha t\u00f6bb <code>*</code> is szerepel a defin\u00edci\u00f3kban, akkor azok ar\u00e1nyos\u00edthat\u00f3ak pl.: <code>*</code> \u00e9s <code>*</code> 1:1-es ar\u00e1nyt jelent, m\u00edg a <code>*</code> \u00e9s <code>3*</code> 1:3-at.</p> <p>A <code>Grid.Row</code>, <code>Grid.Column</code> \u00fagynevezett Attached Property-k (csatolt tulajdons\u00e1gok). Ez azt jelenti, hogy a vez\u00e9rl\u0151, melyn\u00e9l alkalmazzuk, nem rendelkezik ilyen tulajdons\u00e1ggal, \u00e9s ezt az inform\u00e1ci\u00f3t csak \u201ehozz\u00e1csatoljuk\u201d. Ez az inform\u00e1ci\u00f3 eset\u00fcnkben a <code>Grid</code>-nek lesz fontos, hogy el tudja helyezni a gyerekeit. A <code>Grid.Row</code> \u00e9s <code>Grid.Column</code> alap\u00e9rtelmezett \u00e9rt\u00e9ke a 0, teh\u00e1t ezt ki sem k\u00e9ne \u00edrnunk.</p> <p>Imperat\u00edv UI le\u00edr\u00e1s</p> <p>M\u00e1s UI keretrendszerekben, ahol imperat\u00edv a fel\u00fclet \u00f6ssze\u00e1ll\u00edt\u00e1sa, ezt egyszer\u0171en megoldj\u00e1k f\u00fcggv\u00e9nyparam\u00e9terekkel \u2013 pl.: <code>myPanel.Add(new TextBox(), 0, 1)</code>.</p> <p>M\u00e9g magyar\u00e1zatra szorulhat a <code>ListView</code>-n\u00e1l megadott <code>Grid.ColumnSpan=\"2\"</code> csatolt tulajdons\u00e1g: a <code>ColumnSpan</code> \u00e9s <code>RowSpan</code> azt hat\u00e1rozz\u00e1k meg, h\u00e1ny oszlopon illetve soron \"\u00e1t\u00edvel\u0151en\" helyezkedjen el a vez\u00e9rl\u0151. A p\u00e9ld\u00e1nkban a <code>ListView</code> mindk\u00e9t oszlopot kit\u00f6lti.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st (ha nem fordul a k\u00f3d, akkor t\u00f6r\u00f6lj\u00fck a code behind f\u00e1jlban a <code>RecordButton_Click</code> esem\u00e9nykezel\u0151t).</p> <p>Jelen \u00e1llapot\u00e1ban a <code>Grid</code> kit\u00f6lti a teljes teret v\u00edzszintesen \u00e9s f\u00fcgg\u0151legesen is. Mi ennek az oka? A vez\u00e9rl\u0151k elrendez\u00e9s\u00e9nek egyik alapil\u00e9re a <code>HorizontalAlignment</code> \u00e9s <code>VerticalAlignment</code>  tulajdons\u00e1guk. Ezek azt hat\u00e1rozz\u00e1k meg, hogy v\u00edzszintesen \u00e9s f\u00fcgg\u0151legesen hol helyezkedjen el az adott vez\u00e9rl\u0151 az \u0151t tartalmaz\u00f3 kont\u00e9nerben (vagyis a sz\u00fcl\u0151 vez\u00e9rl\u0151ben). A lehets\u00e9ges \u00e9rt\u00e9kek:</p> <ul> <li><code>VerticalAlignment</code>: <code>Top</code>, <code>Center</code>, <code>Bottom</code>, <code>Stretch</code> (fel\u00fclre, k\u00f6z\u00e9pre, alulra igaz\u00edtva, vagy t\u00e9r kit\u00f6lt\u00e9se f\u00fcgg\u0151legesen)</li> <li><code>HorizontalAlignment</code>: <code>Left</code>, <code>Center</code>, <code>Right</code>, <code>Stretch</code> (balra, k\u00f6z\u00e9pre, jobbra igaz\u00edtva, vagy t\u00e9r kit\u00f6lt\u00e9se v\u00edzszintesen)</li> </ul> <p>(Megjegyz\u00e9s: a Stretch eset\u00e9ben sz\u00fcks\u00e9ges, hogy ne legyen a <code>Height</code> ill. <code>Width</code> tujadons\u00e1g megadva a vez\u00e9rl\u0151re.)</p> <p>A <code>Grid</code>-\u00fcnknek nem adtunk meg <code>HorizontalAlignment</code> \u00e9s <code>VerticalAlignment</code> tulajdons\u00e1got, \u00edgy annak \u00e9rt\u00e9ke a Grid eset\u00e9ben alap\u00e9rtelmezett <code>Stretch</code>, emiatt a <code>Grid</code> mindk\u00e9t ir\u00e1nyban kit\u00f6lti a teret a sz\u00fcl\u0151 kont\u00e9ner\u00e9ben, vagyis az ablakban.</p> <p>A fel\u00fclet\u00fcnk m\u00e9g nem \u00fagy n\u00e9z ki, mint amit szeretn\u00e9nk, finom\u00edtsunk kicsit a kin\u00e9zet\u00e9n. Az eszk\u00f6zlend\u0151 v\u00e1ltoz\u00e1sok:</p> <ul> <li>Ne t\u00f6ltse ki az eg\u00e9sz k\u00e9perny\u0151t a t\u00e1bl\u00e1zat, hanem legyen v\u00edzszintesen k\u00f6z\u00e9pen<ul> <li><code>HorizontalAlignment=\"Center\"</code></li> </ul> </li> <li>Legyen 300px sz\u00e9les<ul> <li><code>Width=\"300\"</code></li> </ul> </li> <li>Legyen a sorok k\u00f6z\u00f6tt 10px, az oszlopok k\u00f6z\u00f6tt 5px t\u00e1vols\u00e1g \u00e9s tartsunk 20px t\u00e1vols\u00e1got a kont\u00e9ner sz\u00e9l\u00e9t\u0151l<ul> <li><code>RowSpacing=\"5\" ColumnSpacing=\"10\" Margin=\"20\"</code></li> </ul> </li> <li>Igaz\u00edtsuk a c\u00edmk\u00e9ket (<code>TextBlock</code>) f\u00fcgg\u0151legesen k\u00f6z\u00e9pre<ul> <li><code>VerticalAlignment=\"Center\"</code></li> </ul> </li> <li>Igaz\u00edtsuk a gombot jobbra<ul> <li><code>HorizontalAlignment=\"Right\"</code></li> </ul> </li> <li>Tegy\u00fck beazonos\u00edthat\u00f3v\u00e1 a list\u00e1t<ul> <li><code>BorderThickness=\"1\"</code> \u00e9s <code>BorderBrush=\"DarkGray\"</code></li> </ul> </li> </ul> <pre><code>&lt;Grid x:Name=\"rootGrid\"\n      Width=\"300\"\n      HorizontalAlignment=\"Center\"\n      Margin=\"20\"\n      RowSpacing=\"5\"\n      ColumnSpacing=\"10\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbName\" /&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\" HorizontalAlignment=\"Right\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\"/&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\" /&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\"\n              Grid.Column=\"0\"\n              Grid.ColumnSpan=\"2\"\n              BorderThickness=\"1\"\n              BorderBrush=\"DarkGray\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>B\u0151v\u00edts\u00fck ki m\u00e9g k\u00e9t gombbal az \u0171rlapunkat (\u00b1 gombok az \u00e9letkorhoz, l\u00e1sd kor\u00e1bbi anim\u00e1lt k\u00e9perny\u0151k\u00e9p):</p> <ul> <li>\u2019-\u2019: a <code>TextBox</code> bal oldal\u00e1n</li> <li>\u2019+\u2019 a<code>TextBox</code> jobb oldal\u00e1n</li> </ul> <p>Ehhez vegy\u00fcnk fel a</p> <pre><code>&lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n</code></pre> <p>sor hely\u00e9re (azt kit\u00f6r\u00f6lve) egy 1 soros, 3 oszloppal rendelkez\u0151 <code>Grid</code>-et:</p> <pre><code>&lt;Grid Grid.Row=\"1\" Grid.Column=\"1\" ColumnSpacing=\"5\"&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"0\" Content=\"-\" /&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbAge\" /&gt;\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"2\" Content=\"+\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>T\u00f6bb layout vez\u00e9rl\u0151 egym\u00e1sba \u00e1gyaz\u00e1sa</p> <p>Feltehetj\u00fck a k\u00e9rd\u00e9st, hogy mi\u00e9rt nem a k\u00fcls\u0151 <code>Grid</code>-ben vett\u00fcnk fel plusz oszlopokat \u00e9s sorokat (a <code>ColumnSpan</code> megfelel\u0151 alkalmaz\u00e1s\u00e1val a megl\u00e9v\u0151 vez\u00e9rl\u0151kre). Helyette egys\u00e9gbez\u00e1r\u00e1s elv\u00e9t k\u00f6vett\u00fck: az \u00fajonnan bevezetett vez\u00e9rl\u0151k alapvet\u0151en egybe tartoz\u00f3 elemek, \u00edgy \u00e1tl\u00e1that\u00f3bb megold\u00e1st kaptunk az\u00e1ltal, hogy k\u00fcl\u00f6n <code>Grid</code> vez\u00e9rl\u0151be tett\u00fck \u0151ket. A k\u00fcls\u0151 <code>Grid</code> b\u0151v\u00edt\u00e9se akkor lenne indokolt, ha sp\u00f3rolni akarn\u00e1nk a vez\u00e9rl\u0151k l\u00e9trehoz\u00e1s\u00e1val, teljes\u00edtm\u00e9nyokok miatt. Eset\u00fcnkben ez nem indokolt.</p> <p>K\u00e9szen is vagyunk az egyszer\u0171 \u0171rlapunk kin\u00e9zet\u00e9nek kialak\u00edt\u00e1s\u00e1val.</p>"},{"location":"labor/3-felhasznaloi-felulet/#adatkotes","title":"Adatk\u00f6t\u00e9s","text":""},{"location":"labor/3-felhasznaloi-felulet/#binding","title":"Binding","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben azt oldjuk meg, hogy az el\u0151bb elk\u00e9sz\u00edtett kis \u0171rlapon egy szem\u00e9ly adatait lehessen megadni, m\u00f3dos\u00edtani. Ehhez m\u00e1r el\u0151 van k\u00e9sz\u00edtve egy <code>Person</code> oszt\u00e1ly a projekt <code>Models</code> mapp\u00e1j\u00e1ban, n\u00e9zz\u00fcnk ezt meg.</p> <pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n</code></pre> <p>Azt itt l\u00e9v\u0151 k\u00e9t tulajdons\u00e1got akarjuk a <code>TextBox</code> vez\u00e9rl\u0151kh\u00f6z k\u00f6tni, ehhez adatk\u00f6t\u00e9st fogunk alkalmazni. Az ablakunk code-behind f\u00e1jlj\u00e1ban vezess\u00fcnk be egy propertyt, mely egy <code>Person</code> objektumra hivatkozik, \u00e9s adjunk ennek kezd\u0151\u00e9rt\u00e9ket a konstruktorban:</p> <pre><code>public Person NewPerson { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n}\n</code></pre> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a fenti <code>NewPerson</code> objektum</p> <ul> <li><code>Name</code> tulajdons\u00e1g\u00e1t k\u00f6ss\u00fck hozz\u00e1 a <code>tbName</code> <code>Textbox</code> <code>Text</code> tulajdons\u00e1g\u00e1hoz</li> <li><code>Age</code> tulajdons\u00e1g\u00e1t k\u00f6ss\u00fck hozz\u00e1 a <code>tbAge</code> <code>Textbox</code> <code>Text</code> tulajdons\u00e1g\u00e1hoz , m\u00e9gpedig adatk\u00f6t\u00e9ssel (data binding):</li> </ul> <p><pre><code>Text=\"{x:Bind NewPerson.Name}\"\nText=\"{x:Bind NewPerson.Age}\"\n</code></pre> (a <code>tbName</code> ill. <code>tbAge</code> <code>TextBox</code>-ok soraiba vegy\u00fck fel a fenti 1-1 tulajdons\u00e1g be\u00e1ll\u00edt\u00e1st)</p> <p>Fontos</p> <p>Az adatk\u00f6t\u00e9snek az a l\u00e9nyege, hogy nem k\u00e9zzel, a code-behind f\u00e1jlb\u00f3l \u00e1ll\u00edtgatjuk a fel\u00fcleten megjelen\u0151 vez\u00e9rl\u0151k tulajdons\u00e1gait (eset\u00fcnkben a sz\u00f6veg\u00e9t), hanem \u00f6sszerendelj\u00fck/ \u00f6sszek\u00f6tj\u00fck a tulajdons\u00e1gokat a platform adatk\u00f6t\u00e9s mechanizmus\u00e1val. \u00cdgy azt is el\u00e9rhetj\u00fck, hogyha az egyik tulajdons\u00e1g megv\u00e1ltozik, akkor a m\u00e1sik is automatikusan v\u00e1ltozzon meg!</p> <p>A <code>Text=\"{x:Bind}\"</code> szintaktika az \u00fagynevezett markup extension: ez speci\u00e1lis jelent\u00e9ssel rendelkezik a XAML feldolgoz\u00f3 sz\u00e1m\u00e1ra. Els\u0151sorban emiatt haszn\u00e1lunk XAML \u00e9s nem sima XML-t. Lehet\u0151s\u00e9g\u00fcnk van ak\u00e1r saj\u00e1t Markup Extension-t is k\u00e9sz\u00edteni, de ez nem tananyag.</p> <p>Futtassuk! L\u00e1that\u00f3, hogy az adatk\u00f6t\u00e9s miatt automatikusan beker\u00fclt a k\u00e9t <code>TextBox</code> <code>Text</code> tulajdons\u00e1g\u00e1ba a <code>NewPerson</code> objektum (mint adatforr\u00e1s) <code>Name</code> \u00e9s <code>Age</code> tulajdons\u00e1gaiban megadott n\u00e9v \u00e9s \u00e9letkor.</p>"},{"location":"labor/3-felhasznaloi-felulet/#valtozasertesites","title":"V\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9s","text":"<p>Implement\u00e1ljuk a \u00b1 gombok <code>Click</code> esem\u00e9nykezel\u0151it.</p> <pre><code>&lt;Button Grid.Row=\"1\" Grid.Column=\"0\" Content=\"-\" Click=\"DecreaseButton_Click\"/&gt;\n&lt;!-- ... --&gt;\n&lt;Button Grid.Row=\"1\" Grid.Column=\"2\" Content=\"+\" Click=\"IncreaseButton_Click\"/&gt;\n</code></pre> <pre><code>private void DecreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age--;\n}\n\nprivate void IncreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age++;\n}\n</code></pre> <p>A kor\u00e1bbi pontban bevezetett adatk\u00f6t\u00e9s miatt azt v\u00e1rn\u00e1nk, hogy ha a <code>NewPerson</code> adatforr\u00e1s <code>Age</code> tulajdons\u00e1g\u00e1t v\u00e1ltoztatjuk a fenti esem\u00e9nykezel\u0151kben, akkor a fel\u00fclet\u00fcnk\u00f6n a <code>tbAge</code> <code>Textbox</code> vez\u00e9rl\u0151nk ezt lek\u00f6veti. Pr\u00f3b\u00e1ljuk ki! Ez m\u00e9g egyel\u0151re nem m\u0171k\u00f6dik, ugyanis ehhez sz\u00fcks\u00e9g van m\u00e9g az <code>INotifyPropertyChanged</code> interf\u00e9sz megval\u00f3s\u00edt\u00e1s\u00e1ra is.</p> <ol> <li> <p>Implement\u00e1ljuk az <code>INotifyPropertyChanged</code> interf\u00e9szt a <code>Person</code> oszt\u00e1lyunkban. Ha adatk\u00f6t\u00fcnk ehhez az oszt\u00e1lyhoz, akkor a rendszer a <code>PropertyChanged</code> esem\u00e9nyre fog feliratkozni, ennek az esem\u00e9nynek a els\u00fct\u00e9s\u00e9vel tudjuk \u00e9rtes\u00edteni a bindingot, ha egy property megv\u00e1ltozott.</p> <pre><code>public class Person : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        set\n        {\n            if (name != value)\n            {\n                name = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n            }\n        }\n    }\n\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set\n        {\n            if (age != value)\n            {\n                age = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Age)));\n            }\n        }\n    }\n}\n</code></pre> <p>Terjeng\u0151s a k\u00f3d?</p> <p>A k\u00e9s\u0151bbiekben ezt a logik\u00e1t ki is szervezhetn\u00e9nk egy \u0151soszt\u00e1lyba, de ez m\u00e1r az MVVM mint\u00e1t vezetn\u00e9 el\u0151, mely egy k\u00e9s\u0151bbi tematik\u00e1hoz kapcsol\u00f3dik. Teh\u00e1t ne ijedj\u00fcnk meg ett\u0151l a kiss\u00e9 cs\u00fany\u00e1cska k\u00f3dt\u00f3l.</p> </li> <li> <p>Az adatk\u00f6t\u00e9sen kapcsoljuk be a v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9st a <code>Mode</code> <code>OneWay</code>-re t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1s\u00e1val, mivel az <code>x:Bind</code> alap\u00e9rtelmezett m\u00f3dja a <code>OneTime</code>, mely csak egyszeri adatk\u00f6t\u00e9st jelent.</p> <pre><code>Text=\"{x:Bind NewPerson.Age, Mode=OneWay}\"\n</code></pre> </li> </ol> <p>Pr\u00f3b\u00e1ljuk ki! Az esem\u00e9nykezel\u0151k v\u00e1ltoztatj\u00e1k az adatforr\u00e1st (<code>NewPerson</code>), ennek hat\u00e1s\u00e1ra most m\u00e1r v\u00e1ltozik a fel\u00fclet is a megfelel\u0151en el\u0151k\u00e9sz\u00edtett adatk\u00f6t\u00e9s miatt.</p>"},{"location":"labor/3-felhasznaloi-felulet/#ketiranyu-adatkotes","title":"K\u00e9tir\u00e1ny\u00fa adatk\u00f6t\u00e9s","text":"<p>Az <code>Age</code> mint\u00e1j\u00e1ra, a <code>Name</code> tulajdons\u00e1gra vonatkoz\u00f3 adatk\u00f6t\u00e9st is \u00e1ll\u00edtsuk egyir\u00e1ny\u00fara:</p> <pre><code>Text=\"{x:Bind NewPerson.Name, Mode=OneWay}\"\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, majd ezt k\u00f6vet\u0151en tegy\u00fcnk egy t\u00f6r\u00e9spontot a <code>Person</code> oszt\u00e1ly <code>Name</code> tulajdons\u00e1g\u00e1nak setter\u00e9be (<code>if (name != value)</code> sor) , \u00e9s pr\u00f3b\u00e1ljuk, hogy vissza ir\u00e1nyba is m\u0171k\u00f6dik-e az adatk\u00f6t\u00e9s: ha megv\u00e1ltoztatjuk az egyik <code>TextBox</code> \u00e9rt\u00e9k\u00e9t, megv\u00e1ltozik-e a <code>NewPerson</code> objektum <code>Name</code> tulajdons\u00e1ga? G\u00e9pelj\u00fcnk valamit a Name-hez tartoz\u00f3 sz\u00f6vegdobozba, majd kattintsunk \u00e1t egy m\u00e1sik mez\u0151be: ekkor a Textbox tartalma \"v\u00e9gleges\u00edt\u0151dik\", tartalma vissza kellene \u00edr\u00f3djon az adatforr\u00e1sba, de m\u00e9gsem t\u00f6rt\u00e9nik meg, nem fut r\u00e1 a k\u00f3d a t\u00f6r\u00e9spontunkra.</p> <p>Ez az\u00e9rt van \u00edgy, mert fentebb <code>OneWay</code> adatk\u00f6t\u00e9st haszn\u00e1ltunk, mely csak az adatforr\u00e1sb\u00f3l a fel\u00fcletre ir\u00e1ny\u00fa adatk\u00f6t\u00e9st jelent. Ha azt szeretn\u00e9nk, hogy az adatk\u00f6t\u00e9s a m\u00e1sik ir\u00e1nyba is m\u0171k\u00f6dj\u00f6n (vez\u00e9rl\u0151b\u0151l adatforr\u00e1sba), ahhoz  <code>TwoWay</code>-re kell \u00e1ll\u00edtsuk az adatk\u00f6t\u00e9s m\u00f3dj\u00e1t. Ezt k\u00e9tir\u00e1ny\u0171 adatk\u00f6t\u00e9snek nevezz\u00fck.</p> <pre><code>Text=\"{x:Bind Name, Mode=TwoWay}\"\nText=\"{x:Bind Age, Mode=TwoWay}\"\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki! \u00cdgy az adatk\u00f6t\u00e9s m\u00e1r mindk\u00e9t ir\u00e1nyba m\u0171k\u00f6dik:</p> <ul> <li>Ha a forr\u00e1stulajdons\u00e1g (pl. <code>NewPerson.Name</code>) v\u00e1ltozik, akkor a vez\u00e9rl\u0151 k\u00f6t\u00f6tt tulajdons\u00e1ga (pl. <code>TextBox.Text</code>) ezzel szinkronban marad.</li> <li>Ha a c\u00e9l (vez\u00e9rl\u0151) tulajdons\u00e1g v\u00e1ltozik (pl. <code>TextBox.Text</code>), akkor az forr\u00e1stulajdons\u00e1g (pl. <code>NewPerson.Name</code>) ezzel szinkronban marad.</li> </ul>"},{"location":"labor/3-felhasznaloi-felulet/#listak","title":"List\u00e1k","text":"<p>A k\u00f6vetkez\u0151kben a list\u00e1s adatk\u00f6t\u00e9s alkalmaz\u00e1s\u00e1t fogjuk gyakorolni. Vegy\u00fck fel a <code>Person</code>-\u00f6k list\u00e1j\u00e1t a n\u00e9zet\u00fcnk code-behind f\u00e1jlj\u00e1ba, a konstruktor elej\u00e9n pedig adjunk neki kezd\u0151\u00e9rt\u00e9ket.</p> <pre><code>public List&lt;Person&gt; People { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n\n    People = new List&lt;Person&gt;()\n    {\n      new Person() { Name = \"Peter Griffin\", Age = 40 },\n      new Person() { Name = \"Homer Simpson\", Age = 42 },\n    };\n}\n</code></pre> <p>Adatk\u00f6t\u00e9ssel \u00e1ll\u00edtsuk be a <code>ListView</code> vez\u00e9rl\u0151 <code>ItemsSource</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl, milyen adatforr\u00e1sb\u00f3l dolgozzon.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"/&gt;\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>L\u00e1tjuk, hogy megjelent k\u00e9t elem a list\u00e1ban. Persze nem az van ki\u00edrva, amit mi szeretn\u00e9nk, de ezen k\u00f6nnyen seg\u00edthet\u00fcnk. Alap\u00e9rtelmezetten ugyanis a <code>ListView</code> <code>ToString()</code>-et h\u00edv a listaelemeken, ami ha nem defini\u00e1ljuk fel\u00fcl, akkor az oszt\u00e1ly t\u00edpus\u00e1nak <code>FullName</code> tulajdons\u00e1ga (vagyis a t\u00edpus neve).</p> <p>\u00c1ll\u00edtsunk be a <code>ListView</code>-unk <code>ItemTemplate</code> tulajdons\u00e1g\u00e1t (a m\u00e1r j\u00f3l ismert property element syntax-szal), mely a listaelem megjelen\u00e9s\u00e9t adja meg egy sablon seg\u00edts\u00e9g\u00e9vel: eset\u00fcnkben legyen ez egycell\u00e1s <code>Grid</code>, ahol a <code>TextBlock</code>-ok a <code>Person</code> tulajdons\u00e1gait jelen\u00edtik meg, a nevet balra, az \u00e9letkort jobbra igaz\u00edtva.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"&gt;\n    &lt;ListView.ItemTemplate&gt;\n        &lt;DataTemplate x:DataType=\"model:Person\"&gt;\n            &lt;Grid&gt;\n                &lt;TextBlock Text=\"{x:Bind Name}\" /&gt;\n                &lt;TextBlock Text=\"{x:Bind Age}\" HorizontalAlignment=\"Right\" /&gt;\n            &lt;/Grid&gt;\n        &lt;/DataTemplate&gt;\n    &lt;/ListView.ItemTemplate&gt;\n&lt;/ListView&gt;\n</code></pre> <p>A <code>DataTemplate</code> egy olyan fel\u00fcletsablon, melyet a <code>ListView</code> (he megadjuk az <code>ItemTemplate</code> tulajdons\u00e1g\u00e1nak) minden elem\u00e9re alkalmazni fog a megjelen\u00edt\u00e9s sor\u00e1n.</p> <p>Mivel az <code>x:Bind</code> ford\u00edt\u00e1s idej\u0171 adatk\u00f6t\u00e9s, ez\u00e9rt az adatok t\u00edpus\u00e1t is meg kell adnunk az adatsablonban az <code>x:DataType</code> attrib\u00fatummal. A fenti p\u00e9ld\u00e1ban a <code>model:Person</code>-t adtuk meg, vagyis azt szeretn\u00e9nk, hogy a <code>model</code> prefix a k\u00f3dunk <code>HelloXaml.Models</code> n\u00e9vter\u00e9re k\u00e9pz\u0151dj\u00f6n le (hiszen ebben van a <code>Person</code> oszt\u00e1ly). Ehhez a XAML f\u00e1jlunk elej\u00e9n a <code>Window</code> tag attrib\u00fatumaihoz fel kell vegy\u00fck a k\u00f6vetkez\u0151 n\u00e9vt\u00e9r deklar\u00e1ci\u00f3t is: <code>xmlns:model=\"using:HelloXaml.Models\"</code> (ezt k\u00f6vet\u0151en a <code>model</code> prefix haszn\u00e1lhat\u00f3 lesz). Ezt megtehetj\u00fck k\u00e9zzel, vagy a Visual Studio seg\u00edts\u00e9g\u00e9vel is: csak kattintsunk bele az al\u00e1h\u00fazott (hib\u00e1snak megjel\u00f6lt) <code>model:Person</code>sz\u00f6vegbe, majd kattintsuk a sor elej\u00e9n megjelen\u0151 l\u00e1mp\u00e1csk\u00e1n (vagy <code>Ctrl</code> + <code>.</code> billenty\u0171kombin\u00e1ci\u00f3), \u00e9s v\u00e1lasszuk ki a megjelen\u0151 \"Add xmlns using:HelloXaml.Models\" elemet.</p> <p>Pr\u00f3b\u00e1ljuk ki! Most m\u00e1r j\u00f3l jelennek meg a list\u00e1ban az elemek.</p> <p>Az Add gomb hat\u00e1s\u00e1ra rakjuk bele a list\u00e1ba az \u0171rlapon tal\u00e1lhat\u00f3 szem\u00e9ly adataival egy \u00faj <code>Person</code> m\u00e1solat\u00e1t, majd t\u00f6r\u00f6lj\u00fck ki az \u0171rlap adatait a <code>NewPerson</code> objektumunkban.</p> <p>Ehhez vezess\u00fcnk be egy <code>Click</code> esem\u00e9nykezel\u0151t az Add gombunkra:</p> <pre><code>&lt;Button ... Click=\"AddButton_Click\"&gt;\n</code></pre> <pre><code>private void AddButton_Click(object sender, RoutedEventArgs e)\n{\n    People.Add(new Person()\n    { \n        Name = NewPerson.Name,\n        Age = NewPerson.Age,\n    });\n\n    NewPerson.Name = string.Empty;\n    NewPerson.Age = 0;\n}\n</code></pre> <p>Nem jelenik meg a list\u00e1ban az \u00faj elem, mert a <code>ListView</code> nem \u00e9rtes\u00fcl arr\u00f3l, hogy \u00faj elem ker\u00fclt a list\u00e1ba. Ezt k\u00f6nnyen orvosolhatjuk: a <code>List&lt;Persont&gt;</code>-t cser\u00e9lj\u00fck le <code>ObservableCollection&lt;Person&gt;</code>-re:</p> <pre><code>public ObservableCollection&lt;Person&gt; People { get; set; }\n</code></pre> <p><code>ObservableCollection&lt;T&gt;</code></p> <p>Fontos, hogy itt nem maga a <code>People</code> tulajdons\u00e1g \u00e9rt\u00e9ke v\u00e1ltozott, hanem a <code>List&lt;Person&gt;</code> objektum tartalma, ez\u00e9rt nem az <code>INotifyPropertyChanged</code> interf\u00e9sz a megold\u00e1s, hanem az <code>INotifyCollectionChanged</code> interf\u00e9sz, melyet az <code>ObservableCollection</code> implement\u00e1l.</p> <p>Teh\u00e1t m\u00e1r k\u00e9t v\u00e1ltoz\u00e1skezel\u00e9st t\u00e1mogat\u00f3 interf\u00e9szt ismer\u00fcnk \u00e9s haszn\u00e1lunk, melyek az adatk\u00f6t\u00e9st t\u00e1mogatj\u00e1k: <code>INotifyPropertyChanged</code> \u00e9s <code>INotifyCollectionChanged</code>.</p>"},{"location":"labor/3-felhasznaloi-felulet/#kitekintes-klasszikus-binding","title":"Kitekint\u00e9s: Klasszikus Binding","text":"<p>Az adatk\u00f6t\u00e9snek a klasszikus form\u00e1j\u00e1t a <code>Binding</code> markup extension jelenti.</p> <p>A legfontosabb k\u00fcl\u00f6nbs\u00e9gek az <code>x:Bind</code>-hoz k\u00e9pest:</p> <ul> <li>A <code>Binding</code> alap\u00e9rtelmezett m\u00f3dja a <code>OneWay</code> \u00e9s nem a <code>OneTime</code>: teh\u00e1t figyeli a v\u00e1ltoz\u00e1sokat alap\u00e9rtelmezetten, m\u00edg az <code>x:Bind</code>-n\u00e9l ezt explicit meg kell adni.</li> <li>A <code>Binding</code> alap\u00e9rtelmezetten a <code>DataContext</code>-b\u0151l dolgozik, de lehet\u0151s\u00e9g van \u00e1ll\u00edtani az adatk\u00f6t\u00e9s forr\u00e1s\u00e1t. M\u00edg az <code>x:Bind</code> alap\u00e9rtelmezetten a n\u00e9zet\u00fcnk oszt\u00e1ly\u00e1b\u00f3l (xaml.cs) k\u00f6t.</li> <li>A <code>Binding</code> fut\u00e1sid\u0151ben dolgozik reflection seg\u00edts\u00e9g\u00e9vel, \u00edgy egyr\u00e9szt nem kapunk ford\u00edt\u00e1s idej\u0171 hib\u00e1kat, ha valamit el\u00edrtunk volna, m\u00e1sr\u00e9szt pedig sok adatk\u00f6t\u00e9s (1000-es nagys\u00e1grend) jelent\u0151sen lass\u00edthatja az alkalmaz\u00e1sunkat.</li> <li>Az <code>x:Bind</code> ford\u00edt\u00e1s idej\u0171, \u00edgy a ford\u00edt\u00f3 ellen\u0151rzi, hogy a megadott tulajdons\u00e1gok l\u00e9teznek-e. Adatsablonokban nyilatkozni kell a <code>DataTemplate</code> megad\u00e1sa sor\u00e1n, hogy az milyen adatokon fog dolgozni az <code>x:DataType</code> attrib\u00fatummal.</li> <li>Az <code>x:Bind</code> eset\u00e9ben lehet\u0151s\u00e9g van met\u00f3dusokat is k\u00f6tni, m\u00edg a <code>Binding</code>-n\u00e9l csak konvertereket lehet haszn\u00e1lni. F\u00fcggv\u00e9nyek k\u00f6t\u00e9se eset\u00e9n a v\u00e1ltoz\u00e1s\u00e9rtes\u00edt\u00e9s a param\u00e9terek v\u00e1ltoz\u00e1s\u00e1ra is m\u0171k\u00f6dik.</li> </ul> <p>Aj\u00e1nl\u00e1s</p> <p>\u00d6k\u00f6lszab\u00e1lyk\u00e9nt elmondhat\u00f3, hogy pr\u00f3b\u00e1ljunk prefer\u00e1ltan <code>x:Bind</code>-ot haszn\u00e1lni, mert gyorsabb, \u00e9s ford\u00edt\u00e1s idej\u0171 hib\u00e1kat kapunk, viszont ha valami\u00e9rt probl\u00e9m\u00e1ba \u00fctk\u00f6zn\u00e9nk az <code>x:Bind</code>-dal, akkor <code>Binding</code>-ra \u00e9rdemes \u00e1tt\u00e9rni.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/","title":"3. Entwurf der Benutzeroberfl\u00e4che","text":""},{"location":"labor/3-felhasznaloi-felulet/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>Das Ziel der \u00dcbung ist, die Grundlagen der Entwicklung von Thick-Client-Anwendungen unter Verwendung der deklarativen XAML-Oberfl\u00e4chebeschreibungstechnologie zu erlernen. Die hier gelernten Grundlagen gelten f\u00fcr alle XAML-Dialekte (WinUI, WPF, UWP, Xamarin.Forms, MAUI) oder k\u00f6nnen auf sehr \u00e4hnliche Weise angewendet werden, aber wir werden XAML in der heutigen \u00dcbung speziell \u00fcber das WinAppSDK / WinUI 3-Framework verwenden.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Durchf\u00fchrung des Labors ben\u00f6tigten Werkzeuge:</p> <ul> <li>Betriebssystem Windows 10 oder Windows 11 (Linux und macOS nicht geeignet)</li> <li>Visual Studio 2022</li> <li> <p>Windows Desktop Entwicklung Workload</p> <p></p> </li> </ul>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#losung","title":"L\u00f6sung","text":"Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist auf GitHub im <code>megoldas</code>-Zweig verf\u00fcgbar. Der einfachste Weg, es herunterzuladen, ist, mit dem <code>git clone</code>-Befehl von der Kommandozeile aus zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo -b megoldas</code></p> <p>Sie m\u00fcssen Git auf Ihrem Rechner installiert haben, weitere Informationen hier.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#ursprungliches-projekt","title":"Urspr\u00fcngliches Projekt","text":"<p>In der ersten Aufgabe werden wir die Umgebung einrichten, in der wir die Funktionalit\u00e4t der XAML-Sprache und des WinUI-Frameworks untersuchen werden. Das anf\u00e4ngliche Projekt k\u00f6nnte mit Visual Studio erstellt werden (WinUI 3 Projekt, Blank App, Packaged (WinUI 3 in Desktop) type), aber um den Ablauf der \u00dcbung zu vereinfachen, werden wir das vorgefertigte Projekt verwenden.</p> <p>Wir k\u00f6nnen das Projekt auf unseren Rechner klonen, mit dem folgenden Befehl:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-xaml-kiindulo.git\n</code></pre> <p>\u00d6ffnen wir <code>HelloXaml.sln</code>.</p> <p>Schauen wir uns an, welche Dateien in dem Projekt enthalten sind:</p> <ul> <li>App<ul> <li>Zwei Dateien <code>App.xaml</code> und <code>App.xaml.cs</code>(sp\u00e4ter zu kl\u00e4rende zwei Dateien geh\u00f6ren dazu)</li> <li>Eintrittspunkt in die Anwendung: <code>OnLaunched</code> \u00fcberschriebene Method in <code>App.xaml.cs</code></li> <li>In unserem Fall initialisieren wir das einzige Fenster der Anwendung hier <code>MainWindow</code></li> </ul> </li> <li>MainWindow<ul> <li>Zu dem Hauptfenster unserer Anwendung geh\u00f6rende .xaml und .xaml.cs Dateien.</li> </ul> </li> </ul> Zus\u00e4tzliche L\u00f6sungselemente <p>Die urspr\u00fcngliche VS-L\u00f6sung enth\u00e4lt auch die folgenden Elemente:</p> <ul> <li>Dependencies<ul> <li>Frameworks<ul> <li><code>Microsoft.AspNetCore.App</code>: .NET SDK-Metapaket (verweist auf Microsoft .NET und SDK-Basispakete)</li> <li>Windows-spezifisches .NET SDK</li> </ul> </li> <li>Packages<ul> <li>Windows SDK Build Tools</li> <li>WindowsAppSDK</li> </ul> </li> </ul> </li> <li>Assets<ul> <li>Anwendungslogos</li> </ul> </li> <li>app.manifest, Package.appxmanifest<ul> <li>Eine XML-Datei mit den Metadaten der Anwendung, in der wir, unter anderem, Logos angeben oder, wie bei Android, den Zugriff auf sicherheitskritische Systemressourcen anfordern k\u00f6nnen.</li> </ul> </li> </ul> <p>Starten wir die Anwendung!</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#xaml-einfuhrung","title":"XAML-Einf\u00fchrung","text":"<p>Die Schnittstelle wird in einer XML-basierten Beschreibungssprache, XAML (ausgesprochen: zem\u00f6l), beschrieben.</p> <p>Grafische Designeroberfl\u00e4che</p> <p>Bei einigen XAML-Dialekten (z.B.: WPF) steht auch ein grafisches Designer-Tool f\u00fcr die Gestaltung der Oberfl\u00e4che zur Verf\u00fcgung, das jedoch in der Regel eine weniger effiziente XAML-Beschreibung erzeugt. Dar\u00fcber hinaus unterst\u00fctzt Visual Studio bereits Hot Reload f\u00fcr XAML, so dass die Anwendung w\u00e4hrend der Bearbeitung der XAML nicht angehalten werden muss und die \u00c4nderungen sofort in der laufenden Anwendung sichtbar sind. Daher gibt es f\u00fcr WinUI keine Designer-Unterst\u00fctzung mehr in Visual Studio. Die Erfahrung hat gezeigt, dass es Grenzen gibt, wobei \"gr\u00f6\u00dfere\" \u00c4nderungen einen Neustart der Anwendung erfordern.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#grundlagen-der-xaml-sprache","title":"Grundlagen der XAML-Sprache","text":"<p>Die XAML-Sprache:</p> <ul> <li>Sprache f\u00fcr Objektinstanziierung</li> <li>Standard-XML</li> <li>XML-Elemente/Tags: instanziieren Objekte, deren Klassen Standard-.NET-Klassen sind</li> <li>XML-Attribute: Eigenschaften (dependency properties) werden festgelegt</li> <li>Deklarativ</li> </ul> <p>Schauen wir uns die von der Projektvorlage generierte XAML (<code>MainWindow.xaml</code>) an. Wir k\u00f6nnen sehen, dass f\u00fcr jedes Steuerelement in der XAML ein XML-Element/Tag erstellt wurde. Und die Eigenschaften der Steuerelementen werden auf die Tags der Steuerelementen gesetzt. Z.B. <code>HorizontalAlignment</code>: Ausrichtung innerhalb eines Containers (in unserem Fall Fenster). Steuerelemente k\u00f6nnen andere Steuerelemente enthalten, wodurch ein Baum von Steuerelementen entsteht.</p> <p>Schauen wir uns <code>MainWindow.xaml</code>genauer an:</p> <ul> <li>Namensr\u00e4ume auf dem Root-Tag: definieren, welche Tags und Attribute in XML verwendet werden k\u00f6nnen<ul> <li>Standardnamensraum: Namensraum der XAML-Elemente/Steuerelemente (z. B. <code>Button</code>, <code>TextBox</code> usw.)</li> <li><code>x</code> Namensraum: XAML-Parser-Namensraum (z. B.: <code>x:Class</code>, <code>x:Name</code>)</li> <li>Andere beliebige Namespaces k\u00f6nnen referenziert werden</li> </ul> </li> <li><code>Window</code> Wurzelelement:<ul> <li>Auf der Grundlage unseres Fensters/unserer Seite erstellen wir eine .NET-Klasse, die von der Klasse <code>Window</code> abgeleitet ist.</li> <li>Der Name unserer abgeleiteten Klasse wird durch das Attribut <code>x:Class</code> definiert: Auf der Grundlage von <code>x:Class=\"HelloXaml.MainWindow\"</code> wird eine Klasse namens <code>MainWindow</code> im Namensraum <code>HelloXaml</code> erstellt.</li> <li>Dies ist eine Teilklasse, die \"andere H\u00e4lfte\" der Klasse befindet sich in der Code-Behind-Datei (<code>MainWindow.xaml.cs</code>) f\u00fcr das Fenster/die Seite. Siehe n\u00e4chster Punkt.</li> </ul> </li> <li>Code-Behind-Datei (<code>MainWindow.xaml.cs</code>):<ul> <li>Die andere \"H\u00e4lfte\" unserer partiellen Klasse: \u00dcberpr\u00fcfen wir, ob der Name und der Namensraum der Klasse hier derselbe ist wie in der .xaml-Datei (partielle Klasse!).</li> <li>Hier werden u.a. Ereignishandler und Hilfsfunktionen untergebracht.</li> <li><code>this.InitializeComponent();</code> muss immer im Konstruktor aufgerufen werden, er liest die XAML zur Laufzeit ein, er initialisiert den Inhalt des Fensters/der Seite (d.h. die in der XAML-Datei angegebenen Controls mit den dort definierten Eigenschaften).</li> </ul> </li> </ul> <p>L\u00f6schen wir den Inhalt von <code>Window</code> und den Ereignishandler aus der Code-Behind-Datei (Funktion<code>myButton_Click</code> ). Jetzt werden wir XAML manuell schreiben, um die Oberfl\u00e4che0 zu erstellen. F\u00fcgen wir ein <code>Grid</code>zu <code>Window</code>hinzu, mit dem wir sp\u00e4ter ein Tabellenlayout erstellen k\u00f6nnen:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;Window\n    x:Class=\"HelloXaml.MainWindow\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloXaml\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"&gt;\n\n    &lt;Grid&gt;\n\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> <p>F\u00fchren wir die Anwendung aus (z. B. mit F5 ). Die <code>Grid</code> f\u00fcllt das gesamte Fenster aus, ihre Farbe ist dieselbe wie die Hintergrundfarbe des Fensters, so dass man sie mit dem Auge nicht mehr unterscheiden kann.</p> <p>In den folgenden Aufgaben lassen wir die Anwendung laufen, damit wir die \u00c4nderungen, die wir an der Schnittstelle vorgenommen haben, sofort sehen k\u00f6nnen.</p> <p>Hot Reload Limitations</p> <p>Beachten wir die Einschr\u00e4nkungen von Hot Reload: Wenn eine \u00c4nderung nicht in der laufenden Anwendung erscheinen soll, m\u00fcssen wir die Anwendung neu starten!</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#objektinstanzen-und-ihre-eigenschaften","title":"Objektinstanzen und ihre Eigenschaften","text":"<p>Sehen wir uns an, wie wir Objekte auf der Grundlage von XAML instanziieren und die Eigenschaften dieser Objekte festlegen k\u00f6nnen.</p> <p>F\u00fcgen wir <code>Button</code>innerhalb der <code>Grid</code> hinzu. Die Eigenschaft <code>Content</code> wird verwendet, um den Text des Knopfs, genauer gesagt seinen Inhalt, anzugeben.</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Dadurch wird zur Laufzeit ein Objekt <code>Button</code> an der Stelle erzeugt, an der es deklariert ist, und die Eigenschaft <code>Content</code> auf \"Hello WinUI App!\" gesetzt. Dies h\u00e4tte in C# in der Code-Behind-Datei wie folgt geschehen k\u00f6nnen (was jedoch zu weniger lesbarem Code f\u00fchren w\u00fcrde):</p> <pre><code>// z.B. am Ende des Konstruktors geschrieben:\n\nButton b = new Button();\nb.Content = \"Hello WinUI App!\";\nrootGrid.Children.Add(b); \n// F\u00fcr die vorherige Zeile sollte das Attribut x:Name=\"rootGrid\" des Grids in der XAML-Datei angegeben\n// werden, um das Grid mit dem Namen rootGrid aus dem Code-Behind-Datai zu erreichen.\n</code></pre> <p> Dieses Beispiel verdeutlicht sehr gut, dass XAML im Grunde eine Objektinstanziirungs-Sprache ist und das Setzen von Eigenschaften von Objekten unterst\u00fctzt.</p> <p>Die Eigenschaft <code>Content</code> ist eine Besonderheit: Sie kann nicht nur in einem XML-Attribut, sondern auch innerhalb eines Tags (XML-Element) angegeben werden.</p> <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre> <p>Sogar! Wir k\u00f6nnen nicht nur eine Beschriftung auf die Taste setzen, sondern auch jedes andere Element, das wir m\u00f6chten. F\u00fcgen wir zum Beispiel einen roten Kreis ein. Der Kreis ist 10 Pixel breit, 10 Pixel hoch und die Farbe (<code>Fill</code>) ist rot.</p> <pre><code>&lt;Button&gt;\n    &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n&lt;/Button&gt;\n</code></pre> <p>Dies konnte mit fr\u00fcheren .NET UI-Technologien (z. B. Windows Forms) nicht so einfach erreichen.</p> <p>Neben dem roten Kreis steht nun Record (um den Sinn der roten Kreistaste zu verdeutlichen). Die Taste kann nur ein untergeordnetes Element haben, daher m\u00fcssen wir den Kreis und den Text (<code>TextBlock</code>) in ein Layout-Steuerelement (z. B. ein <code>StackPanel</code>) einf\u00fcgen. F\u00fcgen wir au\u00dferdem einen linken Rand zu <code>TextBlock</code>hinzu, damit sie sich nicht ber\u00fchren.</p> <pre><code>&lt;Button&gt;\n    &lt;StackPanel Orientation=\"Horizontal\"&gt;\n        &lt;Ellipse Width=\"10\" Height=\"10\" Fill=\"Red\" /&gt;\n        &lt;TextBlock Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n    &lt;/StackPanel&gt;\n&lt;/Button&gt;\n</code></pre> <p><code>StackPanel</code> ist ein einfaches Layout-Panel f\u00fcr die Anordnung von Steuerelementen: Die darin enthaltenen Steuerelemente werden nebeneinander angeordnet, wenn <code>Horizental</code> <code>Orientation</code> angegeben ist, und untereinander, wenn <code>Vertical</code> <code>Orientation</code> angegeben ist. In unserem Beispiel legen wir also einfach die beiden Steuerelemente nebeneinander.</p> <p>Das Ergebnis ist:</p> <p></p> <p>XAML-Vektorgrafik-Controller</p> <p>Es ist wichtig zu beachten, dass die meisten XAML-Controller Vektorgrafiken sind. Diese Taste sieht bei jeder DPI oder Vergr\u00f6\u00dferung genauso scharf aus (keine \"Verpixelung\").</p> <p>Es gibt drei Optionen f\u00fcr die Angabe von Eigenschaften von XAML-instanziierten Steuerelementen (von denen wir einige bereits verwendet haben):</p> <ul> <li>Property ATTRIBUTE syntax</li> <li>Property ELEMENT syntax</li> <li>Property CONTENT syntax</li> </ul> <p>Schauen wir uns diese Optionen nun genauer an:</p> <ol> <li> <p>Property ATTRIBUTE syntax.  Wir haben sie bereits in unserem allerersten Beispiel verwendet:</p> <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre> <p>Der Name kommt daher, dass die Eigenschaft als XML-Attribut angegeben wird. Da XML-Attribute nur Strings sein k\u00f6nnen, k\u00f6nnen sie nur f\u00fcr den Zugriff auf einfache Zahlen-, String- usw. Werte in Stringform oder auf Mitgliedsvariablen und Ereignishandler, die in einer Code-Behind-Datei definiert sind, verwendet werden. Wir k\u00f6nnen aber auch \"komplexe\" Objekte mit Hilfe von Typkonvertern angeben. Wir werden nicht viel dar\u00fcber reden, aber wir benutzen die eingebauten Typkonverter sehr oft, praktisch \"instinktiv\". Beispiel:</p> <p>F\u00fcgen wir eine Hintergrundfarbe zu <code>Grid</code>hinzu:</p> <pre><code>&lt;Grid Background=\"Azure\"&gt;\n</code></pre> <p>Oder wir k\u00f6nnen es in Hexadezimal angeben:</p> <pre><code>&lt;Grid Background=\"#FFF0FFFF\"&gt;\n</code></pre> <p>Der Rand (<code>Margin</code>) ist ebenfalls ein zusammengesetzter Wert, wobei der zugeh\u00f6rige Typkonverter durch ein Komma (oder ein Leerzeichen) getrennt ist und Werte f\u00fcr die vier Seiten (links, oben, rechts, unten) erwartet werden. Wir haben es bereits f\u00fcr unseren TextBlock mit <code>Record</code> verwendet. Hinweis: wir k\u00f6nnen eine einzige Zahl f\u00fcr den Rand angeben, die dann f\u00fcr alle vier Seiten gleich ist.</p> </li> <li> <p>Property ELEMENT syntax. Es erm\u00f6glicht uns, eine Eigenschaft auf ein komplex instanziiertes/parametrisiertes Objekt zu setzen, ohne Typkonverter zu verwenden. Schauen wir uns das anhand eines Beispiels an.</p> <ul> <li>Im obigen Beispiel wird durch die Einstellung der Eigenschaft <code>Background</code> auf <code>Azure</code> tats\u00e4chlich ein <code>SolidColorBrush</code>mit der Farbe hellblau erstellt. Dies kann ohne Verwendung eines Typkonverters wie folgt angegeben werden:</li> </ul> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush Color=\"Azure\" /&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p>Damit wird die Eigenschaft <code>Grid</code> <code>Background</code> auf die angegebene <code>SolidColorBrush</code>gesetzt. Dabei handelt es sich um die so genannte \"property element syntax\"-basierte Eigenschafts\u00fcbermittlung.</p> <ul> <li>Der Name kommt daher, dass die Eigenschaft in Form eines XML-Elements (und nicht eines XML-Attributs) angegeben wird.</li> <li> Hier erstellt <code>&lt;Grid.Background&gt;</code> keine Objektinstanz, sondern setzt den Wert der angegebenen Eigenschaft (in diesem Fall <code>Background</code>) auf die entsprechende Objektinstanz (in diesem Fall <code>SolidColorBrush</code>). Sie erkennen dies an dem Punkt im Namen des XML-Elements.</li> <li>Dadurch erh\u00e4lt man eine \"expansivere\" Formeigenschaft, jedoch mit voller Flexibilit\u00e4t. </li> </ul> <p>Ersetzen wir <code>SolidColorBrush</code>durch eine <code>Brush</code> mit Farb\u00fcbergang (<code>LinearGradientBrush</code>):</p> <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;LinearGradientBrush&gt;\n            &lt;LinearGradientBrush.GradientStops&gt;\n                &lt;GradientStop Color=\"Black\" Offset=\"0\" /&gt;\n                &lt;GradientStop Color=\"White\" Offset=\"1\" /&gt;\n            &lt;/LinearGradientBrush.GradientStops&gt;\n        &lt;/LinearGradientBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre> <p>F\u00fcr <code>LinearGradientBrush</code> gibt es keinen Typkonverter, er kann nur mit der Elementsyntax angegeben werden!</p> <p>Es ist eine Frage, wie ist es m\u00f6glich, dass die <code>Background</code> Eigenschaft des <code>Grid</code> Steuerelements sowohl <code>SolidColorBrush</code> und <code>LinearGradientBrush</code> Pinsel haben k\u00f6nnte? Die Antwort ist ganz einfach: Polymorphismus macht dies m\u00f6glich:</p> <ul> <li>Die Klassen <code>SolidColorBrush</code> und <code>LinearGradientBrush</code> sind beide aus der eingebauten Klasse <code>Brush</code> abgeleitet. </li> <li>Die Eigenschaft <code>Background</code> ist eine Eigenschaft des Typs <code>Brush</code>, so dass aufgrund der Polymorphie jeder Nachkomme dieser Eigenschaft verwendet werden kann.</li> </ul> Note <ul> <li>Wenn in den obigen Beispielen <code>Color</code> (Farbe) angegeben ist, z. B. <code>Color=\"Azure\"</code>, erstellt der Typkonverter auch eine blaue <code>Color</code> -Instanz von <code>Azure</code>.  So w\u00fcrde unser vorheriges Beispiel, das auf <code>SolidColorBrush</code> basiert, vollst\u00e4ndig erkl\u00e4rt aussehen: <pre><code>&lt;Grid&gt;\n    &lt;Grid.Background&gt;\n        &lt;SolidColorBrush&gt;\n            &lt;SolidColorBrush.Color&gt;\n                &lt;Color&gt;#FFF0FFFF&lt;/Color&gt;\n            &lt;/SolidColorBrush.Color&gt;\n        &lt;/SolidColorBrush&gt;\n    &lt;/Grid.Background&gt;\n    ...\n</code></pre></li> <li>Wo unterst\u00fctzt, lohnt es sich, die Vorteile von Typkonvertern zu nutzen und die Attributsyntax zu verwenden, um eine ausf\u00fchrliche XAML-Beschreibung zu vermeiden.</li> <li>Bei Werttypen (<code>struct</code>), wie z. B. <code>Color</code>, muss der Wert bei der Instanziierung des Objekts (\"Konstruktorzeit\") angegeben werden, d. h. hier k\u00f6nnen wir die Eigenschaften nicht separat festlegen, sondern m\u00fcssen sich auf die Typkonverter verlassen.</li> </ul> </li> <li> <p>Property CONTENT syntax. Um das besser zu verstehen, schauen wir uns die drei M\u00f6glichkeiten an, die <code>Content</code> Eigenschaft einer Taste auf einen Text zu setzen (wir m\u00fcssen das nicht im Labor machen, schauen wir es sich einfach zusammen in diesem Leitfaden an):</p> <ul> <li>Property attribute syntax (bereits verwendet):     <pre><code>&lt;Button Content=\"Hello WinUI App!\"/&gt;\n</code></pre></li> <li>Richten wir sie mit der property element syntax ein, die wir im vorigen Abschnitt gelernt haben:    <pre><code>&lt;Button&gt;\n    &lt;Button.Content&gt;\n    Hello WinUI App!\n    &lt;/Button.Content&gt;\n&lt;/Button&gt;\n</code></pre></li> <li>Jedes Steuerelement kann f\u00fcr sich selbst eine spezielle Eigenschaft \"Content\" definieren, f\u00fcr die die \u00f6ffnenden und schlie\u00dfenden Tags nicht gedruckt werden m\u00fcssen. Das hei\u00dft, die \u00f6ffnenden und schlie\u00dfenden Tags <code>&lt;Button.Content&gt;</code>, die im vorigen Beispiel verwendet wurden, k\u00f6nnen f\u00fcr diese eine Eigenschaft weggelassen werden:    <pre><code>&lt;Button&gt;\n    Hello WinUI App!\n&lt;/Button&gt;\n</code></pre>    Oder in einer einzigen Zeile geschrieben werden:    <pre><code>&lt;Button&gt;Hello WinUI App!&lt;/Button&gt;\n</code></pre>    Dies ist bekannt, wir haben es in unserem Einf\u00fchrungsbeispiel gesehen: dies ist die so genannte Property CONTENT syntax-basierte Eigenschaftsdeklaration. Der Name deutet auch darauf hin, dass diese eine Eigenschaft im \"Content\"-Teil des Steuerelements angegeben werden kann. Nicht alle Steuerelemente haben <code>Content</code> als Namen f\u00fcr diese besondere Eigenschaft:  <code>StackPanel</code>und <code>Grid</code>haben <code>Children</code> als Namen. Erinnern wir uns, oder schauen wir uns den Code an: wir haben diese bereits verwendet: allerdings haben wir die XML-Elemente <code>StackPanel.Children</code> oder <code>Grid.Children</code> nicht ausgeschrieben, wenn wir das Innere von <code>StackPanel</code> oder <code>Grid</code> angegeben haben (aber wir h\u00e4tten es tun k\u00f6nnen!)</li> </ul> </li> </ol> <p>\u00c4ndern wir den Hintergrund von <code>Grid</code> wieder in etwas sympathisch Einfaches, oder l\u00f6schen wir die Hintergrundfarbe.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#ereignis-management","title":"Ereignis-Management","text":"<p>XAML-Anwendungen sind ereignisgesteuerte Anwendungen. Alle Benutzerinteraktionen werden durch Ereignisse gemeldet, die zur Aktualisierung der Oberfl\u00e4che verwendet werden k\u00f6nnen.</p> <p>Jetzt geht es um das Klicken auf die Taste.</p> <p>Als vorbereitenden Schritt geben wir unserem <code>TextBlock</code> Steuerelement einen Namen, damit wir sp\u00e4ter in der Code-Behind-Datei darauf verweisen k\u00f6nnen:</p> <pre><code>&lt;TextBlock x:Name=\"recordTextBlock\" Text=\"Record\" Margin=\"10,0,0,0\" /&gt;\n</code></pre> <p>Die <code>x:Name</code> ist f\u00fcr den XAML-Parser und erstellt eine Member-Variable in unserer Klasse mit diesem Namen, die den Verweis auf das angegebene Steuerelement enth\u00e4lt.  Denken wir dar\u00fcber nach: da es sich um eine Membervariable ist, k\u00f6nnen wir es in der Code-Behind-Datei erreichen, da es sich einen \"partiellen Teil\" der gleichen Klasse ist!</p> <p>Benannte Steuerelemente</p> <p>Benennen wir keine Steuerelemente, auf die wir nicht verweisen wollen. (Wir sollten uns angew\u00f6hnen, nur auf das zu verweisen, was wir wirklich brauchen. Auch die Datenverkn\u00fcpfung ist hilfreich)</p> <p>Eine Ausnahme: Wenn wir eine sehr komplexe Kontrollhierarchie haben, k\u00f6nnen Namen helfen, den Code transparenter zu machen, da sie im Live Visual Tree-Fenster erscheinen und die generierten Ereignishandlernamen ebenfalls daran ausgerichtet sind.</p> <p>Behandeln wir das Ereignis <code>Click</code> der Taste und probieren wir dann den Code aus.</p> MainWindow.xaml<pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> MainWindow.xaml.cs<pre><code>private void RecordButton_Click(object sender, RoutedEventArgs e)\n{\n    recordTextBlock.Text = \"Recording...\";\n}\n</code></pre> <p>Erstellen von Ereignishandlern</p> <p>Wenn wir f\u00fcr die Ereignishandler nicht New Event Handler w\u00e4hlen, sondern manuell den gew\u00fcnschten Namen eingeben und F12dr\u00fccken oder Rechtsklick / Go to Definition w\u00e4hlen, wird der Ereignishandler in der Code-Behind-Datei generiert.</p> <p>Der Ereignishandler hat zwei Parameter: das sendende Objekt (<code>object sender</code>) und den Parameter, der die Parameter/Bedingungen des Ereignisses enth\u00e4lt (<code>EventArgs e</code>). Schauen wir uns diese im Detail an:</p> <ul> <li><code>object sender</code>: Der Ausl\u00f6ser des Ereignisses. In diesem Fall handelt es sich um die Taste selbst, die unter <code>Button</code>zu finden ist. Wir verwenden diesen Parameter nur selten.</li> <li>Der zweite Parameter ist immer vom Typ <code>EventArgs</code> oder dessen Nachkomme (je nach Art des Ereignisses), in dem die Parameter des Ereignisses zur\u00fcckgegeben werden. F\u00fcr das Ereignis <code>Click</code> ist dies der Typ <code>RoutedEventArgs</code>. </li> </ul> <p>Ereignisargumente</p> <p>Einige Ereignisargumenttypen:</p> <ul> <li>routedEventArgs\": wird z. B. im Falle des Ereignisses \"Click\" verwendet, wie in unserem Beispiel. In der Eigenschaft \"OriginalSource\" wird das Steuerelement angegeben, in dem das Ereignis zuerst ausgel\u00f6st wurde.<ul> <li>Beachten wir, dass es im obigen Fall die Taste selbst ist, aber wenn wir ein Mausklick-Ereignis (nicht <code>Click</code>, sondern <code>PointerPressed</code>) auf z.B. <code>StackPanel</code> behandeln w\u00fcrden, k\u00f6nnten wir eines seiner Kindelemente erhalten, wenn es angeklickt wird.</li> </ul> </li> <li>keyRoutedEventArgs\": z.B. f\u00fcr ein \"KeyDown\"-Ereignis (Tastendruck), erhalten wir die gedr\u00fcckte Taste darin.</li> <li>pointerRoutedEventArgs\": wird z.B. f\u00fcr das \"PointerPressed\"-Ereignis (Maus-/Stiftdruck) verwendet und kann u.a. dazu verwendet werden, die Koordinaten des Klicks zu ermitteln.</li> </ul> <p>Die XAML-Ereignishandler basieren vollst\u00e4ndig auf C#-Ereignissen (Schl\u00fcsselwort<code>event</code>, siehe vorherige \u00dcbung):</p> <p>Z.B. eine</p> <pre><code>&lt;Button Click=\"RecordButton_Click\"&gt;\n</code></pre> <p>ist daf\u00fcr ausgebildet:</p> <pre><code>Button b = new Button();\nb.Click += RecordButton_Click;\n</code></pre>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#layout-gestaltung","title":"Layout, Gestaltung","text":"<p>Die Anordnung der Steuerelemente wird durch zwei Faktoren bestimmt:</p> <ol> <li>Layout-Steuerelemente (panel) und ihre angef\u00fcgte Eigenschaften (attached property)</li> <li>Allgemeine Positionseigenschaften innerhalb des \u00fcbergeordneten Steuerelements (z. B. Rand, vertikale oder horizontale Ausrichtung)</li> </ol> <p>Eingebaute Layout-Steuerelemente zum Beispiel:</p> <ul> <li><code>StackPanel</code>: Elemente untereinander oder nebeneinander</li> <li><code>Grid</code>: Wir k\u00f6nnen ein Raster festlegen, an dem sich die Elemente ausrichten</li> <li><code>Canvas</code>: Wir positionieren die Elemente explizit durch Angabe ihrer X- und Y-Koordinaten</li> <li><code>RelativePanel</code>: Die Beziehung der Elemente zueinander kann durch Nebenbedingungen definiert werden</li> </ul> <p>Versuchen wir es mit <code>Grid</code>(wir verwenden dies normalerweise, um das grundlegende Layout unseres Fensters/unserer Seite einzurichten). Wir werden eine Oberfl\u00e4che erstellen, \u00fcber die man Personen zu einer Liste hinzuf\u00fcgen kann, indem man ihren Namen und ihr Alter eingeben kann. Unser Ziel ist es, das folgende Layout zu erstellen:</p> <p></p> <p>Einige wichtige Verhaltensbeschr\u00e4nkungen:</p> <ul> <li>Wenn die Gr\u00f6\u00dfe des Fensters ge\u00e4ndert wird, sollte das Formular eine feste Breite haben und zentriert bleiben.</li> <li>In der Zeile Alter erh\u00f6ht die Taste + das Alter, die Taste - verringert es.</li> <li>Die Taste Hinzuf\u00fcgen f\u00fcgt die Person mit den oben angegebenen Daten zur unteren Liste hinzu (die Abbildung zeigt die Daten von zwei Personen in der unteren Liste).</li> </ul> <p>Definieren wir die Wurzel <code>Grid</code>als 4 Zeilen und 2 Spalten. Die erste Spalte sollte die Bezeichnungen und die zweite Spalte die Eingabefelder enthalten. Setzen wir unsere vorhandene Taste in Zeile 3 und \u00e4ndern wir ihren Inhalt auf Add, und ersetzen wir den Kreis durch <code>SymbolIcon</code>. Geben wir in Zeile 4 eine Liste ein, die 2 Spalten einnehmen sollte.</p> <pre><code>&lt;Grid x:Name=\"rootGrid\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" /&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" /&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\" /&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\"/&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>F\u00fcr die Zeilen- und Spaltendefinitionen k\u00f6nnen wir angeben, ob die Zeile die Gr\u00f6\u00dfe ihres Inhalts einnehmen soll (<code>Auto</code>) oder den verbleibenden Platz ausf\u00fcllen soll (<code>*</code>), oder sogar eine feste Breite in Pixeln (<code>Width</code> Eigenschaft). Wenn es mehrere <code>*</code> in den Definitionen gibt, k\u00f6nnen sie skaliert werden, z.B. <code>*</code> und <code>*</code> haben ein Verh\u00e4ltnis von 1:1, w\u00e4hrend <code>*</code> und <code>3*</code> ein Verh\u00e4ltnis von 1:3 haben.</p> <p>Die <code>Grid.Row</code>, <code>Grid.Column</code> werden als Attached Properties (angef\u00fcgte Eigneschaften) bezeichnet. Das bedeutet, dass der Controller, auf den sie angewendet wird, diese Eigenschaft nicht besitzt und diese Information nur \"angeh\u00e4ngt\" wird. In unserem Fall sind diese Informationen f\u00fcr <code>Grid</code>wichtig, um Ihre Kinder unterzubringen. Der Standardwert f\u00fcr <code>Grid.Row</code> und <code>Grid.Column</code> ist 0, so dass wir dies gar nicht schreiben sollten.</p> <p>Imperative UI-Beschreibung</p> <p>In anderen UI-Frameworks, in denen die UI imperativ ist, wird dies einfach mit Funktionsparametern gel\u00f6st - z.B.: <code>myPanel.Add(new TextBox(), 0, 1)</code>.</p> <p>Die angef\u00fcgte Eigenschaft <code>Grid.ColumnSpan=\"2\"</code> unter <code>ListView</code>bedarf vielleicht einer Erkl\u00e4rung: <code>ColumnSpan</code> und <code>RowSpan</code> definieren die Anzahl der Spalten und Zeilen, die das Steuerelement \"umspannen\". In unserem Beispiel f\u00fcllt <code>ListView</code> beide Spalten.</p> <p>Probieren wir die Anwendung aus (wenn der Code nicht funktioniert, l\u00f6schen wir den Ereignishandler im Code hinter der Datei <code>RecordButton_Click</code> ).</p> <p>In seinem derzeitigen Zustand f\u00fcllt <code>Grid</code> den gesamten Raum sowohl horizontal als auch vertikal aus. Was ist der Grund daf\u00fcr? Eines der grundlegenden Merkmale des Layouts der Steuerelemente sind ihre Eigenschaften <code>HorizontalAlignment</code> und <code>VerticalAlignment</code>.   Diese bestimmen, wo der Controller horizontal und vertikal in dem ihn enthaltenden Container (d. h. dem \u00fcbergeordneten Controller) positioniert werden soll. Die m\u00f6glichen Werte:</p> <ul> <li><code>VerticalAlignment</code>: <code>Top</code>, <code>Center</code>, <code>Bottom</code>, <code>Stretch</code>(oben, mittig, unten ausgerichtet oder vertikal ausf\u00fcllen)</li> <li><code>HorizontalAlignment</code>: <code>Left</code>, <code>Center</code>, <code>Right</code>, <code>Stretch</code> (links-, zentriert-, rechtsb\u00fcndig oder horizontal ausf\u00fcllen)   </li> </ul> <p>(Hinweis: F\u00fcr Stretch ist es erforderlich, dass die Eigenschaft <code>Height</code> oder <code>Width</code> f\u00fcr den Controller nicht angegeben ist)</p> <p>Unserem <code>Grid</code>wurden die Eigenschaften <code>HorizontalAlignment</code> und <code>VerticalAlignment</code> nicht zugewiesen, so dass sein Wert standardm\u00e4\u00dfig <code>Stretch</code> f\u00fcr das Raster ist, weshalb <code>Grid</code> den Raum im \u00fcbergeordneten Container, dem Fenster, in beide Richtungen f\u00fcllt.</p> <p>Unsere Oberfl\u00e4che sieht nicht so aus, wie wir sie haben wollen, also m\u00fcssen wir sie noch ein wenig optimieren. Die vorzunehmenden \u00c4nderungen:</p> <ul> <li>Die Tabelle muss nicht den ganzen Bildschirm ausf\u00fcllen, sondern sollte horizontal in der Mitte liegen<ul> <li><code>HorizontalAlignment=\"Center\"</code></li> </ul> </li> <li>300px breit machen<ul> <li><code>Width=\"300\"</code></li> </ul> </li> <li>Halten wir 10px zwischen den Zeilen, 5px zwischen den Spalten und 20px vom Rand des Containers<ul> <li><code>RowSpacing=\"5\" ColumnSpacing=\"10\" Margin=\"20\"</code></li> </ul> </li> <li>Richten wir die Bezeichnungen (<code>TexBlock</code>) vertikal in der Mitte aus<ul> <li><code>VerticalAlignment=\"Center\"</code></li> </ul> </li> <li>Richten wir die Taste nach rechts aus<ul> <li><code>HorizontalAlignment=\"Right\"</code></li> </ul> </li> <li>Machen wir die Liste identifizierbar<ul> <li><code>BorderThickness=\"1\"</code> und <code>BorderBrush=\"DarkGray\"</code></li> </ul> </li> </ul> <pre><code>&lt;Grid x:Name=\"rootGrid\"\n      Width=\"300\"\n      HorizontalAlignment=\"Center\"\n      Margin=\"20\"\n      RowSpacing=\"5\"\n      ColumnSpacing=\"10\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Name\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbName\" /&gt;\n    &lt;TextBlock Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Age\" VerticalAlignment=\"Center\"/&gt;\n    &lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n\n    &lt;Button Grid.Row=\"2\" Grid.Column=\"1\" HorizontalAlignment=\"Right\"&gt;\n        &lt;StackPanel Orientation=\"Horizontal\"&gt;\n            &lt;SymbolIcon Symbol=\"Add\"/&gt;\n            &lt;TextBlock Text=\"Add\" Margin=\"5,0,0,0\" /&gt;\n        &lt;/StackPanel&gt;\n    &lt;/Button&gt;\n\n    &lt;ListView Grid.Row=\"3\"\n              Grid.Column=\"0\"\n              Grid.ColumnSpan=\"2\"\n              BorderThickness=\"1\"\n              BorderBrush=\"DarkGray\"/&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Erweitern wir unser Formular um zwei weitere Tasten (\u00b1 Tasten f\u00fcr das Alter, siehe vorheriges animiertes Bildschirmfoto):</p> <ul> <li>-': auf der linken Seite von <code>TextBox</code> </li> <li>+' auf der rechten Seite von<code>TextBox</code> </li> </ul> <p>Dazu nehmen wir anstatt die Zeile (mit L\u00f6schen)</p> <pre><code>&lt;TextBox Grid.Row=\"1\" Grid.Column=\"1\" x:Name=\"tbAge\"/&gt;\n</code></pre> <p>ein <code>Grid</code> mit 1 Zeile und 3 Spalten :</p> <pre><code>&lt;Grid Grid.Row=\"1\" Grid.Column=\"1\" ColumnSpacing=\"5\"&gt;\n    &lt;Grid.ColumnDefinitions&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n        &lt;ColumnDefinition Width=\"*\" /&gt;\n        &lt;ColumnDefinition Width=\"Auto\" /&gt;\n    &lt;/Grid.ColumnDefinitions&gt;\n\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"0\" Content=\"-\" /&gt;\n    &lt;TextBox Grid.Row=\"0\" Grid.Column=\"1\" x:Name=\"tbAge\" /&gt;\n    &lt;Button Grid.Row=\"0\" Grid.Column=\"2\" Content=\"+\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Verschachtelung mehrerer Layout-Steuerelemente</p> <p>Sie fragen sich vielleicht, warum wir nicht zus\u00e4tzliche Spalten und Zeilen in das externe <code>Grid</code>(durch Anwendung von <code>ColumnSpan</code> auf die vorhandenen Steuerelemente) eingef\u00fcgt haben. Stattdessen folgten wir dem Prinzip der Vereinheitlichung: Die neu eingef\u00fchrten Steuerelemente sind im Wesentlichen ein Element, so dass wir eine transparentere L\u00f6sung erhielten, indem wir sie in ein separates <code>Grid</code> Steuerelement einf\u00fcgten. Die Erweiterung des externen <code>Grid</code> w\u00e4re gerechtfertigt, wenn wir aufgrund von Leistungsproblemen bei der Erstellung von Steuerelementen sparen wollten. In unserem Fall ist dies nicht gerechtfertigt.</p> <p>Wir sind fertig mit dem Aussehen unseres einfachen Formulars.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#datenverbindung","title":"Datenverbindung","text":""},{"location":"labor/3-felhasznaloi-felulet/index_ger/#binding","title":"Binding","text":"<p>Im n\u00e4chsten Schritt soll es m\u00f6glich sein, die Daten einer Person in das soeben erstellte kleine Formular einzugeben und zu \u00e4ndern. Erstellen wir dazu zun\u00e4chst eine Datenklasse namens <code>Person</code> in einem neu erstellten Ordner <code>Models</code> im Projekt.</p> <pre><code>public class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n</code></pre> <p>Wir wollen die beiden Eigenschaften hier an die <code>TextBox</code> Steuerelemente binden, also verwenden wir die Datenbindung. F\u00fchren wir in der Code-Behind-Datei unseres Fensters eine Eigenschaft ein, die auf ein Objekt <code>Person</code> verweist, und geben wir ihr im Konstruktor einen Anfangswert:</p> <pre><code>public Person NewPerson { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n}\n</code></pre> <p>Im n\u00e4chsten Schritt werden die Eigenschaften des oben genannten Objekts <code>NewPerson</code> zu die <code>Text</code> Eigenschaft der geigneten Textfelder gebunden:</p> <ul> <li>die Eigenschaft <code>Name</code> zu die <code>Text</code> Eigenschaft von <code>tbName</code> <code>Textbox</code> </li> <li>die Eigenschaft <code>Age</code> zu die <code>Text</code> Eigenschaft von <code>tbAge</code> <code>Textbox</code> </li> </ul> <p>Wir verwenden Datenverbindung (data binding) daf\u00fcr:</p> <p><pre><code>Text=\"{x:Bind NewPerson.Name}\"\nText=\"{x:Bind NewPerson.Age}\"\n</code></pre> (f\u00fcgen wir die oben genannten 1-1 Eigenschaftseinstellungen in die Zeilen von <code>tbName</code> und <code>tbAge</code> <code>TextBox</code>ein)</p> <p>Wichtig</p> <p>Bei der Datenverbindung geht es darum, dass anstatt die Eigenschaften (in unserem Fall den Text) der Steuerelemente in der Oberfl\u00e4che von der Code-Behind-Datei aus manuell einstellen, werden die Eigenschaften mit dem Datenverbindungsmechanismus der Plattform zusammengesetzt/verbunden. So k\u00f6nnen wir auch daf\u00fcr sorgen, dass sich bei einer \u00c4nderung einer Eigenschaft die andere automatisch \u00e4ndert!</p> <p>Die Syntax <code>Text=\"{x:Bind}\"</code> wird als Markup Extension bezeichnet: Sie hat eine besondere Bedeutung f\u00fcr den XAML-Prozessor. Dies ist der Hauptgrund, warum wir XAML und nicht einfaches XML verwenden. Es ist auch m\u00f6glich, eine eigene Markup Extension zu erstellen, aber dies ist kein Material des Kurses.</p> <p>Laufen wir die Anwendung! Es ist zu erkennen, dass den Namen und das Alter, die in den Eigenschaften <code>Name</code> und <code>Age</code> des Objekts <code>NewPerson</code> (als Datenquelle) angegeben sind, wegem der Datenverbindung automatisch in die <code>Text</code> Eigenschaften beider <code>TextBox</code>  \u00fcbernommen wurden.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#benachrichtigung-uber-anderungen","title":"Benachrichtigung \u00fcber \u00c4nderungen","text":"<p>Implementieren wir die <code>Click</code> Ereignishandler f\u00fcr die Tasten \u00b1 . </p> <pre><code>&lt;Button Grid.Row=\"1\" Grid.Column=\"0\" Content=\"-\" Click=\"DecreaseButton_Click\"/&gt;\n&lt;!-- ... --&gt;\n&lt;Button Grid.Row=\"1\" Grid.Column=\"2\" Content=\"+\" Click=\"IncreaseButton_Click\"/&gt;\n</code></pre> <pre><code>private void DecreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age--;\n}\n\nprivate void IncreaseButton_Click(object sender, RoutedEventArgs e)\n{\n    NewPerson.Age++;\n}\n</code></pre> <p>Aufgrund der Datenverbindung, die im vorherigen Abschnitt eingef\u00fchrt wurde, w\u00fcrden wir erwarten, dass, wenn wir die Eigenschaft <code>Age</code> der Datenquelle <code>NewPerson</code> in den obigen Ereignishandlern \u00e4ndern, unser Steuerelement <code>tbAge</code> <code>Textbox</code> auf unserer Oberfl\u00e4che dies verfolgen w\u00fcrde. Probieren wir es aus! Dies funktioniert noch nicht, da es die Implementierung der Schnittstelle <code>INotifyPropertyChanged</code> erfordert.</p> <ol> <li> <p>Implementieren wir die Schnittstelle <code>INotifyPropertyChanged</code> in unserer Klasse <code>Person</code>.  Wenn wir Daten an diese Klasse binden, abonniert das System das Ereignis <code>PropertyChanged</code>. Durch Ausl\u00f6sen dieses Ereignisses k\u00f6nnen wir die Verbindung benachrichtigen, wenn sich eine Eigenschaft ge\u00e4ndert hat.</p> <pre><code>public class Person : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        set\n        {\n            if (name != value)\n            {\n                name = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));\n            }\n        }\n    }\n\n    private int age;\n    public int Age\n    {\n        get { return age; }\n        set\n        {\n            if (age != value)\n            {\n                age = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Age)));\n            }\n        }\n    }\n}\n</code></pre> <p>Ist der Code zu viel?</p> <p>In Zukunft k\u00f6nnte diese Logik in einer Klasse von Vorg\u00e4ngern organisiert werden, aber das w\u00fcrde zum MVVM-Muster f\u00fchren, das mit einem sp\u00e4teren Thema verkn\u00fcpft ist. Lassen wir uns also nicht von diesem etwas h\u00e4sslichen Code abschrecken.</p> </li> <li> <p>Bei der Datenverbindung schalten wir die \u00c4nderungsbenachrichtigung ein, indem wir sie auf <code>Mode</code> <code>OneWay</code>\u00e4ndern, da der Standardmodus f\u00fcr <code>x:Bind</code> <code>OneTime</code> ist, was eine einmalige Datenbindung darstellt.</p> <pre><code>Text=\"{x:Bind NewPerson.Age, Mode=OneWay}\"\n</code></pre> </li> </ol> <p>Probieren wir es aus! Die Ereignishandler \u00e4ndern die Datenquelle (<code>NewPerson</code>), die nun auch die Oberfl\u00e4che aufgrund der richtig vorbereiteten Datenverbindung \u00e4ndert.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#ruckwartige-datenbindung-vom-controller-zur-datenquelle","title":"R\u00fcckw\u00e4rtige Datenbindung (vom Controller zur Datenquelle)","text":"<p>Wie Age sollte auch die Datenbindung f\u00fcr die Eigenschaft Name auf einseitig eingestellt werden:</p> <pre><code>Text=\"{x:Bind NewPerson.Name, Mode=OneWay}\"\n</code></pre> <p>Starten wir die Anwendung und setzen wir dann einen Haltepunkt im Setter der Eigenschaft <code>Name</code> der Klasse <code>Person</code> (Zeile<code>if (name != value)</code> ), und sehen wir nach, ob die Datenverbindung in umgekehrter Richtung funktioniert: Wenn wir den Wert eines der <code>TextBox</code> \u00e4ndern, \u00e4ndert sich dann die Eigenschaft <code>Name</code> des Objekts <code>NewPerson</code>?  Geben wir etwas in das Textfeld ein, das mit dem Namen verkn\u00fcpft ist, und klicken wir dann auf ein anderes Feld: Der Inhalt des Textfelds wird dann \"abgeschlossen\", sein Inhalt sollte in die Datenquelle zur\u00fcckgeschrieben werden, wird aber nicht, der Code l\u00e4uft nicht an unserem Haltepunkt.</p> <p>Das liegt daran, dass wir oben die Datenverbindung <code>OneWay</code> verwendet haben, die nur eine Datenbindung von der Datenquelle zur Oberfl\u00e4che ist. F\u00fcr den Weg zur\u00fcck soll der Datenbindungsmodus auf <code>TwoWay</code> eingestellt werden.</p> <pre><code>Text=\"{x:Bind Name, Mode=TwoWay}\"\nText=\"{x:Bind Age, Mode=TwoWay}\"\n</code></pre> <p>Probieren wir es aus! Auf diese Weise funktioniert die R\u00fcckw\u00e4rts-Datenverbindung: Die angegebene Eigenschaft des Controllers (in unserem Fall Text) und die Datenquelle bleiben bei jeder Richtungs\u00e4nderung synchron.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#listen","title":"Listen","text":"<p>Im Folgenden werden wir die Listenverbindung \u00fcben. F\u00fcgen wir eine Liste von <code>Person</code>-Objekten in die Code-Behind-Datei unserer Ansicht ein und geben wir ihr am Ende des Konstruktors einen Anfangswert.</p> <pre><code>public List&lt;Person&gt; People { get; set; }\n\npublic MainWindow()\n{\n    InitializeComponent();\n\n    NewPerson = new Person()\n    {\n        Name = \"Eric Cartman\",\n        Age = 8\n    };\n\n    People = new List&lt;Person&gt;()\n    {\n      new Person() { Name = \"Peter Griffin\", Age = 40 },\n      new Person() { Name = \"Homer Simpson\", Age = 42 },\n    };\n}\n</code></pre> <p>Verwenden wir die Datenverbindung, um die Datenquelle des Steuerelements <code>ListView</code> festzulegen. Dazu sollen wir die Eigenschaft <code>ItemsSource</code> des Steuerelements <code>ListView</code> einstellen.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"/&gt;\n</code></pre> <p>Probieren wir es aus!</p> <p>Wir sehen, dass zwei Eintr\u00e4ge in der Liste erschienen sind. Nat\u00fcrlich ist es nicht das, was wir wollen, aber das ist leicht zu \u00e4ndern. Standardm\u00e4\u00dfig ruft <code>ListView</code> <code>ToString()</code>bei Listenelementen auf, was die Eigenschaft <code>FullName</code> des Klassentyps (d.h. der Typname) ist, wenn <code>ToString()</code> nicht \u00fcberschrieben wird.</p> <p>Legen wir die Eigenschaft <code>ItemTemplate</code> von <code>ListView</code>fest (unter Verwendung der bekannten property element syntax), die das Aussehen des Listenelementes unter Verwendung einer Vorlage verleiht: In unserem Fall machen wir daraus ein einzelliges <code>Grid</code>, wobei <code>TextBlock</code>s die Eigenschaften von <code>Person</code> anzeigt, wobei der Name links und das Alter rechts ausgerichtet ist.</p> <pre><code>&lt;ListView Grid.Row=\"3\" Grid.ColumnSpan=\"2\" ItemsSource=\"{x:Bind People}\"&gt;\n    &lt;ListView.ItemTemplate&gt;\n        &lt;DataTemplate x:DataType=\"model:Person\"&gt;\n            &lt;Grid&gt;\n                &lt;TextBlock Text=\"{x:Bind Name}\" /&gt;\n                &lt;TextBlock Text=\"{x:Bind Age}\" HorizontalAlignment=\"Right\" /&gt;\n            &lt;/Grid&gt;\n        &lt;/DataTemplate&gt;\n    &lt;/ListView.ItemTemplate&gt;\n&lt;/ListView&gt;\n</code></pre> <p><code>DataTemplate</code> ist eine Oberfl\u00e4chenschablone, die von der <code>ListView</code> (er ist gegeben durch <code>ItemTemplate</code> eigenschaft) auf alle Elemente w\u00e4hrend der Anzeige angewendet wird.</p> <p>Da <code>x:Bind</code> eine Datenverbindung zur \u00dcbersetzungszeit ist, m\u00fcssen wir auch den Datentyp in der Datenvorlage mit dem Attribut <code>x:DataType</code> angeben. Im obigen Beispiel haben wir <code>model:Person</code>angegeben, so dass das Pr\u00e4fix <code>model</code> dem Namensraum <code>HelloXaml.Models</code> unseres Codes zugeordnet werden soll (der die Klasse <code>Person</code> enth\u00e4lt). Dazu m\u00fcssen wir die folgende Namensraumdeklaration zu den Attributen des Tags <code>Window</code> am Anfang unserer XAML-Datei hinzuf\u00fcgen: <code>xmlns:model=\"using:HelloXaml.Models\"</code> (danach wird das Pr\u00e4fix <code>model</code> verwendet). Dies kann manuell oder mit Visual Studio erfolgen: Klicken wir einfach auf den unterstrichenen (als fehlerhaft markierten) <code>model:Person</code>Text, dann auf die Lampe am Anfang der Zeile (oder die Tastenkombination <code>Ctrl</code> + <code>.</code> ) und w\u00e4hlen wir das angezeigte Element \"Add xmlns using:HelloXaml.Models\".</p> <p>Probieren wir es aus! Die Eintr\u00e4ge erscheinen nun gut in der Liste.</p> <p>Klicken wir auf die Taste Add, um eine neue Kopie von <code>Person</code> mit den Daten der Person des Formilar zur Liste hinzuzuf\u00fcgen, und l\u00f6schen wir dann die Formulardaten in unserem Objekt <code>NewPerson</code>. </p> <p>F\u00fcgen wir dazu unserer Taste Add einen <code>Click</code> Ereignishandler hinzu:</p> <pre><code>&lt;Button ... Click=\"AddButton_Click\"&gt;\n</code></pre> <pre><code>private void AddButton_Click(object sender, RoutedEventArgs e)\n{\n    People.Add(new Person()\n    { \n        Name = NewPerson.Name,\n        Age = NewPerson.Age,\n    });\n\n    NewPerson.Name = string.Empty;\n    NewPerson.Age = 0;\n}\n</code></pre> <p>Der neue Eintrag erscheint nicht in der Liste, da <code>ListView</code> nicht dar\u00fcber informiert wird, dass ein neuer Eintrag in die Liste aufgenommen wurde. Dies kann leicht behoben werden, indem <code>List&lt;Person&gt;</code>durch <code>ObservableCollection&lt;Person&gt;</code>ersetzt wird:</p> <pre><code>public ObservableCollection&lt;Person&gt; People { get; set; }\n</code></pre> <p><code>ObservableCollection&lt;T&gt;</code></p> <p>Es ist wichtig zu beachten, dass sich hier nicht der Wert der Eigenschaft <code>People</code> selbst ge\u00e4ndert hat, sondern der Inhalt des Objekts <code>List&lt;Person&gt;</code>. Die L\u00f6sung ist also nicht die Schnittstelle <code>INotifyPropertyChanged</code>, sondern die Schnittstelle <code>INotifyCollectionChanged</code>, die von <code>ObservableCollection</code> implementiert wird.</p> <p>Wir kennen und verwenden also bereits zwei Schnittstellen, die die Datenverbindung unterst\u00fctzen: <code>INotifyPropertyChanged</code> und <code>INotifyCollectionChanged</code>.</p>"},{"location":"labor/3-felhasznaloi-felulet/index_ger/#ausblick-klassische-bindung","title":"Ausblick: Klassische Bindung","text":"<p>Die klassische Form der Datenverbindung ist die <code>Binding</code> Markup Extension.</p> <p>Die wichtigsten Unterschiede im Vergleich zu <code>x:Bind</code>sind:</p> <ul> <li>Der Standardmodus f\u00fcr <code>Binding</code> ist <code>OneWay</code> und nicht <code>OneTime</code>: Er \u00fcberwacht also standardm\u00e4\u00dfig \u00c4nderungen, w\u00e4hrend dies f\u00fcr <code>x:Bind</code>ausdr\u00fccklich angegeben werden muss.</li> <li><code>Binding</code> arbeitet standardm\u00e4\u00dfig mit <code>DataContext</code>, aber es ist m\u00f6glich, die Quelle f\u00fcr die Datenbindung festzulegen. W\u00e4hrend <code>x:Bind</code> standardm\u00e4\u00dfig von unserer Ansichtsklasse (xaml.cs) gebunden wird.</li> <li><code>Binding</code> arbeitet zur Laufzeit mit Reflection, so dass Sie einerseits keine Kompilierfehler bekommen, wenn Sie etwas falsch schreiben, und andererseits k\u00f6nnen viele Datenbindungen (in der Gr\u00f6\u00dfenordnung von 1000) Ihre Anwendung verlangsamen.</li> <li><code>x:Bind</code> ist kompilierbar, d. h. der Compiler pr\u00fcft, ob die angegebenen Eigenschaften vorhanden sind. In Datenvorlagen m\u00fcssen Sie bei der Angabe von <code>DataTemplate</code> mit dem Attribut <code>x:DataType</code> angeben, mit welchen Daten sie arbeiten werden.</li> <li>F\u00fcr <code>x:Bind</code> ist es m\u00f6glich, Methoden zu binden, w\u00e4hrend f\u00fcr <code>Binding</code>nur Konverter verwendet werden k\u00f6nnen. Bei gebundenen Funktionen funktioniert die \u00c4nderungsbenachrichtigung auch bei \u00c4nderungen von Parametern.</li> </ul> <p>Empfehlung</p> <p>Als Faustregel gilt, dass Sie vorzugsweise <code>x:Bind</code>verwenden sollten, da Sie so schneller und zeitnaher Fehler erhalten. Wenn Sie jedoch aus irgendeinem Grund Probleme mit <code>x:Bind</code>haben, sollten Sie zu <code>Binding</code>wechseln.</p>"},{"location":"labor/4-tobbszalu/","title":"4. T\u00f6bbsz\u00e1l\u00fa alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9se","text":""},{"location":"labor/4-tobbszalu/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja, hogy megismertesse a hallgat\u00f3kat a t\u00f6bbsz\u00e1las programoz\u00e1s sor\u00e1n k\u00f6vetend\u0151 alapelvekkel. \u00c9rintett t\u00e9mak\u00f6r\u00f6k (t\u00f6bbek k\u00f6z\u00f6tt):</p> <ul> <li>Sz\u00e1lak ind\u00edt\u00e1sa (<code>Thread</code>)</li> <li>Sz\u00e1lak le\u00e1ll\u00edt\u00e1sa</li> <li>Sz\u00e1lbiztos (thread safe) oszt\u00e1lyok k\u00e9sz\u00edt\u00e9se a <code>lock</code> kulcssz\u00f3 alkalmaz\u00e1s\u00e1val</li> <li><code>ThreadPool</code> haszn\u00e1lata</li> <li>Jelz\u00e9s \u00e9s jelz\u00e9sre v\u00e1rakoz\u00e1s sz\u00e1l szinkroniz\u00e1ci\u00f3 <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel (<code>WaitHandle</code>)</li> <li>WinUI sz\u00e1lkezel\u00e9si saj\u00e1toss\u00e1gok (<code>DispatcherQueue</code>)</li> </ul> <p>Term\u00e9szetesen, mivel a t\u00e9mak\u00f6r hatalmas, csak alapszint\u0171 tud\u00e1st fogunk szerezni, de e tud\u00e1s birtok\u00e1ban m\u00e1r k\u00e9pesek lesz\u00fcnk \u00f6n\u00e1ll\u00f3an is elindulni a bonyolultabb feladatok megval\u00f3s\u00edt\u00e1s\u00e1ban.</p> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Konkurens (t\u00f6bbsz\u00e1l\u00fa) alkalmaz\u00e1sok fejleszt\u00e9se.</p>"},{"location":"labor/4-tobbszalu/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022<ul> <li>Windows Desktop Development Workload</li> </ul> </li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/4-tobbszalu/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre a <code>megoldas</code> \u00e1gat:</p> <p><code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo -b megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/4-tobbszalu/#bevezeto","title":"Bevezet\u0151","text":"<p>A p\u00e1rhuzamosan fut\u00f3 sz\u00e1lak kezel\u00e9se kiemelt fontoss\u00e1g\u00fa ter\u00fclet, melyet minden szoftverfejleszt\u0151nek legal\u00e1bb alapszinten ismernie kell. A gyakorlat sor\u00e1n alapszint\u0171, de kiemelt fontoss\u00e1g\u00fa probl\u00e9m\u00e1kat oldunk meg, ez\u00e9rt t\u00f6rekedn\u00fcnk kell arra, hogy ne csak a v\u00e9geredm\u00e9nyt, hanem az elv\u00e9gzett m\u00f3dos\u00edt\u00e1sok \u00e9rtelm\u00e9t \u00e9s indokait is meg\u00e9rts\u00fck.</p> <p>A feladat sor\u00e1n egyszer\u0171 WinUI alkalmaz\u00e1st fogunk felruh\u00e1zni t\u00f6bbsz\u00e1las k\u00e9pess\u00e9gekkel, egyre komplexebb feladatokat megoldva. Az alapprobl\u00e9ma a k\u00f6vetkez\u0151: van egy f\u00fcggv\u00e9ny\u00fcnk, mely hossz\u00fa ideig fut, s mint l\u00e1tni fogjuk, ennek \u201edirektben\u201d t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sa a fel\u00fcletr\u0151l kellemetlen k\u00f6vetkezm\u00e9nyekkel j\u00e1r. A megold\u00e1s sor\u00e1n egy megl\u00e9v\u0151 alkalmaz\u00e1st fogunk kieg\u00e9sz\u00edteni saj\u00e1t k\u00f3dr\u00e9szletekkel. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.</p>"},{"location":"labor/4-tobbszalu/#0-feladat-ismerkedes-a-kiindulo-alkalmazassal-elokeszites","title":"0. Feladat - Ismerked\u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal, el\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Kl\u00f3nozzuk le a 4. gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo.git</code></li> <li>Nyissuk meg a SuperCalculator.sln solutiont Visual Studio-ban.</li> </ul> <p>A feladatunk az, hogy egy bin\u00e1ris form\u00e1ban megkapott algoritmus futtat\u00e1s\u00e1hoz WinUI technol\u00f3gi\u00e1val felhaszn\u00e1l\u00f3i fel\u00fcletet k\u00e9sz\u00edts\u00fcnk. A bin\u00e1ris forma .NET eset\u00e9ben egy .dll kiterjeszt\u00e9s\u0171 f\u00e1jlt jelent, ami programoz\u00f3i szemmel egy oszt\u00e1lyk\u00f6nyvt\u00e1r.  A f\u00e1jl neve eset\u00fcnkben Algorithms.dll, megtal\u00e1lhat\u00f3 a lekl\u00f3nozott Git repositoryban.</p> <p>A kiindul\u00f3 alkalmaz\u00e1sban a felhaszn\u00e1l\u00f3i fel\u00fclet el\u0151 is van k\u00e9sz\u00edtve. Futtassuk az alkalmaz\u00e1st:</p> <p></p> <p>Az alkalmaz\u00e1s fel\u00fclet\u00e9n meg tudjuk adni az algoritmus bemen\u0151 param\u00e9tereit (<code>double</code> sz\u00e1mok t\u00f6mbje): a p\u00e9ld\u00e1nkban mindig k\u00e9t <code>double</code> sz\u00e1m param\u00e9terrel h\u00edvjuk az algoritmust, ezt a k\u00e9t fels\u0151 sz\u00f6vegmez\u0151ben lehet megadni. A feladatunk az, hogy a Calculate Result gombra kattint\u00e1s sor\u00e1n futtassuk az algoritmust a megadott param\u00e9terekkel, majd, ha v\u00e9gzett, akkor a Result alatti list\u00e1z\u00f3 mez\u0151 \u00faj sor\u00e1ban jelen\u00edts\u00fck meg a kapott eredm\u00e9nyt a bemen\u0151 param\u00e9terekkel egy\u00fctt.</p> <p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben ismerkedj\u00fcnk meg a let\u00f6lt\u00f6tt Visual Studio solutionnel:</p> <p>A keretalkalmaz\u00e1s egy WinUI 3 alap\u00fa alkalmaz\u00e1s. A fel\u00fclet alapvet\u0151en k\u00e9sz, defin\u00edci\u00f3ja a <code>MainWindow.xaml</code> f\u00e1jlban tal\u00e1lhat\u00f3. Ez sz\u00e1munkra a gyakorlat c\u00e9lj\u00e1t tekintve kev\u00e9sb\u00e9 izgalmas, de otthon a gyakorl\u00e1s kedv\u00e9\u00e9rt \u00e9rdemes \u00e1ttekinteni.</p> Fel\u00fclet kialak\u00edt\u00e1sa a <code>MainWindow.xaml</code>-ben <p>Az ablakfel\u00fclet kialak\u00edt\u00e1s\u00e1nak alapjai:</p> <ul> <li>A gy\u00f6k\u00e9relem (root) \"szok\u00e1sosan\" egy <code>Grid</code>. </li> <li>A gy\u00f6k\u00e9r <code>Grid</code>  fels\u0151 sor\u00e1ban tal\u00e1lhat\u00f3 a k\u00e9t <code>TextBox</code>-ot \u00e9s a <code>Button</code>-t tartalmaz\u00f3 <code>StackPanel</code>.</li> <li>A gy\u00f6k\u00e9r <code>Grid</code> als\u00f3 sor\u00e1ban egy m\u00e1sik <code>Grid</code> tal\u00e1lhat\u00f3. A <code>TextBox</code>-szal ellent\u00e9tben a <code>ListBox</code> nem rendelkezik <code>Header</code> tulajdons\u00e1ggal, \u00edgy ezt nek\u00fcnk kellett egy k\u00fcl\u00f6n\u00e1ll\u00f3 \"Result\" sz\u00f6veg\u0171 <code>TextBlock</code> form\u00e1j\u00e1ban bevezetni. Ezt a <code>Grid</code>-et az\u00e9rt vezett\u00fck be (egy \"egyszer\u0171bb\" <code>StackPanel</code> helyett), mert \u00edgy lehetett el\u00e9rni, hogy a fels\u0151 sor\u00e1ban a \"Result\" <code>TextBlock</code> fix magass\u00e1g\u00fa legyen, az als\u00f3 sorban pedig a <code>ListBox</code> t\u00f6ltse ki a teljes marad\u00f3 helyet (a fels\u0151 sor magass\u00e1ga <code>Auto</code>, az als\u00f3 sor magass\u00e1ga <code>*</code>).</li> <li>A \"Calculate Result\" sz\u00f6veg\u0171 gomb sz\u00e9p p\u00e9lda arra, hogy a <code>Button</code> <code>Content</code>-j\u00e9nek sokszor nemcsak egy egyszer\u0171 sz\u00f6veget adunk meg. A p\u00e9ld\u00e1ban egy <code>SymbolIcon</code> \u00e9s a <code>TextBlock</code> kompoz\u00edci\u00f3ja (<code>StackPanel</code> seg\u00edts\u00e9g\u00e9vel megval\u00f3s\u00edtva), ez\u00e1ltal tudjunk a egy megfelel\u0151 ikont/szimb\u00f3lumot rendelni, mely feldobja a megjelen\u00e9s\u00e9t.</li> <li>Arra is l\u00e1tunk p\u00e9ld\u00e1t, hogy a <code>ListBox</code> hogyan tehet\u0151 g\u00f6rgethet\u0151v\u00e9, ha m\u00e1r sok elem van benne (vagy t\u00fal sz\u00e9lesek az elemek). Ehhez a <code>ScrollViewer</code>-\u00e9t kell megfelel\u0151en param\u00e9terezni.</li> <li>A <code>ListBox</code> <code>ItemContainerStyle</code> tulajdons\u00e1g\u00e1val a <code>ListBox</code> elemre adhatunk meg st\u00edlusokat. A p\u00e9ld\u00e1ban a <code>Padding</code>-et vett\u00fck kisebbre az alap\u00e9rtelmezettn\u00e9l, en\u00e9lk\u00fcl a <code>ListBox</code> elemek magass\u00e1ga helypazarl\u00f3an nagy lenne.</li> </ul> <p>A <code>MainWindow.xaml.cs</code> forr\u00e1sf\u00e1jl a f\u0151ablakhoz tartoz\u00f3 code behind f\u00e1jl, ezt tekints\u00fck \u00e1t, f\u0151bb elemei a k\u00f6vetkez\u0151k:</p> <ul> <li>Az eredm\u00e9ny \u00e9s a param\u00e9terek <code>ListBox</code>-ba t\u00f6rt\u00e9n\u0151 napl\u00f3z\u00e1s\u00e1hoz tal\u00e1lunk egy <code>ShowResult</code> nev\u0171 seg\u00e9df\u00fcggv\u00e9nyt.</li> <li>A <code>CalculateResultButton_Click</code> a gomb a Calculate Result gomb kattint\u00e1s\u00e1hoz tartoz\u00f3 esem\u00e9nykezel\u0151. Azt l\u00e1tjuk, hogy a k\u00e9t sz\u00f6vegdobozb\u00f3l kiolvassa a param\u00e9terek \u00e9rt\u00e9k\u00e9t, \u00e9s megpr\u00f3b\u00e1lja sz\u00e1mm\u00e1 alak\u00edtani. Ha siker\u00fcl, akkor itt t\u00f6rt\u00e9nik majd az algoritmus h\u00edv\u00e1sa (ez nincs m\u00e9g megval\u00f3s\u00edtva), illetve, ha nem siker\u00fcl, akkor a <code>DisplayInvalidElementDialog</code> seg\u00edts\u00e9g\u00e9vel egy \u00fczenetablakban t\u00e1j\u00e9koztatja a felhaszn\u00e1l\u00f3t az \u00e9rv\u00e9nytelen param\u00e9terekr\u0151l.</li> <li>A konstruktorb\u00f3l h\u00edvott <code>AddKeyboardAcceleratorToChangeTheme</code> f\u00fcggv\u00e9ny sz\u00e1munkra nem relev\u00e1ns, a vil\u00e1gos \u00e9s s\u00f6t\u00e9t t\u00e9ma k\u00f6z\u00f6tti v\u00e1lt\u00e1st teszi lehet\u0151v\u00e9 (fut\u00e1s k\u00f6zben \u00e9rdemes kipr\u00f3b\u00e1lni, Ctrl+T billenty\u0171kombin\u00e1ci\u00f3).</li> </ul>"},{"location":"labor/4-tobbszalu/#a-dll-ben-levo-kod-felhasznalasa","title":"A DLL-ben lev\u0151 k\u00f3d felhaszn\u00e1l\u00e1sa","text":"<p>A kiindul\u00f3 projektben megtal\u00e1ljuk a Algorithm.dll-t. Ebben leford\u00edtott form\u00e1ban egy <code>Algorithms</code> n\u00e9vt\u00e9rben lev\u0151 <code>SuperAlgorithm</code> nev\u0171 oszt\u00e1ly tal\u00e1lhat\u00f3, melynek egy <code>Calculate</code> nev\u0171 statikus m\u0171velete van. Ahhoz, hogy egy projektben fel tudjuk haszn\u00e1lni a DLL-ben lev\u0151 oszt\u00e1lyokat, a DLL-re a projekt\u00fcnkben egy \u00fan. referenci\u00e1t kell felvegy\u00fcnk.</p> <ol> <li> <p>Solution Explorerben a projekt\u00fcnk Dependencies node-j\u00e1ra jobbklikkelve v\u00e1lasszuk az Add Project reference opci\u00f3t!</p> <p></p> <p>K\u00fcls\u0151 referenci\u00e1k</p> <p>Itt val\u00f3j\u00e1ban nem egy m\u00e1sik Visual Studio projektre adunk referenci\u00e1t, de \u00edgy a legegyszer\u0171bb el\u0151hozni ezt az ablakot.</p> <p>Megeml\u00edtend\u0151 m\u00e9g, hogy k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rak eset\u00e9ben m\u00e1r nem DLL-eket szoktunk refer\u00e1lni egy rendes projektben, hanem a .NET csomagkezel\u0151 rendeszer\u00e9b\u0151l a NuGet-r\u0151l szok\u00e1s a k\u00fcls\u0151 csomagokat beszerezni. Most az Algorithm.dll eset\u00fcnkben nincs NuGet-en publik\u00e1lva, ez\u00e9rt kell k\u00e9zzel felvegy\u00fck azt.</p> </li> <li> <p>Az el\u0151ugr\u00f3 ablak jobb als\u00f3 sarokban tal\u00e1lhat\u00f3 Browse gomb seg\u00edts\u00e9g\u00e9vel keress\u00fck meg \u00e9s v\u00e1lasszuk ki projekt External almapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 Algorithms.dll f\u00e1jlt, majd hagyjuk j\u00f3v\u00e1 a hozz\u00e1ad\u00e1st az OK gombbal!</p> </li> </ol> <p>A Solution Explorerben egy projekt alatti Dependencies csom\u00f3pontot lenyitva l\u00e1thatjuk a hivatkozott k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket. Itt most m\u00e1r megjelenik az Assemblyk k\u00f6z\u00f6tt el\u0151bb felvett Algorithms referencia is. A Frameworks kateg\u00f3ri\u00e1ban a .NET keretrendszer csomagjait tal\u00e1ljuk. Az Analyzerek pedig statikus k\u00f3delemz\u0151 eszk\u00f6z\u00f6k ford\u00edt\u00e1s id\u0151ben. Illetve itt lenn\u00e9nek m\u00e9g a projekt vagy a NuGet referenci\u00e1k is.</p> <p></p> <p>Kattintsunk Algorithms referenci\u00e1n jobb gombbal \u00e9s v\u00e1lasszuk a View in Object Browser funkci\u00f3t. Ekkor megny\u00edlik az Object Browser tabf\u00fcl, ahol megtekinthetj\u00fck, hogy az adott DLL-ben milyen n\u00e9vterek, oszt\u00e1lyok tal\u00e1lhat\u00f3k, illetve ezeknek milyen tagjaik (tagv\u00e1ltoz\u00f3, tagf\u00fcggv\u00e9ny, property, event) vannak. Ezeket a Visual Studio a DLL metaadataib\u00f3l az \u00fan. reflection mechanizmus seg\u00edts\u00e9g\u00e9vel olvassa ki (ilyen k\u00f3dot ak\u00e1r mi is \u00edrhatunk).</p> <p>Az al\u00e1bbi \u00e1br\u00e1nak megfelel\u0151en az Object Browserben baloldalt keress\u00fck ki az Algorithms csom\u00f3pontot, nyissuk le, \u00e9s l\u00e1that\u00f3v\u00e1 v\u00e1lik, hogy egy <code>Algorithms</code> n\u00e9vt\u00e9r van benne, abban pedig egy <code>SuperAlgorithm</code> oszt\u00e1ly. Ezt kiv\u00e1lasztva k\u00f6z\u00e9pen megjelennek az oszt\u00e1ly f\u00fcggv\u00e9nyei, itt egy f\u00fcggv\u00e9nyt kiv\u00e1lasztva pedig az adott f\u00fcggv\u00e9ny pontos szignat\u00far\u00e1ja:</p> <p></p>"},{"location":"labor/4-tobbszalu/#1-feladat-muvelet-futtatasa-a-foszalon","title":"1. Feladat \u2013 M\u0171velet futtat\u00e1sa a f\u0151sz\u00e1lon","text":"<p>Most m\u00e1r r\u00e1t\u00e9rhet\u00fcnk az algoritmus futtat\u00e1s\u00e1ra. Els\u0151 l\u00e9p\u00e9sben ezt az alkalmaz\u00e1sunk f\u0151 sz\u00e1l\u00e1n tessz\u00fck meg.</p> <ol> <li> <p>A f\u0151ablakon l\u00e9v\u0151 gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben h\u00edvjuk meg a sz\u00e1mol\u00f3 f\u00fcggv\u00e9ny\u00fcnket. Ehhez a Solution Explorerben nyissuk meg a <code>MainWindow.xaml.cs</code> code behind f\u00e1jlt, \u00e9s keress\u00fck meg a <code>CalculateResultButton_Click</code> esem\u00e9nykezel\u0151t. Eg\u00e9sz\u00edts\u00fck ki a k\u00f3dot az \u00fajonnan behivatkozott algoritmus megh\u00edv\u00e1s\u00e1val.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n        ShowResult(parameters, result);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az ablak a sz\u00e1mol\u00e1s ideje alatt nem reag\u00e1l a mozgat\u00e1sra, \u00e1tm\u00e9retez\u00e9sre, a fel\u00fclet gyakorlatilag befagy.</p> </li> </ol> <p>Az alkalmaz\u00e1sunk esem\u00e9nyvez\u00e9relt, mint minden Windows alkalmaz\u00e1s. Az oper\u00e1ci\u00f3s rendszer a k\u00fcl\u00f6nb\u00f6z\u0151 interakci\u00f3kr\u00f3l (pl. mozgat\u00e1s, \u00e1tm\u00e9retez\u00e9s, eg\u00e9rkattint\u00e1s) \u00e9rtes\u00edti az alkalmaz\u00e1sunkat: mivel a gombnyom\u00e1st k\u00f6vet\u0151en az alkalmaz\u00e1sunk egyetlen sz\u00e1la a kalkul\u00e1ci\u00f3val van elfoglalva, nem tudja azonnal feldolgozni a tov\u00e1bbi felhaszn\u00e1l\u00f3i utas\u00edt\u00e1sokat. Amint a sz\u00e1m\u00edt\u00e1s lefutott (\u00e9s az eredm\u00e9nyek megjelennek a list\u00e1ban) a kor\u00e1bban kapott parancsok is v\u00e9grehajt\u00e1sra ker\u00fclnek.</p>"},{"location":"labor/4-tobbszalu/#2-feladat-vegezzuk-a-szamitast-kulon-szalban","title":"2. Feladat \u2013 V\u00e9gezz\u00fck a sz\u00e1m\u00edt\u00e1st k\u00fcl\u00f6n sz\u00e1lban","text":"<p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a sz\u00e1m\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9re egy k\u00fcl\u00f6n sz\u00e1lat fogunk ind\u00edtani, hogy az ne blokkolja a felhaszn\u00e1l\u00f3i fel\u00fcletet.</p> <ol> <li> <p>K\u00e9sz\u00edts\u00fcnk egy \u00faj f\u00fcggv\u00e9nyt a <code>MainWindow</code> oszt\u00e1lyban, mely a feldolgoz\u00f3 sz\u00e1l bel\u00e9p\u00e9si pontja lesz.</p> <pre><code>private void CalculatorThread(object arg)\n{\n    var parameters = (double[])arg;\n    var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n    ShowResult(parameters, result);\n}\n</code></pre> </li> <li> <p>Ind\u00edtsuk el a sz\u00e1lat a gomb <code>Click</code> esem\u00e9nykezel\u0151j\u00e9ben. Ehhez cser\u00e9lj\u00fck le a kor\u00e1bban hozz\u00e1adott k\u00f3dot:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var th = new Thread(CalculatorThread);\n        th.Start(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>A Thread objektum <code>Start</code> m\u0171velet\u00e9ben \u00e1tadott param\u00e9tert kapja meg a <code>CalculatorThread</code> sz\u00e1lf\u00fcggv\u00e9ny\u00fcnk.</p> </li> <li> <p>Futtassuk az alkalmaz\u00e1st F5-tel (most fontos, hogy \u00edgy, a debuggerben futtassuk)! The application called an interface that was marshalled for a different thread. (0x8001010E (RPC_E_WRONG_THREAD)) hiba\u00fczenetet kapunk a <code>ShowResult</code> met\u00f3dusban, ugyanis nem abb\u00f3l a sz\u00e1lb\u00f3l pr\u00f3b\u00e1lunk hozz\u00e1f\u00e9rni a UI elemhez / vez\u00e9rl\u0151h\u00f6z, amelyik l\u00e9trehozta (a vez\u00e9rl\u0151t). A k\u00f6vetkez\u0151 feladatban ezt a probl\u00e9m\u00e1t analiz\u00e1ljuk \u00e9s oldjuk meg.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#3-feladat-a-dispatcherqueuehasthreadaccess-es-dispatcherqueuetryenqueue-hasznalata","title":"3. Feladat \u2013 a <code>DispatcherQueue.HasThreadAccess</code> \u00e9s <code>DispatcherQueue.TryEnqueue</code> haszn\u00e1lata","text":"<p>Az el\u0151z\u0151 pontban a probl\u00e9m\u00e1t a k\u00f6vetkez\u0151 okozza. WinUI alkalmaz\u00e1sokn\u00e1l \u00e9l az al\u00e1bbi szab\u00e1ly: az ablakok/fel\u00fcletelemek/vez\u00e9rl\u0151elemek alapvet\u0151en nem sz\u00e1lv\u00e9dett (thread safe) objektumok, \u00edgy egy ablakhoz/fel\u00fcletelemhez/vez\u00e9rl\u0151h\u00f6z csak abb\u00f3l a sz\u00e1lb\u00f3l szabad hozz\u00e1f\u00e9rni (pl. propertyj\u00e9t olvasni, \u00e1ll\u00edtani, m\u0171velet\u00e9t megh\u00edvni), amelyik sz\u00e1l az adott ablakot/fel\u00fcletelemet/vez\u00e9rl\u0151t l\u00e9trehozta, m\u00e1sk\u00fcl\u00f6nben kiv\u00e9telt kapunk. Alkalmaz\u00e1sunkban az\u00e9rt kaptunk kiv\u00e9telt, mert a <code>resultListBox</code> vez\u00e9rl\u0151t a f\u0151 sz\u00e1lban hoztuk l\u00e9tre, a <code>ShowResult</code> met\u00f3dusban az eredm\u00e9ny megjelen\u00edt\u00e9sekor viszont egy m\u00e1sik sz\u00e1lb\u00f3l f\u00e9r\u00fcnk hozz\u00e1 (<code>resultListBox.Items.Add</code> m\u0171velet h\u00edv\u00e1sa).</p> <p>K\u00e9rd\u00e9s, hogyan lehet m\u00e9gis valamilyen m\u00f3don ezekhez a fel\u00fcletelemekhez/vez\u00e9rl\u0151kh\u00f6z egy m\u00e1sik sz\u00e1lb\u00f3l hozz\u00e1f\u00e9rni. A megold\u00e1st a <code>DispatcherQueue</code> alkalmaz\u00e1sa jelenti, mely abban ny\u00fajt seg\u00edts\u00e9get, hogy a vez\u00e9rl\u0151kh\u00f6z mindig a megfelel\u0151 sz\u00e1lb\u00f3l t\u00f6rt\u00e9njen a hozz\u00e1f\u00e9r\u00e9s:</p> <ul> <li><code>DispatcherQueue</code> objektum <code>TryEnqueue</code> f\u00fcggv\u00e9nye a vez\u00e9rl\u0151elemet l\u00e9trehoz\u00f3 sz\u00e1lon futtatja le a sz\u00e1m\u00e1ra param\u00e9terk\u00e9nt megadott f\u00fcggv\u00e9nyt (mely f\u00fcggv\u00e9nyb\u0151l \u00edgy m\u00e1r k\u00f6zvetlen\u00fcl hozz\u00e1f\u00e9rhet\u00fcnk a vez\u00e9rl\u0151h\u00f6z).</li> <li>A <code>DispatcherQueue</code> objektum <code>HasThreadAccess</code> tulajdons\u00e1ga azt seg\u00edt eld\u00f6nteni, sz\u00fcks\u00e9g van-e egy\u00e1ltal\u00e1n az el\u0151z\u0151 pontban eml\u00edtett <code>TryEnqueue</code> alkalmaz\u00e1s\u00e1ra. Ha a tulajdons\u00e1g \u00e9rt\u00e9ke<ul> <li>igaz, akkor a vez\u00e9rl\u0151h\u00f6z k\u00f6zvetlen\u00fcl is hozz\u00e1f\u00e9rhet\u00fcnk (mert az aktu\u00e1lis sz\u00e1l megegyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal), ellenben ha</li> <li>hamis, akkor a vez\u00e9rl\u0151h\u00f6z csak \"ker\u00fcl\u0151 \u00faton\", a <code>DispatcherQueue</code> objektum <code>TryEnqueue</code> seg\u00edts\u00e9g\u00e9vel f\u00e9rhet\u00fcnk hozz\u00e1 (mert az aktu\u00e1lis sz\u00e1l NEM egyezik a vez\u00e9rl\u0151t l\u00e9trehoz\u00f3 sz\u00e1llal).</li> </ul> </li> </ul> <p>A <code>DispatcherQueue</code> seg\u00edts\u00e9g\u00e9vel teh\u00e1t el tudjuk ker\u00fclni kor\u00e1bbi kiv\u00e9tel\u00fcnket (a vez\u00e9rl\u0151h\u00f6z, eset\u00fcnkben a <code>resultListBox</code>-hoz val\u00f3 hozz\u00e1f\u00e9r\u00e9st a megfelel\u0151 sz\u00e1lra tudjuk \"ir\u00e1ny\u00edtani\"). Ezt fogjuk a k\u00f6vetkez\u0151kben megtenni.</p> <p>Note</p> <p>A <code>DispatcherQueue</code> objektum a Window oszt\u00e1ly lesz\u00e1rmazottakban \u00e9rhet\u0151 el a<code>DispatcherQueue</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl (m\u00e1s oszt\u00e1lyokban pedig a <code>DispatcherQueue.GetForCurrentThread()</code> statikus m\u0171velet seg\u00edts\u00e9g\u00e9vel szerezhet\u0151 meg).</p> <p>M\u00f3dos\u00edtanunk kell a <code>ShowResult</code> met\u00f3dust annak \u00e9rdek\u00e9ben, hogy mell\u00e9ksz\u00e1lb\u00f3l t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1s eset\u00e9n se dobjon kiv\u00e9telt.</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    // Closing the window the DispatcherQueue property may return null, so we have to perform a null check\n    if (this.DispatcherQueue == null)\n        return;\n\n    if (this.DispatcherQueue.HasThreadAccess)\n    {\n        var item = new ListBoxItem()\n        {\n            Content = $\"{parameters[0]} #  {parameters[1]} = {result}\"\n        };\n        resultListBox.Items.Add(item);\n        resultListBox.ScrollIntoView(item);\n    }\n    else\n    {\n        this.DispatcherQueue.TryEnqueue( () =&gt; ShowResult(parameters, result) );\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>Ez a megold\u00e1s m\u00e1r m\u0171k\u00f6d\u0151k\u00e9pes, f\u0151bb elemei a k\u00f6vetkez\u0151k:</p> <ul> <li>A <code>DispatcherQueue</code> <code>null</code> vizsg\u00e1lat szerepe: a f\u0151ablak bez\u00e1r\u00e1sa ut\u00e1n a <code>DispatcherQueue</code> m\u00e1r <code>null</code>, nem haszn\u00e1lhat\u00f3.</li> <li>A <code>DispatcherQueue.HasThreadAccess</code> seg\u00edts\u00e9g\u00e9vel megn\u00e9zz\u00fck, hogy a h\u00edv\u00f3 sz\u00e1l hozz\u00e1f\u00e9rhet-e k\u00f6zvetlen\u00fcl a vez\u00e9rl\u0151kh\u00f6z (eset\u00fcnkben a <code>ListBox</code>-hoz):<ul> <li>Ha igen, minden \u00fagy t\u00f6rt\u00e9nik, mint eddig, a <code>ListBox</code>-ot kezel\u0151 k\u00f3d v\u00e1ltozatlan.</li> <li>Ha nem, a <code>DispatcherQueue.TryEnqueue</code> seg\u00edts\u00e9g\u00e9vel f\u00e9r\u00fcnk hozz\u00e1 a vez\u00e9rl\u0151h\u00f6z. A k\u00f6vetkez\u0151 tr\u00fckk\u00f6t alkalmazzuk. A <code>TryEnqueue</code> f\u00fcggv\u00e9nynek egy olyan param\u00e9ter n\u00e9lk\u00fcli, egysoros f\u00fcggv\u00e9nyt adunk meg lambda kifejez\u00e9s form\u00e1j\u00e1ban, mellyel a <code>ShowResult</code> f\u00fcggv\u00e9ny\u00fcnket h\u00edvja meg (gyakorlatilag rekurz\u00edvan), a param\u00e9tereket tov\u00e1bb passzolva sz\u00e1m\u00e1ra. Ez nek\u00fcnk az\u00e9rt j\u00f3, mert ez a <code>ShowResult</code> h\u00edv\u00e1s m\u00e1r azon a sz\u00e1lon t\u00f6rt\u00e9nik, mely a vez\u00e9rl\u0151t l\u00e9trehozta (az alkalmaz\u00e1s f\u0151 sz\u00e1la), ebben a <code>HasThreadAccess</code> \u00e9rt\u00e9ke m\u00e1r igaz, \u00e9s hozz\u00e1 tudunk f\u00e9rni k\u00f6zvetlen\u00fcl a <code>ListBox</code>-unkhoz. Ez a rekurz\u00edv megk\u00f6zel\u00edt\u00e9s egy bevett minta a redund\u00e1ns k\u00f3dok elker\u00fcl\u00e9s\u00e9re.</li> </ul> </li> </ul> <p>Tegy\u00fcnk t\u00f6r\u00e9spontot a <code>ShowResult</code> m\u0171velet els\u0151 sor\u00e1ra, \u00e9s az alkalmaz\u00e1st futtatva gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy a <code>ShowResult</code> m\u0171velet els\u0151 h\u00edv\u00e1sakor <code>HasThreadAccess</code> m\u00e9g hamis (\u00edgy megt\u00f6rt\u00e9nik a <code>TryEnqueue</code> h\u00edv\u00e1sa), majd ennek hat\u00e1s\u00e1ra m\u00e9g egyszer megh\u00edv\u00f3dik a <code>ShowResult</code>, de ekkor a <code>HasThreadAccess</code> \u00e9rt\u00e9ke m\u00e1r igaz.</p> <p>Vegy\u00fck ki a t\u00f6r\u00e9spontot, \u00edgy futtassuk az alkalmaz\u00e1st: vegy\u00fck \u00e9szre, hogy am\u00edg egy sz\u00e1m\u00edt\u00e1s fut, \u00fajabbakat is ind\u00edthatunk, hiszen a fel\u00fclet\u00fcnk v\u00e9gig reszponz\u00edv maradt (a kor\u00e1bban tapasztalt hiba pedig m\u00e1r nem jelentkezik).</p>"},{"location":"labor/4-tobbszalu/#4-feladat-muvelet-vegzese-threadpool-szalon","title":"4. feladat \u2013 M\u0171velet v\u00e9gz\u00e9se Threadpool sz\u00e1lon","text":"<p>Az el\u0151z\u0151 megold\u00e1s egy jellemz\u0151je, hogy mindig \u00faj sz\u00e1lat hoz l\u00e9tre a m\u0171velethez. Eset\u00fcnkben ennek nincs k\u00fcl\u00f6n\u00f6sebb jelent\u0151s\u00e9ge, de ez a megk\u00f6zel\u00edt\u00e9s egy olyan kiszolg\u00e1l\u00f3 alkalmaz\u00e1s eset\u00e9ben, amely nagysz\u00e1m\u00fa k\u00e9r\u00e9st szolg\u00e1l ki \u00fagy, hogy minden k\u00e9r\u00e9shez k\u00fcl\u00f6n sz\u00e1lat ind\u00edt, m\u00e1r probl\u00e9m\u00e1s lehet. K\u00e9t okb\u00f3l is:</p> <ul> <li>Ha a sz\u00e1lf\u00fcggv\u00e9ny gyorsan lefut (egy kliens kiszolg\u00e1l\u00e1sa gyors), akkor a CPU nagy r\u00e9sz\u00e9t arra pazaroljuk, hogy sz\u00e1lakat ind\u00edtsunk \u00e9s \u00e1ll\u00edtsunk le, ezek ugyanis \u00f6nmagukban is er\u0151forr\u00e1sig\u00e9nyesek.</li> <li>T\u00fal nagy sz\u00e1m\u00fa sz\u00e1l is l\u00e9trej\u00f6het, ennyit kell \u00fctemeznie az oper\u00e1ci\u00f3s rendszernek, ami feleslegesen pazarolja az er\u0151forr\u00e1sokat.</li> </ul> <p>Egy m\u00e1sik probl\u00e9ma jelen megold\u00e1sunkkal: mivel a sz\u00e1m\u00edt\u00e1s \u00fan. el\u0151t\u00e9rsz\u00e1lon fut (az \u00fajonnan l\u00e9trehozott sz\u00e1lak alap\u00e9rtelmez\u00e9sben el\u0151t\u00e9rsz\u00e1lak), hi\u00e1ba z\u00e1rjuk be az alkalmaz\u00e1st, a program tov\u00e1bb fut a h\u00e1tt\u00e9rben mindaddig, am\u00edg v\u00e9gre nem hajt\u00f3dik az utolj\u00e1ra ind\u00edtott sz\u00e1mol\u00e1s is: egy processz fut\u00e1sa ugyanis akkor fejez\u0151dik csak be, ha m\u00e1r nincs fut\u00f3 el\u0151t\u00e9rsz\u00e1la.</p> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy \u00faj sz\u00e1l ind\u00edt\u00e1sa helyett threadpool sz\u00e1lon futtassa a sz\u00e1m\u00edt\u00e1st. Ehhez csak a gombnyom\u00e1s esem\u00e9nykezel\u0151j\u00e9t kell ism\u00e9t \u00e1t\u00edrni.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        ThreadPool.QueueUserWorkItem(CalculatorThread, parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, \u00e9s vegy\u00fck \u00e9szre, hogy az alkalmaz\u00e1s az ablak bez\u00e1r\u00e1sakor azonnal le\u00e1ll, nem foglalkozik az esetlegesen m\u00e9g fut\u00f3 sz\u00e1lakkal (mert a threadpool sz\u00e1lak h\u00e1tt\u00e9r sz\u00e1lak).</p>"},{"location":"labor/4-tobbszalu/#5-feladat-termelo-fogyaszto-alapu-megoldas","title":"5. Feladat \u2013 Termel\u0151-fogyaszt\u00f3 alap\u00fa megold\u00e1s","text":"<p>Az el\u0151z\u0151 feladatok megold\u00e1sa sor\u00e1n \u00f6nmag\u00e1ban egy j\u00f3l m\u0171k\u00f6d\u0151 komplett megold\u00e1s\u00e1t kaptuk az eredeti probl\u00e9m\u00e1nak, mely lehet\u0151v\u00e9 teszi, hogy ak\u00e1r t\u00f6bb munkasz\u00e1l is p\u00e1rhuzamosan dolgozzon a h\u00e1tt\u00e9rben a sz\u00e1m\u00edt\u00e1son, ha a gombot sokszor egym\u00e1s ut\u00e1n megnyomjuk. A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1sunkat, hogy a gombnyom\u00e1sra ne mindig keletkezzen \u00faj sz\u00e1l, hanem a feladatok beker\u00fcljenek egy feladatsorba, ahonnan t\u00f6bb, a h\u00e1tt\u00e9rben folyamatosan fut\u00f3 sz\u00e1l egym\u00e1s ut\u00e1n fogja kivenni \u0151ket \u00e9s v\u00e9grehajtani. Ez a feladat a klasszikus termel\u0151-fogyaszt\u00f3 probl\u00e9ma, mely a gyakorlatban is sokszor el\u0151fordul, a m\u0171k\u00f6d\u00e9s\u00e9t az al\u00e1bbi \u00e1bra szeml\u00e9lteti.</p> <p></p> <p>Termel\u0151 fogyaszt\u00f3 vs <code>ThreadPool</code></p> <p>Ha belegondolunk, a <code>ThreadPool</code> is egy speci\u00e1lis, a .NET \u00e1ltal sz\u00e1munkra biztos\u00edtott termel\u0151-fogyaszt\u00f3 \u00e9s \u00fctemez\u0151 mechanizmus. A k\u00f6vetkez\u0151kben egy m\u00e1s jelleg\u0171 termel\u0151-fogyaszt\u00f3 megold\u00e1st dolgozunk ki annak \u00e9rdek\u00e9ben, hogy bizonyos sz\u00e1lkezel\u00e9ssel kapcsolatos konkurencia probl\u00e9m\u00e1kkal tal\u00e1lkozhassunk.</p> <p>A f\u0151sz\u00e1lunk a termel\u0151, a Calculate result gombra kattintva hoz l\u00e9tre egy \u00faj feladatot. Fogyaszt\u00f3/feldolgoz\u00f3 munkasz\u00e1lb\u00f3l az\u00e9rt ind\u00edtunk majd t\u00f6bbet, mert \u00edgy t\u00f6bb CPU magot is ki tudunk haszn\u00e1lni, valamint a feladatok v\u00e9grehajt\u00e1s\u00e1t p\u00e1rhuzamos\u00edtani tudjuk.</p> <p>A feladatok ideiglenes t\u00e1rol\u00e1s\u00e1ra a kiindul\u00f3 projekt\u00fcnkben m\u00e1r n\u00e9mik\u00e9ppen el\u0151k\u00e9sz\u00edtett <code>DataFifo</code> oszt\u00e1lyt tudjuk haszn\u00e1lni (a Solution Explorerben a <code>Data</code> mapp\u00e1ban tal\u00e1lhat\u00f3). N\u00e9zz\u00fck meg a forr\u00e1sk\u00f3dj\u00e1t. Egy egyszer\u0171 FIFO sort val\u00f3s\u00edt meg, melyben <code>double[]</code> elemeket t\u00e1rol. A <code>Put</code> met\u00f3dus hozz\u00e1f\u0171zi a bels\u0151 lista v\u00e9g\u00e9hez az \u00faj p\u00e1rokat, m\u00edg a <code>TryGet</code> met\u00f3dus visszaadja (\u00e9s elt\u00e1vol\u00edtja) a bels\u0151 lista els\u0151 elem\u00e9t. Amennyiben a lista \u00fcres, a f\u00fcggv\u00e9ny nem tud visszaadni elemet. Ilyenkor a <code>false</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelzi ezt.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a gomb esem\u00e9nykezel\u0151j\u00e9t, hogy ne <code>ThreadPool</code>ba dolgozzon, hanem a FIFO-ba:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        _fifo.Put(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>K\u00e9sz\u00edts\u00fck el az \u00faj sz\u00e1lkezel\u0151 f\u00fcggv\u00e9ny na\u00edv implement\u00e1ci\u00f3j\u00e1t az \u0171rlap oszt\u00e1lyunkban:</p> <pre><code>private void WorkerThread()\n{\n    while (true)\n    {\n        if (_fifo.TryGet(out var data))\n        {\n            double result = Algorithms.SuperAlgorithm.Calculate(data);\n            ShowResult(data, result);\n        }\n\n        Thread.Sleep(500);\n    }\n}\n</code></pre> <p>A <code>Thread.Sleep</code> bevezet\u00e9s\u00e9re az\u00e9rt van sz\u00fcks\u00e9g, mert e n\u00e9lk\u00fcl a munkasz\u00e1lak \u00fcres FIFO eset\u00e9n folyamatosan feleslegesen p\u00f6r\u00f6gn\u00e9nek, semmi hasznos m\u0171veletet nem v\u00e9gezve is 100%-ban kiterheln\u00e9nek egy-egy CPU magot. Megold\u00e1sunk nem ide\u00e1lis, k\u00e9s\u0151bb tov\u00e1bbfejlesztj\u00fck.</p> </li> <li> <p>Hozzuk l\u00e9tre, \u00e9s ind\u00edtsuk el a feldolgoz\u00f3 sz\u00e1lakat a konstruktorban:</p> <pre><code>new Thread(WorkerThread) { Name = \"Worker thread 1\" }.Start();\nnew Thread(WorkerThread) { Name = \"Worker thread 2\" }.Start();\nnew Thread(WorkerThread) { Name = \"Worker thread 3\" }.Start();\n</code></pre> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, majd z\u00e1rjuk is be azonnal an\u00e9lk\u00fcl, hogy a Calculate Result gombra kattintan\u00e1nk. Az tapasztaljuk, hogy az ablakunk bez\u00e1r\u00f3dik ugyan, de a processz\u00fcnk tov\u00e1bb fut, az alkalmaz\u00e1s bez\u00e1r\u00e1s\u00e1ra csak a Visual Studiob\u00f3l, vagy a Task Managerb\u0151l van lehet\u0151s\u00e9g:</p> <p></p> <p>A feldolgoz\u00f3 sz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9p\u00e9skor megakad\u00e1lyozz\u00e1k a processz megsz\u0171n\u00e9s\u00e9t. Az egyik megold\u00e1s az lehetne, ha a sz\u00e1lak <code>IsBackground</code> tulajdons\u00e1g\u00e1t <code>true</code>-ra \u00e1ll\u00edtan\u00e1nk a l\u00e9trehoz\u00e1sukat k\u00f6vet\u0151en. A m\u00e1sik megold\u00e1s, hogy kil\u00e9p\u00e9skor gondoskodunk a feldolgoz\u00f3 sz\u00e1lak kil\u00e9ptet\u00e9s\u00e9r\u0151l. Egyel\u0151re tegy\u00fck f\u00e9lre ezt a probl\u00e9m\u00e1t, k\u00e9s\u0151bb visszat\u00e9r\u00fcnk r\u00e1.</p> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st azt tapasztaljuk, hogy miut\u00e1n kattintunk a Calculate Result gombon (csak egyszer kattintsunk rajta) nagy val\u00f3sz\u00edn\u0171s\u00e9ggel kiv\u00e9telt fogunk kapni. A probl\u00e9ma az, hogy a <code>DataFifo</code> nem sz\u00e1lbiztos, inkonzisztens\u00e9 v\u00e1lt. K\u00e9t ered\u0151 ok is h\u00faz\u00f3dik a h\u00e1tt\u00e9rben:</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#problema-1","title":"Probl\u00e9ma 1","text":"<p>N\u00e9zz\u00fck a k\u00f6vetkez\u0151 forgat\u00f3k\u00f6nyvet:</p> <ol> <li>A sor \u00fcres. A feldolgoz\u00f3 sz\u00e1lak egy <code>while</code> ciklusban folyamatosan pollozz\u00e1k a FIFO-t, vagyis h\u00edvj\u00e1k a <code>TryGet</code> met\u00f3dus\u00e1t.</li> <li>A felhaszn\u00e1l\u00f3 egy feladatot tesz a sorba.</li> <li>Az egyik feldolgoz\u00f3 sz\u00e1l a <code>TryGet</code> met\u00f3dusban azt l\u00e1tja, van adat a sorban, vagyis <code>if ( _innerList.Count &gt; 0 )</code> k\u00f3dsor felt\u00e9tele teljes\u00fcl, \u00e9s r\u00e1l\u00e9p a k\u00f6vetkez\u0151 k\u00f3dsorra. Tegy\u00fck fel, hogy ez a sz\u00e1l ebben a pillanatban elveszti a fut\u00e1si jog\u00e1t, m\u00e1r nincs ideje kivenni az adatot a sorb\u00f3l.</li> <li>Egy m\u00e1sik feldolgoz\u00f3 sz\u00e1l is \u00e9ppen ekkor ejti meg az <code>if ( _innerList.Count &gt; 0 )</code> vizsg\u00e1latot, n\u00e1la is teljes\u00fcl a felt\u00e9tel, \u00e9s ez a sz\u00e1l ki is veszi az adatot a sorb\u00f3l.</li> <li>Az els\u0151 sz\u00e1lunk \u00fajra \u00fctemez\u00e9sre ker\u00fcl, fel\u00e9bred, \u0151 is megpr\u00f3b\u00e1lja kivenni az adatot a sorb\u00f3l: a sor viszont m\u00e1r \u00fcres, a m\u00e1sik sz\u00e1lunk kivette az egyetlen adatot a sorb\u00f3l az orra el\u0151tt. \u00cdgy az <code>_innerList[0]</code> hozz\u00e1f\u00e9r\u00e9s kiv\u00e9telt eredm\u00e9nyez.</li> </ol> <p>Ezt a probl\u00e9m\u00e1t csak \u00fagy tudjuk elker\u00fclni, ha a sor \u00fcress\u00e9g\u00e9nek a vizsg\u00e1lat\u00e1t \u00e9s az elem kiv\u00e9tel\u00e9t \"oszthatatlann\u00e1\" tessz\u00fck: ez azt jelenti, hogy am\u00edg az egyik sz\u00e1l nem v\u00e9gzett mindkett\u0151vel, addig a t\u00f6bbi sz\u00e1lnak v\u00e1rnia kell!</p> <p>Thread.Sleep(500)</p> <p>Az \u00fcress\u00e9gvizsg\u00e1latot figyel\u0151 k\u00f3dsort k\u00f6vet\u0151 <code>Thread.Sleep(500);</code> k\u00f3dsornak csak az a szerepe a p\u00e9ldak\u00f3dunkban, hogy a fenti peches forgat\u00f3k\u00f6nyv bek\u00f6vetkez\u00e9s\u00e9nek a val\u00f3sz\u00edn\u0171s\u00e9g\u00e9t megn\u00f6velje, s \u00edgy a p\u00e9ld\u00e1t szeml\u00e9letesebb\u00e9 tegye (mivel ilyenkor szinte biztos, hogy \u00e1t\u00fctemez\u0151dik a sz\u00e1l). A k\u00e9s\u0151bbiekben ezt ki is fogjuk venni, egyel\u0151re hagyjuk benne.</p>"},{"location":"labor/4-tobbszalu/#problema-2","title":"Probl\u00e9ma 2","text":"<p>A <code>DataFifo</code> oszt\u00e1ly egyid\u0151ben t\u00f6bb sz\u00e1lb\u00f3l is hozz\u00e1f\u00e9rhet a <code>List&lt;double[]&gt;</code> t\u00edpus\u00fa <code>_innerList</code> tagv\u00e1ltoz\u00f3hoz. Ugyanakkor, ha megn\u00e9zz\u00fck a <code>List&lt;T&gt;</code> dokument\u00e1ci\u00f3j\u00e1t, azt tal\u00e1ljuk, hogy az oszt\u00e1ly nem sz\u00e1lbiztos (not thread safe). Ez esetben viszont ezt nem tehetj\u00fck meg, nek\u00fcnk kell a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1st z\u00e1rakkal biztos\u00edtanunk: meg kell oldjuk, hogy a sz\u00e1laink egyid\u0151ben csak egy met\u00f3dus\u00e1hoz / tulajdons\u00e1g\u00e1hoz / tagv\u00e1ltoz\u00f3j\u00e1hoz f\u00e9rjenek hozz\u00e1 (pontosabban inkonzisztencia csak egyidej\u0171 \u00edr\u00e1s, illetve egyidej\u0171 \u00edr\u00e1s \u00e9s olvas\u00e1s eset\u00e9n l\u00e9phet fel, de az \u00edr\u00f3kat \u00e9s az olvas\u00f3kat a legt\u00f6bb esetben nem szoktuk megk\u00fcl\u00f6nb\u00f6ztetni, itt sem tessz\u00fck).</p> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a <code>DataFifo</code> oszt\u00e1lyunkat sz\u00e1lbiztoss\u00e1 tessz\u00fck, amivel megakad\u00e1lyozzuk, hogy a fenti k\u00e9t probl\u00e9ma bek\u00f6vetkezhessen.</p>"},{"location":"labor/4-tobbszalu/#6-feladat-tegyuk-szabiztossa-a-datafifo-osztalyt","title":"6. feladat \u2013 Tegy\u00fck sz\u00e1biztoss\u00e1 a DataFifo oszt\u00e1lyt","text":"<p>A <code>DataFifo</code> oszt\u00e1ly sz\u00e1lbiztoss\u00e1 t\u00e9tel\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy objektumra (ez b\u00e1rmilyen referencia t\u00edpus\u00fa objektum lehet), melyet kulcsk\u00e9nt haszn\u00e1lhatunk a z\u00e1rol\u00e1sn\u00e1l. Ezt k\u00f6vet\u0151en a <code>lock</code> kulcssz\u00f3 seg\u00edts\u00e9g\u00e9vel el tudjuk \u00e9rni, hogy egyszerre mindig csak egy sz\u00e1l tart\u00f3zkodjon az adott kulccsal v\u00e9dett blokkokban.</p> <ol> <li> <p>Vegy\u00fcnk fel egy <code>object</code> t\u00edpus\u00fa mez\u0151t <code>_syncRoot</code> n\u00e9ven a <code>DataFifo</code> oszt\u00e1lyba.</p> <pre><code>private object _syncRoot = new object();\n</code></pre> </li> <li> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Put</code> \u00e9s a <code>TryGet</code> f\u00fcggv\u00e9nyeket a z\u00e1rol\u00e1ssal.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data); \n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            Thread.Sleep(500);\n\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> <p>Surround with</p> <p>Haszn\u00e1ljuk a Visual Studio Surround with funkci\u00f3j\u00e1t a CTRL + K, CTRL + S billenty\u0171 kombin\u00e1ci\u00f3j\u00e1val a k\u00f6r\u00fclvenni k\u00edv\u00e1nt kijel\u00f6lt k\u00f3dr\u00e9szleten.</p> </li> </ol> <p>Most m\u00e1r nem szabad kiv\u00e9telt kapnunk.</p> <p>Ki is vehetj\u00fck a <code>TryGet</code> met\u00f3dusb\u00f3l a mesters\u00e9ges k\u00e9sleltet\u00e9st (<code>Thread.Sleep(500);</code> sor).</p> <p>Lockol\u00e1s <code>this</code>-en</p> <p>Felmer\u00fclhet a k\u00e9rd\u00e9s, hogy mi\u00e9rt vezett\u00fcnk be egy k\u00fcl\u00f6n <code>_syncRoot</code> tagv\u00e1ltoz\u00f3t \u00e9s haszn\u00e1ltuk ezt z\u00e1rol\u00e1sra a <code>lock</code> param\u00e9terek\u00e9nt, amikor a <code>this</code>-t is haszn\u00e1lhattuk volna helyette (a <code>DataFifo</code> referencia t\u00edpus, \u00edgy ennek nem lenne akad\u00e1lya). A <code>this</code> alkalmaz\u00e1sa azonban s\u00e9rten\u00e9 az oszt\u00e1lyunk egys\u00e9gbez\u00e1r\u00e1s\u00e1t! Ne feledj\u00fck: a <code>this</code> egy referencia az objektumunkra, de m\u00e1s oszt\u00e1lyoknak is van ugyanerre az objektumra referenci\u00e1juk (pl. eset\u00fcnkben a <code>MainWindow</code>-nak van referenci\u00e1ja a <code>DataFifo</code>-ra), \u00e9s ha ezek a k\u00fcls\u0151 oszt\u00e1lyok z\u00e1rat tesznek a <code>lock</code> seg\u00edts\u00e9g\u00e9vel az objektumra, akkor az \"interfer\u00e1l\" az \u00e1ltalunk az oszt\u00e1lyon bel\u00fck haszn\u00e1lt z\u00e1rol\u00e1ssal (mivel <code>this</code> alkalmaz\u00e1sa miatt a k\u00fcls\u0151 \u00e9s bels\u0151 <code>lock</code>-ok param\u00e9tere ugyanaz lesz). \u00cdgy pl. egy k\u00fcls\u0151 z\u00e1rral teljesen meg lehet \"b\u00e9n\u00edtani\" a <code>TryGet</code> \u00e9s <code>Put</code> m\u0171velet m\u0171k\u00f6d\u00e9s\u00e9t. Ezzel szemben az \u00e1ltalunk v\u00e1lasztott megold\u00e1sban a <code>lock</code> param\u00e9tere, a <code>_syncRoot</code> v\u00e1ltoz\u00f3 priv\u00e1t, ehhez m\u00e1r k\u00fcls\u0151 oszt\u00e1lyok nem f\u00e9rhetnek hozz\u00e1, \u00edgy nem is zavarhatj\u00e1k meg az oszt\u00e1lyunk bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9t.</p>"},{"location":"labor/4-tobbszalu/#7-feladat-hatekony-jelzes-megvalositasa","title":"7. feladat \u2013 Hat\u00e9kony jelz\u00e9s megval\u00f3s\u00edt\u00e1sa","text":""},{"location":"labor/4-tobbszalu/#manualresetevent-hasznalata","title":"ManualResetEvent haszn\u00e1lata","text":"<p>A <code>WorkerThread</code>-ben folyamatosan fut\u00f3 <code>while</code> ciklus \u00fan. akt\u00edv v\u00e1rakoz\u00e1st val\u00f3s\u00edt meg, ami mindig ker\u00fclend\u0151. Ha a <code>Thread.Sleep</code>-et nem tett\u00fck volna a ciklusmagba, akkor ezzel maximumra ki is terheln\u00e9 a processzort. A <code>Thread.Sleep</code> megoldja ugyan a processzor terhel\u00e9s probl\u00e9m\u00e1t, de bevezet egy m\u00e1sikat: ha mindh\u00e1rom munkasz\u00e1lunk \u00e9ppen alv\u00f3 \u00e1llapotba l\u00e9pett, mikor be\u00e9rkezik egy \u00faj adat, akkor feleslegesen v\u00e1runk 500 ms-ot az adat feldolgoz\u00e1s\u00e1nak megkezd\u00e9s\u00e9ig.</p> <p>A k\u00f6vetkez\u0151kben \u00fagy fogjuk m\u00f3dos\u00edtani az alkalmaz\u00e1st, hogy blokkolva v\u00e1rakozzon, am\u00edg adat nem ker\u00fcl a FIFO-ba (amikor viszont adat ker\u00fcl bele, azonnal kezdje meg a feldolgoz\u00e1st). Annak jelz\u00e9s\u00e9re, hogy van-e adat a sorban egy <code>ManualResetEvent</code>-et fogunk haszn\u00e1lni.</p> <ol> <li> <p>Adjunk hozz\u00e1 egy <code>MaunalResetEvent</code> p\u00e9ld\u00e1nyt a <code>DataFifo</code> oszt\u00e1lyunkhoz <code>_hasData</code> n\u00e9ven.</p> <pre><code>// A false konstruktor param\u00e9ter eredm\u00e9nyek\u00e9ppen kezdetben az esem\u00e9ny nem jelzett (kapu csukva)\nprivate ManualResetEvent _hasData = new ManualResetEvent(false);\n</code></pre> </li> <li> <p>A <code>_hasData</code> alkalmaz\u00e1sunkban kapuk\u00e9nt viselkedik. Amikor adat ker\u00fcl a list\u00e1ba \u201ekinyitjuk\u201d, m\u00edg amikor ki\u00fcr\u00fcl a lista \u201ebez\u00e1rjuk\u201d.</p> <p>Az esem\u00e9ny szemantik\u00e1ja \u00e9s elnevez\u00e9se</p> <p>L\u00e9nyeges, hogy j\u00f3 v\u00e1lasszuk meg az esem\u00e9ny\u00fcnk szemantik\u00e1j\u00e1t \u00e9s ezt a v\u00e1ltoz\u00f3nk nev\u00e9vel pontosan ki is fejezz\u00fck. A p\u00e9ld\u00e1nkban a <code>_hasData</code> n\u00e9v j\u00f3l kifejezi, hogy pontosan akkor \u00e9s csak akkor jelzett az esem\u00e9ny\u00fcnk (nyitott a kapu), amikor van feldolgozand\u00f3 adat. Most m\u00e1r \"csak\" az a dolgunk, hogy ezt a szemantik\u00e1t megval\u00f3s\u00edtsuk: jelzettbe tegy\u00fck az esem\u00e9nyt, mikor adat ker\u00fcl a FIFO-ba, \u00e9s jelzetlenbe, amikor ki\u00fcr\u00fcl a FIFO.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data);\n        _hasData.Set();\n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> </li> </ol>"},{"location":"labor/4-tobbszalu/#jelzesre-varakozas-blokkolo-a-get","title":"Jelz\u00e9sre v\u00e1rakoz\u00e1s (blokkol\u00f3 a Get)","text":"<p>Az el\u0151z\u0151 pontban megoldottuk a jelz\u00e9st, \u00e1m ez \u00f6nmag\u00e1ban nem sokat \u00e9r, hiszen nem v\u00e1rakoznak r\u00e1. Ennek megval\u00f3s\u00edt\u00e1sa j\u00f6n most.</p> <ol> <li> <p>M\u00f3dos\u00edtsuk a met\u00f3dust az al\u00e1bbiak szerint: sz\u00farjuk be a <code>_hasData</code> esem\u00e9nyre v\u00e1rakoz\u00e1st.</p> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        _hasData.WaitOne();\n\n        if (_innerList.Count &gt; 0)\n            // ...\n</code></pre> <p>A WaitOne m\u0171velet visszat\u00e9r\u00e9si \u00e9rt\u00e9ke</p> <p>A <code>WaitOne</code> m\u0171velet egy <code>bool</code> \u00e9rt\u00e9kkel t\u00e9r vissza, mely igaz, ha a <code>WaitOne</code> param\u00e9ter\u00e9ben megadott id\u0151korl\u00e1t el\u0151tt jelzett \u00e1llapotba ker\u00fcl az esem\u00e9ny (ill. ennek megfelel\u0151en hamis, ha lej\u00e1rt az id\u0151korl\u00e1t). A p\u00e9ld\u00e1nkban nem adtunk meg id\u0151korl\u00e1tot param\u00e9terben, mely v\u00e9gtelen id\u0151korl\u00e1t alkalmaz\u00e1s\u00e1t jelenti. Ennek megfelel\u0151en nem is vizsg\u00e1ljuk a visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9t (mert v\u00e9gtelen ideig v\u00e1r jelz\u00e9sre).</p> </li> <li> <p>Ezzel a <code>Thread.Sleep</code> a <code>WorkerThread</code>-ben feleslegess\u00e9 v\u00e1lt, kommentezz\u00fck ki!</p> <p>A fenti megold\u00e1s futtat\u00e1sakor azt tapasztaljuk, hogy az alkalmaz\u00e1sunk fel\u00fclete az els\u0151 gombnyom\u00e1st k\u00f6vet\u0151en befagy. Az el\u0151z\u0151 megold\u00e1sunkban ugyanis egy amat\u0151r hib\u00e1t k\u00f6vett\u00fcnk el. A lock-olt k\u00f3dr\u00e9szleten bel\u00fcl v\u00e1rakozunk a <code>_hasData</code> jelz\u00e9s\u00e9re, \u00edgy a f\u0151sz\u00e1lnak lehet\u0151s\u00e9ge sincs arra, hogy a <code>Put</code> m\u0171veletben (egy szint\u00e9n <code>lock</code>-kal v\u00e9dett r\u00e9szen bel\u00fcl) jelz\u00e9st k\u00fcldj\u00f6n <code>_hasData</code>-val. Gyakorlatilag egy holtpont (deadlock) helyzet alakult ki. Fontos, hogy a k\u00f3dot n\u00e9zve gondoljuk \u00e1t r\u00e9szleteiben:</p> <ul> <li>A <code>TryGet</code>-ben az egyik munkasz\u00e1l (mely bejutott a <code>lock</code> blokkba a h\u00e1rom k\u00f6z\u00fcl), a <code>_hasData.WaitOne()</code> sorban arra v\u00e1r, hogy a f\u0151 sz\u00e1l <code>Put</code>-ban a <code>_hasData</code>-t jelzettbe \u00e1ll\u00edtsa.</li> <li>A <code>Put</code>-ban a <code>lock</code> sorban f\u0151 sz\u00e1l arra v\u00e1r, hogy az el\u0151z\u0151 pontban eml\u00edtett munkasz\u00e1l a <code>TryGet</code>-ben kil\u00e9pjen a <code>lock</code> blokkb\u00f3l.</li> </ul> <p>K\u00f6lcs\u00f6n\u00f6sen egym\u00e1sra v\u00e1rnak v\u00e9gtelen ideig, ez a holtpont/deadlock klasszikus esete.</p> <p>Pr\u00f3b\u00e1lkozhatn\u00e1nk egy id\u0151korl\u00e1t megad\u00e1s\u00e1val (ms) a v\u00e1rakoz\u00e1sn\u00e1l (ez nem kell megval\u00f3s\u00edtani):</p> <pre><code>if (_hasData.WaitOne(100))\n</code></pre> <p>Ez \u00f6nmag\u00e1ban sem lenne eleg\u00e1ns megold\u00e1s, r\u00e1ad\u00e1sul a folyamatosan polloz\u00f3 munkasz\u00e1lak jelent\u0151sen ki\u00e9heztetn\u00e9k a Put-ot h\u00edv\u00f3 sz\u00e1lat! Helyette, az eleg\u00e1ns \u00e9s k\u00f6vetend\u0151 minta az, hogy lock-on bel\u00fcl ker\u00fclj\u00fck a blokkolva v\u00e1rakoz\u00e1st.</p> <p>Jav\u00edt\u00e1sk\u00e9nt cser\u00e9lj\u00fck meg a <code>lock</code>-ot \u00e9s a <code>WaitOne</code>-t:</p> <pre><code>public bool TryGet(out double[] data)\n{\n    _hasData.WaitOne();\n\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, most m\u00e1r j\u00f3l m\u0171k\u00f6dik.</p> </li> <li> <p>A <code>lock</code>-on bel\u00fcli \u00fcress\u00e9g-vizsg\u00e1lat szerepe.</p> <p>Az el\u0151z\u0151 l\u00e9p\u00e9sben a <code>TryGet</code>-ben bevezett\u00fcnk <code>_hasData</code> n\u00e9ven egy <code>MaunalResetEvent</code> objektumot. Ez pontosan akkor van jelzett \u00e1llapotban, amikor a FIFO-ban van adat. K\u00e9rd\u00e9s, sz\u00fcks\u00e9g van-e m\u00e9g most is a lock blokkban az sor \u00fcress\u00e9g vizsg\u00e1latra (<code>if (_innerList.Count &gt; 0)</code>). Els\u0151 \u00e9rz\u00e9sre redund\u00e1nsnak gondolhatjuk. De pr\u00f3b\u00e1ljuk ki, az <code>if</code>-ben az \u00fcress\u00e9gvizsg\u00e1lat helyett adjunk meg egy fix <code>true</code> \u00e9rt\u00e9ket, ezzel semleges\u00edtve az <code>if</code> hat\u00e1s\u00e1t (az\u00e9rt dolgozunk \u00edgy, hogy k\u00f6nny\u0171 legyen visszacsin\u00e1lni):</p> <pre><code>    ...\n    lock (_syncRoot)\n    {\n        if (true)\n        {\n            data = _innerList[0];\n            ...\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki. Egy kiv\u00e9telt fogunk kapni, amikor kattintunk a gombon: \u00edgy m\u00e1r nem sz\u00e1lbiztos a megold\u00e1sunk. Vezess\u00fck le, mi\u00e9rt:</p> <ul> <li>Amikor elindul az alkalmaz\u00e1s, mindh\u00e1rom feldolgoz\u00f3 sz\u00e1l a <code>TryGet</code> <code>_hasData.WaitOne();</code> sor\u00e1n\u00e1l v\u00e1r arra, hogy adat ker\u00fclj\u00f6n a FIFO-ba.</li> <li>A gombra kattint\u00e1skor a <code>Put</code> m\u0171velet <code>_hasData</code>-t jelzettre \u00e1ll\u00edtja.</li> <li>A <code>TryGet</code> <code>_hasData.WaitOne();</code> sor\u00e1n mindh\u00e1rom sz\u00e1l \u00e1tjut (ez egy ManualResetEvent, ha jelezett, minden sz\u00e1l mehet tov\u00e1bb).</li> <li>A <code>TryGet</code> <code>lock</code> blokkj\u00e1ba egyetlen sz\u00e1l jut be, a m\u00e1sik kett\u0151 itt v\u00e1r (lock blokkban egyszerre egy sz\u00e1l lehet): ez a sz\u00e1l kiveszi az egyetlen elemet az <code>_innerList</code> list\u00e1b\u00f3l, majd elhagyja a <code>lock</code> blokkot.</li> <li>Most m\u00e1r be tud jutni a <code>lock</code>-n\u00e1l v\u00e1rakoz\u00f3 k\u00e9t sz\u00e1lb\u00f3l (ezek m\u00e1r kor\u00e1bban t\u00faljutottak a <code>hasData.WaitOne()</code> h\u00edv\u00e1son!!!) egy m\u00e1sik is a <code>lock</code> blokkba, az is megpr\u00f3b\u00e1lja a 0. elemet kivenni az <code>_innerList</code> list\u00e1b\u00f3l. De az m\u00e1r nincs ott (az el\u0151z\u0151 l\u00e9p\u00e9sben az els\u0151nek bejut\u00f3 sz\u00e1l elcsente az orra el\u0151l): ebb\u0151l lesz a kiv\u00e9tel.</li> </ul> <p>A megold\u00e1s: biztos\u00edtani kell a <code>lock</code> blockban, hogy ha id\u0151k\u00f6zben egy m\u00e1sik sz\u00e1l ki\u00fcr\u00edtette a sort, akkor a sz\u00e1lunk m\u00e1r ne pr\u00f3b\u00e1ljon elemet kivenni bel\u0151le. Vagyis vissza kell tenni a kor\u00e1bbi \u00fcress\u00e9g vizsg\u00e1latot. Tegy\u00fck is ezt meg! A megold\u00e1sunk \u00edgy j\u00f3l m\u0171k\u00f6dik. El\u0151fordulhat ugyan, hogy feleslegesen fordulunk a list\u00e1hoz, de ezzel \u00edgy most megel\u00e9gsz\u00fcnk.</p> </li> </ol> <p>\u00d6sszefoglalva: </p> <ul> <li>Az \u00fcress\u00e9g vizsg\u00e1latra a <code>ManualResetEvent</code> bevezet\u00e9se ut\u00e1n is sz\u00fcks\u00e9g van. </li> <li>A <code>ManualResetEvent</code> az a c\u00e9lja, hogy feleslegesen ne pollozzuk gyakran a sort, ha az \u00fcres, vagyis az \u00fan. akt\u00edv v\u00e1rakoz\u00e1st ker\u00fclj\u00fck el a seg\u00edts\u00e9g\u00e9vel.</li> </ul> <p>A konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s neh\u00e9zs\u00e9gei</p> <p>J\u00f3l illusztr\u00e1lja a feladat, hogy milyen alapos \u00e1tgondol\u00e1st ig\u00e9nyel a konkurens, t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben val\u00f3 programoz\u00e1s. Tulajdonk\u00e9ppen m\u00e9g szerencs\u00e9nk is volt az el\u0151z\u0151ekben, mert j\u00f3l reproduk\u00e1lhat\u00f3an el\u0151j\u00f6tt a hiba. A gyakorlatban azonban ez ritk\u00e1n van \u00edgy. Sajnos sokkal gyakoribb, hogy a konkurenciahib\u00e1k id\u0151nk\u00e9nti, nem reproduk\u00e1lhat\u00f3 probl\u00e9m\u00e1kat okoznak. Az ilyen jelleg\u0171 feladatok megold\u00e1s\u00e1t mindig nagyon \u00e1t kell gondolni, nem lehet az \"addig-pr\u00f3b\u00e1lkozom-m\u00edg-j\u00f3-nem-lesz-a-k\u00e9zi-teszt-sor\u00e1n\" elv ment\u00e9n leprogramozni.</p> <p>System.Collections.Concurrent</p> <p>A .NET keretrendszerben t\u00f6bb be\u00e9p\u00edtett sz\u00e1lbiztoss\u00e1gra felk\u00e9sz\u00edtett oszt\u00e1ly is tal\u00e1lhat\u00f3 a <code>System.Collections.Concurrent</code> n\u00e9vt\u00e9rben. A fenti p\u00e9ld\u00e1ban a <code>DataFifo</code> oszt\u00e1lyt a <code>System.Collections.Concurrent.ConcurrentQueue</code> oszt\u00e1llyal kiv\u00e1lthattuk volna.</p>"},{"location":"labor/4-tobbszalu/#8-feladat-kulturalt-leallas","title":"8. feladat \u2013 Kultur\u00e1lt le\u00e1ll\u00e1s","text":"<p>Kor\u00e1bban f\u00e9lretett\u00fck azt a probl\u00e9m\u00e1t, hogy az ablakunk bez\u00e1r\u00e1sakor a processz\u00fcnk \u201eberagad\u201d, ugyanis a feldolgoz\u00f3 munkasz\u00e1lak el\u0151t\u00e9rsz\u00e1lak, kil\u00e9ptet\u00e9s\u00fcket eddig nem oldottuk meg. C\u00e9lunk, hogy a v\u00e9gtelen <code>while</code> ciklust kiv\u00e1ltva a munkasz\u00e1laink az alkalmaz\u00e1s bez\u00e1r\u00e1sakor kultur\u00e1lt m\u00f3don \u00e1lljanak le.</p> <ol> <li> <p>Egy <code>ManualResetEvent</code> seg\u00edts\u00e9g\u00e9vel jelezz\u00fck a le\u00e1ll\u00edt\u00e1st a FIFO-ban a <code>TryGet</code>-ben t\u00f6rt\u00e9n\u0151 v\u00e1rakoz\u00e1s sor\u00e1n. A FIFO-ban vegy\u00fcnk fel egy \u00faj <code>ManualResetEvent</code>-et, \u00e9s vezess\u00fcnk be egy <code>Release</code> m\u0171veletet, amellyel a v\u00e1rakoz\u00e1sainkat z\u00e1rhatjuk r\u00f6vidre (\u00faj esem\u00e9ny\u00fcnk jelzett \u00e1llapotba \u00e1ll\u00edthat\u00f3).</p> <pre><code>private ManualResetEvent _releaseTryGet = new ManualResetEvent(false);\n\npublic void Release()\n{\n    _releaseTryGet.Set();\n}\n</code></pre> </li> <li> <p>A <code>TryGet</code>-ben erre az esem\u00e9nyre is v\u00e1rakozzunk. A <code>WaitAny</code> met\u00f3dus akkor engedi tov\u00e1bb a futtat\u00e1st, ha a param\u00e9terk\u00e9nt megadott <code>WaitHandle</code> t\u00edpus\u00fa objektumok k\u00f6z\u00fcl valamelyik jelzett \u00e1llapotba ker\u00fcl, \u00e9s visszaadja annak t\u00f6mbb\u00e9li index\u00e9t. T\u00e9nyleges adatfeldolgoz\u00e1st pedig csak akkor szeretn\u00e9nk, ha a <code>_hasData</code> jelzett (amikor is a <code>WaitAny</code> 0-val t\u00e9r vissza).</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (WaitHandle.WaitAny(new[] { _hasData, _releaseTryGet }) == 0)\n    {\n        lock (_syncRoot)\n        {\n</code></pre> </li> <li> <p><code>MainWindow.xaml.cs</code>-ban vegy\u00fcnk fel egy flag tagv\u00e1ltoz\u00f3t a bez\u00e1r\u00e1s jelz\u00e9s\u00e9re:</p> <pre><code>private bool _isClosed = false;\n</code></pre> </li> <li> <p>A f\u0151ablak bez\u00e1r\u00e1sakor \u00e1ll\u00edtsuk jelzettre az \u00faj esem\u00e9nyt \u00e9s billents\u00fcnk be a flag-et is: a <code>MainWindow</code> oszt\u00e1ly <code>Closed</code> esem\u00e9ny\u00e9re iratkozzunk fel a konstruktorban, \u00e9s \u00edrjuk meg a megfelel\u0151 esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt:</p> <pre><code>public MainWindow()\n{\n    ...\n\n    Closed += MainWindow_Closed;\n}\n\nprivate void MainWindow_Closed(object sender, WindowEventArgs args)\n{\n    _isClosed = true;\n    _fifo.Release();\n}\n</code></pre> </li> <li> <p>\u00cdrjuk \u00e1t a while ciklust az el\u0151z\u0151 pontban felvett flag figyel\u00e9s\u00e9re.</p> <pre><code>private void WorkerThread()\n{\n    while (!_isClosed)\n    {\n</code></pre> </li> <li> <p>V\u00e9g\u00fcl biztos\u00edtsuk, hogy a m\u00e1r bez\u00e1r\u00f3d\u00f3 ablak eset\u00e9ben ne pr\u00f3b\u00e1ljunk \u00fczeneteket ki\u00edrni</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    if (_isClosed)\n        return;\n</code></pre> </li> <li> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s ellen\u0151rizz\u00fck, kil\u00e9p\u00e9skor az processz\u00fcnk val\u00f3ban befejezi-e a fut\u00e1s\u00e1t.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/#kitekintes-task-async-await","title":"Kitekint\u00e9s: Task, async, await","text":"<p>A gyakorlat sor\u00e1n az alacsonyabb szint\u0171 sz\u00e1lkezel\u00e9si technik\u00e1kkal k\u00edv\u00e1ntunk megismerkedni. Ugyanakkor megold\u00e1sunkat (legal\u00e1bbis r\u00e9szben) \u00e9p\u00edthett\u00fck volna a .NET aszinkron programoz\u00e1st t\u00e1mogat\u00f3 magasabb szint\u0171 eszk\u00f6zeire \u00e9s mechanizmusaira, \u00fagymint <code>Task</code>/<code>Task&lt;T&gt;</code> oszt\u00e1lyok \u00e9s <code>async</code>/<code>await</code> kulcsszavak.</p>"},{"location":"labor/4-tobbszalu/index_ger/","title":"4. Erstellung von mehrf\u00e4digen Anwendungen","text":""},{"location":"labor/4-tobbszalu/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>Ziel der \u00dcbung ist, dass die Studenten mit den Grunds\u00e4tzen kennenzulernen, die bei der Programmierung von mehreren Threads beachtet werden m\u00fcssen. Behandelte Themen (unter anderem):</p> <ul> <li>Einen Thread starten (<code>Thread</code>)</li> <li>Einen Thread beenden</li> <li>Erstellen von faedensicheren (thread safe) Klassen mit dem Schl\u00fcsselwort <code>lock</code> </li> <li><code>ThreadPool</code> verwenden</li> <li>Signalisieren und Synchronisation von auf Signal wartenden Threads mit der Hilfe von <code>ManualResetEvent</code> (<code>WaitHandle</code>)</li> <li>Besonderheiten des WinUI-Threadings (<code>DispatcherQueue</code>)</li> </ul> <p>Da das Thema sehr umfangreich ist, werden Sie nat\u00fcrlich nur Grundkenntnisse erwerben, aber mit diesem Wissen werden Sie in der Lage sein, komplexere Aufgaben selbst\u00e4ndig zu bearbeiten.</p> <p>Zugeh\u00f6rige Vorlesungen: Entwicklung konkurrierender (meghrf\u00e4digen) Anwendungen.</p>"},{"location":"labor/4-tobbszalu/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Durchf\u00fchrung der \u00dcbung ben\u00f6tigten Werkzeuge:</p> <ul> <li>Visual Studio 2022<ul> <li>Windows Desktop Development Workload</li> </ul> </li> <li>Betriebssystem Windows 10 oder Windows 11 (Linux und macOS nicht geeignet)</li> </ul>"},{"location":"labor/4-tobbszalu/index_ger/#losung","title":"L\u00f6sung","text":"Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist [verf\u00fcgbar auf GitHub] (https://github.com/bmeviauab00/lab-tobbszalu-kiindulo/tree/megoldas). Der einfachste Weg, es herunterzuladen, ist, den <code>git clone</code>-Zweig von der Kommandozeile aus zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo -b solved</code></p> <p>Sie m\u00fcssen Git auf Ihrem Rechner installiert haben, weitere Informationen hier.</p>"},{"location":"labor/4-tobbszalu/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"<p>Die Verwaltung parallel laufender Threads ist ein Bereich mit hoher Priorit\u00e4t, den alle Softwareentwickler zumindest in den Grundlagen kennen sollten. In der \u00dcbung l\u00f6sen wir grundlegende, aber vorrangige Probleme, so dass wir uns bem\u00fchen sollten, nicht nur das Endergebnis, sondern auch die Bedeutung und die Gr\u00fcnde f\u00fcr die von uns vorgenommenen \u00c4nderungen zu verstehen.</p> <p>In dieser \u00dcbung werden wir einer einfachen WinUI-Anwendung mehrf\u00e4dige F\u00e4higkeiten hinzuf\u00fcgen und zunehmend komplexere Aufgaben l\u00f6sen. Das Grundproblem ist folgendes: Wir haben eine Funktion, die lange l\u00e4uft, und wie wir sehen werden, hat der \"direkte\" Aufruf \u00fcber die Benutzeroberfl\u00e4che unangenehme Folgen. W\u00e4hrend dem L\u00f6sen werden wir eine bestehende Anwendung mit eigenen Codezeile erg\u00e4nzen. Neue Zeilen, die eingef\u00fcgt werden sollen, sind in der Anleitung durch einen hervorgehobenen Hintergrund gekennzeichnet.</p>"},{"location":"labor/4-tobbszalu/index_ger/#0-aufgabe-kennenlernen-des-anfangsprojekt-vorbereitung","title":"0. Aufgabe - Kennenlernen des Anfangsprojekt, Vorbereitung","text":"<p>Klonen wir das Repository der urspr\u00fcnglichen Anwendung f\u00fcr \u00dcbung 4:</p> <ul> <li>\u00d6ffnen wir ein command prompt</li> <li>Navigieren wir zu einem Ordner unserer Wahl, zum Beispiel c:\\work\\NEPTUN</li> <li>Geben wir den folgenden Befehl ein: <code>git clone https://github.com/bmeviauab00/lab-tobbszalu-kiindulo.git</code></li> <li>\u00d6ffnen wir das Solution SuperCalculator.sln in Visual Studio.</li> </ul> <p>Unsere Aufgabe ist es, eine Benutzeroberfl\u00e4che unter Verwendung der WinUI-Technologie zu erstellen, um einen in bin\u00e4rer Form erreichbaren Algorithmus auszuf\u00fchren. Die bin\u00e4re Form von .NET ist eine Datei mit der Erweiterung .dll, die in der Programmiersprache eine Klassenbibliothek darstellt.  In unserem Fall lautet der Dateiname Algorithms.dll, der sich im geklonten Git-Repository befindet.</p> <p>In der Anfangsprojekt ist die Benutzeroberfl\u00e4che bereits vorbereitet. F\u00fchren wir die Anwendung aus:</p> <p></p> <p>In der Benutzeroberfl\u00e4che der Anwendung k\u00f6nnen wir die Eingabeparametern des Algorithmus angeben (<code>double</code> array of numbers): in unserem Beispiel rufen wir den Algorithmus immer mit zwei <code>double</code> Zahlenparametern auf, die in den zwei oberen Textfeldern angegeben werden k\u00f6nnen. Unsere Aufgabe ist es, den Algorithmus mit den angegebenen Parametern auszuf\u00fchren, falls wir auf die Taste Calculate Result klicken, und wenn er fertig ist, das Ergebnis mit den Eingabeparametern in einer neuen Zeile des Listenfeldes unterhalb des Results anzuzeigen.</p> <p>In der n\u00e4chsten Schritten schauen wir zuerst das heruntergeladene Visual Studio Solution an:</p> <p>Die Rahmenanwendung ist eine auf WinUI 3 basierte Anwendung. Die Oberfl\u00e4che ist grunds\u00e4tzlich fertig, ihre Definition ist in der Datei <code>MainWindow.xaml</code> zu finden. Dies ist f\u00fcr uns im Hinblick auf den Zweck der \u00dcbung weniger aufregend, aber es lohnt sich, sie zu Hause zu \u00fcben.</p> Gestaltung der Oberfl\u00e4che in <code>MainWindow.xaml</code> <p>Grundlagen der Gestaltung von Fensterfl\u00e4chen:</p> <ul> <li>Die Wurzel (root) ist \"normalerweise\" ein <code>Grid</code>. </li> <li>In der obersten Zeile des Wurzel-<code>Grid</code> befindet sich das <code>StackPanel</code>, das die zwei Texteingabefelder (<code>TextBox</code>) und die Taste (<code>Button</code>) enth\u00e4lt.</li> <li>Die unterste Zeile des Wurzel-<code>Grid</code> enth\u00e4lt ein weiteres <code>Grid</code>. Im Gegensatz zur <code>TextBox</code> hat die <code>ListBox</code> keine <code>Header</code>-Eigenschaft, so dass wir diese als separaten <code>TextBlock</code> mit dem Text \"Result\" einf\u00fchren mussten. Dieses <code>Grid</code> wurde eingef\u00fchrt (anstelle eines \"einfacheren\" <code>StackPanel</code>), weil es m\u00f6glich war, den <code>TextBlock</code> in der oberen Zeile mit einer festen H\u00f6he f\u00fcr das \"Result\" und die <code>ListBox</code> in der unteren Zeile so zu haben, dass sie den gesamten verbleibenden Platz ausf\u00fcllt (die H\u00f6he der oberen Zeile ist <code>Auto</code>, die H\u00f6he der unteren Zeile ist <code>*</code>).</li> <li>Die Taste mit dem Text \"Calculate Result\" ist ein gutes Beispiel daf\u00fcr, dass der <code>Content</code> eines <code>Button</code> Elementes oft nicht nur ein einfacher Text ist. Das Beispiel zeigt eine Komposition aus einem <code>SymbolIcon</code> und einem <code>TextBlock</code> (implementiert mit <code>StackPanel</code>), so dass wir ein geeignetes Icon/Symbol zuweisen k\u00f6nnen, um sein Aussehen zu verbessern.</li> <li>Wir sehen auch ein Beispiel daf\u00fcr, wie man eine <code>ListBox</code> scrollbar macht, wenn sie bereits viele Elemente enth\u00e4lt (oder die Elemente zu breit sind). Dazu muss der <code>ScrollViewer</code> richtig parametrisiert werden.</li> <li>Die Eigenschaft <code>ItemContainerStyle</code> der <code>ListBox</code> wird verwendet, um Stile f\u00fcr das Element <code>ListBox</code> festzulegen. Im Beispiel ist <code>Padding</code> auf einen kleineren Wert als den Standardwert eingestellt, da sonst die H\u00f6he der <code>ListBox</code>-Elemente \u00fcberfl\u00fcssig gro\u00df w\u00e4re.</li> </ul> <p>Die Quelldatei <code>MainWindow.xaml.cs</code> ist der Code hinter der Datei f\u00fcr das Hauptfenster, lassen wir uns diese \u00fcberpr\u00fcfen, ihre Hauptelemente sind wie folgt:</p> <ul> <li>Um das Ergebnis und die Parameter auf <code>ListBox</code>zu loggen, gibt es eine Hilfsfunktion namens <code>ShowResult</code>. </li> <li><code>CalculateResultButton_Click</code> ist der Ereignishandler f\u00fcr das Anklicken der Taste \" Calculate Result \". Wir sehen, dass er den Wert der Parameter aus den beiden Textfeldern liest und versucht, ihn in eine Zahl umzuwandeln. Wenn er erfolgreich ist, wird der Algorithmus hier aufgerufen (dies ist noch nicht implementiert), oder wenn er fehlschl\u00e4gt, wird der Benutzer \u00fcber <code>DisplayInvalidElementDialog</code> in einem Nachrichtenfenster \u00fcber ung\u00fcltige Parameter informiert.</li> <li>Die Funktion <code>AddKeyboardAcceleratorToChangeTheme</code>, die vom Konstruktor aufgerufen wird, ist f\u00fcr uns nicht relevant, sie erm\u00f6glicht das Umschalten zwischen hellen und dunklen Themen (Sie sollten es zur Laufzeit ausprobieren, Ctrl+T ).</li> </ul>"},{"location":"labor/4-tobbszalu/index_ger/#verwendung-des-codes-in-der-dll","title":"Verwendung des Codes in der DLL","text":"<p>Im urspr\u00fcnglichen Projekt finden wir die Datei Algorithm.dll. In dieser kompilierten Form gibt es eine Klasse <code>SuperAlgorithm</code> im Namensraum <code>Algorithms</code>, die eine statische Operation namens <code>Calculate</code> hat. Um die Klassen einer DLL in einem Projekt verwenden zu k\u00f6nnen, m\u00fcssen wir in unsrem Projekt einen Verweis auf die DLL hinzuf\u00fcgen.</p> <ol> <li> <p>Klicken wir im Solution Explorer mit der rechten Maustaste auf den Knoten Dependencies unseres Projekts und w\u00e4hlen wir Add Project reference!</p> <p></p> <p>Externe Referenzen</p> <p>Hier verweisen wir eigentlich nicht auf ein anderes Visual Studio-Projekt, aber dies ist der einfachste Weg, dieses Fenster aufzurufen.</p> <p>Es sollte auch erw\u00e4hnt werden, dass wir f\u00fcr externe Klassenbibliotheken keine DLLs mehr in einem regul\u00e4ren Projekt referenzieren, sondern die externen Pakete aus dem Paketmanager von .NET, aus dem NuGet beziehen. Jetzt ist Algorithm.dll in unserem Fall nicht in NuGet ver\u00f6ffentlicht, so dass wir sie manuell hinzuf\u00fcgen m\u00fcssen.</p> </li> <li> <p>Verwenden wir die Taste Browse in der rechten unteren Ecke des Popup-Fensters, w\u00e4hlen wir die Datei Algorithms.dll im Unterordner External unseres Projekts aus und klicken wir auf OK, um das Hinzuf\u00fcgen zu best\u00e4tigen!</p> </li> </ol> <p>Im Solution Explorer k\u00f6nnen wir auf den Knoten Dependencies unter einem Projekt klicken, um die referenzierten externen Abh\u00e4ngigkeiten anzuzeigen. Der Verweis auf Algorithmen, der zuvor addiert war, wird auch hier unter Assemblys angezeigt. Die Kategorie Frameworks enth\u00e4lt die .NET Framework-Pakete. Und die Elemente unter Analyzer sind Werkzeuge f\u00fcr die statische Codeanalyse zur Kompilierzeit. Und es g\u00e4be hier auch die Projekt- oder NuGet-Referenzen.</p> <p></p> <p>Klicken wir mit der rechten Maustaste auf die Referenz Algorithms und w\u00e4hlen wir View in Object Browser. Dies \u00f6ffnet die Registerkarte Object Browser, in der wir sehen k\u00f6nnen, welche Namensr\u00e4ume, Klassen und deren Mitglieder (Membervariable, Memberfunktion, Eigenschaft, Ereignis) in der angegebenen DLL enthalten sind. Visual Studio liest diese aus den DLL-Metadaten mit Hilfe des so genannten Reflection-Mechanismus (wir k\u00f6nnen diesen Code selbst schreiben).</p> <p>Wie in der Abbildung unten dargestellt ist, suchen wir im Object Browser den Knoten Algorithmen auf der linken Seite, \u00f6ffnen ihn und sehen, dass er einen Namensraum <code>Algorithms</code> und eine Klasse <code>SuperAlgorithm</code> enth\u00e4lt. Wenn wir dies ausw\u00e4hlen, werden die Funktionen der Klasse in der Mitte angezeigt, und wenn wir hier eine Funktion ausw\u00e4hlen, wird die genaue Signatur dieser Funktion angezeigt:</p> <p></p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-1-ausfuhren-einer-operation-auf-dem-hauptthread","title":"Aufgabe 1 - Ausf\u00fchren einer Operation auf dem Hauptthread","text":"<p>Jetzt k\u00f6nnen wir mit der Ausf\u00fchrung des Algorithmus fortfahren. Zun\u00e4chst tun wir dies im Hauptthread unserer Anwendung.</p> <ol> <li> <p>Im Ereignishandler der Taste <code>Click</code> im Hauptfenster rufen wir unsere Z\u00e4hlerfunktion auf. \u00d6ffnen wir dazu die code behind Datei <code>MainWindow.xaml.cs</code> im Solution Explorer und suchen wir nach dem Ereignishandler <code>CalculateResultButton_Click</code>. Vervollst\u00e4ndigen wir den Code durch den Aufruf des neu referenzierten Algorithmus.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n        ShowResult(parameters, result);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>Probieren wir die Anwendung aus und stellen fest, dass das Fenster w\u00e4hrend der Berechnung nicht auf Verschieben oder Gr\u00f6\u00dfen\u00e4nderung reagiert, die Oberfl\u00e4che friert praktisch ein.</p> </li> </ol> <p>Unsere Anwendung ist ereignisgesteuert, wie alle Windows-Anwendungen. Das Betriebssystem benachrichtigt unsere Anwendung \u00fcber die verschiedenen Interaktionen (z. B. Verschieben, Gr\u00f6\u00dfen\u00e4nderung, Mausklick): Da der einzige Thread unserer Anwendung nach dem Tastendruck mit der Berechnung besch\u00e4ftigt ist, kann er nicht sofort weitere Benutzeranweisungen verarbeiten. Sobald die Berechnung abgeschlossen ist (und die Ergebnisse in der Liste angezeigt werden), werden die zuvor erhaltenen Befehle ausgef\u00fchrt.</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-2-durchfuhrung-der-berechnung-in-einem-separaten-thread","title":"Aufgabe 2 - Durchf\u00fchrung der Berechnung in einem separaten Thread","text":"<p>Im n\u00e4chsten Schritt werden wir einen separaten Thread starten, um die Berechnung durchzuf\u00fchren, damit die Benutzeroberfl\u00e4che nicht blockiert wird.</p> <ol> <li> <p>Erstellen wir eine neue Funktion in der Klasse <code>MainWindow</code>, die der Eintrittspunkt f\u00fcr den VerarbeitungsFaden sein wird.</p> <pre><code>private void CalculatorThread(object arg)\n{\n    var parameters = (double[])arg;\n    var result = Algorithms.SuperAlgorithm.Calculate(parameters);\n    ShowResult(parameters, result);\n}\n</code></pre> </li> <li> <p>Starten wir den Thread in dem Ereignishandler der Taste <code>Click</code>. Ersetzen wir dazu den Code, den wir zuvor hinzugef\u00fcgt haben:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        var th = new Thread(CalculatorThread);\n        th.Start(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>Der in der Operation <code>Start</code> des Fadenobjekts \u00fcbergebene Parameter wird an unsere Fadenfunktion <code>CalculatorThread</code> \u00fcbergeben.</p> </li> <li> <p>F\u00fchren wir die Anwendung mit F5 aus (jetzt ist es wichtig, sie so auszuf\u00fchren, im Debugger)! The application called an interface that was marshalled for a different thread. (0x8001010E (RPC_E_WRONG_THREAD)) Fehlermeldung bekommen wir in der Methode <code>ShowResult</code>, weil wir nicht versuchen, auf das UI-Element/Controller von dem Thread aus zuzugreifen, der es erstellt hat (der Controller). In der n\u00e4chsten \u00dcbung werden wir dieses Problem analysieren und l\u00f6sen.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-3-verwendung-von-dispatcherqueuehasthreadaccess-und-dispatcherqueuetryenqueue","title":"Aufgabe 3 - Verwendung von <code>DispatcherQueue.HasThreadAccess</code> und <code>DispatcherQueue.TryEnqueue</code>","text":"<p>Das Problem im vorigen Aufgabe hat folgende Ursachen. F\u00fcr WinUI-Anwendungen gilt folgende Regel: Fenster/Oberfl\u00e4chen/Steuerelemente sind standardm\u00e4\u00dfig keine fadensicheren Objekte, so dass auf ein Fenster/Oberfl\u00e4che/Steuerelement nur von dem Thread aus zugegriffen werden darf (z.B. Eigenschaft lesen, einstellen, Operation aufrufen), der das gegebenen Fenster/Oberfl\u00e4che/Steuerelement erstellt hat, sondern gibt es eine Ausnahme. In unserer Anwendung haben wir eine Ausnahme bekommen, weil das <code>resultListBox</code> Steuerelement im Haupt-Thread erstellt wird, aber in der <code>ShowResult</code> Methode, wenn das Ergebnis angezeigt wird, wird von einem anderen Thread aus darauf zugegriffen (Aufruf der<code>resultListBox.Items.Add</code> Methode).</p> <p>Die Frage ist, wie auf diese Oberfl\u00e4chenelemente/Steuerelemente von einem anderen Thread aus noch irgendwie zugegriffen werden kann. Die L\u00f6sung besteht in der Verwendung von <code>DispatcherQueue</code>, um sicherzustellen, dass der Zugriff auf die Steuerelemente immer \u00fcber den richtigen Thread erfolgt:</p> <ul> <li>Die Funktion <code>TryEnqueue</code> des Objekts <code>DispatcherQueue</code> f\u00fchrt die als Parameter angegebene Funktion auf dem Thread aus, der das Steuerelement erstellt (von dem aus man nun direkt auf das Steuerelement zugreifen kann).</li> <li>Die Eigenschaft <code>HasThreadAccess</code> des Objekts <code>DispatcherQueue</code> hilft bei der Entscheidung, ob es notwendig ist, <code>TryEnqueue</code> zu verwenden, wie im vorherigen Abschnitt erw\u00e4hnt. Wenn der Wert dieser Eigenschaft<ul> <li>wahr ist, kann auf den Controller direkt zugegriffen werden (weil der aktuelle Thread derselbe ist wie der Thread, der den Controller erstellt hat), aber wenn</li> <li>falsch ist, kann auf den Controller nur \"unter Umgehung\", durch die Funktion <code>TryEnqueue</code> des Objekts <code>DispatcherQueue</code> zugegriffen werden (da der aktuelle Thread NICHT mit dem Thread identisch ist, der den Controller erstellt hat).</li> </ul> </li> </ul> <p>Mit <code>DispatcherQueue</code> k\u00f6nnen wir also unsere vorherige Ausnahme vermeiden (der Zugriff auf den Controller, in diesem Fall <code>resultListBox</code>, kann an den entsprechenden Thread \"geleitet\" werden). Wir werden dies im Folgenden tun.</p> <p>Hinweis</p> <p>Das Objekt <code>DispatcherQueue</code> ist in Nachkommen der Klasse Window \u00fcber die Eigenschaft <code>DispatcherQueue</code> verf\u00fcgbar (und in anderen Klassen \u00fcber die statische Operation <code>DispatcherQueue.GetForCurrentThread()</code> ).</p> <p>Wir m\u00fcssen die Methode <code>ShowResult</code> so \u00e4ndern, dass sie keine Ausnahme ausl\u00f6st, wenn sie aus einem neuen, separaten Thread aufgerufen wird.</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    // Closing the window the DispatcherQueue property may return null, so we have to perform a null check\n    if (this.DispatcherQueue == null)\n        return;\n\n    if (this.DispatcherQueue.HasThreadAccess)\n    {\n        var item = new ListBoxItem()\n        {\n            Content = $\"{parameters[0]} #  {parameters[1]} = {result}\"\n        };\n        resultListBox.Items.Add(item);\n        resultListBox.ScrollIntoView(item);\n    }\n    else\n    {\n        this.DispatcherQueue.TryEnqueue( () =&gt; ShowResult(parameters, result) );\n    }\n}\n</code></pre> <p>Probieren wir es aus!</p> <p>Diese L\u00f6sung ist bereits funktionsf\u00e4hig und ihre wichtigste Elemente sind die folgenden:</p> <ul> <li>Die Rolle der Pr\u00fcfung, ob <code>DispatcherQueue</code> <code>null</code> ist: Nach dem Schlie\u00dfen des Hauptfensters ist <code>DispatcherQueue</code> schon <code>null</code>, es kann nicht verwendet werden.</li> <li>Die <code>DispatcherQueue.HasThreadAccess</code> wird verwendet, um zu pr\u00fcfen, ob der aufrufende Thread direkt auf die Controller zugreifen kann (in unserem Fall <code>ListBox</code>):<ul> <li>Falls ja, wird alles wie bisher passieren, der Code f\u00fcr <code>ListBox</code>bleibt unver\u00e4ndert.</li> <li>Falls nicht, k\u00f6nnen wir durch <code>DispatcherQueue.TryEnqueue</code> auf den Controller zugreifen. Dabei wird der folgende Trick angewendet. Die Funktion <code>TryEnqueue</code> erh\u00e4lt eine parameterlose, einzeilige Funktion in Form eines Lambda-Ausdrucks, der unsere Funktion <code>ShowResult</code> aufruft (praktisch rekursiv) und ihr die Parameter \u00fcbergibt. Das ist gut f\u00fcr uns, weil dieser <code>ShowResult</code>-Aufruf bereits auf dem Thread erfolgt, der den Controller erstellt hat (dem Hauptthread der Anwendung), der Wert von <code>HasThreadAccess</code> ist jetzt wahr, und wir k\u00f6nnen direkt auf unser <code>ListBox</code>zugreifen. Dieser rekursive Ansatz ist ein oft benutztes Muster, um redundanten Code zu vermeiden.</li> </ul> </li> </ul> <p>Setzen wir einen Haltepunkt in der ersten Zeile der Operation <code>ShowResult</code>, und f\u00fchren wir die Anwendung aus, um sicherzustellen, dass <code>HasThreadAccess</code> falsch ist, wenn <code>ShowResult</code> zum ersten Mal aufgerufen wird (also wird <code>TryEnqueue</code> aufgerufen), und dann wird <code>ShowResult</code> erneut aufgerufen, aber <code>HasThreadAccess</code> ist wahr.</p> <p>Entfernen wir den Haltepunkt und f\u00fchren wir die Anwendung aus: Beachten wir, dass w\u00e4hrend eine Berechnung l\u00e4uft, eine andere gestartet werden kann, da unsere Benutzeroberfl\u00e4che durchgehend reaktionsf\u00e4hig bleibt (und der Fehler, der zuvor auftrat, nicht mehr auftritt).</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-4-ausfuhren-einer-operation-auf-einem-threadpool-thread","title":"Aufgabe 4 - Ausf\u00fchren einer Operation auf einem Threadpool-Thread","text":"<p>Eine Merkmal der bisherigen L\u00f6sung ist, dass sie immer einen neuen Thread f\u00fcr die Operation erstellt. In unserem Fall ist dies nicht besonders wichtig, aber dieser Ansatz kann f\u00fcr eine Serveranwendung, die eine gro\u00dfe Anzahl von Anfragen bedient, problematisch sein, da f\u00fcr jede Anfrage ein eigener Thread gestartet wird. Aus zwei Gr\u00fcnden:</p> <ul> <li>Wenn die Fadenfunktion schnell l\u00e4uft (um einen Client schnell zu bedienen), dann wird ein gro\u00dfer Teil der CPU f\u00fcr das Starten und Stoppen von Threads verschwendet, was an sich schon ressourcenintensiv ist.</li> <li>Es k\u00f6nnen zu viele Threads erstellt werden, und das Betriebssystem muss zu viele planen, was unn\u00f6tig Ressourcen verschwendet.</li> </ul> <p>Ein weiteres Problem mit unserer derzeitigen L\u00f6sung: Da die Berechnung auf einem so genannten Vordergrundfaden l\u00e4uft (neu erstellte Threads sind standardm\u00e4\u00dfig Vordergrundf\u00e4den), l\u00e4uft das Programm selbst dann im Hintergrund weiter, obwohl wir die Anwendung schlie\u00dfen, solange bis die letzte Berechnung ausgef\u00fchrt wurde: Ein Prozess h\u00f6rt erst auf zu laufen, wenn er keinen Vordergrundfaden mehr hat.</p> <p>\u00c4ndern wir den Ereignishandler der Taste, um die Berechnung in einem Threadpool-Thread auszuf\u00fchren, anstatt einen neuen Thread zu starten. Um dies zu tun, schreiben wir einfach den Ereignishandler f\u00fcr das Dr\u00fccken der Taste um.</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        ThreadPool.QueueUserWorkItem(CalculatorThread, parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> <p>Probieren wir die Anwendung aus und stellen fest, dass die Anwendung sofort anh\u00e4lt, wenn das Fenster geschlossen wird, ohne sich um eventuell noch laufende Threads zu k\u00fcmmern (denn Threadpool-Threads sind Hintergrundf\u00e4den).</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-5-hersteller-verbraucher-basierte-losung","title":"Aufgabe 5 - Hersteller-Verbraucher-basierte L\u00f6sung","text":"<p>Allein durch die L\u00f6sung der vorangegangenen Probleme erhielten wir eine vollst\u00e4ndige und gut funktionierende L\u00f6sung f\u00fcr das urspr\u00fcngliche Problem, die es erm\u00f6glicht, dass mehrere Threads parallel im Hintergrund arbeiten, wenn die Taste mehrmals nacheinander gedr\u00fcckt wird. Im Folgenden werden wir unsere Anwendung so modifizieren, dass ein Tastendruck nicht immer einen neuen Thread erzeugt, sondern die Aufgaben in eine Aufgabenwarteschlange stellt, aus der mehrere im Hintergrund laufende Threads sie nacheinander ausw\u00e4hlen und ausf\u00fchren. Bei dieser Aufgabe handelt es sich um das klassische Hersteller-Verbraucher-Problem, das in der Praxis h\u00e4ufig auftritt und in der folgenden Abbildung dargestellt ist.</p> <p></p> <p>Hersteller-Verbraucher vs <code>ThreadPool</code></p> <p>Wenn Sie dar\u00fcber nachdenken, ist <code>ThreadPool</code> auch ein spezieller Hersteller-Verbraucher und Scheduler-Mechanismus, der uns von .NET zur Verf\u00fcgung gestellt wird. Im Folgenden entwickeln wir eine andere Art von Hersteller-Verbraucher-L\u00f6sung, um einige mit der Fadenbehandlung verbundenen Wettbewerbsprobleme anzuschauen.</p> <p>Der Hauptthread ist der Hersteller, der eine neue Aufgabe erstellt, falls die Taste Calculate result geklickt wird. Wir werden mehr Threads in der Verbraucher-/verarbeitenden Threads starten, da wir mehr CPU-Kerne verwenden und die Ausf\u00fchrung von Aufgaben parallelisieren k\u00f6nnen.</p> <p>F\u00fcr die Zwischenspeicherung von Aufgaben k\u00f6nnen wir die Klasse <code>DataFifo</code> (im Ordner <code>Data</code> im Solution Explorer) verwenden, die in unserem urspr\u00fcnglichen Projekt bereits etwas vorbereitet ist. Schauen wir uns den Quellcode an. Es implementiert eine einfache FIFO-Warteschlange, um <code>double[]</code> zu speichern. Die Methode <code>Put</code> h\u00e4ngt die neuen Paare an das Ende der internen Liste an, w\u00e4hrend die Methode <code>TryGet</code> das erste Element der internen Liste zur\u00fcckgibt (und entfernt). Wenn die Liste leer ist, kann die Funktion kein Element zur\u00fcckgeben. In diesem Fall zeigt <code>false</code> dies durch einen R\u00fcckgabewert an.</p> <ol> <li> <p>\u00c4ndern wir den Ereignishandler der Taste so, dass er nicht in <code>ThreadPool</code>, sondern in FIFO arbeitet:</p> <pre><code>private void CalculateResultButton_Click(object sender, RoutedEventArgs e)\n{\n    if (double.TryParse(param1TextBox.Text, out var p1) &amp;&amp; double.TryParse(param2TextBox.Text, out var p2))\n    {\n        var parameters = new double[] { p1, p2 };\n\n        _fifo.Put(parameters);\n    }\n    else\n        DisplayInvalidElementDialog();\n}\n</code></pre> </li> <li> <p>Erstellen wir eine naive Implementierung der neuen Fadenbehandlungsfunktion in unserer Formularklasse:</p> <pre><code>private void WorkerThread()\n{\n    while (true)\n    {\n        if (_fifo.TryGet(out var data))\n        {\n            double result = Algorithms.SuperAlgorithm.Calculate(data);\n            ShowResult(data, result);\n        }\n\n        Thread.Sleep(500);\n    }\n}\n</code></pre> <p>Der Grund f\u00fcr die Einf\u00fchrung von <code>Thread.Sleep</code> ist, dass sich die Threads sonst unn\u00f6tigerweise die ganze Zeit mit einem leeren FIFO besch\u00e4ftigen w\u00fcrden, ohne irgendeine n\u00fctzliche Operation auszuf\u00fchren, und einen CPU-Kern zu 100% \u00fcberlasten w\u00fcrden. Unsere L\u00f6sung ist nicht ideal, wir werden sie sp\u00e4ter verbessern.</p> </li> <li> <p>Erstellen und starten wir die Verarbeitungsf\u00e4den im Konstruktor:</p> <pre><code>new Thread(WorkerThread) { Name = \"Worker thread 1\" }.Start();\nnew Thread(WorkerThread) { Name = \"Worker thread 2\" }.Start();\nnew Thread(WorkerThread) { Name = \"Worker thread 3\" }.Start();\n</code></pre> </li> <li> <p>Starten wir die Anwendung und schlie\u00dfen wir sie sofort, ohne auf die Taste Calculate Result zu klicken. Unser Fenster wird geschlossen, aber unser Prozess l\u00e4uft weiter, und die einzige M\u00f6glichkeit, die Anwendung zu schlie\u00dfen, ist \u00fcber Visual Studio oder den Task-Manager:</p> <p></p> <p>Die Verarbeitungsf\u00e4den sind Vordergrundf\u00e4den, die verhindern das Beenden der Prozess beim Schlie\u00dfen des Fensters. Eine L\u00f6sung k\u00f6nnte darin bestehen, die Eigenschaft <code>IsBackground</code> der Threads auf <code>true</code>zu setzen, nachdem sie erstellt wurden. Die andere L\u00f6sung stellt sicher, dass die Verarbeitungsf\u00e4den beim Beenden beendet werden. Lassen wir dieses Thema erst einmal beiseite, wir kommen sp\u00e4ter darauf zur\u00fcck.</p> </li> <li> <p>Starten wir die Anwendung und wir werden feststellen, dass wir nach dem Klicken auf die Taste Calculate Result (nur einmal klicken) h\u00f6chstwahrscheinlich eine Ausnahme erhalten. Das Problem ist, dass <code>DataFifo</code> nicht fadensicher ist, es ist inkonsistent geworden. Hierf\u00fcr gibt es zwei Ursachen:</p> </li> </ol>"},{"location":"labor/4-tobbszalu/index_ger/#problem-1","title":"Problem 1","text":"<p>Betrachten wir das folgende Szenario:</p> <ol> <li>Die Zeile ist leer. Die verarbeitenden Threads fragen den FIFO kontinuierlich in einer <code>while</code>-Schleife ab, d. h. sie rufen die Methode <code>TryGet</code> auf.</li> <li>Der Benutzer f\u00fcgt der Warteschlange eine Aufgabe hinzu.</li> <li>Einer der Verarbeitungsf\u00e4den in der Methode <code>TryGet</code> stellt fest, dass Daten in der Zeile vorhanden sind, d. h. die Bedingung der Codezeile <code>if ( _innerList.Count &gt; 0 )</code> ist erf\u00fcllt, und geht zur n\u00e4chsten Codezeile \u00fcber. Angenommen, dieser Thread verliert an dieser Stelle seine Durchf\u00fchrungsrecht, dann hat er keine Zeit mehr, die Daten aus der Warteschlange zu nehmen.</li> <li>Ein anderer Verarbeitungsthread l\u00e4sst die Pr\u00fcfung von <code>if ( _innerList.Count &gt; 0 )</code> zu diesem Zeitpunkt ebenfalls fallen, die Bedingung ist ebenfalls erf\u00fcllt, und dieser Thread nimmt die Daten aus der Warteschlange.</li> <li>Der erste Thread wird neu geplant, wacht auf und versucht, die Daten aus der Warteschlange zu nehmen: die Warteschlange ist leer, der andere Thread hat die einzigen Daten aus der Warteschlange vor ihm genommen. Der Zugriff auf <code>_innerList[0]</code> f\u00fchrt daher zu einer Ausnahme.</li> </ol> <p>Die einzige M\u00f6glichkeit, dieses Problem zu vermeiden, ist die Pr\u00fcfung der Zeilenleere und die Elementausnahme unteilbar zu machen.</p> <p>Thread.Sleep(500)</p> <p>Die Rolle der Codezeile <code>Thread.Sleep(500);</code>, die auf die Codezeile folgt, die die Leere-Pr\u00fcfung in unserem Beispielcode \u00fcberwacht, besteht nur darin, die Wahrscheinlichkeit zu erh\u00f6hen, dass das obige ungl\u00fcckliche Szenario eintritt, und somit das Beispiel anschaulicher zu machen (da es fast sicher ist, dass der Thread neu geplant wird). Wir werden dies in Zukunft herausnehmen, aber vorl\u00e4ufig lassen wir es drin.</p>"},{"location":"labor/4-tobbszalu/index_ger/#problem-2","title":"Problem 2","text":"<p>Die Klasse <code>DataFifo</code> kann von mehreren Threads gleichzeitig auf die Mitgliedsvariable <code>_innerList</code> mit der Typ <code>List&lt;double[]&gt;</code> zugreifen. Wenn wir uns jedoch die Dokumentation zu <code>List&lt;T&gt;</code> ansehen, werden wir feststellen, dass die Klasse nicht fadensicher (not thread safe) ist. Aber in diesem Fall k\u00f6nnen wir das nicht tun, wir m\u00fcssen Sperren verwenden, um sicherzustellen, dass unser Code nur auf eine Methode/Eigenschaft/Mitgliedsvariable zur gleichen Zeit zugreifen kann (genauer gesagt, kann Inkonsistenz nur im Fall von gleichzeitigen Schreiben und Lesen auftreten, aber wir unterscheiden in den meisten F\u00e4llen nicht zwischen Lesern und Schreibern, und wir tun es hier auch nicht).</p> <p>Der n\u00e4chste Schritt ist, unsere Klasse <code>DataFifo</code> fadensicher zu machen, wodurch die beiden oben genannten Probleme vermieden werden.</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-6-die-datafifo-klasse-fadensicher-machen","title":"Aufgabe 6 - Die DataFifo-Klasse fadensicher machen","text":"<p>Um die Klasse <code>DataFifo</code> fadensicher zu machen, ben\u00f6tigen wir ein Objekt (dies kann ein beliebiges Objekt vom Referenztyp sein), das als Schl\u00fcssel zum Sperren verwendet wird. Mit dem Schl\u00fcsselwort <code>lock</code> k\u00f6nnen wir dann sicherstellen, dass sich jeweils nur ein Thread in den durch diesen Schl\u00fcssel gesch\u00fctzten Bl\u00f6cken aufh\u00e4lt.</p> <ol> <li> <p>F\u00fcgen wir ein Feld vom Typ <code>object</code> mit dem Namen <code>_syncRoot</code> zur Klasse <code>DataFifo</code> hinzu.</p> <pre><code>private object _syncRoot = new object();\n</code></pre> </li> <li> <p>Erg\u00e4nzen wir die Funktionen <code>Put</code> und <code>TryGet</code> mit dem Sperre.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data); \n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            Thread.Sleep(500);\n\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> <p>Surround with</p> <p>Verwenden wir die Funktion \"Surround with\" von Visual Studio, indem Sie STRG + K, STRG + S auf dem ausgew\u00e4hlten Codeschnipsel dr\u00fccken, den wir umschlie\u00dfen m\u00f6chten.</p> </li> </ol> <p>Jetzt d\u00fcrfen wir keine Ausnahme bekommen.</p> <p>Wir k\u00f6nnen die k\u00fcnstliche Verz\u00f6gerung auch aus der Methode <code>TryGet</code> entfernen ( Zeile<code>Thread.Sleep(500);</code> ).</p> <p>Sperre auf <code>this</code></p> <p>Es stellt sich die Frage, warum wir eine separate Membervariable <code>_syncRoot</code> eingef\u00fchrt und diese als Sperrparameter f\u00fcr <code>lock</code> verwendet haben, wenn wir stattdessen auch <code>this</code> h\u00e4tten verwenden k\u00f6nnen ( <code>DataFifo</code> ist der Referenztyp, daher w\u00e4re dies kein Problem). Die Verwendung von <code>this</code> w\u00fcrde jedoch gegen die Einkapselung unserer Klasse versto\u00dfen! Erinnern wir uns: <code>this</code> ist ein Verweis auf unser Objekt, aber andere Klassen haben Verweise auf dasselbe Objekt (z.B. in unserem Fall <code>MainWindow</code>hat einen Verweis auf <code>DataFifo</code>), und wenn diese externen Klassen eine Sperre auf das Objekt setzen, indem sie <code>lock</code> verwenden, wird dies die Sperre \"st\u00f6ren\", die wir auf die Klasse darin verwenden (da die Verwendung von <code>this</code> dazu f\u00fchrt, dass die externen und internen <code>lock</code> denselben Parameter haben). Zum Beispiel kann eine externe Sperre verwendet werden, um die Operationen <code>TryGet</code> und <code>Put</code> vollst\u00e4ndig \"lahmzulegen\". Im Gegensatz dazu ist in unserer L\u00f6sung der Parameter <code>lock</code>, die Variable <code>_syncRoot</code>, privat und kann nicht von externen Klassen aufgerufen werden, so dass sie die internen Abl\u00e4ufe unserer Klasse nicht beeintr\u00e4chtigen kann.</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-7-implementierung-einer-effektiven-signalisierung","title":"Aufgabe 7 - Implementierung einer effektiven Signalisierung","text":""},{"location":"labor/4-tobbszalu/index_ger/#verwendung-von-manualresetevent","title":"Verwendung von ManualResetEvent","text":"<p>Die Schleife <code>while</code>, die in <code>WorkerThread</code>st\u00e4ndig l\u00e4uft, implementiert ein sogenanntes aktives Warten, das immer vermieden werden sollte. Falls <code>Thread.Sleep</code> nicht in den Schleifenkern eingebaut worden w\u00e4re, w\u00e4re der Prozessor \u00fcberlastet gewesen. <code>Thread.Sleep</code> l\u00f6st zwar das Problem der CPU-Belastung, f\u00fchrt aber ein weiteres ein: Wenn sich alle drei Arbeitsf\u00e4den im Ruhezustand befinden, wenn neue Daten empfangen werden, warten wir unn\u00f6tigerweise 500 ms, bevor wir mit der Verarbeitung der Daten beginnen.</p> <p>Im Folgenden wird die Anwendung so ge\u00e4ndert, dass sie in einem blockierten Zustand wartet, bis Daten zum FIFO hinzugef\u00fcgt werden (aber wenn Daten hinzugef\u00fcgt werden, beginnt sie sofort mit der Verarbeitung). Um anzuzeigen, ob sich Daten in der Warteschlange befinden, wird <code>ManualResetEvent</code>verwendet.</p> <ol> <li> <p>F\u00fcgen wir eine Instanz von <code>MaunalResetEvent</code> zu unserer Klasse <code>DataFifo</code> als <code>_hasData</code> hinzu.</p> <pre><code>// Infolge des Konstruktorparameters false wird das Ereignis anf\u00e4nglich nicht signalisiert (Tor geschlossen)\nprivate ManualResetEvent _hasData = new ManualResetEvent(false);\n</code></pre> </li> <li> <p><code>_hasData</code> funktioniert als ein Tor in unserer Anwendung.  Wenn der Liste Daten hinzugef\u00fcgt werden, wird sie \"ge\u00f6ffnet\", und wenn die Liste geleert wird, wird sie \"geschlossen\".</p> <p>Semantik und Benennung des Ereignisses</p> <p>Es ist wichtig, die Semantik unseres Ereignisses gut zu w\u00e4hlen und wir im Namen unseres Ereignisses pr\u00e4zise auszudr\u00fccken. In unserem Beispiel dr\u00fcckt der Name <code>_hasData</code> aus, dass unser Ereignis genau dann und nur dann signalisiert wird, wenn es Daten zu verarbeiten gibt (Tor ge\u00f6ffnet). Jetzt m\u00fcssen wir \"nur\" noch diese Semantik implementieren: das Ereignis signalisiert setzen, wenn Daten in den FIFO eingegeben werden, und nicht signalisiert, wenn der FIFO geleert wird.</p> <pre><code>public void Put(double[] data)\n{\n    lock (_syncRoot)\n    {\n        _innerList.Add(data);\n        _hasData.Set();\n    }\n}\n</code></pre> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_innerList.Count &gt; 0)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true;\n        }\n\n        data = null;\n        return false;\n    }\n}\n</code></pre> </li> </ol>"},{"location":"labor/4-tobbszalu/index_ger/#warten-auf-signal-get-blockiert","title":"Warten auf Signal (Get blockiert)","text":"<p>In dem vorherigen Punkt wurde die Signalisierung gel\u00f6st, aber das sich selbst macht nicht viel, weil niemand auf das Signal wartet. Diese Erkenntnis kommt jetzt.</p> <ol> <li> <p>\u00c4ndern wir die Methode wie folgt: Entfernen wir den Leere-Test und ersetzen wir ihn durch Warten auf das Ereignis.</p> <pre><code>public bool TryGet(out double[] data)\n{\n    lock (_syncRoot)\n    {\n        if (_hasData.WaitOne())\n        {\n            // ...\n</code></pre> <p>Pr\u00fcfung des R\u00fcckgabewerts der Operation WaitOne</p> <p>Die Operation <code>WaitOne</code> gibt den Wert <code>bool</code> zur\u00fcck, der wahr ist, wenn sich das Ereignis vor der im Parameter von <code>WaitOne</code> angegebenen Zeitspanne signalisiert wird (und entsprechend falsch, wenn die Zeitspanne abgelaufen ist). In unserem Beispiel haben wir im Parameter kein Zeitlimit angegeben, was eine unendliche Zeitspanne bedeutet. Dementsprechend ist die Pr\u00fcfung der Bedingung <code>if</code> \u00fcberfl\u00fcssig, da in unserem Fall <code>WaitOne()</code> immer einen wahren Wert liefert. Dies ist der einzige Grund, warum wir dennoch die Konditionstests verwendet haben: Wir erfordern weniger \u00c4nderungen f\u00fcr die n\u00e4chste und eine zuk\u00fcnftige \u00dcbung.</p> </li> <li> <p>Dies macht <code>Thread.Sleep</code> in <code>WorkerThread</code> \u00fcberfl\u00fcssig, kommentieren wir es aus!</p> <p>Wenn wir die obige L\u00f6sung ausf\u00fchren, werden wir feststellen, dass die Oberfl\u00e4che unserer Anwendung nach dem ersten Tastendruck einfriert. Bei unserer vorherigen L\u00f6sung haben wir einen Anf\u00e4ngerfehler gemacht. In dem gesperrten Codeschnipsel warten wir darauf, dass <code>_hasData</code> gesendet wird, so dass der Hauptthread keine Gelegenheit hat, <code>_hasData</code> in der Operation <code>Put</code> zu senden (ebenfalls gesch\u00fctzt durch <code>lock</code>). In der Praxis wurde eine Verklemmung (deadlock) gebildet.</p> <p>Wir k\u00f6nnten versuchen, ein Zeitlimit (ms) f\u00fcr die Wartezeit festzulegen:</p> <pre><code>if (_hasData.WaitOne(100))\n</code></pre> <p>Dies w\u00e4re an sich keine elegante L\u00f6sung, au\u00dferdem w\u00fcrden die st\u00e4ndig verschmutzenden Arbeitsf\u00e4den den Thread, der Put aufruft, erheblich aushungern! Stattdessen ist das elegante Muster zu folgen, um zu vermeiden, dass man innerhalb einer Sperre blockiert wartet.</p> <p>Tauschen wir <code>lock</code> und <code>WaitOne</code> um, und entfernen wir die Wartezeitbegrenzung, also den Parameter von <code>WaitOne</code>:</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (_hasData.WaitOne())\n    {\n        lock (_syncRoot)\n        {\n            data = _innerList[0];\n            _innerList.RemoveAt(0);\n            if (_innerList.Count == 0)\n            {\n                _hasData.Reset();\n            }\n\n            return true; \n        }\n    }\n\n    data = null;\n    return false;\n}\n</code></pre> <p>Probieren wir die App aus. Wenn wir die Taste zum ersten Mal dr\u00fccken, erhalten wir eine Ausnahme. Dadurch wird zwar ein Deadlock vermieden, aber die Fadensicherheit ist verletzt, weiles ist nicht sicher, dass wenn wir in <code>lock</code> eintreten k\u00f6nnen, noch Elemente in der Liste vorhanden sind. Es kann mehrere Threads geben, die mit <code>_hasData.WaitOne()</code> darauf warten, dass ein Element zu der Liste hinzugef\u00fcgt wird. Wenn dies geschieht, wird unser <code>ManualResetEvent</code> Objekt alle durchlassen (au\u00dfer wenn ein Thread schlie\u00dft es schnell, aber das ist nicht garantiert).</p> <p>Die Schwierigkeiten der Programmierung in einer konkurrierenden, mehrf\u00e4digen Umgebung</p> <p>Diese Aufgabe veranschaulicht, wie sorgf\u00e4ltig man bei der Programmierung in einer konkurrierenden, mehrf\u00e4digen Umgebung vorgehen muss. Bei den vorherigen hatten wir sogar noch Gl\u00fcck, denn der Fehler war reproduzierbar. In der Praxis ist dies jedoch selten der Fall. Leider ist es viel h\u00e4ufiger der Fall, dass Konkurenzprobleme gelegentliche, nicht reproduzierbare Probleme verursachen. Die L\u00f6sung einer solchen Aufgabe muss immer sehr sorgf\u00e4ltig durchdacht sein und kann nicht nach dem Motto \"wir-probieren-es-solange-es-wird-gut-im-per-Hand-Test\" programmiert werden.</p> </li> <li> <p>Als Korrektur setzen wir den Leertest in <code>lock</code> zur\u00fcck.</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (_hasData.WaitOne())\n    {\n        lock (_syncRoot)\n        {\n            if (_innerList.Count &gt; 0)\n            {\n                data = _innerList[0];\n                _innerList.RemoveAt(0);\n                if (_innerList.Count == 0)\n                {\n                    _hasData.Reset();\n                }\n\n                return true;  \n            }\n        }\n    }\n\n    data = null;\n    return false;\n}\n</code></pre> <p>Dies funktioniert bereits gut. Es ist m\u00f6glich, dass wir unn\u00f6tigerweise auf die Liste eingehen, aber wir belassen es vorerst dabei.</p> <p>Testen wir die App!</p> </li> </ol> <p>System.Collections.Concurrent</p> <p>Im .NET-Framework gibt es mehrere eingebaute fadensichere Klassen im Namensraum <code>System.Collections.Concurrent</code>.  In dem obigen Beispiel h\u00e4tte die Klasse <code>DataFifo</code> durch <code>System.Collections.Concurrent.ConcurrentQueue</code> ersetzt werden k\u00f6nnen.</p>"},{"location":"labor/4-tobbszalu/index_ger/#aufgabe-8-kulturelle-abschaltung","title":"Aufgabe 8 - Kulturelle Abschaltung","text":"<p>Bisher haben wir das Problem, dass unser Prozess beim Schlie\u00dfen des Fensters \"stecken bleibt\", weil die Verarbeitungsthreads Vordergrundf\u00e4den sind und wir das Problem des Beendens dieser Threads nicht gel\u00f6st haben. Unser Ziel ist es, den unendlichen <code>while</code>-Schleife auszul\u00f6sen, so dass unsere Arbeitsf\u00e4den auf zivilisierte Weise beendet werden, wenn die Anwendung geschlossen wird.</p> <ol> <li> <p>Ein <code>ManualResetEvent</code> wird verwendet, um das Beenden im FIFO anzuzeigen, w\u00e4hrend in <code>TryGet</code>gewartet wird. F\u00fcgen wir im FIFO ein neues <code>ManualResetEvent</code> hinzu und f\u00fchren wir eine <code>Release</code>-Operation ein, um unsere Wartezeiten zu verk\u00fcrzen (unser neues Ereignis kann auf einen signalisierten Zustand gesetzt werden).</p> <pre><code>private ManualResetEvent _releaseTryGet = new ManualResetEvent(false);\n\npublic void Release()\n{\n    _releaseTryGet.Set();\n}\n</code></pre> </li> <li> <p>Warten wir auf diese Ereignis auch in <code>TryGet</code>. Die Methode <code>WaitAny</code> darf die Ausf\u00fchrung fortsetzen, wenn sich eines der als Parameter angegebenen Objekte vom Typ <code>WaitHandle</code> signalisiert ist, und gibt dessen Index innerhalb der Block zur\u00fcck. Und wir wollen die tats\u00e4chliche Verarbeitung nur, wenn <code>_hasData</code> signalisiert ist (wenn <code>WaitAny</code> 0 zur\u00fcckgibt).</p> <pre><code>public bool TryGet(out double[] data)\n{\n    if (WaitHandle.WaitAny(new[] { _hasData, _releaseTryGet }) == 0)\n    {\n        lock (_syncRoot)\n        {\n</code></pre> </li> <li> <p>F\u00fcgen wir eine flag Variable in <code>MainWindow.xaml.cs</code> hinzu, um das Beenden anzuzeigen:</p> <pre><code>private bool _isClosed = false;\n</code></pre> </li> <li> <p>Wenn das Hauptfenster geschlossen wird, setzen wir das neue Ereignis auf signalisiert und setzen wir auch das Flag auf true: abonnieren wir uns auf das Ereignis <code>Closed</code> der Klasse <code>MainWindow</code> im Konstruktor und schreiben wir die entsprechende Ereignishandler:</p> <pre><code>public MainWindow()\n{\n    ...\n\n    Closed += MainWindow_Closed;\n}\n\nprivate void MainWindow_Closed(object sender, WindowEventArgs args)\n{\n    _isClosed = true;\n    _fifo.Release();\n}\n</code></pre> </li> <li> <p>Schreiben wir die while-Schleife so um, dass sie auf das im vorigen Punkt addierte Flag wartet.</p> <pre><code>private void WorkerThread()\n{\n    while (!_isClosed)\n    {\n</code></pre> </li> <li> <p>Stellen wir sicher, dass wir nicht versuchen, Nachrichten f\u00fcr ein Fenster zu senden, das bereits geschlossen ist</p> <pre><code>private void ShowResult(double[] parameters, double result)\n{\n    if (_isClosed)\n        return;\n</code></pre> </li> <li> <p>F\u00fchren wir die Anwendung aus und \u00fcberpr\u00fcfen wir, ob unser Prozess tats\u00e4chlich beendet wird, wenn wir ihn beenden.</p> </li> </ol>"},{"location":"labor/4-tobbszalu/index_ger/#ausblick-task-async-await","title":"Ausblick: Task, async, await","text":"<p>Ziel der \u00dcbung war es, die Techniken f\u00fcr das Management von F\u00e4den auf unterer Ebene kennen zu lernen. Wir h\u00e4tten unsere L\u00f6sung jedoch (zumindest teilweise) auf den \u00fcbergeordneten Werkzeugen und Mechanismen aufbauen k\u00f6nnen, die die asynchrone Programmierung in .NET unterst\u00fctzen, z. B. die Klassen <code>Task</code>/<code>Task&lt;T&gt;</code> und die Schl\u00fcsselw\u00f6rter <code>async</code>/<code>await</code>. </p>"},{"location":"labor/5-mvvm/","title":"5. MVVM","text":""},{"location":"labor/5-mvvm/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A labor sor\u00e1n egy recept b\u00f6ng\u00e9sz\u0151 alkalmaz\u00e1st fogunk k\u00e9sz\u00edteni, amelyben alkalmazzuk az MVVM tervez\u00e9si mint\u00e1t.</p>"},{"location":"labor/5-mvvm/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> <li>Visual Studio 2022<ul> <li>Windows Desktop Development Workload</li> </ul> </li> </ul>"},{"location":"labor/5-mvvm/#kiindulo-projekt","title":"Kiindul\u00f3 projekt","text":"<p>Kl\u00f3nozzuk le a kiindul\u00f3 projektet az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-mvvm-kiindulo\n</code></pre> A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el a <code>megoldas</code> \u00e1gon. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre a <code>megoldas</code> \u00e1gat:</p> <p><code>git clone https://github.com/bmeviauab00/lab-mvvm-kiindulo -b megoldas</code></p>"},{"location":"labor/5-mvvm/#az-mvvm-mintarol","title":"Az MVVM mint\u00e1r\u00f3l","text":"<p>Az MVVM (Model-View-ViewModel) egy architektur\u00e1lis tervez\u00e9si minta, amelyet a XAML alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n haszn\u00e1lhatunk, de gyakran m\u00e1s kliens oldali technol\u00f3gi\u00e1k eset\u00e9ben is megjelenik. Az MVVM minta c\u00e9lja, hogy a felhaszn\u00e1l\u00f3i fel\u00fcletet \u00e9s a m\u00f6g\u00f6tte l\u00e9v\u0151 logik\u00e1t sz\u00e9tv\u00e1lassza, \u00e9s ezzel egy laz\u00e1bb csatol\u00e1s\u00fa alkalmaz\u00e1st hozzon l\u00e9tre, ami n\u00f6veli a tesztelhet\u0151s\u00e9get, a karbantarthat\u00f3s\u00e1got \u00e9s az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got.</p> <p>Az MVVM minta h\u00e1rom (+1) f\u0151 r\u00e9szb\u0151l \u00e1ll:</p> <ul> <li>Model: Az alkalmaz\u00e1s \u00fczleti modellj\u00e9t tartalmazza, amelyet a ViewModel-ek haszn\u00e1lhatnak az adatok t\u00e1rol\u00e1s\u00e1ra.</li> <li>View: A felhaszn\u00e1l\u00f3i fel\u00fclet le\u00edr\u00e1s\u00e1t tartalmazza, \u00e9s a tiszt\u00e1n a n\u00e9zetekhez kapcsol\u00f3d\u00f3 logik\u00e1t (pl.: anim\u00e1ci\u00f3k kezel\u00e9s\u00e9t).</li> <li>ViewModel: A n\u00e9zet absztrakci\u00f3ja, mely tartalmazza a n\u00e9zet \u00e1llapot\u00e1t \u00e9s a n\u00e9zeten v\u00e9grehajthat\u00f3 m\u0171veleteket, n\u00e9zet f\u00fcggetlen\u00fcl. A laza csatol\u00e1st a ViewModel \u00e9s a n\u00e9zet k\u00f6z\u00f6tt az adatk\u00f6t\u00e9s biztos\u00edtja.</li> <li>Services (szolg\u00e1ltat\u00e1sok): Az alkalmaz\u00e1s \u00fczleti logik\u00e1j\u00e1t tartalmaz\u00f3 oszt\u00e1lyok, amelyeket a ViewModel-ek haszn\u00e1lnak. Ha minden \u00fczleti logika a ViewModel-ekben lenne, azok t\u00fal bonyolultak \u00e9s \u00e1tl\u00e1thatatlanok lenn\u00e9nek. Ez nem az MVVM minta r\u00e9sze, de itt eml\u00edtj\u00fck meg, mert mi is \u00edgy fogjuk haszn\u00e1lni az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1t.</li> </ul> <p>\u00daj:</p> <ul> <li>Model: Domainspecifikus adatokat fog \u00f6ssze, melyet a ViewModel-ek haszn\u00e1lhatnak az adatok t\u00e1rol\u00e1s\u00e1ra. Pl. Recipe/Product/Order oszt\u00e1ly, egy recept/term\u00e9k/megrendel\u00e9s adatait fogja \u00f6ssze.</li> <li>View: A felhaszn\u00e1l\u00f3i fel\u00fclet le\u00edr\u00e1s\u00e1t tartalmazza, (\u00e9s a tiszt\u00e1n a n\u00e9zetekhez kapcsol\u00f3d\u00f3 logik\u00e1t, pl. anim\u00e1ci\u00f3k kezel\u00e9s\u00e9t). Tipikusan Window, Page, UserControl lesz\u00e1rmazott oszt\u00e1ly, XAML-beli deklarat\u00edv le\u00edr\u00e1ssal, a code-behind sokszor \u00fcres (mert a logika a ViewModel-ben van).</li> <li>ViewModel: A n\u00e9zethez tartoz\u00f3 logika van benne: tartalmazza a n\u00e9zet \u00e1llapot\u00e1t \u00e9s a n\u00e9zeten v\u00e9grehajthat\u00f3 m\u0171veleteket. F\u00fcggetlen a n\u00e9zett\u0151l, a laza csatol\u00e1st a ViewModel \u00e9s a n\u00e9zet k\u00f6z\u00f6tt adatk\u00f6t\u00e9s biztos\u00edtja (a n\u00e9zet vez\u00e9rl\u0151i k\u00f6tnek a ViewModel tulajdons\u00e1gaihoz). Unit tesztelhet\u0151!</li> <li>Services (szolg\u00e1ltat\u00e1sok): Az alkalmaz\u00e1s \u00fczleti/alkalmaz\u00e1s logik\u00e1j\u00e1t tartalmaz\u00f3 oszt\u00e1lyok, amelyeket a ViewModel-ek haszn\u00e1lnak. Ha minden \u00fczleti logika a ViewModel-ekben lenne, azok t\u00fal bonyolultak \u00e9s \u00e1tl\u00e1thatatlanok lenn\u00e9nek. Ez nem az MVVM minta r\u00e9sze, de itt eml\u00edtj\u00fck meg, mert mi is \u00edgy fogjuk fel\u00e9p\u00edteni az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1t.</li> </ul> <p></p> <p> Mihez k\u00e9sz\u00edt\u00fcnk ViewModel oszt\u00e1lyokat?</p> <ul> <li>Az egyes n\u00e9zetekhez (pl. Window, Page, Dialog, UserControl) mindig k\u00e9sz\u00edt\u00fcnk ViewModel oszt\u00e1lyt, \u00e9s bel\u0151le egy n\u00e9zethez egy objektumot hozunk l\u00e9tre.  Pl. MainPage-hez MainPageViewModel, DancerDialog-hoz DancerDialogViewModel. Ezt a gyakorlat sor\u00e1n is alkalmazzuk.</li> <li>Az egyes modell oszt\u00e1lyokhoz (pl. Recipe, Product, Dancer stb.) opcion\u00e1lisan k\u00e9sz\u00edthet\u00fcnk csomagol\u00f3 ViewModel oszt\u00e1lyokat (pl. RecipeViewModel, ProductViewModel, DancerViewModel), ilyeneket a gyakorlat sor\u00e1n nem fogunk k\u00e9sz\u00edteni. Ez az\u00e9rt van, mert nem a Strict, hanem a Relaxed MVVM mint\u00e1t k\u00f6vetj\u00fck (l\u00e1sd el\u0151ad\u00e1s).</li> </ul>"},{"location":"labor/5-mvvm/#0-feladat-projekt-felepitese","title":"0. Feladat - Projekt fel\u00e9p\u00edt\u00e9se","text":"<p>Az alkalmaz\u00e1s v\u00e1za m\u00e1r el\u0151 van k\u00e9sz\u00edtve. Tekints\u00fck \u00e1t a projekt fel\u00e9p\u00edt\u00e9s\u00e9t.</p> <p>Az <code>MvvmLab</code> a futtathat\u00f3 alkalmaz\u00e1s projektje, amely WinUI keretrendszert haszn\u00e1l a megjelen\u00edt\u00e9si r\u00e9teg\u00e9ben a m\u00e1r tanult XAML nyelvvel. Az <code>MvvmLab.Core</code> projekt (class library) a teljesen n\u00e9zet f\u00fcggetlen \u00fczleti logik\u00e1kat tartalmazza.</p> <p>Ami sz\u00e1munkra fontos a kiindul\u00f3 projektben:</p> <ul> <li><code>App.xaml.cs</code>: Az alkalmaz\u00e1s bel\u00e9p\u00e9si pontja, amely haszn\u00e1lja a modern .NET alkalmaz\u00e1sokban alkalmazott Host Builder \u00e9s Dependency Injection mint\u00e1kat. A f\u00e9l\u00e9vnek ez nem az anyaga, de a f\u00fcgg\u0151s\u00e9g injekt\u00e1l\u00e1sr\u00f3l m\u00e9g a labor sor\u00e1n lesz sz\u00f3.</li> <li><code>Views</code> mappa: Az alkalmaz\u00e1s n\u00e9zeteit tartalmazza, jelenleg a <code>MainPage</code>-et</li> <li><code>ViewModels</code> mappa: Az alkalmaz\u00e1s ViewModel-jeit tartalmazza, jelenleg a <code>MainPageViewModel</code>-t</li> <li><code>INagivationService</code> (<code>Services</code> mapp\u00e1ban): oldalak k\u00f6z\u00f6tti navig\u00e1ci\u00f3hoz haszn\u00e1lt szolg\u00e1ltat\u00e1s</li> </ul> <p>MVVM \u00e9s Boilerplate k\u00f6nyvt\u00e1rak</p> <p>MVVM mint\u00e1t ritk\u00e1n szoktunk kiz\u00e1r\u00f3lag a .NET keretrendszerre t\u00e1maszkodva implement\u00e1lni. \u00c9rdemes haszn\u00e1lni valamilyen MVVM k\u00f6nyvt\u00e1rat, amelyek seg\u00edts\u00e9g\u00e9vel a k\u00f3dunk t\u00f6m\u00f6rebb, \u00e1tl\u00e1that\u00f3bb, \u00e9s kevesebb boilerplate k\u00f3dot fog tartalmazni. A k\u00f6nyvt\u00e1rak k\u00f6z\u00fcl a legelterjedtebbek a k\u00f6vetkez\u0151k:</p> <ul> <li>MVVM Toolkit: Microsoft \u00e1ltal gondozott MVVM k\u00f6nyvt\u00e1r</li> <li>Prism: R\u00e9gen Microsoft gondoz\u00e1s\u00e1ban \u00e1llt \u00e9s nagyon elterjedt volt, de m\u00e1r k\u00fcls\u0151 fejleszt\u0151k tartj\u00e1k karban \u00e9s fizet\u0151s lett id\u0151 k\u00f6zben.</li> <li>ReactiveUI: A Reactive Extensions (Rx) k\u00f6nyvt\u00e1rakat haszn\u00e1lja a ViewModel \u00e1llapot\u00e1nak kezel\u00e9s\u00e9re, \u00e9s a n\u00e9zet \u00e9s ViewModel k\u00f6z\u00f6tti adatk\u00f6t\u00e9sre. Ez a k\u00f6nyvt\u00e1r ny\u00fajtja a legt\u00f6bb szolg\u00e1ltat\u00e1st, de a legnehezebben tanulhat\u00f3 is.</li> <li>Uno.Extensions: MVVM Toolkitre \u00e9p\u00fcl, de t\u00f6bb olyan szolg\u00e1ltat\u00e1st is tartalmaz, amelyek a WinUI keretrendszer hi\u00e1nyoss\u00e1gait p\u00f3tolj\u00e1k.</li> </ul> <p>A labor sor\u00e1n a Microsoft \u00e1ltal gondozott MVVM Toolkitet fogjuk haszn\u00e1lni.</p> <p>A kiindul\u00f3 projekt pedig a Windows Template Studio Visual Studio kieg\u00e9sz\u00edt\u0151 seg\u00edts\u00e9g\u00e9vel k\u00e9sz\u00fclt.</p>"},{"location":"labor/5-mvvm/#1-feladat-receptek-fooldal","title":"1. Feladat - Receptek f\u0151oldal","text":"<p>A megold\u00e1s sor\u00e1n \"alulr\u00f3l\", az adatok fel\u0151l fogunk \u00e9p\u00edtkezni \u00e9s fokozatosan fogunk eljutni a n\u00e9zetig. Ugyan a val\u00f3 \u00e9letben egy top-bottom fejleszt\u00e9s gyakran hasznosabb, de a labor sor\u00e1n az id\u0151 r\u00f6vids\u00e9ge miatt az alulr\u00f3l \u00e9p\u00edtkez\u00e9s gyorsabb \u00e9s egyszer\u0171bb, mert \u00edgy nem kell az adatokat mockolni. Az al\u00e1bbi \u00e1bra a f\u0151oldalhoz tartoz\u00f3 fontosabb oszt\u00e1lyokat tekinti \u00e1t.</p> <p> A f\u0151oldal MMVM alap\u00fa megval\u00f3s\u00edt\u00e1sa <p>Fontosabb elemek:</p> <ul> <li><code>MainPage</code>: ez a View, egy Page lesz\u00e1rmazott, a fel\u00fclet XAML alap\u00fa le\u00edr\u00e1sa.</li> <li><code>MainPageViewModel</code>: a f\u0151oldalhoz (<code>MainPage</code>) tartoz\u00f3 ViewModel. Egy (gener\u00e1lt) <code>RecipeGroups</code> tulajdons\u00e1gban receptcsoportokat, a receptcsoportokban recepteket tartalmaz. A n\u00e9zet ezen a receptcsoportok fejl\u00e9c\u00e9t, illetve a csoportokban lev\u0151 receptek fejl\u00e9c\u00e9t \u00e9s k\u00e9peit jelen\u00edti meg adatk\u00f6t\u00e9ssel.</li> <li><code>RecipeGroup</code> \u00e9s <code>Recipe</code>: a receptcsoportokat \u00e9s a recepteket reprezent\u00e1l\u00f3 modell oszt\u00e1lyok.</li> <li><code>RecipeService</code>: alkalmaz\u00e1slogika/adatel\u00e9r\u00e9s a receptek kezel\u00e9s\u00e9hez (egy t\u00e1voli szolg\u00e1ltat\u00e1ssal kommunik\u00e1l), a ViewModel haszn\u00e1lja.</li> </ul>"},{"location":"labor/5-mvvm/#11-adateleresi-szolgaltatas","title":"1.1 Adatel\u00e9r\u00e9si szolg\u00e1ltat\u00e1s","text":"<p>Kezdj\u00fck az adatel\u00e9r\u00e9si r\u00e9teggel, amit most tekinthet\u00fcnk az MVVM mint\u00e1ban a modell r\u00e9tegnek is.</p> <p>Az alkalmaz\u00e1sunk adatait egy webszerverr\u0151l k\u00e9rdezi le (\u00fan. REST API-n, HTTP-n kereszt\u00fcl \u00e9ri el). Az ehhez hasonl\u00f3 kliens-szerver architekt\u00far\u00e1j\u00fa alkalmaz\u00e1sok egy kifejezetten gyakori megold\u00e1snak sz\u00e1m\u00edtanak a modern alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n. Err\u0151l b\u0151vebben a k\u00f6vetkez\u0151 f\u00e9l\u00e9vben a Mobil \u00e9s Webes szoftverek, illetve az Adatvez\u00e9relt alkalmaz\u00e1sok t\u00e1rgyakban lesz sz\u00f3. Most el\u00e9g annyit tudni, hogy a kliens alkalmaz\u00e1sunk HTTP k\u00e9r\u00e9seket fog k\u00fcldeni a szervernek, amelyekre a szerver v\u00e1laszolni fog, m\u00e9gpedig JSON form\u00e1tumban szolg\u00e1ltat adatokat.</p> <p> Kliens-szerver architekt\u00fara <p>A t\u00e1voli szolg\u00e1ltat\u00e1s a k\u00f6vetkez\u0151 c\u00edmen \u00e9rhet\u0151 el: https://bmecookbook2.azurewebsites.net/api. A szolg\u00e1ltat\u00e1shoz pedig tartozik egy OpenApi alap\u00fa dokument\u00e1ci\u00f3 a https://bmecookbook2.azurewebsites.net/swagger c\u00edmen. Tanulm\u00e1nyozzuk ezt \u00e1t, vagy ak\u00e1r pr\u00f3b\u00e1ljuk ki a v\u00e9gpotokat a Swagger fel\u00fclet\u00e9n kereszt\u00fcl (ehhez \u00edrjuk be az el\u0151z\u0151 \"swagger\" v\u00e9gz\u0151d\u00e9s\u0171 URL-t egy b\u00f6ng\u00e9sz\u0151 c\u00edmsor\u00e1ba). Az els\u0151 feladathoz a <code>/api/Recipes/Groups</code> v\u00e9gpontot fogjuk haszn\u00e1lni, amely a receptek csoportos\u00edt\u00e1s\u00e1t adja vissza.</p> <p>Vegy\u00fcnk fel az <code>MvvmLab.Core</code> projekt <code>Models</code> mapp\u00e1j\u00e1ba egy \u00faj oszt\u00e1lyt <code>RecipeGroup</code> n\u00e9ven.</p> <p>A swagger seg\u00edts\u00e9g\u00e9vel h\u00edvjuk meg az \"api/Recipes/Groups\" v\u00e9gpontot (pontosabban egy http GET k\u00e9r\u00e9st k\u00fcldj\u00fc)</p> <ul> <li>A swagger fel\u00fcleten a \"Get api/Recipes/Groups\" v\u00e9gpont le\u00edr\u00e1st nyissuk le</li> <li>Kattintsunk az Execute gombon</li> <li>A szolg\u00e1ltat\u00e1s \u00e1ltal k\u00fcld\u00f6tt JSON v\u00e1lasz a \"Response body\" alatt jelenik meg: itt azt l\u00e1tjuk, hogy a v\u00e1laszban receptcsoportokat kaptunk. Minden csoportnak van egy \"title\"-je (pl. Chinese, Mexican, Italian), \u00e9s a csoportok alatt tal\u00e1lhat\u00f3k <code>[]</code> k\u00f6z\u00f6tt (JSON t\u00f6mb) a csoportban lev\u0151 receptek adatai. </li> <li> <p>M\u00e1soljunk v\u00e1g\u00f3lapra egy <code>RecipeGroup</code>-nyi JSON adatot. Haszn\u00e1lhatjuk az \"Example Value\" alatti kimenetet is a v\u00e1g\u00f3lapra m\u00e1sol\u00e1skor (de a nyit\u00f3 [ \u00e9s z\u00e1r\u00f3 ] karatereket ne m\u00e1soljuk ki). Ha valami\u00e9rt elakadn\u00e1nk, az al\u00e1bbi leny\u00edl\u00f3 szakaszb\u00f3l is kim\u00e1solhatjuk a v\u00e1g\u00f3lapra a tartalmat:</p> V\u00e1g\u00f3lapra m\u00e1soland\u00f3 <pre><code>{\n    \"Title\": \"string\",\n    \"Recipes\": [\n        {\n            \"Id\": 0,\n            \"Title\": \"string\",\n            \"BackgroundImage\": \"string\"\n        }\n    ]\n}\n</code></pre> </li> </ul> <p>Visual Studio-ban az <code>Edit</code> men\u00fc <code>Paste Special</code> men\u00fcpontj\u00e1ban a <code>Paste JSON as Classes</code> men\u00fcpontot v\u00e1lasztva illessz\u00fck be a v\u00e1g\u00f3lap tartalm\u00e1t. Ekkor olyan oszt\u00e1lyokat gener\u00e1l a VS, mely megfelel a beillesztett JSON szerkezet\u00e9nek.</p> <p></p> <p>A kapott oszt\u00e1lyokat \u00e1tnevezhetj\u00fck, hogy a C# k\u00f3dol\u00e1si konvenci\u00f3knak megfeleljenek. A <code>Rootobject</code> oszt\u00e1lyt nevezz\u00fck \u00e1t <code>RecipeGroup</code>-ra, a <code>Recipe</code> oszt\u00e1lyt pedig <code>RecipeHeader</code>-re.</p> <pre><code>public class RecipeGroup\n{\n    public string Title { get; set; }\n    public RecipeHeader[] Recipes { get; set; }\n}\n\npublic class RecipeHeader\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string BackgroundImage { get; set; }\n}\n</code></pre> <p><code>List&lt;T&gt;</code> haszn\u00e1lata</p> <p>Eset\u00fcnkben nem volt r\u00e1 sz\u00fcks\u00e9g (mert nem b\u0151vj\u00fck receptgy\u0171jtem\u00e9nyeket), de ha k\u00e9nyelmesebb sz\u00e1munkra, akkor nyugodtan \u00edrjuk \u00e1t a gener\u00e1lt k\u00f3dban a t\u00f6mb\u00f6ket <code>List&lt;T&gt;</code>-re.</p> <p>K\u00e9sz\u00edts\u00fcnk egy <code>IRecipeService</code> interf\u00e9szt az <code>MvvmLab.Core.Services</code> n\u00e9vt\u00e9rbe, amelyen kereszt\u00fcl el fogjuk \u00e9rni a t\u00e1voli szolg\u00e1ltat\u00e1st. Az interf\u00e9szben egy <code>GetRecipeGroupsAsync</code> met\u00f3dust hozzunk l\u00e9tre, amely a recept csoportokat k\u00e9rdezi le \u00e9s adja vissza.</p> <pre><code>public interface IRecipeService\n{\n    public Task&lt;RecipeGroup[]&gt; GetRecipeGroupsAsync();\n}\n</code></pre> <p>Task visszat\u00e9r\u00e9si \u00e9rt\u00e9k</p> <p>Az interf\u00e9szben a t\u00e9nyleges visszat\u00e9r\u00e9si \u00e9rt\u00e9ket (<code>RecipeGroup[]</code>) egy <code>Task&lt;T&gt;</code> objektumba csomagoljuk, mivel a h\u00e1l\u00f3zati m\u0171veleteket aszinkron c\u00e9lszer\u0171 implement\u00e1lni. .NET-ben az aszinkron megval\u00f3s\u00edt\u00e1s legkorszer\u0171bb \u00e9s legegyszer\u0171bb m\u00f3dja a <code>Task</code>-ok alkalmaz\u00e1sa. Az aszinkronit\u00e1s pedig azt biztos\u00edtja itt sz\u00e1munkra, hogy ha a h\u00e1l\u00f3zati k\u00e9r\u00e9s sok\u00e1ig tart, akkor se fagyjon be a felhaszn\u00e1l\u00f3i fel\u00fclet (\u00e9s mindezt k\u00fcl\u00f6n sz\u00e1lak ind\u00edt\u00e1sa n\u00e9lk\u00fcl).</p> <p>Az interf\u00e9sz implement\u00e1ci\u00f3j\u00e1t a <code>MvvmLab.Core.Services</code> n\u00e9vt\u00e9rben hozzuk l\u00e9tre <code>RecipeService</code> n\u00e9ven. A szolg\u00e1ltat\u00e1sunk a <code>HttpClient</code> be\u00e9p\u00edtett .NET oszt\u00e1lyt fogja haszn\u00e1lni a REST API h\u00edv\u00e1sokhoz. A <code>GetFromJsonAsync</code> ind\u00edt egy HTTP GET aszinkron k\u00e9r\u00e9st a megadott c\u00edmre, \u00e9s a v\u00e1laszt JSON form\u00e1tumb\u00f3l deszerializ\u00e1lja a megadott t\u00edpusra.</p> <pre><code>public class RecipeService : IRecipeService\n{\n    private readonly string _baseUrl = \"https://bmecookbook2.azurewebsites.net/api\";\n\n    public async Task&lt;RecipeGroup[]&gt; GetRecipeGroupsAsync()\n    {\n        using var client = new HttpClient();\n        return await client.GetFromJsonAsync&lt;RecipeGroup[]&gt;($\"{_baseUrl}/Recipes/Groups\");\n    }\n}\n</code></pre> <p>A <code>GetFromJsonAsync</code> m\u0171velet aszinkron, \u00edgy <code>Task</code>-kal t\u00e9r vissza, ezt nem blokkol\u00f3 m\u00f3don bev\u00e1rni \u00e9s az eredm\u00e9ny\u00e9t el\u00e9rni az <code>await</code> kulcssz\u00f3val tudjuk.</p> <p>async-await</p> <p>Az <code>async</code> \u00e9s <code>await</code> kulcsszavak a legt\u00f6bb modern nyelvben az aszinkron f\u00fcggv\u00e9nyh\u00edv\u00e1s nyelvi szint\u0171 kezel\u00e9s\u00e9re szolg\u00e1lnak. A m\u0171k\u00f6d\u00e9s\u00e9r\u0151l a f\u00e9l\u00e9v v\u00e9g\u00e9n lesz m\u00e9g sz\u00f3 r\u00e9szletesen, de most a haszn\u00e1lathoz az al\u00e1bbiakat \u00e9rdemes tudni:</p> <ul> <li>Az <code>await</code> kulcssz\u00f3val tudunk bev\u00e1rni aszinkron v\u00e9grehajt\u00e1s\u00fa m\u0171veletet, an\u00e9lk\u00fcl, hogy blokkoln\u00e1nk a h\u00edv\u00f3t.</li> <li>Az <code>await</code> kulcssz\u00f3t, csak <code>async</code> kulcssz\u00f3val ell\u00e1tott f\u00fcggv\u00e9nyekben haszn\u00e1lhatjuk.</li> <li>Az <code>async</code> f\u00fcggv\u00e9nyeknek csak <code>Task</code> vagy <code>Task&lt;T&gt;</code> vagy <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00fck lehet. (Illetve \"Task szer\u0171\", de ezt nem itt vessz\u00fck.)<ul> <li>Ha egy <code>async</code> f\u00fcggv\u00e9nyt k\u00edv\u00fclr\u0151l be szeretn\u00e9nk v\u00e1rni, akkor az voiddal nem tudjuk megtenni, mindenk\u00e9ppen <code>Task</code> vagy <code>Task&lt;T&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel kell rendelkeznie.</li> <li>az <code>async</code> f\u00fcggv\u00e9nyekben a <code>return</code> utas\u00edt\u00e1s szintaktik\u00e1ja megv\u00e1ltozik: nem a Task objektummal kell visszat\u00e9rj\u00fcnk, hanem az \u00e1ltala tartalmazott adattal (<code>Task</code> eset\u00e9ben <code>void</code>, <code>Task&lt;T&gt;</code> eset\u00e9ben <code>T</code>).</li> </ul> </li> </ul>"},{"location":"labor/5-mvvm/#12-fooldal-viewmodel","title":"1.2 F\u0151oldal ViewModel","text":"<p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a f\u0151oldal ViewModelj\u00e9t fogjuk elk\u00e9sz\u00edteni, amely az el\u0151bb elk\u00e9sz\u00edtett szolg\u00e1ltat\u00e1st fogja haszn\u00e1lni a recept csoportok lek\u00e9rdez\u00e9s\u00e9hez, \u00e9s \u00e1llapotk\u00e9nt t\u00e1rolja azokat a n\u00e9zet sz\u00e1m\u00e1ra.</p>"},{"location":"labor/5-mvvm/#dependency-injection","title":"Dependency Injection","text":"<p>Nyissuk meg a <code>MainPageViewModel</code> oszt\u00e1lyt az <code>MvvmLab.ViewModels</code> mapp\u00e1b\u00f3l. A ViewModel-\u00fcnknek sz\u00fcks\u00e9ge lesz egy <code>IRecipeService</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyra, amelyen kereszt\u00fcl le tudja k\u00e9rdezni a recept csoportokat. A <code>MainPageViewModel</code> konstruktor\u00e1ban f\u00fcgg\u0151s\u00e9g injekt\u00e1l\u00e1son kereszt\u00fcl szerezz\u00fck be a sz\u00fcks\u00e9ges f\u00fcgg\u0151s\u00e9get. Eset\u00fcnkben ez annyit tesz, hogy v\u00e1runk egy <code>IRecipeService</code> t\u00edpus\u00fa param\u00e9tert, amelyet majd a ViewModel p\u00e9ld\u00e1nyos\u00edt\u00e1skor fog megkapni, a param\u00e9tert pedig elmentj\u00fck egy priv\u00e1t v\u00e1ltoz\u00f3ba.</p> <pre><code>private readonly IRecipeService _recipeService;\n\npublic MainPageViewModel(IRecipeService recipeService)\n{\n    _recipeService = recipeService;\n}\n</code></pre> F\u00fcgg\u0151s\u00e9g Injekt\u00e1l\u00e1s - Dependency Injection - DI <p>Alapesetben az oszt\u00e1lyok szoros csatol\u00e1st alak\u00edtanak ki a f\u00fcgg\u0151s\u00e9geikkel (referencia, p\u00e9ld\u00e1nyos\u00edt\u00e1s). </p> <p> Er\u0151s csatol\u00e1s DI n\u00e9lk\u00fcl </p> <p>Ez a szoros csatol\u00e1s nehez\u00edti a tesztelhet\u0151s\u00e9get, a karbantarthat\u00f3s\u00e1got \u00e9s az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got. Ezen seg\u00edt a Dependency Injection (\u00e9s a Strategy) alkalamaz\u00e1sa. A t\u00e1rgy keret\u00e9ben a tervez\u00e9si mint\u00e1khoz kapcsol\u00f3d\u00f3an tanulunk a Dependency Injection (DI) tervez\u00e9si mint\u00e1r\u00f3l, melyet mindig a Strategy mint\u00e1val egy\u00fctt alkalmazunk. A l\u00e9nyege az, hogy egy oszt\u00e1ly nem maga hozza l\u00e9tre a f\u00fcgg\u0151s\u00e9geit (azon oszt\u00e1lyokat, melyekt\u0151l f\u00fcgg, melyeket felhaszn\u00e1l), hanem k\u00edv\u00fclr\u0151l kapja meg, pl. konstruktor param\u00e9terben. A Strategy mint\u00e1b\u00f3l ad\u00f3d\u00f3an pedig az k\u00f6vetkezik, hogy csak \"interf\u00e9szk\u00e9nt\" f\u00fcgg t\u0151l\u00fck. </p> <p>A mai legt\u00f6bb platform egy plusz szolg\u00e1ltat\u00e1st, \u00fan. DI (m\u00e1s nev\u00e9n IoC) kont\u00e9nert is biztos\u00edt a f\u00fcggg\u0151s\u00e9gek k\u00e9nyelmes kezel\u00e9s\u00e9hez.  A f\u00fcgg\u0151s\u00e9gek \u00e9letciklus\u00e1t ez esetben egy kit\u00fcntetett komponens kezeli, a DI kont\u00e9ner. A DI kont\u00e9ner (\u00e1br\u00e1n Builder) felel\u0151s az oszt\u00e1lyok p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1\u00e9rt \u00e9s a f\u00fcgg\u0151s\u00e9gek beinjekt\u00e1l\u00e1s\u00e1\u00e9rt rekurz\u00edvan.</p> <p> DI oszt\u00e1lydiagramm </p> <p>Ahhoz, hogy a p\u00e9ld\u00e1nyos\u00edt\u00e1s sor\u00e1n a f\u00fcgg\u0151s\u00e9gi gr\u00e1fot bej\u00e1rva beinjekt\u00e1lja a megfelel\u0151 implement\u00e1ci\u00f3kat a kont\u00e9ner, a DI kont\u00e9nerbe be kell regisztr\u00e1lni a f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seket. Alkalmaz\u00e1sunkban ezt az <code>App.xaml.cs</code> f\u00e1jlban a <code>ConfigureServices</code> met\u00f3dusban tessz\u00fck meg. Vegy\u00fck fel az al\u00e1bbi sort, pl. a <code>// Core Services</code> szakasz al\u00e1:</p> <pre><code>services.AddTransient&lt;IRecipeService, RecipeService&gt;();\n</code></pre> <p>Ez azt mondja meg, hogy ahol egy oszt\u00e1lyunk <code>IRecipeService</code> f\u00fcgg\u0151s\u00e9get v\u00e1r (pl. <code>MainPageViewModel</code> konstruktora), a DI keretrendszer egy <code>RecipeService</code> implement\u00e1ci\u00f3t sz\u00far be (\u00e9s mivel itt Tranziens \u00e9lettartam\u00fak\u00e9nt regisztr\u00e1ltuk, minden egyes <code>IRecipeService</code> f\u00fcgg\u0151s\u00e9g ig\u00e9nyt egy \u00faj <code>RecipeService</code> p\u00e9ld\u00e1ny fog kiel\u00e9g\u00edteni).</p> <p>Ahhoz, hogy a Dependency Injection az alkalmaz\u00e1sunkban m\u0171k\u00f6dj\u00f6n, a <code>MainPageViewModel</code> oszt\u00e1lyt is be kell regisztr\u00e1lni a kont\u00e9nerbe, ezt is megtal\u00e1ljuk a <code>ConfigureServices</code> alatt.</p> <p>DI kont\u00e9nerekr\u0151l r\u00e9szletesen</p> <p>A DI kont\u00e9nerek haszn\u00e1lat\u00e1val \u00e9s m\u0171k\u00f6d\u00e9s\u00e9vel Adatvez\u00e9relt rendszerek t\u00e1rgy keret\u00e9ben fogunk k\u00e9s\u0151bb r\u00e9szletesen megismerkedni.</p>"},{"location":"labor/5-mvvm/#viewmodel-allapot","title":"ViewModel \u00e1llapot","text":"<p>K\u00f6vetkez\u0151 l\u00e9p\u00e9sben a ViewModel \u00e1llapot\u00e1nak felt\u00f6lt\u00e9s\u00e9t implement\u00e1ljuk.</p> <p>A c\u00e9lunk az, hogy</p> <ul> <li>a <code>MainPageViewModel</code>-ben legyen <code>RecipeGroups</code>nev\u0171 tulajdons\u00e1g, melyben receptcsoportok vannak (ezt akarjuk a fel\u00fclethez k\u00f6tni),</li> <li>a <code>RecipeGroups</code> v\u00e1ltoz\u00e1sait k\u00f6vesse le a fel\u00fclet, melyhez sz\u00fcks\u00e9g van az <code>INotifyPropertyChanged</code> megval\u00f3s\u00edt\u00e1s\u00e1ra \u00e9s a <code>PropertyChanged</code> megfelel\u0151 els\u00fct\u00e9s\u00e9re (ahogy a kor\u00e1bbi laboron/h\u00e1zi feladatban m\u00e1r l\u00e1ttuk).</li> </ul> <p>Ehhez viszonylag \"sokat\" kellene dolgoznunk, de az MVVM toolkit leegyszer\u0171s\u00edti az \u00e9let\u00fcnket, mind\u00f6ssze a k\u00f6vetkez\u0151t kell megtenn\u00fcnk:</p> <ul> <li>A <code>MainPageViewModel</code>-ben hozzunk l\u00e9tre egy <code>_recipeGroups</code> nev\u0171 <code>RecipeGroup[]</code> tagv\u00e1ltoz\u00f3t (vagyis nem tulajdons\u00e1got).</li> <li>A v\u00e1ltoz\u00f3t l\u00e1ssuk el a <code>ObservableProperty</code> attrib\u00fatummal. </li> </ul> <pre><code>[ObservableProperty]\nprivate RecipeGroup[] _recipeGroups = Array.Empty&lt;RecipeGroup&gt;();\n</code></pre> <p>K\u00e9sz is vagyunk. De mi t\u00f6rt\u00e9nik ennek hat\u00e1s\u00e1ra?</p> <ul> <li>Ez alapj\u00e1n az MVVM Toolkit automatikusan gener\u00e1lni fog egy <code>RecipeGroups</code> nev\u0171 property-t az oszt\u00e1ly gener\u00e1lt m\u00e1sik (partial) fel\u00e9ben.</li> <li>Ez a gener\u00e1lt property kihaszn\u00e1lja az <code>INotifyPropertyChanged</code> interf\u00e9szt, \u00edgy a <code>RecipeGroups</code> property \u00e9rt\u00e9k\u00e9nek megv\u00e1ltoz\u00e1sakor a <code>PropertyChanged</code> esem\u00e9nyt kiv\u00e1ltva \u00e9rtes\u00edti a n\u00e9zetet, az adatk\u00f6t\u00e9sek ment\u00e9n.</li> <li>A <code>MainPageViewModel</code>-\u00fcnk m\u00e1r megval\u00f3s\u00edtja az <code>INotifyPropertyChanged</code> interf\u00e9szt, mert az MVVM Toolkit <code>ObservableObject</code> oszt\u00e1ly\u00e1b\u00f3l sz\u00e1rmazik.</li> </ul> <p>A <code>MainPageViewModel</code>-ben implement\u00e1ljuk az el\u0151k\u00e9sz\u00edtett <code>INavigationAware</code> interf\u00e9szt, amelynek seg\u00edts\u00e9g\u00e9vel a n\u00e9zetek k\u00f6z\u00f6tti navig\u00e1ci\u00f3s \u00e9letciklus esem\u00e9nyt tudjuk lekezelni, \u00e9s ak\u00e1r adatokat is tudunk \u00e1tadni a ViewModel-ek k\u00f6z\u00f6tt. A <code>OnNavigatedTo</code> met\u00f3dusban k\u00e9rdezz\u00fck le a recept csoportokat az <code>IRecipeService</code>-en kereszt\u00fcl, majd t\u00e1roljuk el a <code>RecipeGroups</code> v\u00e1ltoz\u00f3ban.</p> <pre><code>public partial class MainPageViewModel : ObservableObject, INavigationAware\n{\n    // ...\n\n    public async void OnNavigatedTo(object parameter)\n    {\n        RecipeGroups = await _recipeService.GetRecipeGroupsAsync();\n    }\n\n    public void OnNavigatedFrom()\n    {\n    }\n}\n</code></pre>"},{"location":"labor/5-mvvm/#13-fooldal-nezet","title":"1.3 F\u0151oldal n\u00e9zet","text":"<p>A <code>MainPage</code>-en k\u00e9sz\u00edts\u00fck el a n\u00e9zetet, amelyen megjelen\u00edtj\u00fck a recept csoportokat.</p> <p>Ahhoz, hogy a csoportos\u00edt\u00e1st kezelni tudja a <code>GridView</code>, sz\u00fcks\u00e9g\u00fcnk van egy olyan list\u00e1ra, mely elv\u00e9gzi a csoportos\u00edt\u00e1st. Ezt a <code>CollectionViewSource</code> oszt\u00e1ly seg\u00edts\u00e9g\u00e9vel tudjuk megval\u00f3s\u00edtani, ami bizonyos szempontb\u00f3l UI specifikus burkol\u00f3 feladatokat l\u00e1t el gy\u0171jtem\u00e9nyeken. A <code>CollectionViewSource</code>-nak meg kell adnunk a csoportos\u00edtand\u00f3 elemeket, valamint azt, hogy a csoportokat milyen property alapj\u00e1n hozza l\u00e9tre. Tov\u00e1bb\u00e1 meg kell adnunk azt is, hogy a csoportokon bel\u00fcl milyen property alapj\u00e1n jelen\u00edtse meg az elemeket.</p> <p>Hozzuk l\u00e9tre az oldal er\u0151forr\u00e1sai k\u00f6z\u00f6tt a <code>CollectionViewSource</code> p\u00e9ld\u00e1nyt (az al\u00e1bbi k\u00f3dot a <code>MainPage.xaml</code>-be, a Grid f\u00f6l\u00e9 tegy\u00fck be, vele egy szintre).</p> <pre><code>&lt;Page.Resources&gt;\n    &lt;CollectionViewSource x:Name=\"RecipeGroupsCollectionSource\"\n                            IsSourceGrouped=\"True\"\n                            ItemsPath=\"Recipes\"\n                            Source=\"{x:Bind ViewModel.RecipeGroups, Mode=OneWay}\" /&gt;\n&lt;/Page.Resources&gt;\n</code></pre> <p>Note</p> <p>Vegy\u00fck \u00e9szre, hogy az adatk\u00f6t\u00e9s sor\u00e1n a <code>ViewModel</code> tulajdons\u00e1ghoz k\u00f6t\u00fcnk, mely a <code>MainPage.xaml.cs</code>-ben tal\u00e1lhat\u00f3, \u00e9s egyszer\u0171en csak \u00e1tkasztolja a <code>DataContext</code> property-t a ViewModel t\u00edpusunkra.</p> <pre><code>public MainPageViewModel ViewModel =&gt; DataContext as MainPageViewModel;\n</code></pre> <p>Az, hogy a vez\u00e9rl\u0151k (oldalak) <code>DataContext</code> tulajdons\u00e1g\u00e1ban a ViewModel-t t\u00e1roljuk tipikus az MVVM mint\u00e1ban. Eset\u00fcnkben ezt a gener\u00e1lt projekt <code>NavigationService</code> oszt\u00e1lya teszi meg nek\u00fcnk.</p> Er\u0151forr\u00e1sok <p>XAML k\u00f6rnyezetben minden vez\u00e9rl\u0151 (fenti p\u00e9ld\u00e1ban Page) \u00e9s az <code>Application</code> oszt\u00e1ly is, rendelkezik egy <code>Resources</code> property-vel, mely egy kulcs \u00e9rt\u00e9k t\u00e1rol\u00f3 (<code>Dictionary&lt;string, object&gt;</code>), alap esetben. Ebbe tudunk t\u00f6bbsz\u00f6r felhaszn\u00e1lhat\u00f3 objektumokat rakni, ak\u00e1r alkalmaz\u00e1s szinten is. Ha ehhez az er\u0151forr\u00e1sok p\u00e9ld\u00e1nyos\u00edt\u00e1sakor megadjuk az <code>x:Key</code> attrib\u00fatumot, akkor az er\u0151forr\u00e1sokat a kulcs alapj\u00e1n tudjuk lek\u00e9rdezni pl.: a <code>{StaticResource Key}</code> markup extensionnel.</p> <p>Mi viszont itt kifejezetten <code>x:Key</code> helyett <code>x:Name</code>-et adtunk meg, mert az <code>x:Bind</code>-ban n\u00e9v szerint szeretn\u00e9nk majd hivatkozni r\u00e1 (eml\u00e9kezz\u00fcnk: az <code>x:Name</code> attrib\u00fatum seg\u00edts\u00e9g\u00e9vel azt tudjuk el\u00e9rni, hogy gener\u00e1l\u00f3dik ilyen n\u00e9ven egy tagv\u00e1ltoz\u00f3 az oszt\u00e1lyunkban, \u00edgy a code behind f\u00e1jlb\u00f3l, vagy x:Bind adatk\u00f6t\u00e9s sor\u00e1n ilyen n\u00e9ven el tudjuk \u00e9rni).</p> <p>A receptek list\u00e1z\u00e1s\u00e1hoz, most egy speci\u00e1lis <code>GridView</code> lesz\u00e1rmazott vez\u00e9rl\u0151t haszn\u00e1ljunk, m\u00e9gpedig az <code>AdaptiveGridView</code>-t a CommunityToolkit csomagb\u00f3l, amely a n\u00e9zet m\u00e9ret\u00e9nek megfelel\u0151en v\u00e1ltoztatja a megjelen\u00edtett elemek sz\u00e1m\u00e1t \u00e9s m\u00e9ret\u00e9t, illetve t\u00e1mogatja a Command-okat az elem kattint\u00e1s eset\u00e9ben. A k\u00fcls\u0151 vez\u00e9rl\u0151k hivatkoz\u00e1s\u00e1hoz vegy\u00fck fel az oldalra a k\u00f6vetkez\u0151 n\u00e9vteret:</p> <pre><code>xmlns:controls=\"using:CommunityToolkit.WinUI.UI.Controls\"\n</code></pre> <p>K\u00e9sz\u00edts\u00fck el a GridView-t, amelynek a <code>ItemsSource</code> property-j\u00e9t a fenti er\u0151forr\u00e1sban l\u00e9v\u0151 <code>RecipeGroupsCollectionSource.View</code>-ra k\u00f6tj\u00fck.</p> <p>A <code>GridView</code>-en bel\u00fcl a megszokott m\u00f3don az <code>ItemTemplate</code> property-n kereszt\u00fcl tudjuk megadni, hogy az egyes elemeket hogyan kell megjelen\u00edteni. Eset\u00fcnkben egy k\u00e9pet \u00e9s egy sz\u00f6veget rakunk ki a receptek c\u00edme alapj\u00e1n egy \"k\u00e1rtya\" szer\u0171 layoutra.</p> <p>A <code>GroupStyle</code> property-n kereszt\u00fcl pedig meg tudjuk adni, hogy a csoportokat hogyan kell megjelen\u00edteni. Eset\u00fcnkben a fejl\u00e9cet akarjuk testreszabni.</p> <p>A <code>MainPage.xaml</code>-ben a <code>&lt;Grid x:Name=\"ContentArea\"&gt; ...</code> grid-et cser\u00e9lj\u00fck le a k\u00f6vetkez\u0151re:</p> <pre><code>&lt;Grid x:Name=\"ContentArea\" Padding=\"10\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n\n    &lt;TextBlock Text=\"Recipes\"\n               Grid.Row=\"0\"\n               Style=\"{StaticResource TitleLargeTextBlockStyle}\" /&gt;\n\n    &lt;controls:AdaptiveGridView Grid.Row=\"1\"\n                               DesiredWidth=\"180\"\n                               IsItemClickEnabled=\"True\"\n                               ItemHeight=\"160\"\n                               ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                               SelectionMode=\"None\"\n                               StretchContentForSingleRow=\"False\"&gt;\n        &lt;GridView.ItemTemplate&gt;\n            &lt;DataTemplate x:DataType=\"models:RecipeHeader\"&gt;\n                &lt;Grid MaxWidth=\"300\"&gt;\n                    &lt;Image Source=\"{x:Bind BackgroundImage}\" /&gt;\n                    &lt;Border Height=\"40\"\n                            Padding=\"10,0,0,0\"\n                            VerticalAlignment=\"Bottom\"\n                            Background=\"#88000000\"&gt;\n                        &lt;TextBlock VerticalAlignment=\"Center\"\n                                   Foreground=\"White\"\n                                   Text=\"{x:Bind Title}\" /&gt;\n                    &lt;/Border&gt;\n                &lt;/Grid&gt;\n            &lt;/DataTemplate&gt;\n        &lt;/GridView.ItemTemplate&gt;\n        &lt;GridView.GroupStyle&gt;\n            &lt;GroupStyle&gt;\n                &lt;GroupStyle.HeaderTemplate&gt;\n                    &lt;DataTemplate x:DataType=\"models:RecipeGroup\"&gt;\n                        &lt;TextBlock Margin=\"0\"\n                                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                                   Text=\"{x:Bind Title}\" /&gt;\n                    &lt;/DataTemplate&gt;\n                &lt;/GroupStyle.HeaderTemplate&gt;\n            &lt;/GroupStyle&gt;\n        &lt;/GridView.GroupStyle&gt;\n    &lt;/controls:AdaptiveGridView&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Vegy\u00fck fel a k\u00f6vetkez\u0151 n\u00e9vteret (ebben vannak a modell oszt\u00e1lyaink):</p> <pre><code>`xmlns:models=\"using:MvvmLab.Core.Models\"`\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a recept csoportok megjelennek a f\u0151oldalon.</p>"},{"location":"labor/5-mvvm/#2-feladat-recept-reszletes-oldal","title":"2. Feladat - Recept r\u00e9szletes oldal","text":"<p>A receptek r\u00e9szletes oldal\u00e1nak elk\u00e9sz\u00edt\u00e9se a k\u00f6vetkez\u0151 l\u00e9p\u00e9sekb\u0151l fog \u00e1llni:</p> <ol> <li>Kieg\u00e9sz\u00edtj\u00fck az <code>IRecipeService</code> interf\u00e9szt egy <code>GetRecipeAsync</code> met\u00f3dussal, \u00e9s l\u00e9trehozzuk a sz\u00fcks\u00e9ges oszt\u00e1lyokat</li> <li>L\u00e9trehozzuk a <code>RecipeDetailPageViewModel</code> ViewModel-t, amiben lek\u00e9rdezz\u00fck a recept adatait a <code>RecipeDetailPageViewModel</code>-ben az <code>IRecipeService</code>-en kereszt\u00fcl (a VM az azonos\u00edt\u00f3t kapja meg a navig\u00e1ci\u00f3 sor\u00e1n)</li> <li>L\u00e9trehozzuk a <code>RecipeDetailPage</code> n\u00e9zetet, \u00e9p\u00edtve a ViewModel adataira</li> <li>Regisztr\u00e1ljuk a ViewModel-t \u00e9s a n\u00e9zetet a Dependency Injection konfigur\u00e1ci\u00f3hoz \u00e9s a navig\u00e1ci\u00f3hoz</li> <li>\u00c1tnavig\u00e1lunk a <code>RecipeDetailPage</code>-re a <code>MainPageViewModel</code>-b\u0151l a receptre t\u00f6rt\u00e9n\u0151 kattint\u00e1sra az <code>INavigationService</code> seg\u00edts\u00e9g\u00e9vel, \u00e9s \u00e1tadjuk a kiv\u00e1lasztott recept azonos\u00edt\u00f3j\u00e1t a r\u00e9szletes oldalnak</li> </ol>"},{"location":"labor/5-mvvm/#21-recept-lekerdezese","title":"2.1 Recept lek\u00e9rdez\u00e9se","text":"<p>Hozzuk l\u00e9tre a  <code>Recipe</code> oszt\u00e1lyt a <code>MvvmLab.Core.Model</code> n\u00e9vt\u00e9rbe, \u00e9s gener\u00e1ljuk le a tartalm\u00e1t a <code>/api/recipes/{id}</code> v\u00e9gpont \u00e1ltal visszaadott p\u00e9lda JSON adatokb\u00f3l, a fent megismert m\u00f3dszerrel (Paste special).</p> <pre><code>public class Recipe\n{\n    public int Id { get; set; }\n    public string BackgroundImage { get; set; }\n    public string Title { get; set; }\n    public string[] ExtraImages { get; set; }\n    public string[] Ingredients { get; set; }\n    public string Directions { get; set; }\n    public Comment[] Comments { get; set; }\n}\n\npublic class Comment\n{\n    public string Name { get; set; }\n    public string Text { get; set; }\n}\n</code></pre> <p>Warning</p> <p>A \"Paste Special\" sor\u00e1n fontos, hogy olyan receptet tegy\u00fcnk el\u0151tte a v\u00e1g\u00f3lapra, melyhez tartozik megjegyz\u00e9s (k\u00fcl\u00f6nben a <code>Comment</code> oszt\u00e1ly nem fog legener\u00e1l\u00f3dni, illetve a <code>Recipe</code> oszt\u00e1lyban a <code>Comments</code> t\u00edpus\u00e1nak <code>object[]</code> t\u00edpus gener\u00e1l\u00f3dik). \u00c9rdemes ehhez a swagger le\u00edr\u00e1s \"Example value\" mez\u0151j\u00e9b\u0151l a v\u00e1g\u00f3lapra m\u00e1solni a mint\u00e1t!</p> <p>A <code>IRecipeService</code> interf\u00e9szt \u00e9s implement\u00e1ci\u00f3j\u00e1t eg\u00e9sz\u00edts\u00fck ki egy <code>GetRecipeAsync</code> met\u00f3dussal, mely egy receptet ad vissza az azonos\u00edt\u00f3ja alapj\u00e1n.</p> IRecipeService<pre><code>public Task&lt;Recipe&gt; GetRecipeAsync(int id);\n</code></pre> RecipeService<pre><code>public async Task&lt;Recipe&gt; GetRecipeAsync(int id)\n{\n    using var client = new HttpClient();\n    return await client.GetFromJsonAsync&lt;Recipe&gt;($\"{_baseUrl}/Recipes/{id}\");\n}\n</code></pre>"},{"location":"labor/5-mvvm/#22-recept-reszletes-viewmodel","title":"2.2 Recept r\u00e9szletes ViewModel","text":"<p>A ViewModel k\u00e9sz\u00edt\u00e9se a f\u0151oldalhoz k\u00e9pest m\u00e1r ujjgyakorlat (alapvet\u0151en annak mint\u00e1j\u00e1ra lehet dolgozni). Hozzuk l\u00e9tre a <code>RecipeDetailPageViewModel</code> oszt\u00e1lyt az <code>MvvmLab.ViewModels</code> mapp\u00e1ban.</p> <p>A ViewModel-nek sz\u00fcks\u00e9ge lesz egy <code>IRecipeService</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyra, amelyen kereszt\u00fcl le tudja k\u00e9rdezni a receptet. A <code>RecipeDetailPageViewModel</code> konstruktor\u00e1ban DI seg\u00edts\u00e9g\u00e9vel szerezz\u00fck be a sz\u00fcks\u00e9ges f\u00fcgg\u0151s\u00e9get.</p> <pre><code>private readonly IRecipeService _recipeService;\n\npublic RecipeDetailPageViewModel(IRecipeService recipeService)\n{\n    _recipeService = recipeService;\n}\n</code></pre> <p>A <code>RecipeDetailPageViewModel</code>-ben hozzunk l\u00e9tre egy <code>_recipe</code> nev\u0171 <code>Recipe</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3t, amelyben t\u00e1rolni fogjuk a receptet. A v\u00e1ltoz\u00f3t attribut\u00e1ljuk fel a <code>ObservableProperty</code> attrib\u00fatummal, mely alapj\u00e1n az MVVM Toolkit automatikusan gener\u00e1lni fogja a <code>Recipe</code> nev\u0171 property-t az oszt\u00e1ly m\u00e1sik gener\u00e1lt partial fel\u00e9ben. Ehhez sz\u00fcks\u00e9ges, hogy az oszt\u00e1ly az <code>ObservableObject</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazzon, publikus legyen \u00e9s a <code>partial</code> kulcssz\u00f3val legyen ell\u00e1tva.</p> <pre><code>public partial class RecipeDetailPageViewModel : ObservableObject\n{\n    // ...\n\n    [ObservableProperty]\n    private Recipe _recipe = new();\n</code></pre> <p>Implement\u00e1ljuk a <code>RecipeDetailPageViewModel</code>-ben az el\u0151k\u00e9sz\u00edtett <code>INavigationAware</code> interf\u00e9szt. Arra k\u00e9sz\u00fcl\u00fcnk, hogy a navig\u00e1ci\u00f3s param\u00e9terk\u00e9nt a megjelen\u00edteni k\u00edv\u00e1nt recept azonos\u00edt\u00f3j\u00e1t fogjuk megkapni. A <code>OnNavigatedTo</code> met\u00f3dusban k\u00e9rdezz\u00fck le a receptet a <code>RecipeService</code>-en kereszt\u00fcl, majd t\u00e1roljuk el a <code>Recipe</code> tulajdons\u00e1gban.</p> <pre><code>public partial class RecipeDetailPageViewModel : ObservableObject, INavigationAware\n{\n    // ...\n\n    public async void OnNavigatedTo(object parameter)\n    {\n        Recipe = await _recipeService.GetRecipeAsync((int)parameter);\n    }\n\n    public void OnNavigatedFrom()\n    {\n    }\n}\n</code></pre> <p>Note</p> <p>A <code>OnNavigatedTo</code> m\u0171velet fejl\u00e9c\u00e9ben haszn\u00e1lni kellett az <code>async</code> kulcssz\u00f3t, mert haszn\u00e1ltuk az <code>await</code>-et a t\u00f6rzs\u00e9ben.</p>"},{"location":"labor/5-mvvm/#23-recept-reszletes-oldal-navigacio","title":"2.3 Recept r\u00e9szletes oldal, navig\u00e1ci\u00f3","text":"<p>Hozzunk l\u00e9tre egy \u00faj oldalt <code>RecipeDetailPage</code> n\u00e9ven a <code>Views</code> mapp\u00e1ba (Views mapp\u00e1n jobb gomb / Add New Item / Blank Page (WinUI 3)), amelyen megjelen\u00edtj\u00fck a receptet. Els\u0151 k\u00f6rben csak a recept c\u00edm\u00e9t jelen\u00edts\u00fck meg egy <code>TextBlock</code>-ban.</p> <pre><code>&lt;Grid x:Name=\"ContentArea\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"48\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\"\n               Style=\"{StaticResource PageTitleStyle}\"\n               Text=\"{x:Bind ViewModel.Recipe.Title, Mode=OneWay}\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Az adatk\u00f6t\u00e9shez vegy\u00fck fel a <code>RecipeDetailPage.xaml.cs</code>-ben a <code>ViewModel</code> property-t a f\u0151oldal mint\u00e1j\u00e1ra.</p> <pre><code>public RecipeDetailPageViewModel ViewModel =&gt; (RecipeDetailPageViewModel)DataContext;\n</code></pre> <p>Ford\u00edt\u00e1si hib\u00e1k</p> <p>Ha valami\u00e9rt egzotikus hib\u00e1kat kapn\u00e1nk az \u00faj oldal felv\u00e9tele ut\u00e1n t\u00f6r\u00f6lj\u00fck ki a projekt f\u00e1jlb\u00f3l az al\u00e1bbi sorokat:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;None Remove=\"Views\\RecipeDetailPage.xaml\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <pre><code>&lt;Page Update=\"Views\\RecipeDetailPage.xaml\"&gt;\n    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;\n&lt;/Page&gt;\n</code></pre> <p>A navig\u00e1ci\u00f3 t\u00e1mogat\u00e1s\u00e1hoz a <code>Services</code> mapp\u00e1ban l\u00e9v\u0151 <code>PageService</code>-ben regisztr\u00e1ljuk be a <code>RecipeDetailPage</code>-et az al\u00e1bbi 3 l\u00e9p\u00e9sben:</p> <ol> <li> <p>Vegy\u00fck fel a n\u00e9zet kulcs\u00e1t a <code>Pages</code> oszt\u00e1lyba.</p> <pre><code>public static class Pages\n{\n    public static string Main { get; } = \"Main\";\n    public static string Detail { get; } = \"Detail\";\n}\n</code></pre> </li> <li> <p>Regisztr\u00e1ljuk a n\u00e9zetet \u00e9s ViewModel kapcsolatot a <code>PageService</code>-ben.</p> <pre><code>public PageService()\n{\n    Configure&lt;MainPageViewModel, MainPage&gt;(Pages.Main);\n    Configure&lt;RecipeDetailPageViewModel, RecipeDetailPage&gt;(Pages.Detail);\n}\n</code></pre> </li> <li> <p>Az <code>App.xaml.cs</code> f\u00e1jlban a <code>ConfigureServices</code> met\u00f3dusban regisztr\u00e1ljuk be a ViewModel-t \u00e9s a n\u00e9zetet a Dependency Injection kont\u00e9nerbe.</p> <pre><code>services.AddTransient&lt;RecipeDetailPage&gt;();\nservices.AddTransient&lt;RecipeDetailPageViewModel&gt;();\n</code></pre> </li> </ol> <p>Ezekre az\u00e9rt van sz\u00fcks\u00e9g, mert a projekt sablonban l\u00e9v\u0151 <code>INavigationService</code> alapvet\u0151en egy kulccsal azonos\u00edtja a n\u00e9zeteket, annak \u00e9rdek\u00e9ben, hogy a ViewModel-ben ne legyen sz\u00fcks\u00e9g a n\u00e9zet t\u00edpus\u00e1nak ismeret\u00e9re. A kulcs alapj\u00e1n pedig ki tudja keresni, hogy pontosan melyik Viewt kell megjelen\u00edteni, \u00e9s melyik ViewModel-t kell p\u00e9ld\u00e1nyos\u00edtani a n\u00e9zet <code>DataContext</code>-j\u00e9be a DI kont\u00e9nerb\u0151l.</p> <p>A <code>MainPageViewModel</code>-ben injekt\u00e1ljuk be az <code>INavigationService</code>-t, amelyen kereszt\u00fcl navig\u00e1lni fogunk a <code>RecipeDetailPage</code>-re.</p> <pre><code>private readonly INavigationService _navigationService;\n\npublic MainPageViewModel(IRecipeService recipeService, INavigationService navigationService)\n{\n    _recipeService = recipeService;\n    _navigationService = navigationService;\n}\n</code></pre>"},{"location":"labor/5-mvvm/#command","title":"Command","text":"<p>Eddig az MVVM minta egyik oldal\u00e1val foglalkoztunk: hogyan \u00e9ri el adatk\u00f6t\u00e9ssel \u00e9s jelen\u00edti meg a View a ViewModel-ben lev\u0151 adatokat. Ugyanakkor, a View \u00e9s ViewModel k\u00f6z\u00f6tt \u00e1ltal\u00e1ban van egy m\u00e1sik kapcsolat is: ez arr\u00f3l sz\u00f3l, hogy a View esem\u00e9nyei (pl. kattint\u00e1s) hogyan hatnak vissza a ViewModel-re. Most ezzel fogunk foglalkozni.</p> <p>Eset\u00fcnkben pl. meg kell oldani, hogy a f\u0151oldali n\u00e9zeten egy Recepten t\u00f6rt\u00e9n\u0151 kattint\u00e1s eljusson a <code>MainPageViewModel</code>-hez, \u00e9s az ennek hat\u00e1s\u00e1ra \u00e1tnavig\u00e1ljon az adott recept r\u00e9szletes n\u00e9zet\u00e9re.</p> <p>A ViewModel a v\u00e9grehajthat\u00f3 m\u0171veleteket az MVVM mint\u00e1ban tipikusan <code>ICommand</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektumokon kereszt\u00fcl publik\u00e1lja (amelyek a konkr\u00e9t m\u0171velet v\u00e9grehajt\u00e1s\u00e1n t\u00fal kezelhetik a m\u0171velet v\u00e9grehajt\u00e1s\u00e1nak felt\u00e9teleit is).</p> <p>A <code>MainPageViewModel</code>-ben k\u00e9sz\u00edts\u00fcnk egy Commandot, mely a receptre kattintva fog lefutni. A Command param\u00e9terk\u00e9nt megkapja a kiv\u00e1lasztott recept fejl\u00e9cet, \u00e9s \u00e1tnavig\u00e1l a <code>RecipeDetailPage</code>-re, ahol \u00e1tad\u00e1sra ker\u00fcl a kiv\u00e1lasztott recept azonos\u00edt\u00f3ja.</p> <p>Most l\u00e9tre kellene hozzunk egy \u00fagy, <code>ICommand</code> interf\u00e9szt implement\u00e1l\u00f3 oszt\u00e1lyt, majd ebb\u0151l fel kellene vegy\u00fcnk egy p\u00e9ld\u00e1nyt (tulajdons\u00e1got) a ViewModel-be. Ezt a k\u00e9t l\u00e9p\u00e9st az MVVM toolkit leegyszer\u0171s\u00edti, csak egy <code>[RelayCommand]</code> attrib\u00fatummal ell\u00e1tott f\u00fcggv\u00e9nyt kell felvegy\u00fcnk a ViewModelbe:</p> <pre><code>[RelayCommand]\nprivate void RecipeSelected(RecipeHeader recipe)\n{\n    _navigationService.NavigateTo(Pages.Detail, recipe.Id);\n}\n</code></pre> <p>Ennek hat\u00e1s\u00e1ra a compiler legener\u00e1lja a command oszt\u00e1lyt \u00e9s a tulajdons\u00e1got a ViewModel-be <code>RecipeSelectedCommand</code> n\u00e9ven.</p> <p> A parancs \u00e9s a ViewModel el\u0151 van k\u00e9sz\u00edtve, de a View m\u00e9g semmit nem tud a parancsr\u00f3l. A ViewModel-ben lev\u0151 commandunkat a szok\u00e1sos technik\u00e1kkal r\u00e1 kell k\u00f6ss\u00fck a View megfelel\u0151 esem\u00e9ny\u00e9re. MVVM eset\u00e9n mindig \u00edgy haszn\u00e1ljuk a Command mint\u00e1t! A megk\u00f6zel\u00edt\u00e9s sz\u00e9ps\u00e9ge az, hogy ez teljesen a szok\u00e1sos, View-&gt;ViewModel ir\u00e1ny\u00fa adatk\u00f6t\u00e9ssel t\u00f6rt\u00e9nik (amit m\u00e1r eddig is t\u00f6bbsz\u00f6r haszn\u00e1ltunk).</p> <p>Ennek megfelel\u0151en a <code>MainPage</code>-en k\u00f6ss\u00fck a <code>AdaptiveGridView</code> <code>ItemClickCommand</code> tulajdons\u00e1g\u00e1t a <code>RecipeSelectedCommand</code>-ra.</p> <pre><code>ItemClickCommand=\"{x:Bind ViewModel.RecipeSelectedCommand}\"\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! Gy\u0151z\u0151dj\u00fcnk meg r\u00f3la, hogy a receptekre kattintva megjelenik a recept r\u00e9szletes oldala.</p> Kitekint\u00e9s: Ha nincs a haszn\u00e1lni k\u00edv\u00e1nt esem\u00e9nyre Command? <p>Ha a vez\u00e9rl\u0151 bizonyos esem\u00e9nyekre biztos\u00edt Commandot, akkor viszonylag egyszer\u0171 dolgunk van, amire fentebb l\u00e1thattunk egy p\u00e9ld\u00e1t. Azonban, ha a vez\u00e9rl\u0151 nem biztos\u00edt Commandot (pl.: a be\u00e9p\u00edtett <code>GridView.ItemClicked</code>), akkor t\u00f6bb lehet\u0151s\u00e9g\u00fcnk is van:</p> <ol> <li> <p>Code-Behind \"ragaszt\u00f3 k\u00f3d\": A vez\u00e9rl\u0151 esem\u00e9ny\u00e9t kezelj\u00fck le, \u00e9s a code-behindban (xaml.cs) ViewModel-ben h\u00edvjuk meg a megfelel\u0151 met\u00f3dust/commadot.</p> <pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"\n                            ItemClick=\"GridView_ItemClick\"&gt;\n</code></pre> <pre><code>private void GridView_ItemClick(object sender, ItemClickEventArgs e)\n{\n    ViewModel.RecipeSelectedCommand.Execute((RecipeHeader)e.ClickedItem);\n}\n</code></pre> </li> <li> <p>x:Bind esem\u00e9ny k\u00f6t\u00e9s: haszn\u00e1ljuk az <code>x:Bind</code> met\u00f3dus k\u00f6t\u00e9si lehet\u0151s\u00e9g\u00e9t, amelynek seg\u00edts\u00e9g\u00e9vel a vez\u00e9rl\u0151 esem\u00e9ny\u00e9t tudjuk k\u00f6tni a ViewModel-ben l\u00e9v\u0151 met\u00f3dusra.    A met\u00f3dusnak viszont ilyenkor vagy param\u00e9ter n\u00e9lk\u00fclinek kell lennie, vagy olyan param\u00e9tereket kell fogadnia, amely az esem\u00e9ny szignat\u00far\u00e1j\u00e1ra illeszkedik.</p> View - MainPage.xaml<pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"\n                            ItemClick=\"{x:Bind ViewModel.RecipeSelected\"&gt;\n&lt;/controls:AdaptiveGridView&gt;\n</code></pre> ViewModel - MainPageViewModel<pre><code>public void RecipeSelected(object sender, ItemClickEventArgs e)\n{\n   ...\n}\n</code></pre> <p>Ennek a m\u00f3dszernek a h\u00e1tr\u00e1nya, hogy a esem\u00e9ny param\u00e9tereivel a ViewModel-be a n\u00e9zet keretrendszer f\u00fcgg\u0151s\u00e9geit is beviszi (esem\u00e9nykezel\u0151 param\u00e9ter t\u00edpusok), pedig az alap gondolatunk az volt, hogy a ViewModel f\u00fcggetlen legyen a n\u00e9zett\u0151l. Term\u00e9szetesen ez a m\u00f3dszer is j\u00f3l tud m\u0171k\u00f6dni, ha r\u00e9szben feladjuk az MVVM minta szigor\u00fa betart\u00e1s\u00e1t.</p> </li> <li> <p>A Behavior-\u00f6k seg\u00edts\u00e9g\u00e9vel, azon bel\u00fcl is az <code>EventTriggerBehavior</code> \u00e9s <code>InvokeCommandAction</code> oszt\u00e1lyokkal tudunk Commandot k\u00f6tni tetsz\u0151leges vez\u00e9rl\u0151 esem\u00e9nyre.</p> <pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"&gt;\n    &lt;i:Interaction.Behaviors&gt;\n        &lt;c:EventTriggerBehavior EventName=\"ItemClick\"&gt;\n            &lt;c:InvokeCommandAction Command=\"{x:Bind ViewModel.RecipeSelectedCommand}\" \n                                   InputConverter=\"{StaticResource ItemClickedInputConverter}\" /&gt;\n        &lt;/c:EventTriggerBehavior&gt;\n    &lt;/i:Interaction.Behaviors&gt;\n</code></pre> <p>Ezzel szinte teljesen deklarat\u00edvv\u00e1 tudjuk tenni hagyni a n\u00e9zetet, de m\u00e9g \u00edgy is k\u00e9sz\u00edten\u00fcnk kell egy <code>ItemClickedInputConverter</code> oszt\u00e1lyt, amely az esem\u00e9ny param\u00e9tereit \u00e1talak\u00edtja a megfelel\u0151 t\u00edpusra az <code>IValueConverter</code> interf\u00e9sz seg\u00edts\u00e9g\u00e9vel.</p> <pre><code>public class ItemClickedInputConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, string language)\n    {\n        return (RecipeHeader)((value as ItemClickEventArgs)?.ClickedItem);\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, string language)\n    {\n        throw new NotImplementedException();\n    }\n}\n</code></pre> <p>A behavior-\u00f6k egy\u00e9bk\u00e9nt egy teljesen \u00e1ltal\u00e1nos mechanizmus a XAML vil\u00e1gban, amelyek seg\u00edts\u00e9g\u00e9vel a n\u00e9zetekhez tudunk \u00fajrafelhaszn\u00e1lhat\u00f3 viselked\u00e9st hozz\u00e1adni (b\u0151vebben itt).</p> </li> </ol>"},{"location":"labor/5-mvvm/#24-recept-reszletes-nezet","title":"2.4 Recept r\u00e9szletes n\u00e9zet","text":"<p>A recept r\u00e9szletes adatainak megjelen\u00edt\u00e9s\u00e9hez egy <code>Grid</code>-et haszn\u00e1ljunk, amelynek k\u00e9t oszlopa van. Az els\u0151 oszlopban egy <code>ScrollViewer</code>-t helyezz\u00fcnk el, amelybe egy <code>StackPanel</code> ker\u00fcl. A <code>StackPanel</code>-ben helyezz\u00fcnk el egy <code>FlipView</code>-t, amelyben a recept k\u00e9peit fogjuk megjelen\u00edteni. A <code>FlipView</code> egy listak\u00e9nt m\u0171k\u00f6dik, de az elemeit egy lapozhat\u00f3 fel\u00fcleten jelen\u00edti meg.</p> <p>A <code>FlipView</code> alatt lesz tal\u00e1lhat\u00f3 el egy <code>ItemsControl</code> (egyszer\u0171 lista, mely nem t\u00e1mogat g\u00f6rget\u00e9st, kiv\u00e1laszt\u00e1st, kattint\u00e1st stb.), amelyben a recept hozz\u00e1val\u00f3it fogjuk megjelen\u00edteni.</p> <p>Ez al\u00e1 ker\u00fcl egy <code>TextBlock</code>, amelybe a recept elk\u00e9sz\u00edt\u00e9s\u00e9nek l\u00e9p\u00e9sei ker\u00fclnek.</p> <p>A m\u00e1sodik oszlopba helyezz\u00fcnk el egy <code>Grid</code>-et, amelybe kommentek list\u00e1ja \u00e9s beviteli mez\u0151i fognak ker\u00fclni.</p> <p>Az al\u00e1bbi k\u00f3dot a labor sor\u00e1n nyugodtan m\u00e1solhatjuk a <code>RecipeDetailPage.xaml</code> f\u00e1jlba, \u00fajdons\u00e1g ebben a k\u00f3dban nincs az eddigiekhez k\u00e9pest.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;Page x:Class=\"MvvmLab.Views.RecipeDetailPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:local=\"using:MvvmLab.Views\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:models=\"using:MvvmLab.Core.Models\"\n      Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"\n      mc:Ignorable=\"d\"&gt;\n\n    &lt;Grid x:Name=\"ContentArea\"&gt;\n        &lt;Grid.RowDefinitions&gt;\n            &lt;RowDefinition Height=\"Auto\" /&gt;\n            &lt;RowDefinition Height=\"*\" /&gt;\n        &lt;/Grid.RowDefinitions&gt;\n\n        &lt;TextBlock Grid.Row=\"0\" Padding=\"10\"\n                   Style=\"{StaticResource TitleTextBlockStyle}\"\n                   Text=\"{x:Bind ViewModel.Recipe.Title, Mode=OneWay}\" /&gt;\n\n        &lt;Grid Grid.Row=\"1\"&gt;\n            &lt;Grid.ColumnDefinitions&gt;\n                &lt;ColumnDefinition Width=\"3*\" /&gt;\n                &lt;ColumnDefinition Width=\"*\" /&gt;\n            &lt;/Grid.ColumnDefinitions&gt;\n\n            &lt;ScrollViewer Grid.Column=\"0\" Padding=\"20 10 0 20\"&gt;\n                &lt;StackPanel Orientation=\"Vertical\"&gt;\n                    &lt;StackPanel x:Name=\"images\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Images\" /&gt;\n                        &lt;FlipView x:Name=\"flipView\"\n                                  MaxHeight=\"250\"\n                                  VerticalAlignment=\"Top\"\n                                  ItemsSource=\"{x:Bind ViewModel.Recipe.ExtraImages, Mode=OneWay}\"&gt;\n                            &lt;FlipView.ItemTemplate&gt;\n                                &lt;DataTemplate&gt;\n                                    &lt;Image Source=\"{Binding}\" Stretch=\"Uniform\" /&gt;\n                                &lt;/DataTemplate&gt;\n                            &lt;/FlipView.ItemTemplate&gt;\n                        &lt;/FlipView&gt;\n                    &lt;/StackPanel&gt;\n\n                    &lt;StackPanel x:Name=\"ingredients\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Ingredients\" /&gt;\n                        &lt;ItemsControl HorizontalAlignment=\"Left\" ItemsSource=\"{x:Bind ViewModel.Recipe.Ingredients, Mode=OneWay}\"&gt;\n                            &lt;ItemsControl.ItemTemplate&gt;\n                                &lt;DataTemplate&gt;\n                                    &lt;TextBlock Margin=\"0,0,0,10\"\n                                               Text=\"{Binding}\"\n                                               TextWrapping=\"Wrap\" /&gt;\n                                &lt;/DataTemplate&gt;\n                            &lt;/ItemsControl.ItemTemplate&gt;\n                        &lt;/ItemsControl&gt;\n                    &lt;/StackPanel&gt;\n\n                    &lt;StackPanel x:Name=\"directions\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"\n                                RelativePanel.RightOf=\"ingredients\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Directions\" /&gt;\n                        &lt;TextBlock HorizontalAlignment=\"Left\"\n                                   Text=\"{x:Bind ViewModel.Recipe.Directions, Mode=OneWay}\"\n                                   TextWrapping=\"Wrap\" /&gt;\n                    &lt;/StackPanel&gt;\n                &lt;/StackPanel&gt;\n            &lt;/ScrollViewer&gt;\n\n            &lt;Grid Grid.Column=\"1\" RowSpacing=\"12\"&gt;\n                &lt;Grid.RowDefinitions&gt;\n                    &lt;RowDefinition Height=\"Auto\" /&gt;\n                    &lt;RowDefinition Height=\"*\" /&gt;\n                    &lt;RowDefinition Height=\"Auto\" /&gt;\n                &lt;/Grid.RowDefinitions&gt;\n\n                &lt;TextBlock Grid.Row=\"0\"\n                           Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                           Text=\"Comments\" /&gt;\n\n                &lt;ListView Grid.Row=\"1\" ItemsSource=\"{x:Bind ViewModel.Recipe.Comments, Mode=OneWay}\"&gt;\n                    &lt;ListView.ItemTemplate&gt;\n                        &lt;DataTemplate x:DataType=\"models:Comment\"&gt;\n                            &lt;StackPanel Orientation=\"Vertical\" Padding=\"0 5 0 5\"&gt;\n                                &lt;TextBlock FontWeight=\"Bold\" Text=\"{x:Bind Name}\" /&gt;\n                                &lt;TextBlock Text=\"{x:Bind Text}\" /&gt;\n                            &lt;/StackPanel&gt;\n                        &lt;/DataTemplate&gt;\n                    &lt;/ListView.ItemTemplate&gt;\n                &lt;/ListView&gt;\n\n                &lt;StackPanel x:Name=\"comments\"\n                            Grid.Row=\"2\"\n                            Margin=\"24,0,24,0\"\n                            Orientation=\"Vertical\"&gt;\n                    &lt;!-- TODO input fields for comments --&gt;\n                &lt;/StackPanel&gt;\n            &lt;/Grid&gt;\n        &lt;/Grid&gt;\n    &lt;/Grid&gt;\n&lt;/Page&gt;\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p>"},{"location":"labor/5-mvvm/#3-feladat-kommentek-hozzaadasa","title":"3. Feladat - Kommentek hozz\u00e1ad\u00e1sa","text":"<p>Ha j\u00f3l \u00e1llunk id\u0151vel, k\u00e9sz\u00edts\u00fcnk funkci\u00f3t a kommentek hozz\u00e1ad\u00e1s\u00e1hoz a recept r\u00e9szletes oldal\u00e1n.</p>"},{"location":"labor/5-mvvm/#webszolgaltatas","title":"Webszolg\u00e1ltat\u00e1s","text":"<p>Az <code>IRecipeService</code> interf\u00e9szt \u00e9s implement\u00e1ci\u00f3t eg\u00e9sz\u00edts\u00fck ki egy <code>SendCommentAsync</code> met\u00f3dussal, mely egy kommentet k\u00fcld a szervernek a <code>POST /Recipes/{recipeId}/Comments</code> v\u00e9gpontra.</p> IRecipeService<pre><code>public Task SendCommentAsync(int recipeId, Comment comment);\n</code></pre> RecipeService<pre><code>public async Task SendCommentAsync(int recipeId, Comment comment)\n{\n    using var client = new HttpClient();\n    await client.PostAsJsonAsync($\"{_baseUrl}/Recipes/{recipeId}/Comments\", comment);\n}\n</code></pre>"},{"location":"labor/5-mvvm/#viewmodel","title":"ViewModel","text":"<p>A <code>RecipeDetailPageViewModel</code>-ben hozzunk l\u00e9tre egy <code>NewCommentText</code> nev\u0171 <code>string</code> t\u00edpus\u00fa tulajdons\u00e1got \u00e9s egy <code>NewCommentName</code> <code>string</code> tulajdons\u00e1got, melyekben t\u00e1rolni fogjuk a felhaszn\u00e1l\u00f3 \u00e1ltal megadott komment adatait. Haszn\u00e1ljuk az <code>ObservableProperty</code> attrib\u00fatumot!</p> <pre><code>[ObservableProperty]\nprivate string _newCommentName = string.Empty;\n\n[ObservableProperty]\nprivate string _newCommentText = string.Empty;\n</code></pre> <p>A <code>RecipeDetailPageViewModel</code>-ben hozzunk l\u00e9tre egy <code>SendComment</code> nev\u0171 f\u00fcggv\u00e9nyt, amelyen kereszt\u00fcl a felhaszn\u00e1l\u00f3 \u00e1ltal megadott kommentet tudjuk elk\u00fcldeni a szervernek. A f\u00fcggv\u00e9nyb\u0151l gener\u00e1ltassunk egy Commandot az MVVM Toolkit seg\u00edts\u00e9g\u00e9vel (<code>[RelayCommand]</code>).</p> <p>Az implement\u00e1ci\u00f3 egyszer\u0171: elk\u00fcldj\u00fck a kommentet a szervernek, majd friss\u00edtj\u00fck a receptet.</p> <pre><code>[RelayCommand]\nprivate async Task SendComment()\n{\n    await _recipeService.SendCommentAsync(Recipe.Id, new Comment\n    {\n        Name = NewCommentName,\n        Text = NewCommentText\n    });\n\n    NewCommentName = string.Empty;\n    NewCommentText = string.Empty;\n\n    Recipe = await _recipeService.GetRecipeAsync(Recipe.Id);\n}\n</code></pre> <p>A n\u00e9zeten a k\u00f6vetkez\u0151 elemeket helyezz\u00fck el a kommentek hozz\u00e1ad\u00e1s\u00e1hoz:</p> <pre><code>&lt;StackPanel x:Name=\"comments\"\n            Grid.Row=\"2\"\n            Margin=\"24,0,24,0\"\n            Orientation=\"Vertical\"&gt;\n    &lt;TextBox Margin=\"0,0,0,16\"\n             Header=\"Name\"\n             Text=\"{x:Bind ViewModel.NewCommentName, Mode=TwoWay}\" /&gt;\n    &lt;TextBox Margin=\"0,0,0,16\"\n             Header=\"Comment\"\n             Text=\"{x:Bind ViewModel.NewCommentText, Mode=TwoWay}\" /&gt;\n    &lt;Button Margin=\"0,0,0,16\"\n            HorizontalAlignment=\"Right\"\n            Command=\"{x:Bind ViewModel.SendCommentCommand}\"\n            Content=\"Send\" /&gt;\n&lt;/StackPanel&gt;\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy a <code>TextBox</code>-ok <code>Text</code> property-j\u00e9t k\u00e9tir\u00e1ny\u00fa k\u00f6t\u00e9ssel k\u00f6t\u00f6tt\u00fck a ViewModel-ben l\u00e9v\u0151 <code>NewCommentName</code> \u00e9s <code>NewCommentText</code> tulajdons\u00e1gokhoz, \u00e9s a gomb Command-j\u00e1t is a ViewModel-ben l\u00e9v\u0151 <code>SendCommentCommand</code> tulajdons\u00e1ghoz k\u00f6t\u00f6tt\u00fck.</p>"},{"location":"labor/5-mvvm/#kitekintes-commandok-vegrehajtasanak-feltetelei","title":"Kitekint\u00e9s: Commandok v\u00e9grehajt\u00e1s\u00e1nak felt\u00e9telei","text":"<p>A <code>SendCommentCommand</code> Command v\u00e9grehajt\u00e1s\u00e1nak felt\u00e9tele, hogy a <code>NewCommentName</code> \u00e9s a <code>NewCommentText</code> tulajdons\u00e1gok ne legyenek \u00fcresek. A Commandok lehet\u0151s\u00e9get adnak arra, hogy a v\u00e9grehajt\u00e1sukat felt\u00e9telekhez k\u00f6ss\u00fck, amelyeket a <code>CanExecute</code> met\u00f3dusban tudunk megadni. Eset\u00fcnkben egy <code>bool</code>-lal visszat\u00e9r\u0151 met\u00f3dus/property nevet kell megadnunk a Command gener\u00e1tor attrib\u00fatumnak.</p> RecipeDetailPageViewModel-ben:<pre><code>private bool CanExecuteSendComment =&gt; !string.IsNullOrEmpty(NewCommentName) &amp;&amp; !string.IsNullOrEmpty(NewCommentText);\n\n[RelayCommand(CanExecute = nameof(CanExecuteSendComment))]\nprivate async Task SendComment()\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki. Azt tapasztaljuk, hogy a gomb nem lesz enged\u00e9lyezve, viszont a <code>TextBox</code>-ok m\u00f3dos\u00edt\u00e1sa ut\u00e1n sem v\u00e1ltozik a gomb \u00e1llapota.</p> <p>A <code>CanExecute</code> met\u00f3dus akkor h\u00edv\u00f3dik meg (akkor h\u00edvj\u00e1k a vez\u00e9rl\u0151k), amikor a Command els\u00fcti a <code>CanExecuteChanged</code> esem\u00e9nyt. Eset\u00fcnkben ezt az esem\u00e9nyt a <code>NewCommentName</code> \u00e9s a <code>NewCommentText</code> tulajdons\u00e1gok <code>PropertyChanged</code> esem\u00e9ny\u00e9nek kiv\u00e1lt\u00e1sakor kell kiv\u00e1ltani. Erre az MVVM Toolkit egy k\u00fcl\u00f6n attrib\u00fatumot biztos\u00edt (<code>[NotifyCanExecuteChangedFor]</code>), amelyet a <code>NewCommentName</code> \u00e9s a <code>NewCommentText</code> tulajdons\u00e1gokra kell r\u00e1rakni.</p> <p>Teh\u00e1t, ha a <code>NewCommentName</code> vagy a <code>NewCommentText</code> tulajdons\u00e1g \u00e9rt\u00e9ke megv\u00e1ltozik, akkor a <code>SendCommentCommand</code> Command <code>CanExecuteChanged</code> esem\u00e9ny\u00e9t is kiv\u00e1ltjuk, ami miatt a <code>CanExecute</code> met\u00f3dus \u00fajra lefut, \u00e9s a gomb \u00e1llapota is friss\u00fcl.</p> <pre><code>[ObservableProperty]\n[NotifyCanExecuteChangedFor(nameof(SendCommentCommand))]\nprivate string _newCommentName = string.Empty;\n\n[ObservableProperty]\n[NotifyCanExecuteChangedFor(nameof(SendCommentCommand))]\nprivate string _newCommentText = string.Empty;\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki.</p> <p>M\u00e1r csak egy dolog van h\u00e1tra: jelenleg a <code>TextBox</code> \u00e1llapota csak akkor v\u00e1ltozik, ha a felhaszn\u00e1l\u00f3 elhagyja a <code>TextBox</code>-ot. Ezt a viselked\u00e9st az adatk\u00f6t\u00e9s <code>UpdateSourceTrigger</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl tudjuk m\u00f3dos\u00edtani.</p> <pre><code>Text=\"{x:Bind ViewModel.NewCommentName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n\nText=\"{x:Bind ViewModel.NewCommentText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki.</p>"},{"location":"labor/5-mvvm/index_ger/","title":"5. MVVM","text":""},{"location":"labor/5-mvvm/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>In dieser \u00dcbung werden wir eine Rezept-Browser-Anwendung unter Verwendung des MVVM-Entwurfsmusters erstellen.</p>"},{"location":"labor/5-mvvm/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Durchf\u00fchrung des Labors ben\u00f6tigten Werkzeuge:</p> <ul> <li>Betriebssystem Windows 10 oder Windows 11 (Linux und macOS nicht geeignet)</li> <li>Visual Studio 2022<ul> <li>Windows Desktop Development Workload</li> </ul> </li> </ul>"},{"location":"labor/5-mvvm/index_ger/#ursprungliches-projekt","title":"Urspr\u00fcngliches Projekt","text":"<p>Klonen Sie das urspr\u00fcngliche Projekt mit dem folgenden Befehl:</p> <pre><code>git clone https://github.com/bmeviauab00/lab-mvvm-kiindulo\n</code></pre> Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist [auf GitHub] (https://github.com/bmeviauab00/lab-mvvm-kiindulo) im <code>solve</code>-Zweig verf\u00fcgbar. Der einfachste Weg, es herunterzuladen, ist, den <code>git clone</code>-Zweig von der Kommandozeile aus zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-mvvm-kiindulo -b solved</code></p>"},{"location":"labor/5-mvvm/index_ger/#uber-das-mvvm-muster","title":"\u00dcber das MVVM-Muster","text":"<p>Das MVVM (Model-View-ViewModel) ist ein Architekturentwurfsmuster, das bei der Entwicklung von XAML-Anwendungen eingesetzt werden kann, aber auch h\u00e4ufig in anderen clientseitigen Technologien verwendet wird. Das MVVM-Muster wurde entwickelt, um die Benutzeroberfl\u00e4che und die zugrunde liegende Logik zu entkoppeln und so eine lose gekoppelte Anwendung zu schaffen, die die Testbarkeit, Wartbarkeit und Wiederverwendbarkeit erh\u00f6ht.</p> <p>Das MVVM-Muster besteht aus drei (+1) Hauptteilen:</p> <ul> <li>Modell: Enth\u00e4lt das Gesch\u00e4ftsmodell/Dom\u00e4nenmodell der Anwendung, das ViewModels zum Speichern von Daten verwenden k\u00f6nnen.</li> <li>View (Ansicht): Sie enth\u00e4lt eine Beschreibung der Benutzeroberfl\u00e4che und der rein auf die Ansichten bezogenen Logik (z.B.: Behandlung von Animationen).</li> <li>ViewModel (Ansichtsmodell): Eine Abstraktion der Ansicht, die den Zustand der Ansicht und die Operationen enth\u00e4lt, die mit der Ansicht durchgef\u00fchrt werden k\u00f6nnen, unabh\u00e4ngig von der Ansicht. Die lose Kopplung zwischen dem ViewModel und dem View wird durch die Datenverbindung gew\u00e4hrleistet.</li> <li>Services (Dienstleistungen): Klassen, die die Gesch\u00e4ftslogik der Anwendung enthalten und von ViewModels verwendet werden. W\u00e4re die gesamte Gesch\u00e4ftslogik in ViewModels enthalten, w\u00e4ren diese zu komplex und undurchsichtig. Dies ist nicht Teil des MVVM-Musters, aber wir erw\u00e4hnen es hier, weil wir die Anwendungsarchitektur auf diese Weise nutzen werden.</li> </ul> <p>Neu:</p> <ul> <li>Modell: Erfasst dom\u00e4nenspezifische Daten, die ViewModels zum Speichern von Daten verwenden k\u00f6nnen. Z.B. die Klasse Recipe/Product/Order, die die Daten eines Rezepts/Produkts/Bestellung zusammenfasst.</li> <li>View (Ansicht): Sie enth\u00e4lt eine Beschreibung der Benutzeroberfl\u00e4che (und der rein auf die Ansichten bezogenen Logik, z. B. die Behandlung von Animationen). Typischerweise eine von Window, Page, UserControl abgeleitete Klasse, mit einer deklarativen Beschreibung in XAML, der Code-Behind ist oft leer (weil die Logik im ViewModel ist).</li> <li>ViewModel (Ansichtsmodell): Sie enth\u00e4lt die Logik f\u00fcr die Ansicht: Sie enth\u00e4lt den Zustand der Ansicht und die Operationen, die mit der Ansicht durchgef\u00fchrt werden k\u00f6nnen. Sie ist unabh\u00e4ngig von der Ansicht, wird eine lose Kopplung zwischen dem ViewModel und der Ansicht durch Datenverbindung erreicht (die Steuerelemente der Ansicht binden an die Eigenschaften des ViewModels). Einheitlich testbar (unit test)!</li> <li>Services (Dienstleistungen): Klassen, die die Gesch\u00e4fts-/Anwendungslogik enthalten und von ViewModels verwendet werden. W\u00e4re die gesamte Gesch\u00e4ftslogik in ViewModels enthalten, w\u00e4ren diese zu komplex und undurchsichtig. Dies ist nicht Teil des MVVM-Musters, aber wir erw\u00e4hnen es hier, weil wir auf diese Weise die Architektur der Anwendung aufbauen werden.</li> </ul> <p></p> <p> Wozu erstellen wir ViewModel-Klassen?</p> <ul> <li>Wir erstellen immer eine ViewModel-Klasse f\u00fcr jede Ansicht (z.B. Window, Page, Dialog, UserControl) und erzeugen daraus je ein Objekt f\u00fcr jede Ansicht.  Z.B. MainPage f\u00fcr MainPageViewModel, DancerDialog f\u00fcr DancerDialogViewModel. Wir wenden dies in der Praxis an.</li> <li>F\u00fcr jede Modellklasse (z.B. Recipe, Product, Dancer  usw.) k\u00f6nnen Sie optional Wrapper-ViewModel-Klassen erstellen (z.B. RecipeViewModel, ProductViewModel, DancerViewModel), aber wir werden sie in dieser \u00dcbung nicht erstellen. Das liegt daran, dass wir nicht dem Strict MVVM-Muster folgen, sondern dem Relaxed MVVM-Muster (siehe Vorlesung).</li> </ul>"},{"location":"labor/5-mvvm/index_ger/#aufgabe-0-projektstruktur","title":"Aufgabe 0. - Projektstruktur","text":"<p>Der Anwendungsrahmen ist bereits vorbereitet. Schauen wir uns die Projektstruktur an.</p> <p><code>MvvmLab</code> ist ein Projekt f\u00fcr eine ausf\u00fchrbare Anwendung, die das WinUI-Framework in seiner Anzeigeschicht mit der bereits erlernten XAML-Sprache verwendet. Das Projekt <code>MvvmLab.Core</code> (Klassenbibliothek) enth\u00e4lt die vollst\u00e4ndig ansichtsunabh\u00e4ngige Gesch\u00e4ftslogik.</p> <p>Was ist f\u00fcr uns in der Anfangsphase des Projekts wichtig?</p> <ul> <li><code>App.xaml.cs</code>: Ein Anwendungseintrittspunkt, der die in modernen .NET-Anwendungen verwendeten Muster Host Builder und Dependency Injection verwendet. Dies ist nicht das Thema dieses Semesters, aber die Injektion von Abh\u00e4ngigkeit wird im Labor behandelt werden.</li> <li><code>Views</code>-Ordner: Enth\u00e4lt Ansichten der Anwendung, derzeit <code>MainPage</code></li> <li><code>ViewModels</code>-Ordner: Enth\u00e4lt die ViewModels der Anwendung, derzeit <code>MainPageViewModel</code></li> <li><code>INagivationService</code> ( im Ordner <code>Services</code> ): Dienst f\u00fcr die Navigation zwischen Seiten</li> </ul> <p>MVVM und Boilerplate-Bibliotheken</p> <p>MVVM-Muster wird selten allein auf der Grundlage des .NET-Frameworks implementiert. Es lohnt sich, einige MVVM-Bibliotheken zu verwenden, die Ihren Code kompakter und \u00fcbersichtlicher machen und weniger Boilerplate-Code enthalten. Die am h\u00e4ufigsten verwendeten Bibliotheken sind:</p> <ul> <li>MVVM Toolkit: MVVM-Bibliothek, die von Microsoft gepflegt wird</li> <li>[Prism] (https://prismlibrary.com/): Fr\u00fcher wurde es von Microsoft gewartet und war sehr weit verbreitet, aber jetzt wird es von externen Entwicklern gewartet und ist mit der Zeit kostenpflichtig geworden.</li> <li>ReactiveUI: Es verwendet die Reactive Extensions (Rx)-Bibliotheken, um den Zustand des ViewModels zu verwalten und Daten zwischen der Ansicht und dem ViewModel zu binden. Diese Bibliothek bietet die meisten Dienste, ist aber auch am schwierigsten zu erlernen.</li> <li>Uno.Extensions: Es basiert auf dem MVVM-Toolkit, enth\u00e4lt aber auch mehrere Funktionen, die M\u00e4ngel im WinUI-Framework ausf\u00fcllen.</li> </ul> <p>W\u00e4hrend des Praktikums werden wir das MVVM-Toolkit von Microsoft verwenden.</p> <p>Das urspr\u00fcngliche Projekt wurde mit dem Visual Studio Add-on Windows Template Studio erstellt.</p>"},{"location":"labor/5-mvvm/index_ger/#aufgabe-1-rezepte-hauptseite","title":"Aufgabe 1. - Rezepte Hauptseite","text":"<p>Die L\u00f6sung werden wir \"von unten\" aufbauen, von den Daten ausgehend werden wir schrittweise zur Ansicht. Die Entwicklung von oben nach unten ist zwar in der Praxis oft n\u00fctzlicher, aber aufgrund der zeitlichen Beschr\u00e4nkungen im Labor ist die Entwicklung von unten nach oben schneller und einfacher, weil man die Daten so nicht mocken muss. Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die wichtigsten Klassen, die mit der Hauptseite verbunden sind.</p> <p> MMVM-basierte Implementierung der Homepage <p>Schl\u00fcsselelemente:</p> <ul> <li><code>MainPage</code>: Diese Ansicht, ein Nachkomme der Seite, ist eine XAML-basierte Beschreibung der Benutzeroberfl\u00e4che.</li> <li><code>MainPageViewModel</code>: das ViewModel f\u00fcr die Hauptseite (<code>MainPage</code>). Es enth\u00e4lt Rezeptgruppen in einer (generierten) <code>RecipeGroups</code> Eigenschaft, und Rezepte in den Rezeptgruppen. Diese Ansicht zeigt die Kopfzeile der Rezeptgruppen sowie die Kopfzeile und die Bilder der Rezepte in den Gruppen mit Datenverbindung.</li> <li><code>RecipeGroup</code> und <code>Recipe</code>: Modellklassen f\u00fcr Rezeptgruppen und Rezepte.</li> <li><code>RecipeService</code>: Anwendungslogik/Datenzugriff zur Verwaltung von Rezepten (kommuniziert mit einem entfernten Dienst) unter Verwendung von ViewModel.</li> </ul>"},{"location":"labor/5-mvvm/index_ger/#11-datenzugangsdienst","title":"1.1 Datenzugangsdienst","text":"<p>Beginnen wir mit der Datenzugriffsschicht, die nun als Modellschicht im MVVM-Muster betrachtet werden kann.</p> <p>Unsere Anwendung ruft Daten von einem Webserver ab (\u00fcber die sogenannte REST-API, HTTP). Client-Server-Architekturen wie diese sind eine sehr verbreitete L\u00f6sung in der modernen Anwendungsentwicklung. Dies wird im n\u00e4chsten Semester in Mobile und Web Software, und Data Driven Applications ausf\u00fchrlicher behandelt. F\u00fcr den Moment gen\u00fcgt es zu wissen, dass unsere Client-Anwendung HTTP-Anfragen an den Server sendet, der mit der R\u00fcckgabe von Daten im JSON-Format antwortet.</p> <p> Client-Server-Architektur <p>Der Ferndienst ist verf\u00fcgbar unter: https://bmecookbook2.azurewebsites.net/api. Der Dienst umfasst eine OpenApi-basierte Dokumentation \u00fcber die https://bmecookbook2.azurewebsites.net/swagger am. Schauen wir uns dies an oder probieren wir die Endpunkte auch \u00fcber die Oberfl\u00e4che von Swagger aus (indem man die URL mit der Endung \"swagger\" in die Adresszeile eines Browsers eingibt). F\u00fcr die erste Aufgabe werden wir den Endpunkt <code>/api/Recipes/Groups</code> verwenden, der die Gruppierung von Rezepten zur\u00fcckgibt.</p> <p>F\u00fcgen wir eine neue Klasse namens <code>RecipeGroup</code> in den Ordner <code>Models</code> des Projekts <code>MvvmLab.Core</code> ein.</p> <p>Rufen wir mit Swagger den Endpunkt \"api/Recipes/Groups\" auf (genauer gesagt, senden wir eine HTTP-GET-Anfrage)</p> <ul> <li>\u00d6ffnen wir in der Swagger-Oberfl\u00e4che die Beschreibung des Endpunktes \"Get api/Recipes/Groups\".</li> <li>Klicken wir auf die Taste Execute.</li> <li>Die vom Dienst gesendete JSON-Antwort wird unter \"Response body\" angezeigt: Hier sehen wir, dass die Antwort Rezeptgruppen enth\u00e4lt. Jede Gruppe hat einen \"Titel\" (z.B. Chinese, Mexican, Italian), und unter jeder Gruppe finden wir zwischen <code>[]</code> (JSON-Array) die Daten der Rezepte in der Gruppe. </li> <li> <p>Kopieren wir die JSON-Daten von <code>RecipeGroup</code> in die Zwischenablage. Wir k\u00f6nnen auch die Ausgabe unter \"Example Value\" verwenden, wenn wir sie in die Zwischenablage kopieren (kopieren wir jedoch nicht die \u00f6ffnenden [ und schlie\u00dfenden ] Schriftzeichen). Wenn wir aus irgendeinem Grund nicht weiterkommen k\u00f6nnen, k\u00f6nnen wir den Inhalt auch aus das folgende Dropdown-Men\u00fc in die Zwischenablage kopieren:</p> In die Zwischenablage zu kopieren <pre><code>{\n    \"Title\": \"string\",\n    \"Recipes\": [\n        {\n            \"Id\": 0,\n            \"Title\": \"string\",\n            \"BackgroundImage\": \"string\"\n        }\n    ]\n}\n</code></pre> </li> </ul> <p>In Visual Studio w\u00e4hlen wir im Men\u00fc <code>Edit</code> / <code>Paste Special</code> / <code>Paste JSON as Classes</code> aus, um den Inhalt der Zwischenablage einf\u00fcgen. VS generiert dann Klassen, die der Struktur des von uns eingef\u00fcgten JSON entsprechen.</p> <p></p> <p>Die entstehenden Klassen k\u00f6nnen umbenannt werden, um den C#-Codierungskonventionen zu entsprechen. Benennen wir die Klasse <code>Rootobject</code> in <code>RecipeGroup</code> und die Klasse <code>Recipe</code> in <code>RecipeHeader</code> um.</p> <pre><code>public class RecipeGroup\n{\n    public string Title { get; set; }\n    public RecipeHeader[] Recipes { get; set; }\n}\n\npublic class RecipeHeader\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string BackgroundImage { get; set; }\n}\n</code></pre> <p> Verwenden von <code>List&lt;T&gt;</code> </p> <p>In unserem Fall war es nicht notwendig (weil wir die Rezeptgruppen nicht erweitern), aber wenn es bequemer f\u00fcr uns ist, k\u00f6nnen wir die Bl\u00f6cke in den generierten Code im  <code>List&lt;T&gt;</code> umwandeln.</p> <p>Erstellen wir eine Schnittstelle <code>IRecipeService</code> zum Namespace <code>MvvmLab.Core.Services</code>, \u00fcber die auf den Remote-Dienst zugegriffen werden soll. In der Schnittstelle erstellen wir eine Methode <code>GetRecipeGroupsAsync</code>, die die Rezeptgruppen abfragt und zur\u00fcckgibt.</p> <pre><code>public interface IRecipeService\n{\n    public Task&lt;RecipeGroup[]&gt; GetRecipeGroupsAsync();\n}\n</code></pre> <p>Task-R\u00fcckgabewert</p> <p>In der Schnittstelle ist der eigentliche R\u00fcckgabewert (<code>RecipeGroup[]</code>) in ein Objekt <code>Task&lt;T&gt;</code> verpackt, da es vorzuziehen ist, Netzwerkoperationen asynchron zu implementieren. In .NET ist die modernste und einfachste Art, Asynchronit\u00e4t zu implementieren, die Verwendung von <code>Task</code>s. Und die Asynchronit\u00e4t sorgt daf\u00fcr, dass die Benutzeroberfl\u00e4che nicht einfriert, wenn die Netzwerkanforderung lange dauert (und das alles, ohne separate Threads zu starten).</p> <p>Die Implementierung der Schnittstelle wird im Namespace <code>MvvmLab.Core.Services</code> unter <code>RecipeService</code> erstellt. Unser Dienst wird die integrierte .NET-Klasse <code>HttpClient</code> f\u00fcr REST-API-Aufrufe verwenden.  <code>GetFromJsonAsync</code> stellt eine asynchrone HTTP GET-Anfrage an die angegebene Adresse und deserialisiert die Antwort von JSON in den angegebenen Typ.</p> <pre><code>public class RecipeService : IRecipeService\n{\n    private readonly string _baseUrl = \"https://bmecookbook2.azurewebsites.net/api\";\n\n    public async Task&lt;RecipeGroup[]&gt; GetRecipeGroupsAsync()\n    {\n        using var client = new HttpClient();\n        return await client.GetFromJsonAsync&lt;RecipeGroup[]&gt;($\"{_baseUrl}/Recipes/Groups\");\n    }\n}\n</code></pre> <p>Die Operation <code>GetFromJsonAsync</code> ist asynchron, sie gibt also <code>Task</code> zur\u00fcck, wir k\u00f6nnen dies nicht blockierend erwarten und mit dem Schl\u00fcsselwort <code>await</code> auf das Ergebnis zugreifen.</p> <p>async-await</p> <p>Die Schl\u00fcsselw\u00f6rter <code>async</code> und <code>await</code> werden in den meisten modernen Sprachen verwendet, um asynchrone Funktionsaufrufe auf Sprachebene zu behandeln. Wir werden am Ende des Semesters mehr dar\u00fcber sprechen, wie es funktioniert, aber bis dahin m\u00fcssen Sie Folgendes wissen, um es zu nutzen:</p> <ul> <li>Mit dem Schl\u00fcsselwort <code>await</code> k\u00f6nnen wir auf eine asynchrone Ausf\u00fchrung warten, ohne den Aufrufer zu blockieren.</li> <li>Das Schl\u00fcsselwort <code>await</code> kann nur in Funktionen mit dem Schl\u00fcsselwort <code>async</code> verwendet werden.</li> <li><code>async</code>-Funktionen k\u00f6nnen nur den R\u00fcckgabewert <code>Task</code> oder <code>Task&lt;T&gt;</code> oder <code>void</code> haben. (Oder \"Task-\u00e4hnlich\", aber das nehmen wir hier nicht.)<ul> <li>Wenn man eine <code>async</code>-Funktion von au\u00dfen abwarten will, kann man das nicht mit void tun, sondern man muss einen R\u00fcckgabewert von <code>Task</code> oder <code>Task&lt;T&gt;</code> haben.</li> <li>In <code>async</code>-Funktionen wird die Syntax der <code>return</code>-Anweisung ge\u00e4ndert: es muss nicht das Task-Objekt zur\u00fcckgegeben werden, sondern die darin enthaltenen Daten (<code>void</code> f\u00fcr <code>Task</code>, <code>Task&lt;T&gt;</code> f\u00fcr <code>T</code>).</li> </ul> </li> </ul>"},{"location":"labor/5-mvvm/index_ger/#12-startseite-viewmodel","title":"1.2 Startseite ViewModel","text":"<p>Im n\u00e4chsten Schritt erstellen wir das ViewModel der Hauptseite, das den soeben erstellten Dienst verwendet, um die Rezeptgruppen abzurufen und sie als Status f\u00fcr die Ansicht zu speichern.</p>"},{"location":"labor/5-mvvm/index_ger/#dependency-injection","title":"Dependency Injection\u00b6","text":"<p>\u00d6ffnen wir die Klasse <code>MainPageViewModel</code> aus dem Ordner <code>MvvmLab.ViewModels</code>.  Unser ViewModel ben\u00f6tigt eine Klasse, die die Schnittstelle <code>IRecipeService</code> implementiert, \u00fcber die es die Rezeptgruppen abfragen kann. Im <code>MainPageViewModel</code> Konstruktor erhalten wir die erforderliche Abh\u00e4ngigkeit \u00fcber Dependency Injection. In unserem Fall bedeutet dies, dass wir einen Parameter vom Typ <code>IRecipeService</code> erwarten, der vom ViewModel empfangen wird, wenn es instanziiert wird, und der Parameter wird in einer privaten Variablen gespeichert.</p> <pre><code>private readonly IRecipeService _recipeService;\n\npublic MainPageViewModel(IRecipeService recipeService)\n{\n    _recipeService = recipeService;\n}\n</code></pre> Dependency Injection - DI <p>Standardm\u00e4\u00dfig sind Klassen eng mit ihren Abh\u00e4ngigkeiten gekoppelt (Referenz, Instanziierung). </p> <p> Starke Kopplung ohne DI </p> <p>Diese enge Kopplung erschwert die Pr\u00fcfung, Wartung und Wiederverwendung. Dies wird durch den Einsatz von Dependency Injection (und Strategy) unterst\u00fctzt. In diesem Kurs lernen wir das Dependency Injection (DI) Entwurfmuster kennen, das immer in Verbindung mit dem Strategy-Muster verwendet wird. Die Idee ist, dass eine Klasse ihre Abh\u00e4ngigkeiten (die Klassen, von denen sie abh\u00e4ngt und die sie verwendet) nicht selbst erzeugt, sondern sie von au\u00dfen erh\u00e4lt, z.B. in einem Konstruktorparameter. Das Strategy-Muster impliziert, dass sie nur als \"Schnittstelle\" von ihnen abh\u00e4ngt. </p> <p>Die meisten Plattformen bieten heute auch einen zus\u00e4tzlichen Dienst, einen so genannten DI-Container (auch IoC-Container genannt),  zur bequemen Verwaltung von Abh\u00e4ngigkeiten.  Der Lebenszyklus von Abh\u00e4ngigkeiten wird dann von einer speziellen Komponente, dem DI-Container, verwaltet. Der DI-Container (dargestellt als Builder) ist f\u00fcr die Instanziierung von Klassen und die rekursive Injektion von Abh\u00e4ngigkeiten zust\u00e4ndig.</p> <p> DI-Klassendiagramm </p> <p>Um die entsprechenden Implementierungen zu injektieren, w\u00e4hrend des Durchlaufens der Abh\u00e4ngigkeitsgraph w\u00e4hrend der Instanziierung, m\u00fcssen die Abh\u00e4ngigkeitszuordnungen im DI-Container registriert werden. In unserer Anwendung tun wir dies in der Datei <code>App.xaml.cs</code> in der Methode <code>ConfigureServices</code>.  F\u00fcgen wir die folgende Zeile hinzu, z.B. unter dem Abschnitt <code>// Core Services</code>: </p> <pre><code>services.AddTransient&lt;IRecipeService, RecipeService&gt;();\n</code></pre> <p>Dies sagt uns, dass das DI-Framework eine <code>RecipeService</code>-Implementierung injektiert, wenn eine Klasse eine <code>IRecipeService</code>-Abh\u00e4ngigkeit erwartet (z.B. den Konstruktor von <code>MainPageViewModel</code>). (Da wir sie hier als Transient Lifetime registriert haben, wird jede <code>IRecipeService</code>-Abh\u00e4ngigkeitsanforderung durch eine neue <code>RecipeService</code>-Instanz erf\u00fcllt).</p> <p>Damit Dependency Injection in unserer Anwendung funktioniert, muss die Klasse <code>MainPageViewModel</code> auch im Container registriert sein, der ebenfalls unter <code>ConfigureServices</code> zu finden ist.</p> <p>\u00dcber DI-Container im Detail</p> <p>Die Verwendung und Funktionsweise von DI-Containern wird sp\u00e4ter im Kurs Datengesteuerte Systeme ausf\u00fchrlich behandelt.</p>"},{"location":"labor/5-mvvm/index_ger/#viewmodel-status","title":"ViewModel-Status","text":"<p>Im n\u00e4chsten Schritt werden wir das Hochladen des ViewModel-Status implementieren.</p> <p>Unser Ziel ist, dass</p> <ul> <li><code>MainPageViewModel</code> hat eine Eigenschaft namens <code>RecipeGroups</code>, die Rezeptgruppen enth\u00e4lt (wir wollen diese an die Oberfl\u00e4che binden),</li> <li>die \u00c4nderungen von <code>RecipeGroups</code> von der Schnittstelle verfolgt werden, was die Implementierung von <code>INotifyPropertyChanged</code> und das korrekte Ausl\u00f6sen von <code>PropertyChanged</code> erfordert (wie wir bereits in der vorherigen \u00dcbung/Hausaufgabe gesehen haben).</li> </ul> <p>Dies w\u00fcrde relativ \"viel\" Arbeit erfordern, aber das MVVM-Toolkit vereinfacht unser Leben, denn wir m\u00fcssen nur das Folgendes tun:</p> <ul> <li>Erstellen wir in <code>MainPageViewModel</code> eine <code>RecipeGroup[]</code> Member-Variable (keine Eigenschaft) mit dem Namen <code>_recipeGroups</code>. </li> <li>Die Variable wird mit dem Attribut <code>ObservableProperty</code> versehen. </li> </ul> <pre><code>[ObservableProperty]\nprivate RecipeGroup[] _recipeGroups = Array.Empty&lt;RecipeGroup&gt;();\n</code></pre> <p>Hier sind wir nun. Aber was passiert dann?</p> <ul> <li>Auf dieser Grundlage erzeugt MVVM Toolkit automatisch eine Eigenschaft namens <code>RecipeGroups</code> in der generierten (partiellen) H\u00e4lfte der Klasse.</li> <li>Diese generierte Eigenschaft nutzt die Vorteile der Schnittstelle <code>INotifyPropertyChanged</code>. Wenn sich der Wert der Eigenschaft <code>RecipeGroups</code> \u00e4ndert, wird das Ereignis <code>PropertyChanged</code> ausgel\u00f6st, um die Ansicht entlang der Datenverbindungen zu benachrichtigen.</li> <li>Unser <code>MainPageViewModel</code> implementiert bereits die Schnittstelle <code>INotifyPropertyChanged</code>, da es von der Klasse <code>ObservableObject</code> des MVVM-Toolkits stammt.</li> </ul> <p>In <code>MainPageViewModel</code> implementieren wir die vorbereitete Schnittstelle <code>INavigationAware</code>, die es uns erm\u00f6glicht, das Navigations-Lebenszyklus-Ereignis zwischen Ansichten zu handhaben und sogar Daten zwischen ViewModels zu \u00fcbergeben. In der Methode <code>OnNavigatedTo</code> werden die Rezeptgruppen \u00fcber <code>IRecipeService</code> abgefragt und in der Variablen <code>RecipeGroups</code> gespeichert.</p> <pre><code>public partial class MainPageViewModel : ObservableObject, INavigationAware\n{\n    // ...\n\n    public async void OnNavigatedTo(object parameter)\n    {\n        RecipeGroups = await _recipeService.GetRecipeGroupsAsync();\n    }\n\n    public void OnNavigatedFrom()\n    {\n    }\n}\n</code></pre>"},{"location":"labor/5-mvvm/index_ger/#13-ansicht-der-hauptseite","title":"1.3 Ansicht der Hauptseite","text":"<p>Erstellen wir die Ansicht auf <code>MainPage</code>, in der die Rezeptgruppen angezeigt werden.</p> <p>Damit <code>GridView</code> die Gruppierung behandeln kann, brauchen wir eine Liste, die die Gruppierung vornimmt. Wir k\u00f6nnen dies mit der Klasse <code>CollectionViewSource</code> tun, die in gewisser Weise UI-spezifische Wrapping-Aufgaben f\u00fcr Sammlungen \u00fcbernimmt. <code>CollectionViewSource</code> muss die zu gruppierenden Elemente und die Eigenschaft, auf der die Gruppen basieren, angegeben werden. Wir m\u00fcssen auch die Eigenschaft angeben, auf der die Elemente innerhalb der Gruppen angezeigt werden sollen.</p> <p>Erstellen wir die Instanz <code>CollectionViewSource</code> in den Ressourcen der Seite (f\u00fcgen wir den Code unten in <code>MainPage.xaml</code> ein, oberhalb des Grids, auf der gleichen Ebene wo es liegt).</p> <pre><code>&lt;Page.Resources&gt;\n    &lt;CollectionViewSource x:Name=\"RecipeGroupsCollectionSource\"\n                            IsSourceGrouped=\"True\"\n                            ItemsPath=\"Recipes\"\n                            Source=\"{x:Bind ViewModel.RecipeGroups, Mode=OneWay}\" /&gt;\n&lt;/Page.Resources&gt;\n</code></pre> <p>Note</p> <p>Beachten Sie, dass wir in der Datenverbindung an die Eigenschaft <code>ViewModel</code> binden, die sich in <code>MainPage.xaml.cs</code> befindet, und einfach die Eigenschaft <code>DataContext</code> an unseren ViewModel-Typ \u00fcbergeben.</p> <pre><code>public MainPageViewModel ViewModel =&gt; DataContext as MainPageViewModel;\n</code></pre> <p>Die Speicherung des ViewModels in der Eigenschaft <code>DataContext</code> der Steuerelemente (Seiten) ist typisch f\u00fcr das MVVM-Muster. In unserem Fall \u00fcbernimmt die Klasse \"NavigationService\" des generierten Projekts diese Aufgabe f\u00fcr uns.</p> Ressourcen <p>In der XAML-Umgebung hat jedes Steuerelement (im obigen Beispiel die Seite) und die Klasse <code>Application</code> standardm\u00e4\u00dfig eine Eigenschaft <code>Resources</code>, die ein Schl\u00fcssel-Wert-Speicher ist (<code>Dictionary&lt;string, object&gt;</code>). Sie k\u00f6nnen wiederverwendbare Objekte einf\u00fcgen, sogar auf der Anwendungsebene. Wenn Sie bei der Instanziierung von Ressourcen das Attribut <code>x:Key</code> angeben, k\u00f6nnen Sie Ressourcen nach Schl\u00fcsseln abfragen, z.B. mit der Markup-Erweiterung <code>{StaticResource Key}</code>. </p> <p>Aber hier haben wir explizit <code>x:Name</code> anstelle von <code>x:Key</code> angegeben, weil wir uns in <code>x:Bind</code> auf den Namen beziehen wollen (zur Erinnerung: das Attribut <code>x:Name</code> wird verwendet, um eine Mitgliedsvariable in unserer Klasse mit diesem Namen zu erzeugen, so dass wir sie aus dem code behind Datei oder w\u00e4hrend der Verwendung von x:Bind Datenverbindung, mit diesem Namen erreichen k\u00f6nnen).</p> <p>F\u00fcr die Auflistung der Rezepte verwenden wir nun ein spezielles, von <code>GridView</code> abgeleitetes Steuerelement, n\u00e4mlich <code>AdaptiveGridView</code>aus dem CommunityToolkit-Paket, das die Anzahl und Gr\u00f6\u00dfe der angezeigten Elemente in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe der Ansicht \u00e4ndert und die Benutzung von Commands f\u00fcr Elementklicks unterst\u00fctzt. Um auf externe Steuerelemente zu verweisen, f\u00fcgen wir zu der Seite den folgenden Namespace hinzu:</p> <pre><code>xmlns:controls=\"using:CommunityToolkit.WinUI.UI.Controls\"\n</code></pre> <p>Erstellen wir die GridView mit der Eigenschaft <code>ItemsSource</code>, die in der obigen Ressource an <code>RecipeGroupsCollectionSource.View</code> gebunden ist.</p> <p>Innerhalb von <code>GridView</code> k\u00f6nnen wir wie gewohnt \u00fcber die Eigenschaft <code>ItemTemplate</code> festlegen, wie jedes Element angezeigt werden soll. In unserem Fall haben wir ein Bild und einen Text, der auf dem Titel des Rezepts basiert, in ein \"karten\u00e4hnliches\" Layout gesetzt.</p> <p>Und \u00fcber die Eigenschaft <code>GroupStyle</code> k\u00f6nnen wir festlegen, wie die Gruppen angezeigt werden sollen. In diesem Fall wollen wir die Kopfzeile anpassen.</p> <p>Ersetzen wir in <code>MainPage.xaml</code> das Gitter <code>&lt;Grid x:Name=\"ContentArea\"&gt; ...</code> durch das folgende:</p> <pre><code>&lt;Grid x:Name=\"ContentArea\" Padding=\"10\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"Auto\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n\n    &lt;TextBlock Text=\"Recipes\"\n               Grid.Row=\"0\"\n               Style=\"{StaticResource TitleLargeTextBlockStyle}\" /&gt;\n\n    &lt;controls:AdaptiveGridView Grid.Row=\"1\"\n                               DesiredWidth=\"180\"\n                               IsItemClickEnabled=\"True\"\n                               ItemHeight=\"160\"\n                               ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                               SelectionMode=\"None\"\n                               StretchContentForSingleRow=\"False\"&gt;\n        &lt;GridView.ItemTemplate&gt;\n            &lt;DataTemplate x:DataType=\"models:RecipeHeader\"&gt;\n                &lt;Grid MaxWidth=\"300\"&gt;\n                    &lt;Image Source=\"{x:Bind BackgroundImage}\" /&gt;\n                    &lt;Border Height=\"40\"\n                            Padding=\"10,0,0,0\"\n                            VerticalAlignment=\"Bottom\"\n                            Background=\"#88000000\"&gt;\n                        &lt;TextBlock VerticalAlignment=\"Center\"\n                                   Foreground=\"White\"\n                                   Text=\"{x:Bind Title}\" /&gt;\n                    &lt;/Border&gt;\n                &lt;/Grid&gt;\n            &lt;/DataTemplate&gt;\n        &lt;/GridView.ItemTemplate&gt;\n        &lt;GridView.GroupStyle&gt;\n            &lt;GroupStyle&gt;\n                &lt;GroupStyle.HeaderTemplate&gt;\n                    &lt;DataTemplate x:DataType=\"models:RecipeGroup\"&gt;\n                        &lt;TextBlock Margin=\"0\"\n                                   Style=\"{ThemeResource TitleTextBlockStyle}\"\n                                   Text=\"{x:Bind Title}\" /&gt;\n                    &lt;/DataTemplate&gt;\n                &lt;/GroupStyle.HeaderTemplate&gt;\n            &lt;/GroupStyle&gt;\n        &lt;/GridView.GroupStyle&gt;\n    &lt;/controls:AdaptiveGridView&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Nehmen wir den folgenden Namespace (hier befinden sich unsere Modellklassen) auf:</p> <pre><code>`xmlns:models=\"using:MvvmLab.Core.Models\"`\n</code></pre> <p>Probieren wir die App aus! Achten Sie darauf, dass die Rezeptgruppen auf der Hauptseite erscheinen.</p>"},{"location":"labor/5-mvvm/index_ger/#aufgabe-2-rezept-detailseite","title":"Aufgabe 2. - Rezept-Detailseite","text":"<p>Die Erstellung der detaillierten Rezeptseite erfolgt in folgenden Schritten:</p> <ol> <li>F\u00fcgen wir der Schnittstelle <code>IRecipeService</code> eine Methode <code>GetRecipeAsync</code> hinzu und erstellen wir die erforderlichen Klassen</li> <li>Erstellen wir ein Ansichtsmodell <code>RecipeDetailPageViewModel</code>, in dem wir die Rezeptdaten in <code>RecipeDetailPageViewModel</code> \u00fcber <code>IRecipeService</code> abfragen (die VM erh\u00e4lt die ID bei der Navigation)</li> <li>Erstellen wir die Ansicht <code>RecipeDetailPage</code>, die auf den Daten des ViewModel aufbaut</li> <li>Registrieren wir das ViewModel und View f\u00fcr Dependency Injection Konfiguration und Navigation</li> <li>Navigieren wir von <code>MainPageViewModel</code> zu <code>RecipeDetailPage</code> durch <code>INavigationService</code>, falls es auf das Rezept angeklickt wird und die ID des ausgew\u00e4hlten Rezepts wird an die Detailseite \u00fcbergegeben</li> </ol>"},{"location":"labor/5-mvvm/index_ger/#21-abfrage-eines-rezepts","title":"2.1 Abfrage eines Rezepts","text":"<p>Erstellen wir die Klasse <code>Recipe</code> im Namensraum <code>MvvmLab.Core.Model</code> und generieren wir ihren Inhalt aus den JSON-Beispieldaten, die vom Endpunkt <code>/api/recipes/{id}</code> zur\u00fcckgegeben werden, unter Verwendung der oben beschriebenen Methode (Paste special).</p> <pre><code>public class Recipe\n{\n    public int Id { get; set; }\n    public string BackgroundImage { get; set; }\n    public string Title { get; set; }\n    public string[] ExtraImages { get; set; }\n    public string[] Ingredients { get; set; }\n    public string Directions { get; set; }\n    public Comment[] Comments { get; set; }\n}\n\npublic class Comment\n{\n    public string Name { get; set; }\n    public string Text { get; set; }\n}\n</code></pre> <p>Warning</p> <p>W\u00e4hrend des \"Paste Special\" ist es wichtig, ein Rezept in die Zwischenablage zu legen, das einen Kommentar enth\u00e4lt (andernfalls wird die Klasse <code>Comment</code> nicht erzeugt, und die Klasse <code>Recipe</code> erzeugt den Typ <code>object[]</code> des Typs <code>Comments</code>). Es lohnt sich, das Beispiel aus dem Feld \"Example value\" der Swagger-Beschreibung in die Zwischenablage zu kopieren!</p> <p>Die Schnittstelle <code>IRecipeService</code> und ihre Implementierung werden mit einer Methode <code>GetRecipeAsync</code> erweitert, die ein Rezept auf der Grundlage seiner Identifizierungsnummer zur\u00fcckgibt.</p> IRecipeService<pre><code>public Task&lt;Recipe&gt; GetRecipeAsync(int id);\n</code></pre> RecipeService<pre><code>public async Task&lt;Recipe&gt; GetRecipeAsync(int id)\n{\n    using var client = new HttpClient();\n    return await client.GetFromJsonAsync&lt;Recipe&gt;($\"{_baseUrl}/Recipes/{id}\");\n}\n</code></pre>"},{"location":"labor/5-mvvm/index_ger/#22-rezept-detailliertes-viewmodel","title":"2.2 Rezept detailliertes ViewModel","text":"<p>Die Erstellung eines ViewModels ist im Vergleich zur Hauptseite eine Finger\u00fcbung (wir k\u00f6nnen grunds\u00e4tzlich auf seinem Muster arbeiten). Erstellen wir die Klasse <code>RecipeDetailPageViewModel</code> im Ordner <code>MvvmLab.ViewModels</code>. </p> <p>Das ViewModel ben\u00f6tigt eine Klasse, die die Schnittstelle <code>IRecipeService</code> implementiert, \u00fcber die es das Rezept abfragen kann. Im <code>RecipeDetailPageViewModel</code> Konstruktor wird DI verwendet, um die notwendige Abh\u00e4ngigkeit zu erhalten.</p> <pre><code>private readonly IRecipeService _recipeService;\n\npublic RecipeDetailPageViewModel(IRecipeService recipeService)\n{\n    _recipeService = recipeService;\n}\n</code></pre> <p>Erstellen wir in <code>RecipeDetailPageViewModel</code> eine Variable des Typs <code>Recipe</code> mit dem Namen <code>_recipe</code>, in der das Rezept gespeichert werden soll. Die Variable wird mit dem Attribut <code>ObservableProperty</code> versehen, wodurch MVVM Toolkit automatisch die Eigenschaft <code>Recipe</code> in der anderen generierten partiellen H\u00e4lfte der Klasse erzeugen kann. Dies setzt voraus, dass die Klasse von der Klasse <code>ObservableObject</code> abgeleitet ist, \u00f6ffentlich ist und das Schl\u00fcsselwort <code>partial</code> enth\u00e4lt.</p> <pre><code>public partial class RecipeDetailPageViewModel : ObservableObject\n{\n    // ...\n\n    [ObservableProperty]\n    private Recipe _recipe = new();\n</code></pre> <p>Implementieren wir die vorbereitete Schnittstelle <code>INavigationAware</code> in <code>RecipeDetailPageViewModel</code>. Wir bereiten uns darauf vor, dass wir  die ID des Rezepts als Navigationsparameter erhalten, das wir anzeigen wollen. In der Methode <code>OnNavigatedTo</code> rufen wir das Rezept \u00fcber <code>RecipeService</code> ab und speichern es in der Eigenschaft <code>Recipe</code>. </p> <pre><code>public partial class RecipeDetailPageViewModel : ObservableObject, INavigationAware\n{\n    // ...\n\n    public async void OnNavigatedTo(object parameter)\n    {\n        Recipe = await _recipeService.GetRecipeAsync((int)parameter);\n    }\n\n    public void OnNavigatedFrom()\n    {\n    }\n}\n</code></pre> <p>Note</p> <p>In der Kopfzeile der Aktion <code>OnNavigatedTo</code> mussten wir das Schl\u00fcsselwort <code>async</code> verwenden, weil wir <code>await</code> in der Wurzel verwendet haben.</p>"},{"location":"labor/5-mvvm/index_ger/#23-rezeptdetailseite-navigation","title":"2.3 Rezeptdetailseite, Navigation","text":"<p>Erstellen wir eine neue Seite mit dem Namen <code>RecipeDetailPage</code> im Ordner <code>Views</code> (Rechtsklick auf den Ordner Views / Add New Item / Blank Page (WinUI 3)), auf der wir das Rezept anzeigen k\u00f6nnen. Zeigen wir zun\u00e4chst nur den Titel des Rezepts in einer <code>TextBlock</code> an.</p> <pre><code>&lt;Grid x:Name=\"ContentArea\"&gt;\n    &lt;Grid.RowDefinitions&gt;\n        &lt;RowDefinition Height=\"48\" /&gt;\n        &lt;RowDefinition Height=\"*\" /&gt;\n    &lt;/Grid.RowDefinitions&gt;\n\n    &lt;TextBlock Grid.Row=\"0\"\n               Style=\"{StaticResource PageTitleStyle}\"\n               Text=\"{x:Bind ViewModel.Recipe.Title, Mode=OneWay}\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>Zu der Datenverbingung f\u00fcgen wir die Eigenschaft <code>ViewModel</code> in <code>RecipeDetailPage.xaml.cs</code> zur Hauptseite hinzu.</p> <pre><code>public RecipeDetailPageViewModel ViewModel =&gt; (RecipeDetailPageViewModel)DataContext;\n</code></pre> <p>\u00dcbersetzungsfehler</p> <p>Wenn Sie aus irgendeinem Grund exotische Fehler erhalten, nachdem Sie eine neue Seite hinzugef\u00fcgt haben, l\u00f6schen Sie die folgenden Zeilen in der Projektdatei:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;None Remove=\"ViewsRecipeDetailPage.xaml\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <pre><code>&lt;Page Update=\"ViewsRecipeDetailPage.xaml\"&gt;\n    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;\n&lt;/Page&gt;\n</code></pre> <p>Um die Navigation zu unterst\u00fctzen, registrieren wir <code>RecipeDetailPage</code> in <code>PageService</code> im Ordner <code>Services</code> in den folgenden 3 Schritten:</p> <ol> <li> <p>Nehmen wir den Ansichtsschl\u00fcssel in die Klasse <code>Pages</code> auf.</p> <pre><code>public static class Pages\n{\n    public static string Main { get; } = \"Main\";\n    public static string Detail { get; } = \"Detail\";\n}\n</code></pre> </li> <li> <p>Registrieren wir die Ansicht und ViewModel-Verbindung in <code>PageService</code>.</p> <pre><code>public PageService()\n{\n    Configure&lt;MainPageViewModel, MainPage&gt;(Pages.Main);\n    Configure&lt;RecipeDetailPageViewModel, RecipeDetailPage&gt;(Pages.Detail);\n}\n</code></pre> </li> <li> <p>In der Datei <code>App.xaml.cs</code> registrieren wir das ViewModel und den View im Dependency Injection Container in der Methode <code>ConfigureServices</code>. </p> <pre><code>services.AddTransient&lt;RecipeDetailPage&gt;();\nservices.AddTransient&lt;RecipeDetailPageViewModel&gt;();\n</code></pre> </li> </ol> <p>Diese werden ben\u00f6tigt, weil die <code>INavigationService</code> in der Projektvorlage die Ansichten grunds\u00e4tzlich mit einem Schl\u00fcssel identifiziert, so dass das ViewModel den Ansichtstyp nicht kennen muss. Und anhand des Schl\u00fcssels kann man genau herausfinden, welche View angezeigt und welches ViewModel in der View <code>DataContext</code> aus dem DI-Container instanziiert werden soll.</p> <p>In das <code>MainPageViewModel</code> injektieren wir den <code>INavigationService</code>, \u00fcber den wir zur <code>RecipeDetailPage</code> navigieren werden.</p> <pre><code>private readonly INavigationService _navigationService;\n\npublic MainPageViewModel(IRecipeService recipeService, INavigationService navigationService)\n{\n    _recipeService = recipeService;\n    _navigationService = navigationService;\n}\n</code></pre>"},{"location":"labor/5-mvvm/index_ger/#command","title":"Command","text":"<p>Bisher haben wir uns mit einem Aspekt des MVVM-Musters besch\u00e4ftigt: wie die View auf die Daten im ViewModel zugreift und diese anzeigt, indem sie Daten bindet. Gleichzeitig besteht in der Regel eine weitere Beziehung zwischen View und ViewModel: Hier geht es darum, wie sich Ereignisse in der View (z.B. Klicks) auf das ViewModel auswirken. Damit werden wir uns jetzt befassen.</p> <p>In unserem Fall m\u00fcssen wir zum Beispiel daf\u00fcr sorgen, dass ein Klick auf ein Rezept in der Hauptseitenansicht zu <code>MainPageViewModel</code> f\u00fchrt und dann zur Detailansicht dieses Rezepts navigiert.</p> <p>Das ViewModel ver\u00f6ffentlicht die ausf\u00fchrbaren Operationen im MVVM-Muster durch Objekte, die typischerweise die Schnittstelle <code>ICommand</code> implementieren (die neben der Ausf\u00fchrung der spezifischen Operation auch die Bedingungen f\u00fcr die Ausf\u00fchrung der Operation verwalten k\u00f6nnen).</p> <p>Erstellen wir unter <code>MainPageViewModel</code> einen Command, der ausgef\u00fchrt wird, wenn wir auf das Rezept klicken. Der Command erh\u00e4lt die Kopfzeile des ausgew\u00e4hlten Rezepts als Parameter und wird an <code>RecipeDetailPage</code> weitergeleitet, wo die ID des ausgew\u00e4hlten Rezepts \u00fcbergeben wird.</p> <p>Jetzt sollten wir eine Klasse erstellen, die die Schnittstelle <code>ICommand</code> implementiert, und dann eine Instanz (Eigenschaft) davon in das ViewModel aufnehmen. Diese beiden Schritte werden durch das MVVM-Toolkit vereinfacht, wir m\u00fcssen nur eine Funktion mit dem Attribut <code>[RelayCommand]</code> zum ViewModel hinzuf\u00fcgen:</p> <pre><code>[RelayCommand]\nprivate void RecipeSelected(RecipeHeader recipe)\n{\n    _navigationService.NavigateTo(Pages.Detail, recipe.Id);\n}\n</code></pre> <p>Dies veranlasst den Compiler, die Commandsklasse und die Eigenschaft im ViewModel als <code>RecipeSelectedCommand</code> zu generieren.</p> <p> Der Befehl und das ViewModel sind vorbereitet, aber die View wei\u00df noch nichts \u00fcber den Befehl. Unser Befehl im ViewModel muss mit den \u00fcblichen Techniken an das entsprechende Ereignis in der View gebunden werden. Verwenden wir f\u00fcr MVVM immer das Command-Muster wie dieses! Das Sch\u00f6ne an diesem Ansatz ist, dass er vollst\u00e4ndig mit der standardm\u00e4\u00dfigen direktionalen Datenverbindung von View-&gt;ViewModel durchgef\u00fchrt wird (die wir bereits mehrfach verwendet haben).</p> <p>Binden wir daher auf <code>MainPage</code> die Eigenschaft <code>AdaptiveGridView</code> <code>ItemClickCommand</code> an <code>RecipeSelectedCommand</code>.</p> <pre><code>ItemClickCommand=\"{x:Bind ViewModel.RecipeSelectedCommand}\"\n</code></pre> <p>Probieren wir die App aus! Klicken wir auf die Rezepte, um die Rezeptdetailseite zu sehen.</p> Ausblick: Gibt es keinen Befehl f\u00fcr das Ereignis, das Sie verwenden m\u00f6chten? <p>Wenn der Controller einen Befehl f\u00fcr bestimmte Ereignisse bereitstellt, ist dies relativ einfach zu bewerkstelligen, wie im obigen Beispiel gezeigt. Wenn das Steuerelement jedoch keinen Befehl bereitstellt (z.B. das eingebaute <code>GridView.ItemClicked</code>), haben wir mehrere M\u00f6glichkeiten:</p> <ol> <li> <p>Code-Behind \"Klebercode\": Behandeln Sie das Ereignis des Controllers und rufen Sie die entsprechende Methode/Befehl des Code-Behind im ViewModel (xaml.cs) auf.</p> <pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"\n                            ItemClick=\"GridView_ItemClick\"&gt;\n</code></pre> <pre><code>private void GridView_ItemClick(object sender, ItemClickEventArgs e)\n{\n    ViewModel.RecipeSelectedCommand.Execute((RecipeHeader)e.ClickedItem);\n}\n</code></pre> </li> <li> <p>x:Bind-Ereignisbindung: Verwenden Sie die Bindungsoption der Methode <code>x:Bind</code>, um das Ereignis des Steuerelements an die Methode im ViewModel zu binden.    Die Methode muss dann entweder parameterlos sein oder einen Parameter annehmen, der der Signatur des Ereignisses entspricht.</p> View - MainPage.xaml<pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"\n                            ItemClick=\"{x:Bind ViewModel.RecipeSelected\"&gt;\n&lt;/controls:AdaptiveGridView&gt;\n</code></pre> ViewModel - MainPageViewModel<pre><code>public void RecipeSelected(object sender, ItemClickEventArgs e)\n{\n   ...\n}\n</code></pre> <p>Der Nachteil dieser Methode ist, dass sie die Framework-Abh\u00e4ngigkeiten des View (Eventhandler-Parametertypen) mit den Ereignisparametern in das ViewModel einf\u00fchrt, obwohl die Idee war, das ViewModel unabh\u00e4ngig von der View zu machen. Nat\u00fcrlich kann diese Methode auch gut funktionieren, wenn wir die strikte Einhaltung des MVVM-Musters teilweise aufgeben.</p> </li> <li> <p>Mit Hilfe von Behavior, ganz konkret <code>EventTriggerBehavior</code> und <code>InvokeCommandAction</code> Klassen, k\u00f6nnen Sie einen Command an ein Ereignis eines beliebigen Steuererelementes binden.</p> <pre><code>&lt;controls:AdaptiveGridView x:Name=\"gridView\"\n                            ItemsSource=\"{x:Bind RecipeGroupsCollectionSource.View, Mode=OneWay}\"\n                            IsItemClickEnabled=\"True\"&gt;\n    &lt;i:Interaction.Behaviors&gt;\n        &lt;c:EventTriggerBehavior EventName=\"ItemClick\"&gt;\n            &lt;c:InvokeCommandAction Command=\"{x:Bind ViewModel.RecipeSelectedCommand}\" \n                                   InputConverter=\"{StaticResource ItemClickedInputConverter}\" /&gt;\n        &lt;/c:EventTriggerBehavior&gt;\n    &lt;/i:Interaction.Behaviors&gt;\n</code></pre> <p>Dies erm\u00f6glicht es uns, die Ansicht fast vollst\u00e4ndig deklarativ zu gestalten, aber wir m\u00fcssen immer noch eine Klasse <code>ItemClickedInputConverter</code> erstellen, die die Ereignisparameter mithilfe der Schnittstelle <code>IValueConverter</code> in den entsprechenden Typ umwandelt.</p> <pre><code>public class ItemClickedInputConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, string language)\n    {\n        return (RecipeHeader)((value as ItemClickEventArgs)?.ClickedItem);\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, string language)\n    {\n        throw new NotImplementedException();\n    }\n}\n</code></pre> <p>Behaviors sind in der XAML-Welt weit verbreiteter Mechanismus, um wiederverwendbare Verhaltensweisen zu Views hinzuzuf\u00fcgen (weitere Informationen hier).</p> </li> </ol>"},{"location":"labor/5-mvvm/index_ger/#24-rezept-detailansicht","title":"2.4 Rezept-Detailansicht","text":"<p>Um die Details des Rezepts anzuzeigen, verwenden wir eine <code>Grid</code> mit zwei Spalten. Legen wir in die erste Spalte ein <code>ScrollViewer</code>, in das ein <code>StackPanel</code> eingef\u00fcgt wird. Legen wir auf <code>StackPanel</code> eine <code>FlipView</code>, an der die Bilder des Rezepts angezeigt werden sollen.  <code>FlipView</code> funktioniert wie eine Liste, zeigt aber ihre Elemente in einer bl\u00e4tterbaren Oberfl\u00e4che an.</p> <p>Unter <code>FlipView</code> finden wir <code>ItemsControl</code> (eine einfache Liste, die kein Scrollen, Ausw\u00e4hlen, Anklicken usw. unterst\u00fctzt), in der die Zutaten des Rezepts angezeigt werden.</p> <p>Darunter befindet sich eine <code>TextBlock</code>, die die Schritte zur Zubereitung des Rezepts enth\u00e4lt.</p> <p>In der zweiten Spalte platzieren wir ein <code>Grid</code>, wo die Liste der Kommentare und ihre Eingabefelder platziert werden.</p> <p>Wir k\u00f6nnen den folgenden Code w\u00e4hrend des Praktikums auf <code>RecipeDetailPage.xaml</code> kopieren. Dieser Code ist im Vergleich zu den vorherigen nicht neu.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;Page x:Class=\"MvvmLab.Views.RecipeDetailPage\"\n      xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n      xmlns:local=\"using:MvvmLab.Views\"\n      xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n      xmlns:models=\"using:MvvmLab.Core.Models\"\n      Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"\n      mc:Ignorable=\"d\"&gt;\n\n    &lt;Grid x:Name=\"ContentArea\"&gt;\n        &lt;Grid.RowDefinitions&gt;\n            &lt;RowDefinition Height=\"Auto\" /&gt;\n            &lt;RowDefinition Height=\"*\" /&gt;\n        &lt;/Grid.RowDefinitions&gt;\n\n        &lt;TextBlock Grid.Row=\"0\" Padding=\"10\"\n                   Style=\"{StaticResource TitleTextBlockStyle}\"\n                   Text=\"{x:Bind ViewModel.Recipe.Title, Mode=OneWay}\" /&gt;\n\n        &lt;Grid Grid.Row=\"1\"&gt;\n            &lt;Grid.ColumnDefinitions&gt;\n                &lt;ColumnDefinition Width=\"3*\" /&gt;\n                &lt;ColumnDefinition Width=\"*\" /&gt;\n            &lt;/Grid.ColumnDefinitions&gt;\n\n            &lt;ScrollViewer Grid.Column=\"0\" Padding=\"20 10 0 20\"&gt;\n                &lt;StackPanel Orientation=\"Vertical\"&gt;\n                    &lt;StackPanel x:Name=\"images\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Images\" /&gt;\n                        &lt;FlipView x:Name=\"flipView\"\n                                  MaxHeight=\"250\"\n                                  VerticalAlignment=\"Top\"\n                                  ItemsSource=\"{x:Bind ViewModel.Recipe.ExtraImages, Mode=OneWay}\"&gt;\n                            &lt;FlipView.ItemTemplate&gt;\n                                &lt;DataTemplate&gt;\n                                    &lt;Image Source=\"{Binding}\" Stretch=\"Uniform\" /&gt;\n                                &lt;/DataTemplate&gt;\n                            &lt;/FlipView.ItemTemplate&gt;\n                        &lt;/FlipView&gt;\n                    &lt;/StackPanel&gt;\n\n                    &lt;StackPanel x:Name=\"ingredients\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Ingredients\" /&gt;\n                        &lt;ItemsControl HorizontalAlignment=\"Left\" ItemsSource=\"{x:Bind ViewModel.Recipe.Ingredients, Mode=OneWay}\"&gt;\n                            &lt;ItemsControl.ItemTemplate&gt;\n                                &lt;DataTemplate&gt;\n                                    &lt;TextBlock Margin=\"0,0,0,10\"\n                                               Text=\"{Binding}\"\n                                               TextWrapping=\"Wrap\" /&gt;\n                                &lt;/DataTemplate&gt;\n                            &lt;/ItemsControl.ItemTemplate&gt;\n                        &lt;/ItemsControl&gt;\n                    &lt;/StackPanel&gt;\n\n                    &lt;StackPanel x:Name=\"directions\"\n                                Margin=\"0,0,24,0\"\n                                Orientation=\"Vertical\"\n                                RelativePanel.RightOf=\"ingredients\"&gt;\n                        &lt;TextBlock Margin=\"0,0,0,12\"\n                                   Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                                   Text=\"Directions\" /&gt;\n                        &lt;TextBlock HorizontalAlignment=\"Left\"\n                                   Text=\"{x:Bind ViewModel.Recipe.Directions, Mode=OneWay}\"\n                                   TextWrapping=\"Wrap\" /&gt;\n                    &lt;/StackPanel&gt;\n                &lt;/StackPanel&gt;\n            &lt;/ScrollViewer&gt;\n\n            &lt;Grid Grid.Column=\"1\" RowSpacing=\"12\"&gt;\n                &lt;Grid.RowDefinitions&gt;\n                    &lt;RowDefinition Height=\"Auto\" /&gt;\n                    &lt;RowDefinition Height=\"*\" /&gt;\n                    &lt;RowDefinition Height=\"Auto\" /&gt;\n                &lt;/Grid.RowDefinitions&gt;\n\n                &lt;TextBlock Grid.Row=\"0\"\n                           Style=\"{StaticResource SubtitleTextBlockStyle}\"\n                           Text=\"Comments\" /&gt;\n\n                &lt;ListView Grid.Row=\"1\" ItemsSource=\"{x:Bind ViewModel.Recipe.Comments, Mode=OneWay}\"&gt;\n                    &lt;ListView.ItemTemplate&gt;\n                        &lt;DataTemplate x:DataType=\"models:Comment\"&gt;\n                            &lt;StackPanel Orientation=\"Vertical\" Padding=\"0 5 0 5\"&gt;\n                                &lt;TextBlock FontWeight=\"Bold\" Text=\"{x:Bind Name}\" /&gt;\n                                &lt;TextBlock Text=\"{x:Bind Text}\" /&gt;\n                            &lt;/StackPanel&gt;\n                        &lt;/DataTemplate&gt;\n                    &lt;/ListView.ItemTemplate&gt;\n                &lt;/ListView&gt;\n\n                &lt;StackPanel x:Name=\"comments\"\n                            Grid.Row=\"2\"\n                            Margin=\"24,0,24,0\"\n                            Orientation=\"Vertical\"&gt;\n                    &lt;!-- TODO input fields for comments --&gt;\n                &lt;/StackPanel&gt;\n            &lt;/Grid&gt;\n        &lt;/Grid&gt;\n    &lt;/Grid&gt;\n&lt;/Page&gt;\n</code></pre> <p>Probieren wir die App aus!</p>"},{"location":"labor/5-mvvm/index_ger/#aufgabe-3-kommentare-hinzufugen","title":"Aufgabe 3. - Kommentare hinzuf\u00fcgen","text":"<p>Wenn wir einen engen Zeitplan haben, k\u00f6nnen wir eine Funktion zum Hinzuf\u00fcgen von Kommentaren auf der Rezeptdetailseite erstellen.</p>"},{"location":"labor/5-mvvm/index_ger/#webdienst","title":"Webdienst","text":"<p>F\u00fcgen wir der Schnittstelle <code>IRecipeService</code> und der Implementierung eine Methode <code>SendCommentAsync</code> hinzu, die einen Kommentar an den Server unter dem Endpunkt <code>POST /Recipes/{recipeId}/Comments</code> sendet.</p> IRecipeService<pre><code>public Task SendCommentAsync(int recipeId, Comment comment);\n</code></pre> RecipeService<pre><code>public async Task SendCommentAsync(int recipeId, Comment comment)\n{\n    using var client = new HttpClient();\n    await client.PostAsJsonAsync($\"{_baseUrl}/Recipes/{recipeId}/Comments\", comment);\n}\n</code></pre>"},{"location":"labor/5-mvvm/index_ger/#viewmodel","title":"ViewModel","text":"<p>Erstellen wir in <code>RecipeDetailPageViewModel</code>eine Eigenschaft <code>string</code> mit dem Namen <code>NewCommentText</code> und eine Eigenschaft <code>NewCommentName</code> <code>string</code> mit dem Namen, in denen die vom Benutzer bereitgestellten Kommentarinformationen gespeichert werden sollen. Verwenden wir das Attribut <code>ObservableProperty</code>! </p> <pre><code>[ObservableProperty]\nprivate string _newCommentName = string.Empty;\n\n[ObservableProperty]\nprivate string _newCommentText = string.Empty;\n</code></pre> <p>Erstellen wir in <code>RecipeDetailPageViewModel</code> eine Funktion namens <code>SendComment</code>, mit der der Kommentar des Benutzers an den Server gesendet werden kann. Generieren wir einen Befehl aus der Funktion mit dem MVVM Toolkit (<code>[RelayCommand]</code>).</p> <p>Die Umsetzung ist einfach: Wir senden den Kommentar an den Server und aktualisieren dann das Rezept.</p> <pre><code>[RelayCommand]\nprivate async Task SendComment()\n{\n    await _recipeService.SendCommentAsync(Recipe.Id, new Comment\n    {\n        Name = NewCommentName,\n        Text = NewCommentText\n    });\n\n    NewCommentName = string.Empty;\n    NewCommentText = string.Empty;\n\n    Recipe = await _recipeService.GetRecipeAsync(Recipe.Id);\n}\n</code></pre> <p>Die folgenden Elemente werden in der Ansicht platziert, um Kommentare hinzuzuf\u00fcgen:</p> <pre><code>&lt;StackPanel x:Name=\"comments\"\n            Grid.Row=\"2\"\n            Margin=\"24,0,24,0\"\n            Orientation=\"Vertical\"&gt;\n    &lt;TextBox Margin=\"0,0,0,16\"\n             Header=\"Name\"\n             Text=\"{x:Bind ViewModel.NewCommentName, Mode=TwoWay}\" /&gt;\n    &lt;TextBox Margin=\"0,0,0,16\"\n             Header=\"Comment\"\n             Text=\"{x:Bind ViewModel.NewCommentText, Mode=TwoWay}\" /&gt;\n    &lt;Button Margin=\"0,0,0,16\"\n            HorizontalAlignment=\"Right\"\n            Command=\"{x:Bind ViewModel.SendCommentCommand}\"\n            Content=\"Send\" /&gt;\n&lt;/StackPanel&gt;\n</code></pre> <p>Beachten wir, dass die Eigenschaft <code>Text</code> von <code>TextBox</code> an die Eigenschaften <code>NewCommentName</code> und <code>NewCommentText</code> im ViewModel mit einer bidirektionalen Bindung gebunden ist, und dass die Eigenschaft Command der Taste an die Eigenschaft <code>SendCommentCommand</code> im ViewModel gebunden ist.</p>"},{"location":"labor/5-mvvm/index_ger/#ausblick-bedingungen-fur-die-ausfuhrung-von-befehlen","title":"Ausblick: Bedingungen f\u00fcr die Ausf\u00fchrung von Befehlen","text":"<p>Der Befehl <code>SendCommentCommand</code> erfordert, dass die Eigenschaften <code>NewCommentName</code> und <code>NewCommentText</code> nicht leer sind. Befehle bieten die M\u00f6glichkeit, ihre Ausf\u00fchrung an Bedingungen zu kn\u00fcpfen, die in der Methode <code>CanExecute</code> angegeben werden k\u00f6nnen. In unserem Fall m\u00fcssen wir dem Attribut Command generator einen Methoden-/Eigenschaftsnamen geben, der <code>bool</code> zur\u00fcckgibt.</p> RecipeDetailPageViewModel-ben:<pre><code>private bool CanExecuteSendComment =&gt; !string.IsNullOrEmpty(NewCommentName) &amp;&amp; !string.IsNullOrEmpty(NewCommentText);\n\n[RelayCommand(CanExecute = nameof(CanExecuteSendComment))]\nprivate async Task SendComment()\n</code></pre> <p>Probieren wir es aus. Wir stellen fest, dass die Taste nicht aktiviert wird, aber nach der \u00c4nderung von <code>TextBox</code> \u00e4ndert sich der Zustand der Taste nicht.</p> <p>Die Methode <code>CanExecute</code> wird aufgerufen (von den Steuerelementen), wenn Command das Ereignis <code>CanExecuteChanged</code> ausl\u00f6st. In unserem Fall soll dieses Ereignis ausgel\u00f6st werden, wenn das Ereignis <code>PropertyChanged</code> der Eigenschaften <code>NewCommentName</code> und <code>NewCommentText</code> ausgel\u00f6st wird. Zu diesem Zweck bietet das MVVM Toolkit ein eigenes Attribut (<code>[NotifyCanExecuteChangedFor]</code>), das zu den Eigenschaften <code>NewCommentName</code> und <code>NewCommentText</code> hinzugef\u00fcgt werden muss.</p> <p>Wenn sich also der Wert der Eigenschaft <code>NewCommentName</code> oder <code>NewCommentText</code> \u00e4ndert, wird auch das Ereignis <code>SendCommentCommand</code> Befehl <code>CanExecuteChanged</code> ausgel\u00f6st, wodurch die Methode <code>CanExecute</code> erneut ausgef\u00fchrt und der Zustand der Taste aktualisiert wird.</p> <pre><code>[ObservableProperty]\n[NotifyCanExecuteChangedFor(nameof(SendCommentCommand))]\nprivate string _newCommentName = string.Empty;\n\n[ObservableProperty]\n[NotifyCanExecuteChangedFor(nameof(SendCommentCommand))]\nprivate string _newCommentText = string.Empty;\n</code></pre> <p>Probieren wir es aus.</p> <p>Es gibt nur noch eine Sache: Derzeit \u00e4ndert sich der Zustand von <code>TextBox</code> nur, wenn der Benutzer <code>TextBox</code> verl\u00e4sst. Dieses Verhalten kann \u00fcber die Eigenschaft <code>UpdateSourceTrigger</code> der Datenverbindung ge\u00e4ndert werden.</p> <pre><code>Text=\"{x:Bind ViewModel.NewCommentName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n\nText=\"{x:Bind ViewModel.NewCommentText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\"\n</code></pre> <p>Probieren wir es aus.</p>"},{"location":"labor/6-tervezesi-mintak/","title":"6. Tervez\u00e9si mint\u00e1k (kiterjeszthet\u0151s\u00e9g)","text":""},{"location":"labor/6-tervezesi-mintak/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai (egy \u00f6sszetettebb, \u00e9letszer\u0171 p\u00e9lda alapj\u00e1n):</p> <ul> <li>Kiterjeszthet\u0151s\u00e9get, \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got, k\u00f3d \u00e1tl\u00e1that\u00f3s\u00e1got \u00e9s karbantarthat\u00f3s\u00e1got seg\u00edt\u0151 n\u00e9h\u00e1ny tervez\u00e9si alapelv gyakorl\u00e1sa: SRP, OPEN-CLOSED, DRY, KISS stb.</li> <li>N\u00e9h\u00e1ny, a kiterjeszthet\u0151s\u00e9ghez legink\u00e1bb kapcsol\u00f3d\u00f3 tervez\u00e9si minta alkalmaz\u00e1sa (Template Method, Strategy, Dependency Injection).</li> <li>Kiterjeszthet\u0151s\u00e9get \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 tov\u00e1bbi technik\u00e1k (pl. delegate/lambda kifejez\u00e9s) gyakorl\u00e1sa \u00e9s kombin\u00e1l\u00e1sa tervez\u00e9si mint\u00e1kkal.</li> <li>K\u00f3d refaktor\u00e1l\u00e1s gyakorl\u00e1sa.</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok:</p> <ul> <li>Tervez\u00e9si mint\u00e1k: kiterjeszthet\u0151s\u00e9ghez kapcsol\u00f3d\u00f3 mint\u00e1k (bevezet\u0151, Template Method, Strategy), valamint a Dependency Injection \"minta\".</li> </ul>"},{"location":"labor/6-tervezesi-mintak/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> </ul> <p>Gyakorlat Linuxon vagy macOS alatt</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studiora k\u00e9sz\u00fclt, de az elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is m\u00e1s fejleszt\u0151eszk\u00f6z\u00f6kkel (pl. VS Code, Rider, Visual Studio for Mac), vagy ak\u00e1r egy sz\u00f6vegszerkeszt\u0151vel \u00e9s CLI (parancssori) eszk\u00f6z\u00f6kkel. Ezt az teszi lehet\u0151v\u00e9, hogy a p\u00e9ld\u00e1k egy egyszer\u0171 Console alkalmaz\u00e1s kontextus\u00e1ban ker\u00fclnek ismertet\u00e9sre (nincsenek Windows specifikus elemek), a .NET 8 SDK pedig t\u00e1mogatott Linuxon \u00e9s macOS alatt. Hello World Linuxon.</p>"},{"location":"labor/6-tervezesi-mintak/#elmeleti-hatter-szemleletmod","title":"Elm\u00e9leti h\u00e1tt\u00e9r, szeml\u00e9letm\u00f3d *","text":"<p>A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. A megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t/m\u00f3dos\u00edt\u00e1s\u00e1t ig\u00e9nylik: ennek sor\u00e1n \u00faj hib\u00e1k sz\u00fcletnek, illetve jelent\u0151s munk\u00e1t kell fektetni a k\u00f3d nagy l\u00e9pt\u00e9k\u0171 \u00fajratesztel\u00e9s\u00e9be is!</p> <p>A c\u00e9lunk az, hogy az ilyen v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyeket a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d \u00e9rdemi m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - meg tudjuk val\u00f3s\u00edtani. A kulcssz\u00f3: m\u00f3dos\u00edt\u00e1ssal szemben b\u0151v\u00edt\u00e9s. Ehhez kapcsol\u00f3d\u00f3an: amennyiben bizonyos logik\u00e1ink kiterjeszthet\u0151k, akkor azok \u00e1ltal\u00e1nosabbak is leszek, t\u00f6bb kontextusban k\u00f6nnyebben is fel tudjuk ezeket haszn\u00e1lni. \u00cdgy hosszabb t\u00e1von gyorsabban haladunk, r\u00f6videbb a k\u00f3d, elker\u00fclj\u00fck a k\u00f3dduplik\u00e1ci\u00f3t (ez\u00e1ltal k\u00f6nnyebben karbantarthat\u00f3 is a k\u00f3d).</p> <p>A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Jelen gyakorlat keret\u00e9ben azon mint\u00e1kra, tervez\u00e9si elvekre \u00e9s n\u00e9h\u00e1ny programoz\u00f3i eszk\u00f6zre f\u00f3kusz\u00e1lunk, melyek a fenti probl\u00e9m\u00e1kon seg\u00edtenek. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen. Ennek t\u00fckr\u00e9ben nem is c\u00e9lunk (\u00e9s sokszor nincs is r\u00e1 lehet\u0151s\u00e9g\u00fcnk), hogy minden j\u00f6v\u0151beli kiterjeszthet\u0151s\u00e9gi ig\u00e9nyt el\u0151re meg\u00e9rezz\u00fcnk, illetve nagyon el\u0151re \u00e1tgondoljunk. A l\u00e9nyeg az, hogy ak\u00e1r egy egyszer\u0171 megold\u00e1sb\u00f3l kiindulva, az egyes probl\u00e9m\u00e1kat felismerve, a k\u00f3dunkat folyamatosan refaktor\u00e1ljuk \u00fagy, hogy az aktu\u00e1lis (funkcion\u00e1lis \u00e9s nemfunkcion\u00e1lis) k\u00f6vetelm\u00e9nyeknek \u00e9s el\u0151rel\u00e1t\u00e1sunk szerint a megfelel\u0151 pontokban tegy\u00fck k\u00f3dunkat k\u00f6nnyebben kiterjeszthet\u0151v\u00e9 \u00e9s \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1.</p> <p>Meg kell eml\u00edteni, hogy kapcsol\u00f3d\u00f3 tervez\u00e9si mint\u00e1k \u00e9s nyelvi eszk\u00f6z\u00f6k a k\u00f3dunk egys\u00e9gtesztelhet\u0151v\u00e9 t\u00e9tel\u00e9ben is nagym\u00e9rt\u00e9kben seg\u00edtenek: sok c\u00e9gn\u00e9l egy szoftverterm\u00e9k fejleszt\u00e9se eset\u00e9n (jogos) alapelv\u00e1r\u00e1s a fejleszt\u0151kt\u0151l, hogy nagy k\u00f3dlefedetts\u00e9g\u0171 egys\u00e9gteszteket (unit test) k\u00e9sz\u00edtsenek. Ennek kivitelez\u00e9se viszont gyakorlatilag lehetetlen, ha a k\u00f3dunk egyes egys\u00e9gei/oszt\u00e1lyai t\u00fal szoros csatol\u00e1sban vannak egym\u00e1ssal.</p>"},{"location":"labor/6-tervezesi-mintak/#0-feladat-ismerkedes-a-feladattal-es-a-kiindulo-alkalmazassal","title":"0. Feladat - Ismerked\u00e9s a feladattal \u00e9s a kiindul\u00f3 alkalmaz\u00e1ssal","text":"<p>Kl\u00f3nozzuk le a 6. laborhoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-patterns-extensibility-kiindulo.git</code></li> <li>Nyissuk meg a Lab-Patterns-Extensibility.sln solutiont Visual Studio-ban.</li> </ul>"},{"location":"labor/6-tervezesi-mintak/#a-feladat-ismertetese","title":"A feladat ismertet\u00e9se","text":"<p>A labor sor\u00e1n egy konzol alap\u00fa, adatfeldolgoz\u00f3 (pontosabban anonimiz\u00e1l\u00f3) alkalmaz\u00e1st fogunk a folyamatosan alakul\u00f3 ig\u00e9nyeknek megfelel\u0151en - k\u00fcl\u00f6nb\u00f6z\u0151 pontok ment\u00e9n \u00e9s k\u00fcl\u00f6nb\u00f6z\u0151 technik\u00e1kat alkalmazva - kiterjeszthet\u0151v\u00e9 tenni. Az els\u0151 feladat keret\u00e9ben az anonimiz\u00e1l\u00e1s fogalm\u00e1val is megismerked\u00fcnk.</p> <p>Az alkalmaz\u00e1s bemenete egy CSV sz\u00f6vegf\u00e1jl, mely minden sora egy adott szem\u00e9lyre vonatkoz\u00f3an tartalmaz adatokat. A f\u00e1jlrendszerben nyissuk meg a Data mapp\u00e1ban lev\u0151 us-500.csv f\u00e1jlt (duplakattal, vagy ak\u00e1r a Jegyzett\u00f6mb/Notepad alkalmaz\u00e1sban). Az l\u00e1tjuk, hogy \"\" k\u00f6z\u00f6tt, vessz\u0151vel elv\u00e1lasztva tal\u00e1lhat\u00f3k az egyes szem\u00e9lyekre vonatkoz\u00f3 adatok (ezek nem val\u00f3sak). N\u00e9zz\u00fck az els\u0151 sort:</p> <pre><code>\"James\",\"Rhymes\",\"Benton, John B Jr\",\"6649 N Blue Gum St\",\"New Orleans \",\"Orleans\",\"LA\",\"70116\",\"504-621-8927\",\"504-845-1427\",\"30\",\"65\",\"Heart-related\",\"jRhymes@gmail.com\"\n</code></pre> <p>Az els\u0151 sorban lev\u0151 szem\u00e9lyt James Rhymesnak nevezik, a \"Benton, John B Jr\" c\u00e9gn\u00e9l dolgozik, majd n\u00e9h\u00e1ny c\u00edmre vonatkoz\u00f3 mez\u0151 tal\u00e1lhat\u00f3, 30 \u00e9ves, 65 kg a tests\u00falya. Az ezt k\u00f6vet\u0151 mez\u0151 azt mondja meg, milyen s\u00falyosabb betegs\u00e9ge van (a fenti sorban ez \"Heart-related\"). Az utols\u00f3 oszlop pedig a szem\u00e9ly e-mail c\u00edm\u00e9t tartalmazza.</p> Adatok forr\u00e1sa \u00e9s pontos form\u00e1tuma * <p>Az adatok forr\u00e1sa: https://www.briandunning.com/sample-data/, p\u00e1r oszloppal (kor, s\u00faly, betegs\u00e9g) kieg\u00e9sz\u00edtve. A mez\u0151k sorrendje: First Name, Last Name, Company, Address, City, County (where applicable), State/Province (where applicable), ZIP/Postal Code, Phone 1, Phone 2, Age, Weight, Illness, Email</p> <p>Az alkalmaz\u00e1s alapfeladata, hogy ezeket az adatokat az aktu\u00e1lis ig\u00e9nyeknek megfelel\u0151en anonimiz\u00e1lja, majd egy kimeneti CSV sz\u00f6vegf\u00e1jlba ki\u00edrja. Az anonimiz\u00e1l\u00e1s c\u00e9lja, hogy az adatok \u00e1talak\u00edt\u00e1s\u00e1val adathalmazban lev\u0151 szem\u00e9lyeket beazonos\u00edthatatlann\u00e1 tegye, de olyan m\u00f3don, hogy az adatokb\u00f3l m\u00e9gis lehessen kimutat\u00e1sokat k\u00e9sz\u00edteni. Az anonimiz\u00e1l\u00e1s egy k\u00fcl\u00f6n\u00e1ll\u00f3, nagyon komoly \u00e9s sok kih\u00edv\u00e1st rejt\u0151 adatfeldolgoz\u00e1si szakter\u00fclet. A gyakorlat keret\u00e9ben nem c\u00e9lunk, hogy val\u00f3s k\u00f6rnyezetben is haszn\u00e1lhat\u00f3, vagy ak\u00e1r minden tekintetben \u00e9rtelmes megold\u00e1sokat dolgozzunk ki. Sz\u00e1munkra tulajdonk\u00e9ppen csak egy valamilyen adatfeldolgoz\u00f3 algoritmus \"bevet\u00e9se\" a fontos a mint\u00e1k bemutat\u00e1s\u00e1hoz. Ez tal\u00e1n kicsit \"izgalmasabb\" keretet ad, mint egy egyszer\u0171 adatsz\u0171r\u00e9s/sorrendez\u00e9s/stb. alap\u00fa adatfeldolgoz\u00e1s (melyeket r\u00e1ad\u00e1sul a .NET m\u00e1r eleve be\u00e9p\u00edtve t\u00e1mogat).</p> <p>P\u00e1r gondolat az anonimiz\u00e1l\u00e1sr\u00f3l</p> <p>Azt gondolhatn\u00e1nk, hogy az anonimiz\u00e1l\u00e1s egy egyszer\u0171 probl\u00e9mak\u00f6r. Pl. csak el kell t\u00e1vol\u00edtani, vagy ki kell \"csillagozni\" a szem\u00e9lyek neveit, lakc\u00edm\u00e9b\u0151l az utca-h\u00e1zsz\u00e1mot, telefonsz\u00e1mokat, e-mail c\u00edmet, \u00e9s meg is vagyunk. P\u00e9ld\u00e1ul a bemenet\u00fcnk els\u0151 sor\u00e1ra ez lenne a kimenet:</p> <pre><code>\"***\",\"***\",\"Benton, John B Jr\",\"***\",\"New Orleans \",\"Orleans\",\"LA\",\"70116\",\"***\",\"***\",\"30\",\"65\",\"Heart-related\",\"***\"\n</code></pre> <p>De ez kor\u00e1nt sincs \u00edgy, k\u00fcl\u00f6n\u00f6sen, ha igaz\u00e1n sok adatr\u00f3l van sz\u00f3. Gondoljunk arra, hogy van egy kisebb falu, ahol nem laknak sokan. Tegy\u00fck fel, hogy az egyik fenti m\u00f3don anonimiz\u00e1lt szem\u00e9ly \u00e9letkora 14 \u00e9v, de rendk\u00edv\u00fcl t\u00fals\u00falyos, 95 kg. Ez egy ritka \"kombin\u00e1ci\u00f3\", m\u00e1s szem\u00e9ly j\u00f3 es\u00e9llyel nem \u00e9l ilyen param\u00e9terekkel a faluban. Ha az \u0151 oszt\u00e1lyt\u00e1rsai k\u00f6z\u00fcl (nyolcadikos, hiszen 14 \u00e9ves) valaki megn\u00e9zi az \"anonimiz\u00e1lt\" adatokat, tudni fogja ki \u0151 (nincs m\u00e1s ennyire t\u00fals\u00falyos nyolcadikos az iskol\u00e1ban), beazonos\u00edtja a szem\u00e9lyt. \u00cdgy pl. tudni fogja, milyen betegs\u00e9ge van az illet\u0151nek. Tanuls\u00e1g: az adatok \u00f6sszef\u00fcgg\u00e9sben \u00e1rulkod\u00f3k lehetnek.</p> <p>Mi a megold\u00e1s? A v\u00e1rost, az \u00e9letkort \u00e9s a testt\u00f6meget nem t\u00f6r\u00f6lhetj\u00fck/csillagozhatjuk, mert ezekre vonatkoz\u00f3an kell kimutat\u00e1st k\u00e9sz\u00edteni. Egy tipikus megold\u00e1s: nem pontos \u00e9letkort/tests\u00falyt adunk meg az anonimiz\u00e1l\u00e1st k\u00f6vet\u0151en, hanem s\u00e1vokat (vagyis \u00e1ltal\u00e1nos\u00edtjuk az adatokat): pl. a fenti szem\u00e9ly eset\u00e9ben az \u00e9letkora 10..20 \u00e9v, tests\u00falya 80..100 kg, \u00e9s ezeket adjuk meg erre a szem\u00e9lyre vonatkoz\u00f3an a kimeneti f\u00e1jlban. \u00cdgy m\u00e1r nem lehet beazonos\u00edtani a szem\u00e9lyeket. Ezt a technik\u00e1t mi is fogjuk k\u00e9s\u0151bb alkalmazni.</p>"},{"location":"labor/6-tervezesi-mintak/#kiindulo-kovetelmenyek","title":"Kiindul\u00f3 k\u00f6vetelm\u00e9nyek","text":"<p>Az alkalmaz\u00e1ssal szemben t\u00e1masztott kiindul\u00f3 k\u00f6vetelm\u00e9nyek:</p> <ol> <li>Egy adott \u00fcgyf\u00e9lt\u0151l kapott f\u00e1jlokat (mindnek ugyanaz a form\u00e1tuma) kell ugyanazzal az anonimiz\u00e1l\u00f3 algoritmussal, ugyanabba a kimeneti form\u00e1tumba konvert\u00e1lni. Az anonimiz\u00e1l\u00e1s egyszer\u0171en a keresztn\u00e9v \u00e9s vezet\u00e9kn\u00e9v \"kicsillagoz\u00e1s\u00e1b\u00f3l\" \u00e1lljon.</li> <li>Sz\u00fcks\u00e9g van n\u00e9mi adattiszt\u00edt\u00e1sra. A bemeneti adatokban a v\u00e1rost tartalmaz\u00f3 oszlop elej\u00e9n/v\u00e9g\u00e9n lehetnek felesleges <code>_</code> \u00e9s <code>#</code> karakterek, ezeket el kell t\u00e1vol\u00edtani (trim m\u0171velet).</li> <li>Ki kell \u00edrni minden sor feldolgoz\u00e1sa ut\u00e1n a konzolra, hogy a sor feldolgoz\u00e1sa megt\u00f6rt\u00e9nt, ill. a minden adat feldolgoz\u00e1s ut\u00e1n n\u00e9mi \u00f6sszes\u00edt\u0151 inform\u00e1ci\u00f3t (Summary) is meg kell jelen\u00edteni: h\u00e1ny sort dolgoztunk fel, \u00e9s mennyin\u00e9l kellett a v\u00e1rosnevet trimmelni.</li> <li>L\u00e9nyeges szempont: az alkalmaz\u00e1sra csak r\u00f6vid id\u0151re lesz sz\u00fcks\u00e9g, nem a k\u00edv\u00e1njuk k\u00e9s\u0151bbiekben b\u0151v\u00edteni.</li> </ol> <p>Megjegyz\u00e9s: annak \u00e9rdek\u00e9ben, hogy a k\u00f3dban kevesebb mez\u0151vel kelljen dolgozni, \u00e9s a kimenet is \u00e1tl\u00e1that\u00f3bb legyen, elhagyunk m\u00e9g n\u00e9h\u00e1ny mez\u0151t a feldolgoz\u00e1s sor\u00e1n.</p> <p>P\u00e9ldak\u00e9nt a bemeneti f\u00e1jlunk els\u0151 sor\u00e1ra a v\u00e1rt kimenet:</p> <pre><code>***; ***; LA; New Orleans; 30; 65; Heart-related\n</code></pre>"},{"location":"labor/6-tervezesi-mintak/#1-megoldas-minden-egyben-1-startstart","title":"1. Megold\u00e1s - minden egyben (1-Start/Start)","text":"<p>A Visual Studio Solution Explorer\u00e9ben mapp\u00e1kat l\u00e1tunk, 1-t\u0151l 4-ig sz\u00e1mmal kezd\u0151d\u0151 n\u00e9vvel. Ezek az egyes munkaiter\u00e1ci\u00f3khoz tartoz\u00f3 megold\u00e1sokat tartalmazz\u00e1k. Az els\u0151 k\u00f6r\u00f6s megold\u00e1s az \"1-Start\" mapp\u00e1ban, \"Start\" projektn\u00e9v alatt tal\u00e1lhat\u00f3. N\u00e9zz\u00fck meg a projektben tal\u00e1lhat\u00f3 f\u00e1jlokat:</p> <ul> <li><code>Person.cs</code> - Egy szem\u00e9ly sz\u00e1munkra \u00e9rdekes adatai tartalmazza, ennek objektumaiba olvassuk be egy-egy szem\u00e9ly adatait.</li> <li><code>Program.cs</code> - Ennek Main f\u00fcggv\u00e9ny\u00e9ben van megval\u00f3s\u00edtva minden logika, k\u00f3dmegjegyz\u00e9sekkel \"elv\u00e1lasztva\". Amennyiben kicsit is bonyolultabb\u00e1 v\u00e1lik a logika, m\u00e1r egy-k\u00e9t nap (\u00f3ra?) ut\u00e1n mi magunk is csak nehezen fogjuk \u00e1ttekinteni \u00e9s meg\u00e9rteni a saj\u00e1t k\u00f3dunkat. Ezt a megold\u00e1st ne is n\u00e9zz\u00fck.</li> </ul> <p>\u00d6sszeg\u00e9sz\u00e9ben minden nagyon egyszer\u0171 a megold\u00e1sban, hiszen a k\u00f3dnak nem j\u00f3solunk hossz\u00fa j\u00f6v\u0151t. De az egy f\u00fcggv\u00e9nybe \u00f6nt\u00f6tt \"szkriptszer\u0171\", \"minden egybe\" megold\u00e1s ekkor sem j\u00f3 ir\u00e1ny, nagyon neh\u00e9zz\u00e9 teszi a k\u00f3d \u00e1tl\u00e1t\u00e1s\u00e1t, meg\u00e9rt\u00e9s\u00e9t. Ne is n\u00e9zz\u00fck ezt tov\u00e1bb.</p>"},{"location":"labor/6-tervezesi-mintak/#2-megoldas-2-organizedtofunctionsorganizedtofunctions-1","title":"2. Megold\u00e1s (2-OrganizedToFunctions/OrganizedToFunctions-1)","text":"<p>T\u00e9rj\u00fcnk \u00e1t Visual Studioban a \"2-OrganizedToFunctions\" mapp\u00e1ban tal\u00e1lhat\u00f3 \"OrganizedToFunctions-1\" projektben tal\u00e1lhat\u00f3 megold\u00e1sra. Ez m\u00e1r sokkal szimpatikusabb, mert f\u00fcggv\u00e9nyekre bontottuk a logik\u00e1t. Tekints\u00fck \u00e1t a k\u00f3dot r\u00f6viden:</p> <p><code>Anonymizer.cs</code></p> <ul> <li>A <code>Run</code> f\u00fcggv\u00e9ny a \"gerince\", ez tartalmazza a vez\u00e9rl\u00e9si logik\u00e1t, ez h\u00edvja az egyes l\u00e9p\u00e9sek\u00e9rt felel\u0151s f\u00fcggv\u00e9nyeket.</li> <li><code>ReadFromInput</code> m\u0171velet: beolvassa a forr\u00e1sf\u00e1jlt, minden sorhoz k\u00e9sz\u00edt egy <code>Person</code> objektumot, \u00e9s visszat\u00e9r a beolvasott <code>Person</code> objektumok list\u00e1j\u00e1val.</li> <li><code>TrimCityNames</code>: Az adattiszt\u00edt\u00e1st v\u00e9gzi (v\u00e1rosnevek trimmel\u00e9se).</li> <li><code>Anonymize</code>: Minden egyes beolvasott <code>Person</code> objektummal megh\u00edv\u00e1sra ker\u00fcl, \u00e9s feladata, hogy visszaadjon egy \u00faj <code>Person</code> objektumot, mely m\u00e1r az anonimiz\u00e1lt adatokat tartalmazza.</li> <li><code>WriteToOutput</code>: m\u00e1r anonimiz\u00e1lt <code>Person</code> objektumokat ki\u00edrja a kimeneti f\u00e1jlba.</li> <li><code>PrintSummary</code>: ki\u00edrja az \u00f6sszes\u00edt\u00e9st a feldolgoz\u00e1s v\u00e9g\u00e9n a konzolra.</li> </ul> <p><code>Program.cs</code></p> <ul> <li>L\u00e9trehoz egy <code>Anonymizer</code> objektumot \u00e9s a <code>Run</code> h\u00edv\u00e1s\u00e1val futtatja. L\u00e1that\u00f3, hogy az anonimiz\u00e1l\u00e1s sor\u00e1n maszkol\u00e1sra haszn\u00e1lt stringet konstruktor param\u00e9terben kell megadni.</li> </ul> <p>Pr\u00f3b\u00e1ljuk ki, futtassuk! Ehhez a \"OrganizedToFunctions-1\" legyen Visual Studioban a startup projekt (jobb katt rajta, \u00e9s Set as Startup Project), majd futtassuk:</p> <p></p> <p>A kimeneti f\u00e1jt f\u00e1jlkezel\u0151ben tudjuk megn\u00e9zni, az \"OrganizedToFunctions-1\\bin\\Debug\\net8.0\\\" vagy hasonl\u00f3 nev\u0171 mapp\u00e1ban tal\u00e1ljuk, \"us-500.processed.txt\" n\u00e9ven. Nyissuk meg, \u00e9s vess\u00fcnk egy pillant\u00e1st az adatokra.</p>"},{"location":"labor/6-tervezesi-mintak/#a-megoldas-ertekelese","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<ul> <li>A megold\u00e1s alapvet\u0151en j\u00f3l struktur\u00e1lt, k\u00f6nnyen meg\u00e9rthet\u0151.</li> <li>K\u00f6veti a KISS (Keep It Stupid Simple) elvet, nem haszn\u00e1l felesleges bonyol\u00edt\u00e1sokat. Ez \u00edgy j\u00f3, hiszen nem mer\u00fcltek fel potenci\u00e1lis j\u00f6v\u0151beli tov\u00e1bbfejleszt\u00e9si ig\u00e9nyek, nem kell k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1tumokat, logik\u00e1kat stb. t\u00e1mogatni.</li> <li> <p>A megold\u00e1sunk ugyanakkor nem k\u00f6veti az egyik legalapvet\u0151bb \u00e9s legh\u00edresebb tervez\u00e9si elvet, mely Single Responsibility Principle (r\u00f6viden SRP) n\u00e9ven k\u00f6zismert. Ez - n\u00e9mi egyszer\u0171s\u00edt\u00e9ssel \u00e9lve - azt v\u00e1rja el, hogy egy oszt\u00e1lynak egy felel\u0151ss\u00e9ge legyen (alapvet\u0151en egy dologgal foglalkozzon).</p> <ul> <li>K\u00e9ts\u00e9gtelen, hogy az <code>Anonymizer</code> oszt\u00e1lyunknak sz\u00e1mos felel\u0151ss\u00e9ge van: bemenet feldolgoz\u00e1sa, adattiszt\u00edt\u00e1s, anonimiz\u00e1l\u00e1s, kimenet el\u0151\u00e1ll\u00edt\u00e1sa stb.</li> <li>Ez a probl\u00e9ma n\u00e1lunk az\u00e9rt nem felt\u0171n\u0151, illetve az\u00e9rt nem okoz gondot, mert mindegyik felel\u0151ss\u00e9g megval\u00f3s\u00edt\u00e1sa egyszer\u0171, \"belef\u00e9rt\" egy-egy r\u00f6videbb f\u00fcggv\u00e9nybe. De ha b\u00e1rmelyik is \u00f6sszetettebb lenne, t\u00f6bb f\u00fcggv\u00e9nyben lenn\u00e9nek megval\u00f3s\u00edtva, akkor mindenk\u00e9ppen k\u00fcl\u00f6n oszt\u00e1lyba illene szervezni.</li> </ul> Mi\u00e9rt probl\u00e9ma, ha egy oszt\u00e1lynak t\u00f6bb felel\u0151ss\u00e9ge van? * <ul> <li>Nehezebb meg\u00e9rteni a m\u0171k\u00f6d\u00e9s\u00e9t, mert nem egy dologra f\u00f3kusz\u00e1l.</li> <li>Ha b\u00e1rmelyik felel\u0151ss\u00e9g ment\u00e9n is j\u00f6n be v\u00e1ltoz\u00e1si ig\u00e9ny, egy nagy, sok mindennel foglalkoz\u00f3 oszt\u00e1lyt kell v\u00e1ltoztatni \u00e9s \u00fajra tesztelni.</li> </ul> </li> <li> <p>A megold\u00e1shoz lehet \u00edrni automatiz\u00e1lt integr\u00e1ci\u00f3s (input-output) teszteket, de \"igazi\" egys\u00e9gteszteket nem.</p> </li> </ul>"},{"location":"labor/6-tervezesi-mintak/#3-megoldas-organizedtofunctions-2-twoalgorithms","title":"3. Megold\u00e1s (OrganizedToFunctions-2-TwoAlgorithms)","text":"<p>A kor\u00e1bbi \"tervekkel\" ellent\u00e9tben \u00faj felhaszn\u00e1l\u00f3i ig\u00e9nyek mer\u00fcltek fel. Az \u00fcgyfel\u00fcnk meggondolta mag\u00e1t, egy m\u00e1sik adathalmazn\u00e1l m\u00e1sf\u00e9le anonimiz\u00e1l\u00f3 algoritmus megval\u00f3s\u00edt\u00e1s\u00e1t k\u00e9ri: a szem\u00e9lyek \u00e9letkor\u00e1t kell s\u00e1vosan menteni, nem der\u00fclhet ki a szem\u00e9lyek pontos \u00e9letkora. Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben ez esetben a szem\u00e9lyek nev\u00e9t nem fogjuk anonimiz\u00e1lni, \u00edgy tekints\u00fck ezt egyfajta \"pszeudo\" anonimiz\u00e1l\u00e1snak (ett\u0151l m\u00e9g lehet \u00e9rtelme, csak nem teljesen korrekt ezt anonimiz\u00e1l\u00e1snak nevezni).</p> <p>A megold\u00e1sunkat - mely egyar\u00e1nt t\u00e1mogatja a r\u00e9gi \u00e9s az \u00faj algoritmust (egyszerre csak az egyiket) - a VS solution OrganizedToFunctions-2-TwoAlgorithms nev\u0171 projektj\u00e9ben tal\u00e1ljuk. N\u00e9zz\u00fcnk r\u00e1 az <code>Anonymizer</code> oszt\u00e1lyra, a megold\u00e1s alapelve (ezeket tekints\u00fck \u00e1t a k\u00f3dban):</p> <ul> <li>Bevezett\u00fcnk egy <code>AnonymizerMode</code> enum t\u00edpust, mely meghat\u00e1rozza, hogy melyik \u00fczemm\u00f3dban (algoritmussal) haszn\u00e1ljuk az <code>Anonymizer</code> oszt\u00e1lyt.</li> <li>Az <code>Anonymizer</code> oszt\u00e1lynak k\u00e9t anonimiz\u00e1l\u00f3 m\u0171velete van: <code>Anonymize_MaskName</code>, <code>Anonymize_AgeRange</code></li> <li>Az <code>Anonymizer</code> oszt\u00e1ly a <code>_anonymizerMode</code> tagj\u00e1ban t\u00e1rolja, melyik algoritmust kell haszn\u00e1lni: a k\u00e9t \u00fczemm\u00f3dhoz k\u00e9t k\u00fcl\u00f6n konstruktort vezett\u00fcnk be, ezek \u00e1ll\u00edtj\u00e1k be az <code>_anonymizerMode</code> \u00e9rt\u00e9k\u00e9t.</li> <li>Az <code>Anonymizer</code> oszt\u00e1ly t\u00f6bb helyen is megvizsg\u00e1lja (pl. <code>Run</code>, <code>GetAnonymizerDescription</code> m\u0171veletek), hogy mi az <code>_anonymizerMode</code> \u00e9rt\u00e9ke, \u00e9s ennek f\u00fcggv\u00e9ny\u00e9ben el\u00e1gazik.</li> <li> <p>A <code>GetAnonymizerDescription</code>-ben az\u00e9rt kell ezt megtenni, mert ennek a m\u0171veletnek a feladata az anonimiz\u00e1l\u00f3 algoritmusr\u00f3l egy egysoros le\u00edr\u00e1s el\u0151\u00e1ll\u00edt\u00e1sa, melyet a feldolgoz\u00e1s v\u00e9g\u00e9n a \"summary\"-ben megjelen\u00edt. N\u00e9zz\u00fcnk r\u00e1 a <code>PintSummary</code> k\u00f3dj\u00e1ra, ez a m\u0171velet h\u00edvja. Pl. ez jelenik meg a konzolon \u00f6sszefoglal\u00f3k\u00e9nt, ha \u00e9letkor anonimiz\u00e1l\u00f3t haszn\u00e1lunk 20-as range-dzsel:</p> <p><code>Summary - Anonymizer (Age anonymizer with range size 20): Persons: 500, trimmed: 2</code></p> </li> </ul>"},{"location":"labor/6-tervezesi-mintak/#a-megoldas-ertekelese_1","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>\u00d6sszeg\u00e9sz\u00e9ben megold\u00e1sunk k\u00f3dmin\u0151s\u00e9g tekintet\u00e9ben a kor\u00e1bbin\u00e1l rosszabb lett. Kor\u00e1bban nem volt probl\u00e9ma, hogy anonimiz\u00e1l\u00f3 algoritmusok tekintet\u00e9ben nem volt kiterjeszthet\u0151, hiszen nem volt r\u00e1 ig\u00e9ny. De ha m\u00e1r egyszer felmer\u00fclt az ig\u00e9ny \u00faj algoritmus bevezet\u00e9s\u00e9re, akkor hiba ebben a tekintetben nem kiterjeszthet\u0151v\u00e9 tenni a megold\u00e1sunkat: ett\u0151l kezdve sokkal ink\u00e1bb sz\u00e1m\u00edtunk arra, hogy \u00fajabb tov\u00e1bbi algoritmusokat kell bevezetni a j\u00f6v\u0151ben.</p> <p>Mi\u00e9rt \u00e1ll\u00edtjuk azt, hogy a k\u00f3dunk nem kiterjeszthet\u0151, amikor \"csak\" egy \u00faj enum \u00e9rt\u00e9ket, \u00e9s egy-egy plusz <code>if</code>/<code>switch</code> \u00e1gat kell a k\u00f3d n\u00e9h\u00e1ny pontj\u00e1ra bevezetni, amikor \u00faj algoritmust kell majd bevezetni?</p> <p> Open/Closed principle Kulcsfontoss\u00e1g\u00fa, hogy egy oszt\u00e1lyt akkor tekint\u00fcnk kiterjeszthet\u0151nek, ha annak b\u00e1rmilyen nem\u0171 m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl, puszt\u00e1n a k\u00f3d kiterjeszt\u00e9s\u00e9vel/b\u0151v\u00edt\u00e9s\u00e9vel lehet \u00faj viselked\u00e9st (eset\u00fcnkben \u00faj algoritmust) bevezetni. Vagyis eset\u00fcnkben az <code>Anonymizer</code> k\u00f3dj\u00e1hoz nem szabadna hozz\u00e1ny\u00falni, ami egy\u00e9rtelm\u0171en nem teljes\u00fcl. Ez a h\u00edres Open/Closed principle/elv: the class should be Open for Extension, Closed for Modification. A k\u00f3d m\u00f3dos\u00edt\u00e1sa az\u00e9rt probl\u00e9ma, mert annak sor\u00e1n j\u00f3 es\u00e9llyel \u00faj bugokat vezet\u00fcnk be, ill. a m\u00f3dos\u00edtott k\u00f3dot mindig \u00fajra kell tesztelni, ez pedig jelent\u0151s id\u0151/k\u00f6lts\u00e9gr\u00e1ford\u00edt\u00e1si ig\u00e9nyt jelenthet.</p> <p>Mi is a pontos c\u00e9l, \u00e9s hogyan \u00e9rj\u00fck ezt el? Vannak olyan r\u00e9szek az oszt\u00e1lyunkban, melyeket nem szeretn\u00e9nk be\u00e9getni:</p> <ul> <li>Ezek nem adatok, hanem viselked\u00e9sek (k\u00f3d, logika).</li> <li>Nem <code>if</code>/<code>switch</code> utas\u00edt\u00e1sokkal oldjuk meg: \"kiterjeszt\u00e9si pontokat\" vezet\u00fcnk be, \u00e9s valamilyen m\u00f3don megoldjuk, hogy ezekben \"tetsz\u0151leges\" k\u00f3d lefuthasson.</li> <li>Ezek v\u00e1ltoz\u00f3/esetf\u00fcgg\u0151 r\u00e9szek k\u00f3dj\u00e1t m\u00e1s oszt\u00e1lyokba tessz\u00fck (az oszt\u00e1lyunk szempontj\u00e1b\u00f3l \"lecser\u00e9lhet\u0151\" m\u00f3don)!</li> </ul> <p>Note</p> <p>Ne gondoljunk semmif\u00e9le var\u00e1zslatra, a m\u00e1r ismert eszk\u00f6z\u00f6ket fogjuk erre haszn\u00e1lni: \u00f6r\u00f6kl\u00e9st absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekkel, vagy interf\u00e9szeket, vagy delegate-eket.</p> <p>Keress\u00fck meg azokat a r\u00e9szeket, melyek esetf\u00fcgg\u0151, v\u00e1ltoz\u00f3 logik\u00e1k, \u00edgy nem j\u00f3 be\u00e9getni az <code>Anonymizer</code> oszt\u00e1lyba:</p> <ul> <li>Az egyik maga az anonimiz\u00e1l\u00e1si logika: <code>Anonymize_MaskName</code>/<code>Anonymize_AgeRange</code></li> <li>A m\u00e1sik a <code>GetAnonymizerDescription</code></li> </ul> <p>Ezeket kell lev\u00e1lasztani az oszt\u00e1lyr\u00f3l, ezekben a pontokban kell kiterjeszthet\u0151v\u00e9 tenni az oszt\u00e1lyt. Az al\u00e1bbi \u00e1bra illusztr\u00e1lja a c\u00e9lt \u00e1ltal\u00e1noss\u00e1g\u00e1ban *:</p> Az \u00e1ltal\u00e1nos megold\u00e1si elv illusztr\u00e1l\u00e1sa <p></p> <p>A h\u00e1rom konkr\u00e9t tervez\u00e9si mint\u00e1t, ill. technik\u00e1t n\u00e9z\u00fcnk meg a fentiek megval\u00f3s\u00edt\u00e1s\u00e1ra:</p> <ul> <li>Template Method tervez\u00e9si minta</li> <li>Strategy tervez\u00e9si minta (Dependency Injectionnel egyetemben)</li> <li>Delegate (opcion\u00e1lisan Lambda kifejez\u00e9ssel)</li> </ul> <p>Val\u00f3j\u00e1ban mind haszn\u00e1ltuk m\u00e1r a tanulm\u00e1nyaink sor\u00e1n, de most m\u00e9lyebben megismerked\u00fcnk vel\u00fck, \u00e9s \u00e1tfog\u00f3bban be fogjuk gyakorolni ezek alkalmaz\u00e1s\u00e1t. Az els\u0151 kett\u0151t a labor keret\u00e9ben, a harmadikat pedig majd egy kapcsol\u00f3d\u00f3 h\u00e1zi feladat keret\u00e9ben.</p>"},{"location":"labor/6-tervezesi-mintak/#4-megoldas-3-templatemethodtemplatemethod-1","title":"4. Megold\u00e1s (3-TemplateMethod/TemplateMethod-1)","text":"<p>Ebben a l\u00e9p\u00e9sben a Template Method tervez\u00e9si minta alkalmaz\u00e1s\u00e1val fogjuk a megold\u00e1sunkat a sz\u00fcks\u00e9ges pontokban kiterjeszthet\u0151v\u00e9 tenni.</p> <p>Note</p> <p>A minta neve \"megt\u00e9veszt\u0151\": semmi k\u00f6ze nincs a C++-ban tanult sablonmet\u00f3dusokhoz!</p> Template Method alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Template Method alap\u00fa megold\u00e1st, a l\u00e9nyegre f\u00f3kusz\u00e1lva:</p> <p></p> <p>A mint\u00e1ban a k\u00f6vetkez\u0151 elvek ment\u00e9n val\u00f3sul meg a \"v\u00e1ltozatlan\" \u00e9s \"v\u00e1ltoz\u00f3\" r\u00e9szek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa (\u00e9rdemes a fenti oszt\u00e1lydiagram alapj\u00e1n - a p\u00e9ld\u00e1nkra vet\u00edtve - ezeket meg\u00e9rteni):</p> <ul> <li>A \"k\u00f6z\u00f6s/v\u00e1ltozatlan\" r\u00e9szeket egy \u0151soszt\u00e1lyba tessz\u00fck.</li> <li>Ebben a kiterjeszt\u00e9si pontokat absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyek bevezet\u00e9se jelenti, ezeket h\u00edvjuk a kiterjeszt\u00e9si pontokban.</li> <li>Ezek esetf\u00fcgg\u0151 megval\u00f3s\u00edt\u00e1sa a lesz\u00e1rmazott oszt\u00e1lyokba ker\u00fcl.</li> </ul> <p>A j\u00f3l ismert \"tr\u00fckk\" a dologban az, hogy amikor az \u0151s megh\u00edvja az absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyeket, akkor a lesz\u00e1rmazottb\u00e9li, esetf\u00fcgg\u0151 k\u00f3d h\u00edv\u00f3dik meg.</p> <p>A k\u00f6vetkez\u0151kben a kor\u00e1bbi <code>enum</code>, illetve <code>if</code>/<code>switch</code> alap\u00fa megold\u00e1st alak\u00edtjuk \u00e1t Template Method alap\u00fara (ebben m\u00e1r nem lesz enum). Egy \u0151soszt\u00e1lyt \u00e9s k\u00e9t, algoritmusf\u00fcgg\u0151 lesz\u00e1rmazottat vezet\u00fcnk be.</p> <p>Alak\u00edtsuk \u00e1t a k\u00f3dunkat ennek megfelel\u0151en. A VS solution-ben a \"3-TemplateMethod\" mapp\u00e1ban a \"TemplateMethod-0-Begin\" projekt tartalmazza a kor\u00e1bbi megold\u00e1sunk k\u00f3dj\u00e1t (annak \"m\u00e1solat\u00e1t\"), ebben a projektben dolgozzunk:</p> <ol> <li>Nevezz\u00fck \u00e1t az <code>Anonymizer</code> oszt\u00e1lyt <code>AnonymizerBase</code>-re (pl. az oszt\u00e1ly nev\u00e9re \u00e1llva a forr\u00e1sf\u00e1jlban \u00e9s F2-t nyomva).</li> <li>Vegy\u00fcnk fel az projektbe egy <code>NameMaskingAnonymizer</code> \u00e9s egy <code>AgeAnonymizer</code> oszt\u00e1lyt (projekten jobb katt, Add/Class).</li> <li>Sz\u00e1rmaztassuk az <code>AnonymizerBase</code>-b\u0151l \u0151ket</li> <li> <p>Az <code>AnonymizerBase</code>-b\u0151l mozgassuk \u00e1t a <code>NameMaskingAnonymizer</code>-be az ide tartoz\u00f3 r\u00e9szeket:</p> <ol> <li>A <code>_mask</code> tagv\u00e1ltoz\u00f3t.</li> <li>A <code>string inputFileName, string mask</code> param\u00e9terez\u00e9s\u0171 konstruktort, \u00e1tnevezve <code>NameMaskingAnonymizer</code>-re,<ol> <li><code>_anonymizerMode = AnonymizerMode.Name;</code> sort t\u00f6r\u00f6lve,</li> <li> <p>a <code>this</code> konstruktorh\u00edv\u00e1s helyett <code>base</code> konstruktorh\u00edv\u00e1ssal.</p> A konstruktor k\u00f3dja <pre><code>public NameMaskingAnonymizer(string inputFileName, string mask): base(inputFileName)\n{\n    _mask = mask;\n}\n</code></pre> </li> </ol> </li> </ol> </li> <li> <p>Az <code>AnonymizerBase</code>-b\u0151l mozgassuk \u00e1t az <code>AgeAnonymizer</code>-be az ide tartoz\u00f3 r\u00e9szeket:</p> <ol> <li>A <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t.</li> <li>A <code>string inputFileName, string rangeSize</code> param\u00e9terez\u00e9s\u0171 konstruktort, \u00e1tnevezve <code>AgeAnonymizer</code>-re,<ol> <li><code>_anonymizerMode = AnonymizerMode.Age;</code> sort t\u00f6r\u00f6lve,</li> <li> <p>a <code>this</code> konstruktorh\u00edv\u00e1s helyett <code>base</code> konstruktorh\u00edv\u00e1ssal.</p> A konstruktor k\u00f3dja <pre><code>public AgeAnonymizer(string inputFileName, int rangeSize): base(inputFileName)\n{\n    _rangeSize = rangeSize;\n}\n</code></pre> </li> </ol> </li> </ol> </li> <li> <p>Az <code>AnonymizerBase</code>-ben:</p> <ol> <li>T\u00f6r\u00f6lj\u00fck az <code>AnonymizerMode</code> enum t\u00edpust.</li> <li>T\u00f6r\u00f6lj\u00fck a <code>_anonymizerMode</code> tagot.</li> </ol> </li> </ol> <p>Keress\u00fck meg azokat a r\u00e9szeket, melyek esetf\u00fcgg\u0151, v\u00e1ltoz\u00f3 logik\u00e1k, \u00edgy nem akarjuk be\u00e9getni az \u00fajrafelhaszn\u00e1lhat\u00f3nak sz\u00e1nt <code>AnonymizerBase</code> oszt\u00e1lyba:</p> <ul> <li>Az egyik az <code>Anonymize_MaskName</code>/<code>Anonymize_AgeRange</code>,</li> <li>a m\u00e1sik a <code>GetAnonymizerDescription</code>.</li> </ul> <p>A mint\u00e1t k\u00f6vetve ezekre az \u0151sben absztrakt (vagy esetleg virtu\u00e1lis) f\u00fcggv\u00e9nyeket vezet\u00fcnk be, \u00e9s ezeket h\u00edvjuk, az esetf\u00fcgg\u0151 implement\u00e1ci\u00f3ikat pedig a lesz\u00e1rmazott oszt\u00e1lyokba tessz\u00fck (override):</p> <ol> <li>Tegy\u00fck az <code>AnonymizerBase</code> oszt\u00e1lyt absztraktt\u00e1 (a <code>class</code> el\u00e9 <code>abstract</code> kulcssz\u00f3).</li> <li> <p>Vezess\u00fcnk be az <code>AnonymizerBase</code>-ben egy</p> <pre><code>protected abstract Person Anonymize(Person person);\n</code></pre> <p>m\u0171veletet (ennek feladata lesz az anonimiz\u00e1l\u00e1s v\u00e9grehajt\u00e1sa).</p> </li> <li> <p>Az <code>Anonymize_MaskName</code> m\u0171veletet mozgassuk \u00e1t a <code>NameMaskingAnonymizer</code> oszt\u00e1lyba, \u00e9s alak\u00edtsuk \u00e1t a szignat\u00far\u00e1j\u00e1t \u00fagy, hogy override-olja az \u0151sbeli <code>Anonymize</code> absztrakt f\u00fcggv\u00e9nyt:</p> <pre><code>protected override Person Anonymize(Person person)\n{\n    return new Person(_mask, _mask, person.CompanyName,\n        person.Address, person.City, person.State, person.Age, person.Weight, person.Decease);\n}\n</code></pre> <p>A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a megsz\u00fcntetett <code>mask</code> param\u00e9tert, hanem a <code>_mask</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja.</p> </li> <li> <p>Az el\u0151z\u0151 l\u00e9p\u00e9ssel teljesen anal\u00f3g m\u00f3don az <code>Anonymize_AgeRange</code> m\u0171veletet mozgassuk \u00e1t a <code>AgeAnonymizer</code> oszt\u00e1lyba, \u00e9s alak\u00edtsuk \u00e1t a szignat\u00far\u00e1j\u00e1t \u00fagy, hogy override-olja az \u0151sbeli <code>Anonymize</code> absztrakt f\u00fcggv\u00e9nyt:</p> <pre><code>protected override Person Anonymize(Person person)\n{\n    ...\n}\n</code></pre> <p>A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a megsz\u00fcntetett <code>rangeSize</code> param\u00e9tert, hanem a <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja.</p> </li> <li> <p>A <code>AnonymizerBase</code> oszt\u00e1ly <code>Run</code> f\u00fcggv\u00e9ny\u00e9ben az <code>if</code>/<code>else</code> kifejez\u00e9sben tal\u00e1lhat\u00f3 <code>Anonymize</code> h\u00edv\u00e1sokat most m\u00e1r le tudjuk cser\u00e9lni egy egyszer\u0171 absztrakt f\u00fcggv\u00e9ny h\u00edv\u00e1sra:</p> <pre><code>Person person;\nif (_anonymizerMode == AnonymizerMode.Name)\n    person = Anonymize_MaskName(persons[i], _mask);\nelse if (_anonymizerMode == AnonymizerMode.Age)\n    person = Anonymize_AgeRange(persons[i], _rangeSize);\nelse\n    throw new NotSupportedException(\"The requested anonymization mode is not supported.\");\n</code></pre> <p>helyett:</p> <pre><code>var person = Anonymize(persons[i]);\n</code></pre> </li> </ol> <p>Az egyik kiterjeszt\u00e9si pontunkkal el is k\u00e9sz\u00fclt\u00fcnk. De maradt m\u00e9g egy, a <code>GetAnonymizerDescription</code>, mely kezel\u00e9se szint\u00e9n esetf\u00fcgg\u0151. Ennek \u00e1talak\u00edt\u00e1sa nagyon hasonl\u00f3 az el\u0151z\u0151 l\u00e9p\u00e9ssorozathoz:</p> <ol> <li> <p>Az <code>AnonymizerBase</code> oszt\u00e1ly <code>GetAnonymizerDescription</code> m\u0171velet\u00e9t m\u00e1soljuk \u00e1t a <code>NameMaskingAnonymizer</code>-be, a szignat\u00far\u00e1ba belev\u00e9ve az <code>override</code> kulcssz\u00f3t, a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben csak a <code>NameMaskingAnonymizer</code>-re vonatkoz\u00f3 logik\u00e1t meghagyva:</p> <pre><code>protected override string GetAnonymizerDescription()\n{\n    return $\"NameMasking anonymizer with mask {_mask}\";\n}\n</code></pre> </li> <li> <p>A <code>AnonymizerBase</code> <code>GetAnonymizerDescription</code> m\u0171velet\u00e9t m\u00e1soljuk \u00e1t az <code>AgeAnonymizer</code>-be is, a szignat\u00far\u00e1ba belev\u00e9ve az <code>override</code> kulcssz\u00f3t, a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben most csak a <code>AgeAnonymizer</code>-re vonatkoz\u00f3 logik\u00e1t meghagyva:</p> <pre><code>protected override string GetAnonymizerDescription()\n{\n    return $\"Age anonymizer with range size {_rangeSize}\";\n}\n</code></pre> </li> <li> <p>K\u00e9rd\u00e9s, mi legyen <code>AnonymizerBase</code>-ben a <code>GetAnonymizerDescription</code> m\u0171velettel. Ezt nem absztrakt\u00e1, hanem virtu\u00e1lis f\u00fcggv\u00e9nny\u00e9 alak\u00edtjuk, hiszen itt tudunk \u00e9rtelmes alap\u00e9rtelmezett viselked\u00e9st biztos\u00edtani: egyszer\u0171en visszaadjuk az oszt\u00e1ly nev\u00e9t (mely pl. a <code>NameMaskingAnonymizer</code> oszt\u00e1ly eset\u00e9ben \"NameMaskingAnonymizer\" lenne). Mindenesetre a rugalmatlan <code>switch</code> szerkezett\u0151l ezzel megszabadulunk:</p> <pre><code>protected virtual string GetAnonymizerDescription()\n{\n    return GetType().Name;\n}\n</code></pre> <p>Reflexi\u00f3</p> <p>Az object \u0151sb\u0151l \u00f6r\u00f6k\u00f6lt <code>GetType()</code> m\u0171velettel egy <code>Type</code> t\u00edp\u00fas\u00fa objektumot szerz\u00fcnk az oszt\u00e1lyunkra vonatkoz\u00f3an. Ez a refelexi\u00f3 t\u00e9mak\u00f6rh\u00f6z tartozik, err\u0151l a f\u00e9l\u00e9v v\u00e9g\u00e9n fogunk el\u0151ad\u00e1son r\u00e9szletesebben tanulni.</p> </li> </ol> <p>Egy dolog van m\u00e1r csak h\u00e1tra: a <code>Program.cs</code> <code>Main</code> f\u00fcggv\u00e9ny\u00e9ben most az <code>AnonymizerBase</code> \u0151st pr\u00f3b\u00e1ljuk p\u00e9ld\u00e1nyos\u00edtani (a kor\u00e1bbi \u00e1tnevez\u00e9s miatt). Helyette a k\u00e9t lesz\u00e1rmazott valamelyik\u00e9t kellene. Pl.:</p> <pre><code>NameMaskingAnonymizer anonymizer = new(\"us-500.csv\", \"***\");\nanonymizer.Run();\n</code></pre> <p>El is k\u00e9sz\u00fclt\u00fcnk. Pr\u00f3b\u00e1ljuk ki, hogy jobban \"\u00e9rezz\u00fck\", val\u00f3ban m\u0171k\u00f6dnek az kiterjeszt\u00e9si pontok (de ha kev\u00e9s az id\u0151nk a labor sor\u00e1n, ez k\u00fcl\u00f6n\u00f6sebben nem fontos, hasonl\u00f3t m\u00e1r kor\u00e1bbi f\u00e9l\u00e9vekben C++/Java nyelvek kontextus\u00e1ban is csin\u00e1ltunk):</p> <ul> <li>Visual Studioban a TemplateMethod-0-Begin projekt legyen a startup projekt, ha ezt eddig m\u00e9g nem \u00e1ll\u00edtottuk be.</li> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot az <code>AnonymizerBase</code> oszt\u00e1ly <code>var person = Anonymize(persons[i]);</code> sor\u00e1ra.</li> <li>Amikor fut\u00e1s k\u00f6zben itt meg\u00e1ll a debugger, F11-gyel l\u00e9pj\u00fcnk bele.</li> <li>Az tapasztaljuk, hogy a  lesz\u00e1rmazott <code>AgeAnonymizer</code> m\u0171velete h\u00edv\u00f3dik.</li> </ul> <p>Vethet\u00fcnk egy pillant\u00e1st a megold\u00e1s oszt\u00e1lydiagramj\u00e1ra:</p> Template Method alap\u00fa megold\u00e1s oszt\u00e1lydiagram * <p></p> <p>Az eddigi munk\u00e1nk megold\u00e1sa a <code>3-TemplateMethod/TemplateMethod-1</code> projektben megtal\u00e1lhat\u00f3, ha esetleg sz\u00fcks\u00e9g lenne r\u00e1.</p> Mi\u00e9rt Template Method a minta neve * <p>A minta az\u00e9rt kapta a Template Method nevet, mert - alkalmaz\u00e1sunkat p\u00e9ldak\u00e9nt haszn\u00e1lva - a <code>Run</code> \u00e9s a <code>PrintSummary</code> olyan \"sablon met\u00f3dusok\", melyek meghat\u00e1roznak egy sablonszer\u0171 logik\u00e1t, v\u00e1zat, melyben bizonyos l\u00e9p\u00e9sek nincsenek megk\u00f6tve. Ezek \"k\u00f3dj\u00e1t\" absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekre b\u00edzzuk, \u00e9s a lesz\u00e1rmazott oszt\u00e1lyok hat\u00e1rozz\u00e1k meg a megval\u00f3s\u00edt\u00e1sukat.</p>"},{"location":"labor/6-tervezesi-mintak/#a-megoldas-ertekelese_2","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>Ellen\u0151rizz\u00fck a megold\u00e1st, megval\u00f3s\u00edtja-e a c\u00e9ljainkat:</p> <ul> <li>Az <code>AnonymizerBase</code> egy \u00fajrafelhaszn\u00e1lhat\u00f3(bb) oszt\u00e1ly lett.</li> <li>Ha \u00faj anonimiz\u00e1l\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak sz\u00e1rmaztatunk bel\u0151le. Ez nem m\u00f3dos\u00edt\u00e1s, hanem b\u0151v\u00edt\u00e9s.</li> <li>Ennek megfelel\u0151en teljes\u00fcl az OPEN/CLOSED elv, vagyis a k\u00f3dj\u00e1nak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl tudjuk az \u0151sben megadott k\u00e9t pontban a logik\u00e1t testre szabni, kiterjeszteni.</li> </ul> <p>Legyen minden pontban kiterjeszthet\u0151 az oszt\u00e1lyunk?</p> <p>Figyelj\u00fck meg, hogy nem tett\u00fcnk az <code>AnonymizerBase</code> minden m\u0171velet\u00e9t virtu\u00e1liss\u00e1 (\u00edgy sok pontban kiterjeszthet\u0151v\u00e9 az oszt\u00e1lyt). Csak ott tett\u00fck meg, ahol azt gondoljuk, hogy a j\u00f6v\u0151ben sz\u00fcks\u00e9g lehet a logika kiterjeszt\u00e9s\u00e9re.</p>"},{"location":"labor/6-tervezesi-mintak/#5-megoldas-3-templatemethodtemplatemethod-2-progress","title":"5. Megold\u00e1s (3-TemplateMethod/TemplateMethod-2-Progress)","text":"<p>T.f.h \u00faj - viszonylag egyszer\u0171 - ig\u00e9ny mer\u00fcl fel:</p> <ul> <li> <p>A <code>NameMaskinAnonimizer</code> eset\u00e9n marad ugyan a kor\u00e1bbi egyszer\u0171 progress kijelz\u00e9s (minden sor ut\u00e1n ki\u00edrjuk, h\u00e1nyadikn\u00e1l tartottunk),</p> Egyszer\u0171 progress illusztr\u00e1l\u00e1sa <p></p> </li> <li> <p>de az <code>AgeAnonymizer</code> eset\u00e9n a progress kijelz\u00e9s m\u00e1s kell legyen: azt kell ki\u00edrni - minden sor ut\u00e1n friss\u00edtve -, hogy h\u00e1ny sz\u00e1zal\u00e9kn\u00e1l tart a feldolgoz\u00e1s.</p> Sz\u00e1zal\u00e9kos progress illusztr\u00e1l\u00e1sa <p></p> <p>(Mivel jelenleg kev\u00e9s az adatunk (mind\u00f6ssze 500 sor), ezt a megold\u00e1sunk v\u00e9g\u00e9n nem \u00edgy l\u00e1tjuk majd, pillanatok alatt 100%-ra ugrik)</p> </li> </ul> <p>A megold\u00e1s nagyon egyszer\u0171: a <code>Run</code> m\u0171veletben sz\u00e9lesebb k\u00f6rben alkalmazva a Template Method mint\u00e1t, a progress ki\u00edr\u00e1skor is egy kiterjeszt\u00e9si pontot vezet\u00fcnk be, egy virtu\u00e1lis f\u00fcggv\u00e9nyre b\u00edzzuk a megval\u00f3s\u00edt\u00e1st.</p> <p>Ugorjunk egyb\u0151l a k\u00e9sz megold\u00e1sra (3-TemplateMethod/TemplateMethod-2-Progress projekt):</p> <ul> <li><code>AnonymizerBase</code> oszt\u00e1lyban \u00faj <code>PrintProgress</code> virtu\u00e1lis f\u00fcggv\u00e9ny (alap\u00e9rtelmez\u00e9sben nem \u00edr ki semmit)</li> <li><code>Run</code>-ban ennek h\u00edv\u00e1sa</li> <li><code>NameMaskingAnonymizer</code>-ben \u00e9s <code>NameMaskingAnonymizer</code>-ben megfelel\u0151 megval\u00f3s\u00edt\u00e1s (override)</li> </ul> <p>Ennek egyel\u0151re k\u00fcl\u00f6n\u00f6sebb tanuls\u00e1ga nincs, de a k\u00f6vetkez\u0151 l\u00e9p\u00e9sben m\u00e1r lesz.</p>"},{"location":"labor/6-tervezesi-mintak/#6-megoldas-3-templatemethodtemplatemethod-3-progressmultiple","title":"6. Megold\u00e1s (3-TemplateMethod/TemplateMethod-3-ProgressMultiple)","text":"<p>\u00daj - \u00e9s teljesen logikus - ig\u00e9ny mer\u00fclt fel: a j\u00f6v\u0151ben b\u00e1rmely anonimiz\u00e1l\u00f3 algoritmust b\u00e1rmely progress megjelen\u00edt\u00e9ssel lehessen haszn\u00e1lni. Ez jelen pillanatban n\u00e9gy keresztkombin\u00e1ci\u00f3t jelent:</p> Anonimiz\u00e1l\u00f3 Progress N\u00e9v anonimiz\u00e1l\u00f3 Egyszer\u0171 progress N\u00e9v anonimiz\u00e1l\u00f3 Sz\u00e1zal\u00e9k progress Kor anonimiz\u00e1l\u00f3 Egyszer\u0171 progress Kor anonimiz\u00e1l\u00f3 Sz\u00e1zal\u00e9k progress <p>Ugorjunk a k\u00e9sz megold\u00e1sra (3-TemplateMethod/TemplateMethod-3-ProgressMultiple projekt). K\u00f3d helyett a <code>Main.cd</code> oszt\u00e1lydiagramot nyissuk meg a projektben, \u00e9s a megold\u00e1st az alapj\u00e1n tekintj\u00fck \u00e1t (vagy n\u00e9zhetj\u00fck a diagramot al\u00e1bb az \u00fatmutat\u00f3ban).</p> Template Method alap\u00fa megold\u00e1s (k\u00e9t aspektus) oszt\u00e1lydiagram <p></p> <p>\u00c9rezhet\u0151, hogy valami \"baj van\", minden keresztkombin\u00e1ci\u00f3nak k\u00fcl\u00f6n lesz\u00e1rmazottat kellett l\u00e9trehozni. S\u0151t, a k\u00f3dduplik\u00e1ci\u00f3 cs\u00f6kkent\u00e9s\u00e9re m\u00e9g plusz, k\u00f6ztes oszt\u00e1lyok is vannak a hierarchi\u00e1ban. R\u00e1ad\u00e1sul:</p> <ul> <li>Ha a j\u00f6v\u0151ben \u00faj anonimiz\u00e1l\u00f3 algoritmust vezet\u00fcnk be, annyi \u00faj oszt\u00e1lyt kell \u00edrni (legal\u00e1bb), ah\u00e1ny progress t\u00edpust t\u00e1mogatunk.</li> <li>Ha a j\u00f6v\u0151ben \u00faj progress t\u00edpust vezet\u00fcnk be, annyi \u00faj oszt\u00e1lyt kell \u00edrni (legal\u00e1bb), ah\u00e1ny anonimiz\u00e1l\u00f3 t\u00edpust t\u00e1mogatunk.</li> </ul> <p>Mi okozta a probl\u00e9m\u00e1t? Az, hogy az oszt\u00e1lyunk viselked\u00e9s\u00e9t t\u00f6bb aspektus/dimenzi\u00f3 ment\u00e9n (p\u00e9ld\u00e1nkban az anonimiz\u00e1l\u00e1s \u00e9s progress) kell kiterjeszthet\u0151v\u00e9 tenni, \u00e9s ezeket sok keresztkombin\u00e1ci\u00f3ban kell t\u00e1mogatni. Ha \u00fajabb aspektusok ment\u00e9n kellene ezt megtenni (pl. beolvas\u00e1s m\u00f3dja, kimenet gener\u00e1l\u00e1sa), akkor a probl\u00e9ma exponenci\u00e1lisan tov\u00e1bb \"robbanna\". Ilyen esetekben a Template Method tervez\u00e9si minta nem alkalmazhat\u00f3.</p>"},{"location":"labor/6-tervezesi-mintak/#7-megoldas-4-strategystrategy-1","title":"7. Megold\u00e1s (4-Strategy/Strategy-1)","text":"<p>Ebben a l\u00e9p\u00e9sben a Strategy tervez\u00e9si minta alkalmaz\u00e1s\u00e1val fogjuk a kezdeti megold\u00e1sunkat a sz\u00fcks\u00e9ges pontokban kiterjeszthet\u0151v\u00e9 tenni. A mint\u00e1ban a k\u00f6vetkez\u0151 elvek ment\u00e9n val\u00f3sul meg a \"v\u00e1ltozatlan/\u00fajrafelhaszn\u00e1lhat\u00f3\" \u00e9s \"v\u00e1ltoz\u00f3\" r\u00e9szek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa:</p> <ul> <li>A \"k\u00f6z\u00f6s/v\u00e1ltozatlan\" r\u00e9szeket egy adott oszt\u00e1lyba tessz\u00fck (de ez most nem egy \"\u0151soszt\u00e1ly\" lesz).</li> <li>A Template Methoddal szemben nem \u00f6r\u00f6kl\u00e9st, hanem kompoz\u00edci\u00f3t (tartalmaz\u00e1st) alkalmazunk: interf\u00e9szk\u00e9nt tartalmazott m\u00e1s objektumokra b\u00edzzuk a viselked\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1t a kiterjeszt\u00e9si pontokban (\u00e9s nem absztrakt/virtu\u00e1lis f\u00fcggv\u00e9nyekre).</li> <li>Mindezt az oszt\u00e1ly viselked\u00e9s\u00e9nek minden olyan aspektus\u00e1ra/dimenzi\u00f3j\u00e1ra, melyet lecser\u00e9lhet\u0151v\u00e9/b\u0151v\u00edthet\u0151v\u00e9 szeretn\u00e9nk tenni, egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl megtessz\u00fck. Mint l\u00e1tni fogjuk, ezzel az el\u0151z\u0151 fejezetben tapasztalt kombinatorikus robban\u00e1s elker\u00fclhet\u0151.</li> </ul> <p>Ez sokkal egyszer\u0171bb a gyakorlatban, mint amilyennel le\u00edrva \u00e9rz\u0151dik (m\u00e1r haszn\u00e1ltuk is p\u00e1rszor kor\u00e1bbi tanulm\u00e1nyaink sor\u00e1n). \u00c9rts\u00fck meg a p\u00e9ld\u00e1nkra vet\u00edtve.</p> <p>A k\u00f6vetkez\u0151kben tekints\u00fck \u00e1t a Strategy alap\u00fa megold\u00e1st illusztr\u00e1l\u00f3 oszt\u00e1lydiagramot (a diagramot k\u00f6vet\u0151 magyar\u00e1zatra \u00e9p\u00edtve).</p> Strategy alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Strategy alap\u00fa megold\u00e1st, a l\u00e9nyegre f\u00f3kusz\u00e1lva:</p> <p></p> <p>A Strategy minta alkalmaz\u00e1s\u00e1nak els\u0151 l\u00e9p\u00e9se, hogy meghat\u00e1rozzuk, az oszt\u00e1ly viselked\u00e9s\u00e9nek h\u00e1ny k\u00fcl\u00f6nb\u00f6z\u0151 aspektusa van, melyet kiterjeszthet\u0151v\u00e9 szeretn\u00e9nk tenni. A p\u00e9ld\u00e1nkban ebb\u0151l - egyel\u0151re legal\u00e1bbis - kett\u0151 van:</p> <ul> <li>Anonimiz\u00e1l\u00e1shoz k\u00f6t\u0151d\u0151 viselked\u00e9s, melyhez k\u00e9t m\u0171velet tartozik:<ul> <li>Anonimiz\u00e1l\u00f3 logika</li> <li>Anonimiz\u00e1l\u00f3 logika le\u00edr\u00e1s\u00e1nak meghat\u00e1roz\u00e1sa (description string el\u0151\u00e1ll\u00edt\u00e1sa)</li> </ul> </li> <li>Progress kezel\u00e9s, melyhez egy m\u0171velet tartozik:<ul> <li>Progress megjelen\u00edt\u00e9se</li> </ul> </li> </ul> <p>A nehez\u00e9vel meg is vagyunk, ett\u0151l kezdve alapvet\u0151en mechanikusan lehet dolgozni a Strategy mint\u00e1t k\u00f6vetve:</p> <ol> <li>A fenti aspektusok mindegyik\u00e9hez egy-egy strategy interf\u00e9szt kell bevezetni, a fent meghat\u00e1rozott m\u0171veletekkel, \u00e9s ezekhez el kell k\u00e9sz\u00edteni a megfelel\u0151 implement\u00e1ci\u00f3kat.</li> <li>Az <code>Anonymizer</code> oszt\u00e1lyba be kell vezetni egy-egy strategy interf\u00e9sz tagv\u00e1ltoz\u00f3t, \u00e9s a kiterjeszt\u00e9si pontokban ezen tagv\u00e1ltoz\u00f3kon kereszt\u00fcl haszn\u00e1lni az aktu\u00e1lisan be\u00e1ll\u00edtott strategy implement\u00e1ci\u00f3s objektumokat.</li> </ol> <p>A fenti oszt\u00e1lydiagramon meg is jelennek ezek az elemek. Most t\u00e9rj\u00fcnk \u00e1t a k\u00f3dra. Kiindul\u00f3 k\u00f6rnyezet\u00fcnk a \"4-Strategy\" mapp\u00e1ban a \"Strategy-0-Begin\" projektben tal\u00e1lhat\u00f3, ebben dolgozzunk. Ez ugyanaz, az enum-ot haszn\u00e1l\u00f3 megold\u00e1s, mint amelyet a Template Method minta eset\u00e9ben is kiindul\u00e1sk\u00e9nt haszn\u00e1ltunk. </p>"},{"location":"labor/6-tervezesi-mintak/#anonimizalasi-strategia","title":"Anonimiz\u00e1l\u00e1si strat\u00e9gia","text":"<p>Az anonimiz\u00e1l\u00e1si strat\u00e9gia/aspektus kezel\u00e9s\u00e9vel kezd\u00fcnk. Vezess\u00fck be az ehhez tartoz\u00f3 interf\u00e9szt:</p> <ol> <li>Hozzunk l\u00e9tre a projektben egy <code>AnonymizerAlgorithms</code> nev\u0171 mapp\u00e1t (jobb katt a \"Strategy-0-Begin\" projekten, majd Add/New Folder men\u00fc). A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben minden interf\u00e9szt \u00e9s oszt\u00e1lyt egy k\u00fcl\u00f6n, a nev\u00e9nek megfelel\u0151 forr\u00e1sf\u00e1jlba tegy\u00fcnk a szok\u00e1sos m\u00f3don!</li> <li> <p>Vegy\u00fcnk fel ebben a mapp\u00e1ban egy <code>IAnonymizerAlgorithm</code> interf\u00e9szt az al\u00e1bbi k\u00f3ddal:</p> IAnonymizerAlgorithm.cs<pre><code>public interface IAnonymizerAlgorithm\n{\n    Person Anonymize(Person person);\n    string GetAnonymizerDescription() =&gt; GetType().Name;\n}\n</code></pre> <p>Azt is megfigyelhetj\u00fck a <code>GetAnonymizerDescription</code> m\u0171velet eset\u00e9ben, hogy a modern C# nyelven, amennyiben akarunk, tudunk az egyes interf\u00e9sz m\u0171veleteknek alap\u00e9rtelmezett implement\u00e1ci\u00f3t adni!</p> </li> </ol> <p>Most ennek az interf\u00e9sznek a n\u00e9v anonimiz\u00e1l\u00e1shoz tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t k\u00e9sz\u00edtj\u00fck el (vagyis egy strategy implement\u00e1ci\u00f3t k\u00e9sz\u00edt\u00fcnk). </p> <ol> <li>Vegy\u00fcnk fel egy <code>NameMaskingAnonymizerAlgorithm</code> oszt\u00e1lyt ugyenebbe a mapp\u00e1ba.</li> <li>Az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l mozgassuk \u00e1t a <code>NameMaskingAnonymizerAlgorithm</code>-be az ide tartoz\u00f3 <code>_mask</code> tagv\u00e1ltoz\u00f3t:</li> <li> <p>A <code>NameMaskingAnonymizerAlgorithm</code>-be vegy\u00fck fel a k\u00f6vetkez\u0151 konstruktort:</p> <pre><code>public NameMaskingAnonymizerAlgorithm(string mask)\n{\n    _mask = mask;\n}\n</code></pre> </li> <li> <p>Val\u00f3s\u00edtsuk meg a <code>IAnonymizerAlgorithm</code> interf\u00e9szt. Miut\u00e1n az oszt\u00e1ly neve ut\u00e1n be\u00edrjuk a <code>: IAnonymizerAlgorithm</code> interf\u00e9szt, c\u00e9lszer\u0171 a m\u0171veletek v\u00e1z\u00e1t a Visual Studioval legener\u00e1ltatni: tegy\u00fck a kurzort a interf\u00e9sz nev\u00e9re (kattintsunk r\u00e1 a forr\u00e1sk\u00f3dban), haszn\u00e1ljuk a 'ctrl' + '.' billenty\u0171kombin\u00e1ci\u00f3t, majd a megjelen\u0151 men\u00fcben \"Implement interface\" kiv\u00e1laszt\u00e1sa. Megjegyz\u00e9s: mivel a <code>GetAnonymizerDescription</code> m\u0171velethez van alap\u00e9rtelmezett implement\u00e1ci\u00f3 az interf\u00e9szben, csak az <code>Anonymize</code> m\u0171velet gener\u00e1l\u00f3dik le, de ez most nek\u00fcnk egyel\u0151re rendben van \u00edgy. </p> </li> <li>Az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l vegy\u00fck \u00e1t a <code>Anonymize_MaskName</code> m\u0171velet t\u00f6rzs\u00e9t a <code>NameMaskingAnonymizerAlgorithm</code>.<code>Anonymize</code>-be. A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a m\u00e1r nem l\u00e9tez\u0151 <code>mask</code> param\u00e9tert, hanem a <code>_mask</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja. Az <code>Anonymize</code> oszt\u00e1ly <code>Anonymize_MaskName</code>-et pedig t\u00f6r\u00f6lj\u00fck.</li> <li> <p>A stategy interf\u00e9sz <code>GetAnonymizerDescription</code>m\u0171velet\u00e9nek megval\u00f3s\u00edt\u00e1s\u00e1ra t\u00e9r\u00fcnk most \u00e1t. Az <code>Anonymizer</code> oszt\u00e1ly <code>GetAnonymizerDescription</code> m\u0171velet\u00e9t m\u00e1soljuk \u00e1t a <code>NameMaskingAnonymizerAlgorithm</code>-be, a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben csak a n\u00e9v anonimiz\u00e1l\u00f3ra vonatkoz\u00f3 logik\u00e1t meghagyva, a m\u0171veletet publikuss\u00e1 t\u00e9ve:</p> <pre><code>public string GetAnonymizerDescription()\n{\n    return $\"NameMasking anonymizer with mask {_mask}\";\n}  \n</code></pre> </li> <li> Ezzel a n\u00e9v anonimiz\u00e1l\u00e1shoz tartoz\u00f3 strategy implement\u00e1ci\u00f3nk elk\u00e9sz\u00fclt, a teljes k\u00f3dja a k\u00f6vetkez\u0151 lett NameMaskingAnonymizerAlgorithm.cs<pre><code>public class NameMaskingAnonymizerAlgorithm: IAnonymizerAlgorithm\n{\n    private readonly string _mask;\n\n    public NameMaskingAnonymizerAlgorithm(string mask)\n    {\n        _mask = mask;\n    }\n\n    public Person Anonymize(Person person)\n    {\n        return new Person(_mask, _mask, person.CompanyName,\n            person.Address, person.City, person.State, person.Age, person.Weight, person.Decease);\n    }\n\n    public string GetAnonymizerDescription()\n    {\n        return $\"NameMasking anonymizer with mask {_mask}\";\n    }\n}\n</code></pre> </li> </ol> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben az <code>IAnonymizerAlgorithm</code> strategy interf\u00e9sz\u00fcnk \u00e9letkor anonimiz\u00e1l\u00e1shoz tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t k\u00e9sz\u00edtj\u00fck el.</p> <ol> <li>Vegy\u00fcnk fel egy <code>AgeAnonymizerAlgorithm</code> oszt\u00e1lyt ugyenebbe a mapp\u00e1ba (AnonymizerAlgorithms).</li> <li>Az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l mozgassuk \u00e1t a <code>AgeAnonymizerAlgorithm</code>-be az ide tartoz\u00f3 <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t:</li> <li> <p>A <code>AgeAnonymizerAlgorithm</code>-be vegy\u00fck fel a k\u00f6vetkez\u0151 konstruktort:</p> <pre><code>public AgeAnonymizerAlgorithm(int rangeSize)\n{\n    _rangeSize = rangeSize;\n}\n</code></pre> </li> <li> <p>Val\u00f3s\u00edtsuk meg a <code>IAnonymizerAlgorithm</code> interf\u00e9szt. Miut\u00e1n az oszt\u00e1ly neve ut\u00e1n be\u00edrjuk a <code>: IAnonymizerAlgorithm</code> interf\u00e9szt, most is c\u00e9lszer\u0171 az <code>Anonymize</code> m\u0171velet v\u00e1z\u00e1t a Visual Studioval a kor\u00e1bbihoz hasonl\u00f3 m\u00f3don legener\u00e1ltatni. </p> </li> <li>Az <code>Anonymizer</code> oszt\u00e1lyb\u00f3l vegy\u00fck \u00e1t az <code>Anonymize_AgeRange</code> m\u0171velet t\u00f6rzs\u00e9t a <code>AgeAnonymizerAlgorithm</code>.<code>Anonymize</code>-be. A f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t csak annyiban kell \u00e1t\u00edrni, hogy ne a m\u00e1r nem l\u00e9tez\u0151 <code>rangeSize</code> param\u00e9tert, hanem a <code>_rangeSize</code> tagv\u00e1ltoz\u00f3t haszn\u00e1lja. Az <code>Anonymize</code> oszt\u00e1ly <code>Anonymize_AgeRange</code>-et pedig t\u00f6r\u00f6lj\u00fck.</li> <li> <p>A stategy interf\u00e9sz <code>GetAnonymizerDescription</code>m\u0171velet\u00e9nek megval\u00f3s\u00edt\u00e1s\u00e1ra t\u00e9r\u00fcnk most \u00e1t. Az <code>Anonymizer</code> oszt\u00e1ly <code>GetAnonymizerDescription</code> m\u0171velet\u00e9t m\u00e1soljuk \u00e1t az <code>AgeAnonymizerAlgorithm</code>-be, a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben csak a kor anonimiz\u00e1l\u00f3ra vonatkoz\u00f3 logik\u00e1t meghagyva, a m\u0171veletet publikuss\u00e1 t\u00e9ve:</p> <pre><code>public string GetAnonymizerDescription()\n{\n    return $\"Age anonymizer with range size {_rangeSize}\";\n} \n</code></pre> </li> <li> Ezzel a kor anonimiz\u00e1l\u00e1shoz tartoz\u00f3 strategy implement\u00e1ci\u00f3nk elk\u00e9sz\u00fclt, a teljes k\u00f3dja a k\u00f6vetkez\u0151 lett AgeAnonymizerAlgorithm.cs<pre><code>public class AgeAnonymizerAlgorithm: IAnonymizerAlgorithm\n{\n    private readonly int _rangeSize;\n\n    public AgeAnonymizerAlgorithm(int rangeSize)\n    {\n        _rangeSize = rangeSize;\n    }\n\n    public Person Anonymize(Person person)\n    {\n        // This is whole number integer arithmetics, e.g for 55 / 20 we get 2\n        int rangeIndex = int.Parse(person.Age) / _rangeSize;\n        string newAge = $\"{rangeIndex * _rangeSize}..{(rangeIndex + 1) * _rangeSize}\";\n\n        return new Person(person.FirstName, person.LastName, person.CompanyName,\n            person.Address, person.City, person.State, newAge,\n            person.Weight, person.Decease);\n    }\n\n    public string GetAnonymizerDescription()\n    {\n        return $\"Age anonymizer with range size {_rangeSize}\";\n    }\n}\n</code></pre> </li> </ol> <p> Mindenk\u00e9ppen figyelj\u00fck meg, hogy az interf\u00e9sz \u00e9s a megval\u00f3s\u00edt\u00e1sai kiz\u00e1r\u00f3lag az anonimiz\u00e1l\u00e1ssal foglalkoznak, semmif\u00e9le m\u00e1s logika (pl. progress kezel\u00e9s) nincs itt!</p>"},{"location":"labor/6-tervezesi-mintak/#progress-strategia","title":"Progress strat\u00e9gia","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben vezess\u00fck be a progress kezel\u00e9shez tartoz\u00f3 interf\u00e9szt \u00e9s implement\u00e1ci\u00f3kat:</p> <ol> <li>Hozzunk l\u00e9tre a projektben egy <code>Progresses</code> nev\u0171 mapp\u00e1t. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben minden interf\u00e9szt \u00e9s oszt\u00e1lyt egy k\u00fcl\u00f6n, a nev\u00e9nek megfelel\u0151 forr\u00e1sf\u00e1jlba tegy\u00fcnk a szok\u00e1sos m\u00f3don.</li> <li> <p>Vegy\u00fcnk fel ebben a mapp\u00e1ban egy <code>IProgress</code> interf\u00e9szt az al\u00e1bbi k\u00f3ddal:</p> Megold\u00e1s IProgress.cs<pre><code>public interface IProgress\n{\n    void Report(int count, int index);\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek az egyszer\u0171 progresshez tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba. Az implement\u00e1ci\u00f3 az <code>Anonymizer</code> oszt\u00e1lyunk <code>PrintProgress</code> m\u0171velet\u00e9b\u0151l lett \"levezetve\":</p> Megold\u00e1s SimpleProgress.cs<pre><code>public class SimpleProgress: IProgress\n{\n    public void Report(int count, int index)\n    {\n        Console.WriteLine($\"{index + 1}. person processed\");\n    }\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel ennek az interf\u00e9sznek a sz\u00e1zal\u00e9kos progresshez tartoz\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1t ugyanebbe a mapp\u00e1ba. A k\u00f3d \u00e9rtelmez\u00e9s\u00e9vel ne foglalkozzunk. Erre megold\u00e1s az <code>Anonymizer</code> oszt\u00e1lyunkban nincs, hiszen ezt csak a template method alap\u00fa megold\u00e1sunkn\u00e1l vezett\u00fck be (ott nem n\u00e9zt\u00fck a k\u00f3dj\u00e1t, de azzal gyakorlatilag megegyezik a l\u00e9nyege):</p> Megold\u00e1s PercentProgress.cs<pre><code>public class PercentProgress: IProgress\n{\n    public void Report(int count, int index)\n    {\n        int percentage = (int)((double)(index+1) / count * 100);\n\n        var pos = Console.GetCursorPosition();\n        Console.SetCursorPosition(0, pos.Top);\n\n        Console.Write($\"Processing: {percentage} %\");\n\n        if (index == count - 1)\n            Console.WriteLine();\n    }\n}\n</code></pre> </li> </ol> <p> Mindenk\u00e9ppen figyelj\u00fck meg, hogy az interf\u00e9sz \u00e9s a megval\u00f3s\u00edt\u00e1sai kiz\u00e1r\u00f3lag a progress kezel\u00e9ssel foglalkoznak, semmif\u00e9le m\u00e1s logika (pl. anonimiz\u00e1l\u00e1s) nincs itt!</p>"},{"location":"labor/6-tervezesi-mintak/#a-strategiak-alkalmazasa","title":"A strat\u00e9gi\u00e1k alkalmaz\u00e1sa","text":"<p>A k\u00f6vetkez\u0151 fontos l\u00e9p\u00e9s az anonimiz\u00e1l\u00f3 alaposzt\u00e1ly \u00fajrafelhaszn\u00e1lhat\u00f3v\u00e1 \u00e9s kiterjeszthet\u0151v\u00e9 t\u00e9tele a fent bevezetett strategy-k seg\u00edts\u00e9g\u00e9vel. Az <code>Anonymizer.cs</code> f\u00e1jlban:</p> <ol> <li> <p>T\u00f6r\u00f6lj\u00fck a k\u00f6vetkez\u0151ket:</p> <ul> <li><code>AnonymizerMode</code> enum t\u00edpus</li> <li><code>_anonymizerMode</code> tag (illetve a <code>_mask</code> \u00e9s <code>_rangeSize</code> tagok, ha esetleg itt maradtak kor\u00e1bban)</li> </ul> </li> <li> <p>Vezess\u00fcnk be egy-egy strategy interf\u00e9sz t\u00edpus\u00fa tagot:</p> <pre><code>private readonly IProgress _progress;\nprivate readonly IAnonymizerAlgorithm _anonymizerAlgorithm;\n</code></pre> </li> <li> <p>A f\u00e1jl elej\u00e9re sz\u00farjunk be a megfelel\u0151 usingokat:</p> <pre><code>using Lab_Extensibility.AnonymizerAlgorithms;\nusing Lab_Extensibility.Progresses;\n</code></pre> </li> <li> <p>Az el\u0151z\u0151 pontban bevezetett <code>_progress</code> \u00e9s <code>_anonymizerAlgorithm</code> kezd\u0151\u00e9rt\u00e9ke null, a konstruktorban \u00e1ll\u00edtsuk ezeket a referenci\u00e1kat az ig\u00e9nyeinknek megfelel\u0151 implement\u00e1ci\u00f3ra. Pl.:</p> <pre><code>public Anonymizer(string inputFileName, string mask) : this(inputFileName)\n{\n    _progress = new PercentProgress();\n    _anonymizerAlgorithm = new NameMaskingAnonymizerAlgorithm(mask);\n}\n\npublic Anonymizer(string inputFileName, int rangeSize) : this(inputFileName)\n{\n    _progress = new PercentProgress();\n    _anonymizerAlgorithm = new AgeAnonymizerAlgorithm(rangeSize);\n}\n</code></pre> </li> </ol> <p>Az <code>Anonymizer</code> oszt\u00e1lyban a jelenleg be\u00e9getett, de anonimiz\u00e1l\u00e1s f\u00fcgg\u0151 logik\u00e1kat b\u00edzzuk a <code>_anonymizerAlgorithm</code> tagv\u00e1ltoz\u00f3 \u00e1ltal hivatkozott strategy implement\u00e1ci\u00f3ra:</p> <ol> <li> <p>Az oszt\u00e1ly <code>Run</code> f\u00fcggv\u00e9ny\u00e9ben az <code>if</code>/<code>else</code> kifejez\u00e9sben tal\u00e1lhat\u00f3 <code>Anonymize</code> h\u00edv\u00e1sokat most m\u00e1r deleg\u00e1ljuk a <code>_anonymizerAlgorithm</code> objektumnak:</p> <pre><code>Person person;\nif (_anonymizerMode == AnonymizerMode.Name)\n    person = Anonymize_MaskName(persons[i], _mask);\nelse if (_anonymizerMode == AnonymizerMode.Age)\n    person = Anonymize_AgeRange(persons[i], _rangeSize);\nelse\n    throw new NotSupportedException(\"The requested anonymization mode is not supported.\");\n</code></pre> <p>helyett:</p> <pre><code>Person person = _anonymizerAlgorithm.Anonymize(persons[i]);\n</code></pre> </li> <li> <p>Ha esetleg kor\u00e1bban nem tett\u00fck meg, t\u00f6r\u00f6lj\u00fck a <code>Anonymize_MaskName</code> \u00e9s <code>Anonymize_AgeRange</code> f\u00fcggv\u00e9nyeket, hiszen ezek k\u00f3dja m\u00e1r a strategy implement\u00e1ci\u00f3kba ker\u00fclt, az oszt\u00e1lyr\u00f3l lev\u00e1lasztva.</p> </li> <li> <p>A <code>PrintSummary</code> f\u00fcggv\u00e9ny\u00fcnk a rugalmatlan, <code>switch</code> alapokon m\u0171k\u00f6d\u0151 <code>GetAnonymizerDescription</code>-t h\u00edvja. Ezt a <code>GetAnonymizerDescription</code> h\u00edv\u00e1st cser\u00e9lj\u00fck le, deleg\u00e1ljuk a <code>_anonymizerAlgorithm</code> objektumnak. A <code>PrintSummary</code> f\u00fcggv\u00e9nyben (csak a l\u00e9nyeget kiemelve):</p> <pre><code>    ... GetAnonymizerDescription() ...\n</code></pre> <p>helyett:</p> <pre><code>    ... _anonymizerAlgorithm.GetAnonymizerDescription() ...\n</code></pre> <p>P\u00e1r sorral lejjebb a <code>GetAnonymizerDescription</code> f\u00fcggv\u00e9nyt t\u00f6r\u00f6lj\u00fck is az oszt\u00e1lyb\u00f3l (ennek k\u00f3dja megfelel\u0151 strategy implement\u00e1ci\u00f3kba bek\u00fclt).</p> </li> </ol> <p>Az utols\u00f3 l\u00e9p\u00e9s az <code>Anonymizer</code> oszt\u00e1lyba be\u00e9getett progress kezel\u00e9s lecser\u00e9l\u00e9se:</p> <ol> <li> <p>Itt is deleg\u00e1ljuk a k\u00e9r\u00e9st, m\u00e9gpedig a kor\u00e1bban bevezetett <code>_progress</code> objektumunknak. A <code>Run</code> f\u00fcggv\u00e9nyben egy sort kell ehhez lecser\u00e9lni:</p> <pre><code>PrintProgress(i);\n</code></pre> <p>helyett:</p> <pre><code>_progress.Report(persons.Count, i);\n</code></pre> </li> <li> <p>T\u00f6r\u00f6lj\u00fck a <code>PrintProgress</code> f\u00fcggv\u00e9nyt, hiszen ennek k\u00f3dja m\u00e1r egy megfelel\u0151 strategy implement\u00e1ci\u00f3ba ker\u00fclt, az oszt\u00e1lyr\u00f3l lev\u00e1lasztva.</p> </li> </ol> <p>Elk\u00e9sz\u00fclt\u00fcnk, a k\u00e9sz megold\u00e1s a \"4-Strategy/Strategy-1\" projektben meg is tal\u00e1lhat\u00f3 (ha valahol elakadtunk, vagy nem fordul a k\u00f3d, ezzel \u00f6ssze lehet n\u00e9zni).</p>"},{"location":"labor/6-tervezesi-mintak/#a-megoldas-ertekelese_3","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>A strategy minta bevezet\u00e9s\u00e9vel elk\u00e9sz\u00fclt\u00fcnk. Jelen form\u00e1j\u00e1ban ugyanakkor szinte soha nem haszn\u00e1ljuk. Ellen\u0151rizz\u00fck a megold\u00e1sunkat: val\u00f3ban \u00fajrafelhaszn\u00e1lhat\u00f3, \u00e9s az <code>Anomymizer</code> oszt\u00e1ly m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl lehet\u0151s\u00e9g van-e az anonimiz\u00e1l\u00f3 algoritmus, illetve a progress kezel\u00e9s megv\u00e1ltoztat\u00e1s\u00e1ra? Ehhez azt kell megn\u00e9zni, b\u00e1rhol az oszt\u00e1lyban van-e olyan k\u00f3d, mely implement\u00e1ci\u00f3 f\u00fcgg\u0151.</p> <p>Sajnos tal\u00e1lunk ilyet. A konstruktorba be van \u00e9getve, milyen algoritmus implement\u00e1ci\u00f3t \u00e9s progress implement\u00e1ci\u00f3t hozunk l\u00e9tre. Ezt mindenk\u00e9ppen n\u00e9zz\u00fck meg a k\u00f3dban! Ha algoritmus vagy progress m\u00f3dot akarunk v\u00e1ltoztatni, ezekben a sorokban \u00e1t kell \u00edrni a <code>new</code> oper\u00e1tor ut\u00e1ni t\u00edpust, mely \u00edgy az oszt\u00e1ly m\u00f3dos\u00edt\u00e1s\u00e1val j\u00e1r.</p> <p>Sokan - teljesen jogosan - ezt jelen form\u00e1j\u00e1ban nem is tekintik igazi Strategy alap\u00fa megold\u00e1snak. A teljes k\u00f6r\u0171 megold\u00e1st a k\u00f6vetkez\u0151 l\u00e9p\u00e9sben val\u00f3s\u00edtjuk meg.</p>"},{"location":"labor/6-tervezesi-mintak/#8-megoldas-4-strategystrategy-2-di","title":"8. Megold\u00e1s (4-Strategy/Strategy-2-DI)","text":"<p> Dependency Injection (DI) A megold\u00e1st a Dependency Injection (r\u00f6viden DI) alkalmaz\u00e1sa jelenti. Ennek l\u00e9nyege az, hogy nem maga az oszt\u00e1ly p\u00e9ld\u00e1nyos\u00edtja a viselked\u00e9sbeli f\u00fcgg\u0151s\u00e9geit (ezek a strategy implement\u00e1ci\u00f3k), hanem ezeket k\u00edv\u00fclr\u0151l adjuk \u00e1t neki, pl. konstruktor param\u00e9terekben, vagy ak\u00e1r property-k vagy setter m\u0171veletek form\u00e1j\u00e1ban. Term\u00e9szetesen interf\u00e9sz t\u00edpusk\u00e9nt hivatkozva!</p> <p>Alak\u00edtsuk \u00e1t ennek megfelel\u0151en az <code>Anonymizer</code> oszt\u00e1lyt \u00fagy, hogy ne maga p\u00e9ld\u00e1nyos\u00edtsa a strategy implement\u00e1ci\u00f3it, hanem konstruktor param\u00e9terekben kapja meg azokat:</p> <ol> <li>T\u00f6r\u00f6lj\u00fck mindh\u00e1rom konstruktor\u00e1t</li> <li> <p>Vegy\u00fck fel a k\u00f6vetkez\u0151 konstruktort:</p> <pre><code>public Anonymizer(string inputFileName, IAnonymizerAlgorithm anonymizerAlgorithm, IProgress progress = null)\n{\n    ArgumentException.ThrowIfNullOrEmpty(inputFileName);\n    ArgumentNullException.ThrowIfNull(anonymizerAlgorithm);\n\n    _inputFileName = inputFileName;\n    _anonymizerAlgorithm = anonymizerAlgorithm;\n    _progress = progress;\n}\n</code></pre> <p>Mint l\u00e1that\u00f3, a <code>progress</code> param\u00e9ter megad\u00e1sa nem k\u00f6telez\u0151, hiszen lehet, hogy az oszt\u00e1ly haszn\u00e1l\u00f3ja nem k\u00edv\u00e1ncsi semmif\u00e9le progress inform\u00e1ci\u00f3ra.</p> </li> <li> <p>Mivel a _progress strategy null is lehet, egy null vizsg\u00e1latot be kell vezess\u00fcnk a haszn\u00e1lata sor\u00e1n. A \".\" oper\u00e1tor helyett a \"?.\" oper\u00e1tort haszn\u00e1ljuk:</p> <pre><code>_progress?.Report(persons.Count,i);\n</code></pre> </li> <li> <p>Most m\u00e1r elk\u00e9sz\u00fclt\u00fcnk, az <code>Anonymizer</code> oszt\u00e1ly teljesen f\u00fcggetlen lett a strategy implement\u00e1ci\u00f3kt\u00f3l. Lehet\u0151s\u00e9g\u00fcnk van az <code>Anonymizer</code> oszt\u00e1lyt b\u00e1rmilyen anonimiz\u00e1l\u00f3 algoritmus \u00e9s b\u00e1rmilyen progress kezel\u00e9s kombin\u00e1ci\u00f3val haszn\u00e1lni (annak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl). Hozzunk is l\u00e9tre h\u00e1rom <code>Anonymizer</code> k\u00fcl\u00f6nb\u00f6z\u0151 kombin\u00e1ci\u00f3kkal a <code>Program.cs</code> f\u00e1jl <code>Main</code> f\u00fcggv\u00e9ny\u00e9ben (a megl\u00e9v\u0151 k\u00f3dot el\u0151tte t\u00f6r\u00f6lj\u00fck a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l):</p> <pre><code>Anonymizer p1 = new(\"us-500.csv\",\n    new NameMaskingAnonymizerAlgorithm(\"***\"),\n    new SimpleProgress());\np1.Run();\n\nConsole.WriteLine(\"--------------------\");\n\nAnonymizer p2 = new(\"us-500.csv\",\n    new NameMaskingAnonymizerAlgorithm(\"***\"),\n    new PercentProgress());\np2.Run();\n\nConsole.WriteLine(\"--------------------\");\n\nAnonymizer p3 = new(\"us-500.csv\",\n    new AgeAnonymizerAlgorithm(20),\n    new SimpleProgress());\np3.Run();\n</code></pre> </li> <li> <p>Ahhoz, hogy a k\u00f3d foruljon, sz\u00farjuk be a f\u00e1jl elej\u00e9re a sz\u00fcks\u00e9ges <code>using</code>-okat</p> <pre><code>using Lab_Extensibility.AnonymizerAlgorithms;\nusing Lab_Extensibility.Progresses;\n</code></pre> </li> </ol> <p>Elk\u00e9sz\u00fclt\u00fcnk, a k\u00e9sz megold\u00e1s a \"4-Strategy/Strategy-2-DI\" projektben meg is tal\u00e1lhat\u00f3 (ha valahol elakadtunk, vagy nem fordul a k\u00f3d, ezzel \u00f6ssze lehet n\u00e9zni).</p> <p>A m\u0171k\u00f6d\u00e9s ellen\u0151rz\u00e9se</p> <p>A gyakorlat sor\u00e1n erre val\u00f3sz\u00edn\u0171leg nem lesz id\u0151, de aki bizonytalan abban, \"mit\u0151l is m\u0171k\u00f6dik\" a strategy minta, mit\u0151l lesz m\u00e1s a viselked\u00e9s a fenti n\u00e9gy esetre: \u00e9rdemes t\u00f6r\u00e9spontokat tenni a <code>Program.cs</code> f\u00e1jlban a n\u00e9gy <code>Run</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sra, \u00e9s a f\u00fcggv\u00e9nyekbe a debuggerben belel\u00e9pkedve kipr\u00f3b\u00e1lni, hogy mindig a megfelel\u0151 strategy implement\u00e1ci\u00f3 h\u00edv\u00f3dik meg.</p> <p>A projektben tal\u00e1lhat\u00f3 egy oszt\u00e1lydiagram (<code>Main.cd</code>), ezen is megtekinthet\u0151 a k\u00e9sz megold\u00e1s:</p> Strategy alap\u00fa megold\u00e1s oszt\u00e1lydiagram <p>Az al\u00e1bbi UML oszt\u00e1lydiagram illusztr\u00e1lja a Strategy alap\u00fa megold\u00e1sunkat:</p> <p></p>"},{"location":"labor/6-tervezesi-mintak/#a-megoldas-ertekelese_4","title":"A megold\u00e1s \u00e9rt\u00e9kel\u00e9se","text":"<p>Ellen\u0151rizz\u00fck a megold\u00e1st, megval\u00f3s\u00edtja-e a c\u00e9ljainkat:</p> <ul> <li>Az <code>Anonymizer</code> egy \u00fajrafelhaszn\u00e1lhat\u00f3(bb) oszt\u00e1ly lett.</li> <li>Ha \u00faj anonimiz\u00e1l\u00f3 logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak egy \u00faj <code>IAnonymizerAlgorithm</code> implement\u00e1ci\u00f3t kell bevezetni. Ez nem m\u00f3dos\u00edt\u00e1s, hanem kiterjeszt\u00e9s/b\u0151v\u00edt\u00e9s.</li> <li>Ha \u00faj progress logik\u00e1ra van sz\u00fcks\u00e9g a j\u00f6v\u0151ben, csak egy \u00faj <code>IProgress</code> implement\u00e1ci\u00f3t kell bevezetni. Ez nem m\u00f3dos\u00edt\u00e1s, hanem b\u0151v\u00edt\u00e9s.</li> <li>A fenti k\u00e9t pontban teljes\u00fcl az OPEN/CLOSED elv, vagyis az <code>Anonymizer</code> k\u00f3dj\u00e1nak m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl tudjuk a logik\u00e1j\u00e1t testre szabni, kiterjeszteni.</li> <li>Itt nem kell tartani a Template Methodn\u00e1l tapasztalt kombinatorikus robban\u00e1st\u00f3l: b\u00e1rmely <code>IAnonymizerAlgorithm</code> implement\u00e1ci\u00f3 b\u00e1rmely <code>IProgress</code> implement\u00e1ci\u00f3val k\u00e9nyelmesen haszn\u00e1lhat\u00f3, nem kell a kombin\u00e1ci\u00f3khoz \u00faj oszt\u00e1lyokat bevezetni (ezt l\u00e1ttuk a <code>Program.cs</code> f\u00e1jlban).</li> </ul> <p>Tov\u00e1bbi Strategy el\u0151ny\u00f6k a Template Methoddal szemben *</p> <ul> <li>Fut\u00e1s k\u00f6zben lecser\u00e9lhet\u0151 viselked\u00e9s is megval\u00f3s\u00edthat\u00f3. Ha sz\u00fcks\u00e9g lenne arra, hogy egy adott <code>Anonymizer</code> objektumra vonatkoz\u00f3an a l\u00e9trehoz\u00e1sa ut\u00e1n meg tudjuk v\u00e1ltoztatni az anonimiz\u00e1l\u00f3 vagy progress viselked\u00e9st, akkor azt k\u00f6nnyen meg tudn\u00e1nk tenni (csak egy <code>SetAnonimizerAlgorithm</code>, ill. <code>SetProgress</code> m\u0171veletet kellene bevezetni, melyben a param\u00e9terben megkapott implement\u00e1ci\u00f3ra lehetne \u00e1ll\u00edtani az oszt\u00e1ly \u00e1ltal haszn\u00e1lt strategy-t).</li> <li>Egys\u00e9gtesztelhet\u0151s\u00e9g t\u00e1mogat\u00e1sa (laboron ezt nem n\u00e9zz\u00fck).</li> </ul>"},{"location":"labor/7-adatkezeles/","title":"7. Adatkezel\u00e9s","text":""},{"location":"labor/7-adatkezeles/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9lja az ADO.NET programoz\u00e1si modellj\u00e9nek megismer\u00e9se \u00e9s a leggyakoribb adatkezel\u00e9si probl\u00e9m\u00e1k, buktat\u00f3k szeml\u00e9ltet\u00e9se alapvet\u0151 CRUD m\u0171veletek meg\u00edr\u00e1s\u00e1n kereszt\u00fcl.</p> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok: Adatkezel\u00e9s, ADO.NET alapismeretek.</p>"},{"location":"labor/7-adatkezeles/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>A gyakorlat sor\u00e1n Visual Studio-ban az SQL Server Object Explorer-t fogjuk haszn\u00e1lni az adatb\u00e1zis objektumok k\u00f6z\u00f6tti navig\u00e1l\u00e1s\u00e1ra \u00e9s a lek\u00e9rdez\u00e9sek futtat\u00e1s\u00e1ra. Ehhez sz\u00fcks\u00e9g lehet az SQL Server Data Tools komponensre, melyet legegyszer\u0171bben az Individual Components oldalon tudunk telep\u00edteni a Visual Studio Installer-ben, de a Data Storage and Processing workload is tartalmazza ezt.</li> </ul> <p>Gyakorlat Linuxon vagy Macen</p> <p>A gyakorlat anyag alapvet\u0151en Windowsra \u00e9s Visual Studio-ra k\u00e9sz\u00fclt, de - n\u00e9mik\u00e9ppen m\u00e1s \u00faton - elv\u00e9gezhet\u0151 m\u00e1s oper\u00e1ci\u00f3s rendszereken is, mivel a .NET SDK t\u00e1mogatott Linuxon \u00e9s Mac-en is, Linuxon:</p> <ul> <li>Visual Studio helyett, sz\u00f6vegszerkeszt\u0151vel (pl.: VSCode) \u00e9s CLI eszk\u00f6z\u00f6kkel.</li> <li>Az SQL szervernek van Linuxos v\u00e1ltozata, Mac-en pedig Dockerben futtathat\u00f3 (de Linuxon is tal\u00e1n a Docker legk\u00e9nyelmesebb m\u00f3d a futtat\u00e1s\u00e1ra).</li> <li>Az adatok vizualiz\u00e1ci\u00f3j\u00e1ra haszn\u00e1lhat\u00f3 a szint\u00e9n keresztplatformos Azure Data Studio eszk\u00f6z.</li> </ul>"},{"location":"labor/7-adatkezeles/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-adatkezeles-megoldas</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/7-adatkezeles/#bevezeto","title":"Bevezet\u0151","text":"Megjegyz\u00e9s gyakorlatvezet\u0151knek <p>Ezt a fejezetet gyakorlaton nem kell a le\u00edrtaknak megfelel\u0151 r\u00e9szletess\u00e9ggel ismertetni, a fontosabb fogalmakat azonban mindenk\u00e9ppen ismertess\u00fck r\u00f6viden.</p>"},{"location":"labor/7-adatkezeles/#adonet","title":"ADO.NET","text":"<p>Alacsony szint\u0171 adatb\u00e1zis-kezel\u00e9sre a .NET platformon az ADO.NET \u00e1ll rendelkez\u00e9sre, seg\u00edts\u00e9g\u00e9vel rel\u00e1ci\u00f3s adatb\u00e1zisokat tudunk el\u00e9rni.</p> <p>Az ADO.NET haszn\u00e1lata sor\u00e1n k\u00e9t elt\u00e9r\u0151 adathozz\u00e1f\u00e9r\u00e9si modellt alkalmazhatunk:</p> <ul> <li>Kapcsolatalap\u00fa modell</li> <li>Kapcsolat n\u00e9lk\u00fcli modell</li> </ul> <p>Az al\u00e1bbi k\u00e9t blokkot lenyitva \u00e1ttekint\u00e9st kaphatunk a k\u00e9t modell alapelv\u00e9r\u0151l.</p> A Kapcsolatalap\u00fa modell alapelvei <p>L\u00e9nyege az, hogy az adatb\u00e1zis-kapcsolatot v\u00e9gig nyitva tartjuk, am\u00edg az adatokat lek\u00e9rdezz\u00fck, m\u00f3dos\u00edtjuk, majd a v\u00e1ltoztat\u00e1sokat az adatb\u00e1zisba vissza\u00edrjuk. A megold\u00e1sra DataReader objektumokat haszn\u00e1lhatunk (l\u00e1sd k\u00e9s\u0151bb). A megold\u00e1s el\u0151nye az egyszer\u0171s\u00e9g\u00e9ben rejlik (egyszer\u0171bb programoz\u00e1si modell \u00e9s konkurenciakezel\u00e9s). A megold\u00e1s h\u00e1tr\u00e1nya, hogy a folyamatosan fenntartott h\u00e1l\u00f3zati kapcsolat miatt sk\u00e1l\u00e1zhat\u00f3s\u00e1gi probl\u00e9m\u00e1k ad\u00f3dhatnak. Ez azt jelenti, hogy az adatkezel\u0151h\u00f6z t\u00f6rt\u00e9n\u0151 nagysz\u00e1m\u00fa p\u00e1rhuzamos felhaszn\u00e1l\u00f3i hozz\u00e1f\u00e9r\u00e9s eset\u00e9n folyamatosan nagysz\u00e1m\u00fa adatb\u00e1zis kapcsolat \u00e9l, ami adatkezel\u0151 rendszerek eset\u00e9n a teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l k\u00f6lts\u00e9ges er\u0151forr\u00e1snak sz\u00e1m\u00edt. \u00cdgy a fejleszt\u00e9s sor\u00e1n c\u00e9lszer\u0171 arra t\u00f6rekedni, hogy az adatb\u00e1zis kapcsolatokat miel\u0151bb z\u00e1rjuk le.</p> <p>A modell el\u0151nyei:</p> <ul> <li>Egyszer\u0171bb a konkurencia kezel\u00e9se</li> <li>Az adatok mindenhol a legfrissebbek</li> </ul> <p>Megjegyz\u00e9s: ezek az el\u0151ny\u00f6k akkor jelentkeznek, ha az adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9shez az adatkezel\u0151 szigor\u00fa z\u00e1rakat haszn\u00e1l \u2013 ezt mi a hozz\u00e1f\u00e9r\u00e9s sor\u00e1n megfelel\u0151 tranzakci\u00f3 izol\u00e1ci\u00f3s szint megad\u00e1s\u00e1val tudjuk szab\u00e1lyozni. (Ennek technik\u00e1i k\u00e9s\u0151bbi tanulm\u00e1nyok sor\u00e1n ker\u00fclnek ismertet\u00e9sre.)</p> <p>H\u00e1tr\u00e1nyok:</p> <ul> <li>Folyamatos h\u00e1l\u00f3zati kapcsolat</li> <li>Sk\u00e1l\u00e1zhat\u00f3s\u00e1g hi\u00e1nya</li> </ul> A Kapcsolat-n\u00e9lk\u00fcli modell alapelvei <p>A kapcsolatalap\u00fa modellel ellent\u00e9tben az adatok megjelen\u00edt\u00e9se \u00e9s mem\u00f3ri\u00e1ban t\u00f6rt\u00e9n\u0151 m\u00f3dos\u00edt\u00e1sa sor\u00e1n nem tartunk fent adatb\u00e1zis kapcsolatot. Ennek megfelel\u0151en a f\u0151bb l\u00e9p\u00e9sek a k\u00f6vetkez\u0151k: a kapcsolat felv\u00e9tel\u00e9t \u00e9s az adatok lek\u00e9rdez\u00e9s\u00e9t k\u00f6vet\u0151en azonnal bontjuk a kapcsolatot. Az adatokat ezt k\u00f6vet\u0151en tipikusan megjelen\u00edtj\u00fck \u00e9s lehet\u0151s\u00e9get biztos\u00edtunk a felhaszn\u00e1l\u00f3nak az adatok m\u00f3dos\u00edt\u00e1s\u00e1ra (rekordok felv\u00e9tele, m\u00f3dos\u00edt\u00e1sa, t\u00f6rl\u00e9se ig\u00e9ny szerint). A m\u00f3dos\u00edt\u00e1sok ment\u00e9se sor\u00e1n \u00fajra felvessz\u00fck az adatkapcsolatot, mentj\u00fck az adatb\u00e1zisba a v\u00e1ltoztat\u00e1sokat \u00e9s z\u00e1rjuk a kapcsolatot. Term\u00e9szetesen a modell megk\u00f6veteli, hogy a lek\u00e9rdez\u00e9se \u00e9s a m\u00f3dos\u00edt\u00e1sok vissza\u00edr\u00e1sa k\u00f6z\u00f6tt \u2013 amikor nincs kapcsolatunk az adatb\u00e1zissal \u2013 az adatokat \u00e9s a v\u00e1ltoztat\u00e1sokat a mem\u00f3ri\u00e1ban nyilv\u00e1ntartsuk. Erre az ADO.NET k\u00f6rnyezetben nagyon k\u00e9nyelmes megold\u00e1st ny\u00fajt a <code>DataSet</code> objektumok alkalmaz\u00e1sa.</p> <p>A modell el\u0151nyei:</p> <ul> <li>Nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat</li> <li>Sk\u00e1l\u00e1zhat\u00f3s\u00e1g</li> </ul> <p>H\u00e1tr\u00e1nyok</p> <ul> <li>Az adatok nem mindig a legfrissebbek</li> <li>\u00dctk\u00f6z\u00e9sek lehets\u00e9gesek</li> </ul> <p>Megjegyz\u00e9s: Sz\u00e1mos lehet\u0151s\u00e9g\u00fcnk van arra, hogy az objektumokat \u00e9s kapcsol\u00f3d\u00f3 v\u00e1ltoz\u00e1sokat nyilv\u00e1ntartsuk a mem\u00f3ri\u00e1ban. A <code>DataSet</code> csak az egyik lehets\u00e9ges technika. De haszn\u00e1lhatunk erre a c\u00e9lra k\u00f6z\u00f6ns\u00e9ges objektumokat, illetve ezek menedzsel\u00e9s\u00e9t megk\u00f6nny\u00edt\u0151 - az ADO.NET-n\u00e9l korszer\u0171bb - .NET technol\u00f3gi\u00e1kat (pl. Entity Framework Core).</p>"},{"location":"labor/7-adatkezeles/#a-kapcsolatalapu-modell","title":"A kapcsolatalap\u00fa modell","text":"<p>A labor keret\u00e9ben a kapcsolatalap\u00fa modellt ismerj\u00fck meg.</p> <p>Az alapfolyamat a k\u00f6vetkez\u0151:</p> <ol> <li>Kapcsolat l\u00e9trehoz\u00e1sa az alkalmaz\u00e1s, illetve az adatb\u00e1zis kezel\u0151 rendszer k\u00f6z\u00f6tt (<code>Connection</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>A futtatand\u00f3 SQL utas\u00edt\u00e1s \u00f6ssze\u00e1ll\u00edt\u00e1sa (<code>Command</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>Utas\u00edt\u00e1s futtat\u00e1sa (<code>Command</code> objektum felhaszn\u00e1l\u00e1s\u00e1val).</li> <li>Lek\u00e9rdez\u00e9sek eset\u00e9n a visszakapott rekordhalmaz feldolgoz\u00e1sa (<code>DataReader</code> objektum felhaszn\u00e1l\u00e1s\u00e1val). Erre a m\u00f3dos\u00edt\u00f3 parancsok eset\u00e9n \u00e9rtelemszer\u0171en nincs sz\u00fcks\u00e9g.</li> <li>Kapcsolat lez\u00e1r\u00e1sa.</li> </ol> <p>Mint a fentiekb\u0151l kider\u00fcl, az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3nak ebben a modellben h\u00e1rom f\u0151 \u00f6sszetev\u0151je van:</p> <ul> <li>Connection</li> <li>Command</li> <li>Data Reader</li> </ul> <p>Ezek az \u00f6sszetev\u0151k egy-egy oszt\u00e1lyk\u00e9nt jelennek meg, adatb\u00e1zis-kezel\u0151-f\u00fcggetlen r\u00e9sz\u00fck a BCL System.Data.Common n\u00e9vter\u00e9ben tal\u00e1lhat\u00f3 <code>DbConnection</code>, <code>DbCommand</code>, illetve <code>DbDataReader</code> n\u00e9ven. Ezek absztrakt oszt\u00e1lyok, az adatb\u00e1zis-kezel\u0151k gy\u00e1rt\u00f3inak feladata, hogy ezekb\u0151l lesz\u00e1rmazva meg\u00edrj\u00e1k a konkr\u00e9t adatb\u00e1zis-kezel\u0151ket t\u00e1mogat\u00f3 v\u00e1ltozatokat.</p> <p>Mindh\u00e1rom ADO.NET \u00f6sszetev\u0151 t\u00e1mogatja a Dispose mint\u00e1t, \u00edgy <code>using</code> blokkban haszn\u00e1lhat\u00f3k \u2013 haszn\u00e1ljuk is \u00edgy, amikor csak tudjuk. Az adatb\u00e1zis-kezel\u0151 \u00e1ltal\u00e1ban m\u00e1sik g\u00e9pen tal\u00e1lhat\u00f3, mint ahol a k\u00f3dunk fut (a labor sor\u00e1n pont nem :)), \u00edgy tekints\u00fcnk ezekre, mint t\u00e1voli h\u00e1l\u00f3zati er\u0151forr\u00e1sokra.</p> <p>A Microsoft SQL Server-t t\u00e1mogat\u00f3 v\u00e1ltozat a Microsoft.Data.SqlClient NuGet csomagban, az \u201eSql\u201d prefix\u0171 oszt\u00e1lyokban tal\u00e1lhat\u00f3k (<code>SqlConnection</code>, <code>SqlCommand</code> \u00e9s <code>SqlDataReader</code>).</p> <p>A t\u00f6bbi gy\u00e1rt\u00f3 k\u00fcl\u00f6n dll-(ek)be teszi a saj\u00e1t v\u00e1ltozat\u00e1t, az \u00edgy l\u00e9trej\u00f6tt komponenst data provider-nek nevezik. Teljess\u00e9g ig\u00e9nye n\u00e9lk\u00fcl n\u00e9h\u00e1ny p\u00e9lda:</p> <ul> <li>PostgreSQL</li> <li>SQLite </li> <li>Oracle</li> </ul>"},{"location":"labor/7-adatkezeles/#connection","title":"Connection","text":"<p>Ez teremti meg a kapcsolatot a programunk, illetve az adatb\u00e1zis-kezel\u0151-rendszer k\u00f6z\u00f6tt. Inicializ\u00e1l\u00e1s\u00e1hoz sz\u00fcks\u00e9g van egy connection string-re, mely a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9hez sz\u00fcks\u00e9ges adatokat adja meg a driver sz\u00e1m\u00e1ra. Adatb\u00e1zisgy\u00e1rt\u00f3nk\u00e9nt elt\u00e9r\u0151 a bels\u0151 form\u00e1tuma (b\u0151vebben).</p> <p>\u00daj <code>Connection</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem biztos, hogy t\u00e9nyleg \u00faj kapcsolat fog l\u00e9trej\u00f6nni az adatb\u00e1zis fel\u00e9, a driverek \u00e1ltal\u00e1ban connection pooling-ot alkalmaznak, hasonl\u00f3an, mint a thread pool eset\u00e9ben, \u00fajrahaszn\u00e1lhatj\u00e1k a kor\u00e1bbi (\u00e9ppen nem haszn\u00e1lt) kapcsolatokat.</p> <p>A <code>Connection</code> k\u00fcl\u00f6n\u00f6sen k\u00f6lts\u00e9ges nem fel\u00fcgyelt er\u0151forr\u00e1sokat haszn\u00e1l, \u00edgy kiemelten fontos, hogy a lehet\u0151 leghamarabb gondoskodjunk lez\u00e1r\u00e1s\u00e1r\u00f3l, amikor m\u00e1r nincs r\u00e1 sz\u00fcks\u00e9g (pl. a <code>Dispose()</code> h\u00edv\u00e1s\u00e1val, amit az esetek t\u00f6bbs\u00e9g\u00e9ben legegyszer\u0171bben a <code>using</code> blokk alkalmaz\u00e1s\u00e1val tehet\u00fcnk meg).</p>"},{"location":"labor/7-adatkezeles/#command","title":"Command","text":"<p>Ennek seg\u00edts\u00e9g\u00e9vel vagyunk k\u00e9pesek \u201eutas\u00edt\u00e1sokat\u201d megfogalmazni az adatb\u00e1zis kezel\u0151 sz\u00e1m\u00e1ra. Ezeket SQL nyelven kell megfogalmaznunk. A <code>Command</code>-nak be kell \u00e1ll\u00edtani egy kapcsolatot \u2013 ezen kereszt\u00fcl fog a parancs v\u00e9grehajt\u00f3dni. A parancsnak k\u00fcl\u00f6nb\u00f6z\u0151 eredm\u00e9nye lehet, ennek megfelel\u0151en k\u00fcl\u00f6nb\u00f6z\u0151 f\u00fcggv\u00e9nyekkel futtatjuk a parancsot:</p> <ul> <li>ExecuteReader: Eredm\u00e9nyhalmaz (result set) lek\u00e9rdez\u00e9se</li> <li>ExecuteScalar: Skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se</li> <li>ExecuteNonQuery: Nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9k (Pl: INSERT, UPDATE \u00e9s DELETE), viszont a m\u0171velet k\u00f6vetkezt\u00e9ben \u00e9rintett rekordok sz\u00e1m\u00e1t visszakapjuk</li> </ul>"},{"location":"labor/7-adatkezeles/#data-reader","title":"Data Reader","text":"<p>Ha a parancs eredm\u00e9nye eredm\u00e9nyhalmaz, akkor ennek a komponensnek a seg\u00edts\u00e9g\u00e9vel tudjuk az adatokat kiolvasni. Az eredm\u00e9nyhalmaz egy t\u00e1bl\u00e1zatnak tekinthet\u0151, a <code>Data Reader</code> ezen tud soronk\u00e9nt v\u00e9gignavig\u00e1lni (csak egyes\u00e9vel el\u0151refel\u00e9!). A kurzor egyszerre egy soron \u00e1ll, ha a sorb\u00f3l a sz\u00fcks\u00e9ges adatokat kiolvastuk, a kurzort egy sorral el\u0151re l\u00e9ptethetj\u00fck. Csak az aktu\u00e1lis sorb\u00f3l tudunk olvasni. Kezdetben a kurzor nem az els\u0151 soron \u00e1ll, azt egyszer l\u00e9ptetn\u00fcnk kell, hogy az els\u0151 sorra \u00e1lljon.</p> <p>Megjegyz\u00e9s: navig\u00e1l\u00e1s kliens oldalon t\u00f6rt\u00e9nik a mem\u00f3ri\u00e1ban, nincs k\u00f6ze az egyes adatkezel\u0151k \u00e1ltal t\u00e1mogatott kiszolg\u00e1l\u00f3 oldali kurzorokhoz.</p>"},{"location":"labor/7-adatkezeles/#1-feladat-adatbazis-elokeszitese","title":"1. Feladat \u2013 Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se","text":"<p>Els\u0151k\u00e9nt sz\u00fcks\u00e9g\u00fcnk van egy adatb\u00e1zis-kezel\u0151re. Ezt val\u00f3s k\u00f6rnyezetben dedik\u00e1lt szerveren fut\u00f3, adatb\u00e1zis adminisztr\u00e1torok \u00e1ltal fel\u00fcgyelt, teljes-\u00e9rt\u00e9k\u0171 adatb\u00e1zis-kezel\u0151k jelentik. Fejleszt\u00e9si id\u0151ben, lok\u00e1lis tesztel\u00e9shez azonban k\u00e9nyelmesebb egy fejleszt\u0151i adatb\u00e1zis-kezel\u0151 haszn\u00e1lata. A Visual Studio telep\u00edt\u00e9s\u00e9nek r\u00e9szek\u00e9nt kapunk is egy ilyen adatb\u00e1zismotort, ez a LocalDB, mely a teljes-\u00e9rt\u00e9k\u0171 SQL Server egyszer\u0171s\u00edtett v\u00e1ltozata. F\u0151bb tulajdons\u00e1gai:</p> <ul> <li>nem csak a Visual Studio-val, hanem k\u00fcl\u00f6n is telep\u00edthet\u0151,</li> <li>az adatb\u00e1zismotor szinte teljes m\u00e9rt\u00e9kben kompatibilis a teljes-\u00e9rt\u00e9k\u0171 Microsoft SQL Server-rel,</li> <li>alapvet\u0151en arr\u00f3l a g\u00e9pr\u0151l \u00e9rhet\u0151 el, melyre telep\u00edtett\u00fck,</li> <li>t\u00f6bb p\u00e9ld\u00e1ny is l\u00e9trehozhat\u00f3 ig\u00e9ny szerint, a p\u00e9ld\u00e1nyok alapvet\u0151en a l\u00e9trehoz\u00f3 oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3ja sz\u00e1m\u00e1ra \u00e9rhet\u0151k el (ig\u00e9ny eset\u00e9n megoszthat\u00f3 egy p\u00e9ld\u00e1ny a felhaszn\u00e1l\u00f3k k\u00f6z\u00f6tt),</li> <li>a saj\u00e1t p\u00e9ld\u00e1nyok kezel\u00e9se (l\u00e9trehoz\u00e1s, t\u00f6rl\u00e9s stb.) nem ig\u00e9nyel adminisztr\u00e1tori jogokat.</li> </ul> ssqllocaldb parancssori eszk\u00f6z <p>A gyakorlat sor\u00e1n nincs sz\u00fcks\u00e9g\u00fcnk erre, de a p\u00e9ld\u00e1nyok kezel\u00e9s\u00e9re az <code>sqllocaldb</code> parancssori eszk\u00f6z haszn\u00e1lhat\u00f3.  N\u00e9h\u00e1ny parancs, melyet az <code>sqllocaldb</code> ut\u00e1n be\u00edrva alkalmazhatunk:</p> Paracs Le\u00edr\u00e1s info az aktu\u00e1lis felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra l\u00e1that\u00f3 p\u00e9ld\u00e1nyok list\u00e1ja create \u201elocdb\u201d \u00faj p\u00e9ld\u00e1ny l\u00e9trehoz\u00e1sa \u201elocdb\u201d n\u00e9vvel delete \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny t\u00f6rl\u00e9se start \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny ind\u00edt\u00e1sa stop \u201elocdb\u201d \u201elocdb\u201d nev\u0171 p\u00e9ld\u00e1ny le\u00e1ll\u00edt\u00e1sa <p>A Visual Studio is telep\u00edt, illetve ind\u00edt LocalDB p\u00e9ld\u00e1nyokat, ez\u00e9rt \u00e9rdemes megn\u00e9zni, hogy a Visual Studio alapesetben milyen p\u00e9ld\u00e1nyokat l\u00e1t.</p> <ol> <li>Ind\u00edtsuk el a Visual Studio-t, a View men\u00fcb\u0151l v\u00e1lasszuk az SQL Server Object Explorer-t (SSOE).</li> <li>Nyissuk ki az SQL Server csom\u00f3pontot, ha alatta l\u00e1tunk tov\u00e1bbi csom\u00f3pontokat, akkor nyert \u00fcgy\u00fcnk van, nyissuk ki valamelyiket (ilyenkor indul el a p\u00e9ld\u00e1ny, ha nincs elind\u00edtva, \u00edgy lehet, hogy v\u00e1rni kell kicsit).</li> <li>Ha nem jelent meg semmi, akkor parancssorb\u00f3l az <code>mssqllocaldb info</code> parancs megadja a l\u00e9tez\u0151 p\u00e9ld\u00e1nyokat. V\u00e1lasszuk az SQL Server csom\u00f3ponton jobbklikkelve az Add SQL Server opci\u00f3t, majd adjuk meg valamelyik l\u00e9tez\u0151 p\u00e9ld\u00e1nyt, pl.: (localdb)\\MSSQLLocalDB</li> <li>A megjelen\u0151 Databases csom\u00f3ponton v\u00e1lasszuk a New Database opci\u00f3t, itt adjunk meg egy adatb\u00e1zisnevet. (Laboron, mivel t\u00f6bb hallgat\u00f3 is haszn\u00e1lhatja ugyanazt az oper\u00e1ci\u00f3s rendszer felhaszn\u00e1l\u00f3t, javasolt a Neptun k\u00f3d, mint n\u00e9v haszn\u00e1lata).</li> <li>Az \u00faj adatb\u00e1zis csom\u00f3pontj\u00e1n jobbklikkelve v\u00e1lasszuk a New Query opci\u00f3t, ami egy \u00faj query ablakot nyit.</li> <li>Nyissuk meg vagy t\u00f6lts\u00fck le a Northwind adatb\u00e1zis inicializ\u00e1l\u00f3 szkriptet.</li> <li>M\u00e1soljuk be a teljes szkriptet a query ablakba.</li> <li>Futtassuk le a szkriptet a kis z\u00f6ld ny\u00edllal (Execute). Figyelj\u00fcnk oda, hogy j\u00f3 adatb\u00e1zis (melyet fenti 4. l\u00e9p\u00e9sben hoztunk l\u00e9tre) legyen kiv\u00e1lasztva a query ablak tetej\u00e9n a leg\u00f6rd\u00fcl\u0151ben!.</li> <li>Ellen\u0151rizz\u00fck, hogy az adatb\u00e1zisunkban megjelentek-e t\u00e1bl\u00e1k, n\u00e9zetek.</li> <li>Fedezz\u00fck fel az SSOE legfontosabb funkci\u00f3it (t\u00e1bl\u00e1k adatainak, s\u00e9m\u00e1j\u00e1nak lek\u00e9rdez\u00e9se stb.).</li> </ol> <p>MSSQL menedzsment eszk\u00f6z\u00f6k</p> <p>A Visual Studio-ban k\u00e9t eszk\u00f6zzel is kezelhet\u00fcnk adatb\u00e1zisokat: a Server Explorer-rel \u00e9s az SQL Server Object Explorer-rel is. El\u0151bbi egy \u00e1ltal\u00e1nosabb eszk\u00f6z, mely nem csak adatb\u00e1zis, hanem egy\u00e9b szerver er\u0151forr\u00e1sok (pl. Azure szerverek) kezel\u00e9s\u00e9re is alkalmas, m\u00edg a m\u00e1sik kifejezetten csak adatb\u00e1zis-kezel\u00e9sre van kihegyezve. Mindkett\u0151 el\u00e9rhet\u0151 a View men\u00fcb\u0151l \u00e9s mindkett\u0151 hasonl\u00f3 funkci\u00f3kat ad adatb\u00e1zis-kezel\u00e9shez, ez\u00e9rt ebben a m\u00e9r\u00e9sben csak az egyiket (SQL Server Object Explorer) haszn\u00e1ljuk.</p> <p>Amikor nem \u00e1ll rendelkez\u00e9s\u00fcnkre a Visual Studio fejleszt\u0151k\u00f6rnyezet, akkor az adatb\u00e1zisunk menedzsel\u00e9s\u00e9re az (ingyenes) SQL Server Management Studio-t vagy a szint\u00e9n ingyenes \u00e9s multiplatform Azure Data Studio-t tudjuk haszn\u00e1lni.</p>"},{"location":"labor/7-adatkezeles/#2-feladat-lekerdezes-adonet-sqldatareader-rel","title":"2. Feladat \u2013 Lek\u00e9rdez\u00e9s ADO.NET SqlDataReader-rel","text":"<p>A feladat egy olyan C# nyelv\u0171 konzol alkalmaz\u00e1s elk\u00e9sz\u00edt\u00e9se, amely haszn\u00e1lja a Northwind adatb\u00e1zis <code>Shippers</code> t\u00e1bl\u00e1j\u00e1nak rekordjait.</p> <ol> <li> <p>Hozzunk l\u00e9tre egy C# nyelv\u0171 konzolos alkalmaz\u00e1st. A projekt t\u00edpusa Console App legyen, \u00e9s NE a Console App (.NET Framework):</p> <ul> <li>A projekt neve legyen AdoExample</li> <li>A Target Framework legyen .NET 8</li> <li>Pip\u00e1ljuk be a Do not use top-level statements kapcsol\u00f3t</li> </ul> </li> <li> <p>Keress\u00fck ki a connection string-et az SSOE-b\u0151l: jobbklikk az adatb\u00e1zis-kapcsolatunkon (pirossal jel\u00f6lve az al\u00e1bbi \u00e1br\u00e1n) / Properties.</p> <p></p> </li> <li> <p>M\u00e1soljuk a Properties ablakb\u00f3l a Connection String tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t egy v\u00e1ltoz\u00f3ba, a <code>Program</code> oszt\u00e1lyba.</p> <pre><code>private const string ConnString = @\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=neptun;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\";\n</code></pre> <p>SQL Server connection string form\u00e1tuma</p> <p>MSSQL eset\u00e9ben a connection string kulcs \u00e9rt\u00e9kp\u00e1rokat tartalmaz pontosvessz\u0151vel elv\u00e1lasztva. A <code>Data Source</code> kulcs alatt az SQL szerver p\u00e9ld\u00e1ny neve, az<code>Initial Catalog</code> kulcs alatt pedig az adatb\u00e1zis neve szerepel. Az <code>Integrated Security=true</code> kapcsol\u00f3 pedig a Windows autentik\u00e1ci\u00f3t jelenti.</p> <p>@-os string (C# verbatim string)</p> <p>A <code>@</code> egy speci\u00e1lis karakter (verbatim identifier), amit itt arra haszn\u00e1lunk, hogy a connection string-ben megjelen\u0151 backslash karakter (<code>\\</code>) ne felold\u00f3jelk\u00e9nt (escape character) ker\u00fclj\u00f6n \u00e9rtelmez\u00e9sre.</p> </li> <li> <p>Vegy\u00fck fel a projektbe a <code>Microsoft.Data.SqlClient</code> NuGet csomagot. Ezt k\u00e9tf\u00e9lek\u00e9ppen tehetj\u00fck meg:</p> <ul> <li>A) Visual Studio NuGet kezel\u0151ben:<ol> <li>Projekten jobb gomb / Manage NuGet Packages..., a megjelen\u0151 oldalon Browse oldalra v\u00e1lt\u00e1s.</li> <li>A keres\u0151be Microsoft.Data.SqlClient be\u00edr\u00e1sa.</li> <li>A Version mez\u0151ben az 5.0.1 kiv\u00e1laszt\u00e1sa (laboron az\u00e9rt v\u00e1lasztjuk ki ezt a verzi\u00f3t, mert ez szerepel a g\u00e9peken a NuGet cache-ben, otthoni gyakorl\u00e1s sor\u00e1n v\u00e1lasszuk ink\u00e1bb a Latest stable-t).</li> </ol> </li> <li> <p>B) Bem\u00e1soljuk az al\u00e1bbi csomag referenci\u00e1t a a projektf\u00e1jlba:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Microsoft.Data.SqlClient\" Version=\"5.0.1\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> </li> </ul> <p>NuGet csomagkezel\u0151</p> <p>A NuGet egy olyan online csomagkezel\u0151 rendszer, ahonnan .NET alap\u00fa projektjeinkbe tudunk k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9geket, oszt\u00e1lyk\u00f6nyvt\u00e1rakat egyszer\u0171en, verzi\u00f3zott form\u00e1ban behivatkozni. B\u0151vebben az els\u0151 el\u0151ad\u00e1son szerepel.</p> </li> <li> <p>\u00cdrjunk lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt, mely lek\u00e9rdezi az \u00f6sszes sz\u00e1ll\u00edt\u00f3t:</p> <pre><code>private static void GetShippers()\n{\n    using (var conn = new SqlConnection(ConnString))\n    using (var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn))\n    {\n        conn.Open();\n        Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\", \"ShipperID\", \"CompanyName\", \"Phone\");\n        Console.WriteLine(new string('-', 60));\n        using (SqlDataReader reader = command.ExecuteReader())\n        {\n            while (reader.Read())\n            {\n                Console.WriteLine(\n                    $\"{reader[\"ShipperID\"],-10}\" +\n                    $\"{reader[\"CompanyName\"],-20}\" +\n                    $\"{reader[\"Phone\"],-20}\");\n            }\n        }\n    }\n}\n</code></pre> <p>A kapcsolat alap\u00fa modell folyamata:</p> <ul> <li>Kapcsolat, parancs inicializ\u00e1l\u00e1sa</li> <li>Kapcsolat megnyit\u00e1sa</li> <li>Parancs futtat\u00e1sa</li> <li>Eredm\u00e9ny feldolgoz\u00e1sa</li> <li>Kapcsolat bont\u00e1sa, takar\u00edt\u00e1s</li> </ul> <p>N\u00e9h\u00e1ny megjegyz\u00e9s a k\u00f3dhoz</p> <ul> <li>A <code>DataReader</code>-t a parancs futtat\u00e1s\u00e1nak eredm\u00e9nyek\u00e9nt kapjuk meg, nem pedig k\u00f6zvetlen\u00fcl p\u00e9ld\u00e1nyos\u00edtjuk</li> <li>A parancs futtat\u00e1sa el\u0151tt meg kell nyitnunk a kapcsolatot</li> <li>A <code>DbConnection</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sakor nem nyit\u00f3dik meg a kapcsolat (nem t\u00f6rt\u00e9nik h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3)</li> <li>A <code>DataReader.Read()</code> f\u00fcggv\u00e9nye mutatja, hogy van-e m\u00e9g adat az eredm\u00e9nyhalmazban</li> <li>A <code>DataReader</code>-t az eredm\u00e9nyhalmazban tal\u00e1lhat\u00f3 oszlopok nev\u00e9vel indexelhetj\u00fck \u2013 az eredm\u00e9ny <code>object</code> lesz, \u00edgy, ha konkr\u00e9tabb t\u00edpusra van sz\u00fcks\u00e9g\u00fcnk cast-olni kell</li> <li>A ford\u00edt\u00f3 nem \u00e9rtelmezi az SQL parancs sz\u00f6veg\u00e9t (az csak egy string), hanem majd csak az adatb\u00e1zis, \u00edgy hib\u00e1s SQL eset\u00e9n csak fut\u00e1si idej\u0171 kiv\u00e9telt kapunk</li> <li>Figyelj\u00fck meg, hogy az adatb\u00e1zis s\u00e9ma v\u00e1ltoz\u00e1sa eset\u00e9n, pl. egy oszlop \u00e1tnevez\u00e9se ut\u00e1n, h\u00e1ny helyen kell k\u00e9zzel \u00e1t\u00edrni string-eket a k\u00f3dban</li> <li><code>$</code>-ral prefixelve string interpol\u00e1ci\u00f3t alkalmazhatunk, azaz k\u00f6zvetlen\u00fcl a string-be \u00e1gyazhatunk ki\u00e9rt\u00e9kelend\u0151 kifejez\u00e9seket (C# 6-os k\u00e9pess\u00e9g). A <code>$@</code> seg\u00edts\u00e9g\u00e9vel t\u00f6bbsoros string interpol\u00e1ci\u00f3s kifejez\u00e9seket \u00edrhatunk (a sort\u00f6r\u00e9st a {}-k k\u00f6z\u00f6tt kell betenn\u00fcnk, k\u00fcl\u00f6nben a kimeneten is megjelenik). \u00c9rdekess\u00e9g: C# 8-t\u00f3l f\u00f6lfele b\u00e1rmilyen sorrendben \u00edrhatjuk a $ \u00e9s @ karaktereket, teh\u00e1t a <code>$@</code> \u00e9s a <code>@$</code> is helyesnek sz\u00e1m\u00edt.</li> <li> <p>A using kulcssz\u00f3 blokk utas\u00edt\u00e1s helyett egysoros kifejez\u00e9sk\u00e9nt is haszn\u00e1lhat\u00f3. Ilyen esetben a using blokk v\u00e9ge a tartalmaz\u00f3 blokkig tart (eset\u00fcnkben a f\u00fcggv\u00e9ny v\u00e9g\u00e9ig). Ezzel cs\u00f6kkenthet\u0151 a beh\u00faz\u00e1sok sz\u00e1ma, de ne legyen automatikus reflex a haszn\u00e1lata, mert el\u0151fordulhat, hogy hamarabb c\u00e9lszer\u0171 kik\u00e9nyszer\u00edteni az er\u0151forr\u00e1sok felszabad\u00edt\u00e1s\u00e1t, mint a tartalmaz\u00f3 blokk v\u00e9ge.</p> <pre><code>private static void GetShippers()\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn);\n\n    conn.Open();\n\n    Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\",\"ShipperID\", \"CompanyName\", \"Phone\");\n    Console.WriteLine(new string('-', 60));\n\n    using var reader = command.ExecuteReader();\n    while (reader.Read())\n    {\n        Console.WriteLine(\n            $\"{reader[\"ShipperID\"],-10}\" +\n            $\"{reader[\"CompanyName\"],-20}\" +\n            $\"{reader[\"Phone\"],-20}\");\n    }\n}\n</code></pre> <p>A tov\u00e1bbiakban ezt a m\u00f3dszert haszn\u00e1ljuk a beh\u00faz\u00e1sok \u00e9s z\u00e1r\u00f3jelek megsp\u00f3rol\u00e1sa \u00e9rdek\u00e9ben.</p> </li> </ul> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l.</p> <pre><code>private static void Main(string[] args)\n{\n    GetShippers();\n}\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Rontsuk el az SQL-t, \u00e9s \u00fagy is pr\u00f3b\u00e1ljuk ki.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#3-feladat-beszuras-sql-utasitassal","title":"3. Feladat \u2013 Besz\u00far\u00e1s SQL utas\u00edt\u00e1ssal","text":"<ol> <li> <p>\u00cdrjunk f\u00fcggv\u00e9nyt, mely \u00faj sz\u00e1ll\u00edt\u00f3t sz\u00far be az adatb\u00e1zisba:</p> <pre><code>private static void InsertShipper(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        \"INSERT INTO Shippers(CompanyName, Phone) VALUES(@name,@phone)\", conn);\n    command.Parameters.AddWithValue(\"@name\", companyName);\n    command.Parameters.AddWithValue(\"@phone\", phone);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>Itt olyan SQL-t kell \u00edrnunk, melynek az \u00f6ssze\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l k\u00edv\u00fclr\u0151l kapott v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit is felhaszn\u00e1ltuk. A string \u00f6sszerak\u00e1s\u00e1hoz egyszer\u0171en a string \u00f6sszef\u0171z\u00e9s oper\u00e1tort, string interpol\u00e1ci\u00f3t vagy <code>string.Format</code>-ot is haszn\u00e1lhattunk volna, de ez biztons\u00e1gi kock\u00e1zatot (SQL Injection \u2013 b\u0151vebben l\u00e1sd lentebb) rejt \u2013 SOHA!!! ne rakjuk \u00f6ssze az SQL-t string m\u0171velettel. Helyette \u00edrjuk meg \u00fagy az SQL-t, hogy ahov\u00e1 a v\u00e1ltoz\u00f3k \u00e9rt\u00e9keit \u00edrn\u00e1nk, oda param\u00e9terhivatkoz\u00e1sokat tesz\u00fcnk. SQL Server eset\u00e9ben a hivatkoz\u00e1s szintaxisa: @param\u00e9tern\u00e9v.</p> <p>A parancs futtat\u00e1s\u00e1hoz a param\u00e9terek \u00e9rt\u00e9keit is \u00e1t kell adnunk az adatb\u00e1zisnak, ugyanis az fogja elv\u00e9gezni a param\u00e9terek hely\u00e9re az \u00e9rt\u00e9kek behelyettes\u00edt\u00e9s\u00e9t.</p> <p>A besz\u00far\u00e1si parancs kimenete nem eredm\u00e9nyhalmaz, \u00edgy az <code>ExecuteNonQuery</code> m\u0171velettel kell futtatnuk, mely visszaadja besz\u00fart sorok sz\u00e1m\u00e1t.</p> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l.</p> <pre><code>GetShippers();\nInsertShipper(\"Super Shipper\",\"49-98562\");\nGetShippers();\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy beker\u00fclt-e az \u00faj sor. Az SSOE-ben val\u00f3 gyors \u00e9s k\u00e9nyelmes ellen\u0151rz\u00e9shez a <code>Shippers</code> t\u00e1bla context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Data lehet\u0151s\u00e9get.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#4-feladat-modositas-tarolt-eljarassal","title":"4. Feladat - M\u00f3dos\u00edt\u00e1s t\u00e1rolt elj\u00e1r\u00e1ssal","text":"<ol> <li> <p>Tanulm\u00e1nyozzuk SSOE-ben a <code>Product_Update</code> t\u00e1rolt elj\u00e1r\u00e1s k\u00f3dj\u00e1t. Ehhez nyissuk le a Programmability alatt tal\u00e1lhat\u00f3 Stored Procedures csom\u00f3pontot, majd a <code>Product_Update</code> t\u00e1rolt elj\u00e1r\u00e1s context men\u00fcj\u00e9b\u0151l v\u00e1lasszuk a View Code lehet\u0151s\u00e9get.</p> <p>Programk\u00f3d az adatb\u00e1zisban</p> <p>A nagyobb adatkezel\u0151 rendszerek lehet\u0151s\u00e9get biztos\u00edtanak arra, hogy programk\u00f3dot defini\u00e1ljunk mag\u00e1ban az adatkezel\u0151 adatb\u00e1zis\u00e1ban. Ezeket t\u00e1rol elj\u00e1r\u00e1soknak (stored procedure) nevezz\u00fck. A nyelve adatkezel\u0151 f\u00fcgg\u0151, de MSSQL eset\u00e9ben ez T-SQL.</p> <p>Manaps\u00e1g m\u00e1r egyre ink\u00e1bb kezd kikopni az a gyakorlat az iparb\u00f3l, hogy komolyabb \u00fczleti logik\u00e1t az adatb\u00e1zisban helyezz\u00fcnk el, mivel ezeknek az SQL dialektusoknak az eszk\u00f6zk\u00e9szlete ma m\u00e1r j\u00f3val korl\u00e1tosabb, mint egy magas szint\u0171 programoz\u00e1si nyelv\u00e9 (C#, Java). R\u00e1ad\u00e1sul a rendszer tesztelhet\u0151s\u00e9g\u00e9t nagyban rontja a t\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata. Ennek ellen\u00e9re n\u00e9ha indokolt lehet az adatb\u00e1zisban tartani valamennyi logik\u00e1t, amikor ki szeretn\u00e9nk azt haszn\u00e1lni, hogy az adatokhoz k\u00f6zel futnak a programk\u00f3djaink, pl. ha nem akarjuk megutaztatni a h\u00e1l\u00f3zaton az adatot egy egyszer\u0171 t\u00f6meges adatkarbantart\u00e1s \u00e9rdek\u00e9ben.</p> </li> <li> <p>\u00cdrjunk f\u00fcggv\u00e9nyt, mely ezt a t\u00e1rolt elj\u00e1r\u00e1st h\u00edvja</p> <pre><code>private static void UpdateProduct(int productID, string productName, decimal price)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"Product_Update\", conn);\n\n    command.CommandType = CommandType.StoredProcedure;\n\n    command.Parameters.AddWithValue(\"@ProductID\", productID);\n    command.Parameters.AddWithValue(\"@ProductName\", productName);\n    command.Parameters.AddWithValue(\"@UnitPrice\", price);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>A <code>Command</code>-nak a t\u00e1rolt elj\u00e1r\u00e1s nev\u00e9t kellett megadni, \u00e9s a parancs t\u00edpus\u00e1t kellett \u00e1t\u00e1ll\u00edtani, egy\u00e9bk\u00e9nt szerkezetileg hasonl\u00edt a kor\u00e1bbi besz\u00far\u00f3 k\u00f3dra.</p> </li> <li> <p>H\u00edvjuk meg az \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l, p\u00e9ld\u00e1ul az al\u00e1bbi param\u00e9terez\u00e9ssel:</p> <pre><code>UpdateProduct(1, \"MyProduct\", 50);\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, ellen\u0151rizz\u00fck a konzolban \u00e9s az SSOE-ben is, hogy m\u00f3dosult-e az 1-es azonos\u00edt\u00f3j\u00fa term\u00e9k.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/#5-feladat-sql-injection","title":"5. Feladat - SQL Injection","text":"<ol> <li> <p>\u00cdrjuk meg a besz\u00far\u00f3 f\u00fcggv\u00e9nyt \u00fagy, hogy string interpol\u00e1ci\u00f3val rakja \u00f6ssze az SQL-t.</p> <pre><code>private static void InsertShipper2(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        $\"INSERT INTO Shippers(CompanyName, Phone) VALUES('{companyName}','{phone}')\",\n        conn);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n    Console.WriteLine($\"{affectedRows} row(s) inserted\");\n}\n</code></pre> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l \u201especi\u00e1lisan\u201d param\u00e9terezve.</p> <pre><code>InsertShipper2(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\n</code></pre> <p>\u00dagy \u00e1ll\u00edtottuk \u00f6ssze a m\u00e1sodik param\u00e9tert, hogy az lez\u00e1rja az eredeti utas\u00edt\u00e1st, ezut\u00e1n tetsz\u0151leges (!!!) SQL-t \u00edrhatunk, v\u00e9g\u00fcl kikommentezz\u00fck az eredeti utas\u00edt\u00e1s marad\u00e9k\u00e1t (<code>--</code>).</p> </li> <li> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st, hib\u00e1t kell kapjunk, mely arra utal, hogy valamelyik sz\u00e1ll\u00edt\u00f3 nem t\u00f6r\u00f6lhet\u0151 idegen kulcs hivatkoz\u00e1s miatt.</p> <p>Teh\u00e1t a <code>DELETE FROM</code> is lefutott! N\u00e9zz\u00fck meg debugger-rel (pl. a <code>conn.Open</code> utas\u00edt\u00e1son \u00e1llva), hogy mi a v\u00e9gleges SQL (<code>command.CommandText</code>).</p> <p>Tanuls\u00e1gok:</p> <ul> <li>SOSE f\u0171zz\u00fcnk \u00f6ssze programozottan SQL-t (semmilyen m\u00f3dszerrel), mert azzal kitessz\u00fck a k\u00f3dunkat SQL Injection alap\u00fa t\u00e1mad\u00e1snak.</li> <li>Az adatb\u00e1zis \u00e1ll\u00edtsa \u00f6ssze a v\u00e9gleges SQL-t az SQL param\u00e9terek alapj\u00e1n, mert ilyenkor biztos\u00edtott, hogy a param\u00e9ter \u00e9rt\u00e9kek nem fognak SQL-k\u00e9nt \u00e9rtelmez\u0151dni (hi\u00e1ba \u00edrunk be SQL-t). Haszn\u00e1ljunk param\u00e9terezett SQL-t vagy t\u00e1rolt elj\u00e1r\u00e1st.</li> <li>Haszn\u00e1ljunk adatb\u00e1zis k\u00e9nyszereket, pl. a v\u00e9letlen t\u00f6rl\u00e9s ellen is v\u00e9d.</li> <li>Konfigur\u00e1ljunk adatb\u00e1zisban felhaszn\u00e1l\u00f3kat k\u00fcl\u00f6nb\u00f6z\u0151 jogosults\u00e1gokkal, a programunk connection string-j\u00e9ben megadott felhaszn\u00e1l\u00f3 csak a m\u0171k\u00f6d\u00e9shez sz\u00fcks\u00e9ges minim\u00e1lis jogokkal rendelkezzen. A mi eset\u00fcnkben nem adtunk meg felhaszn\u00e1l\u00f3t, a windows-os felhaszn\u00e1l\u00f3k\u00e9nt fogunk csatlakozni.</li> </ul> </li> <li> <p>H\u00edvjuk meg az eredeti (vagyis a biztons\u00e1gos, SQL param\u00e9tereket haszn\u00e1l\u00f3) besz\u00far\u00f3 f\u00fcggv\u00e9nyt a \u201especi\u00e1lis\u201d param\u00e9terez\u00e9ssel, hogy l\u00e1ssuk, m\u0171k\u00f6dik-e a v\u00e9delem:</p> <pre><code>InsertShipper(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\nInsertShipper(\"XXX');DELETE FROM Shippers;--\", \"49-98562\");\n</code></pre> <p>Az els\u0151n\u00e9l nem f\u00e9r\u00fcnk bele a m\u00e9retkorl\u00e1tba, a m\u00e1sodik lefut, de csak egy \u201efurcsa\u201d nev\u0171 sz\u00e1ll\u00edt\u00f3 ker\u00fclt be. A param\u00e9ter \u00e9rt\u00e9ke t\u00e9nyleg \u00e9rt\u00e9kk\u00e9nt \u00e9rtelmez\u0151d\u00f6tt nem pedig SQL-k\u00e9nt. Nem \u00fagy mint itt:</p> <p></p> </li> </ol>"},{"location":"labor/7-adatkezeles/#6-feladat-torles","title":"6. Feladat - T\u00f6rl\u00e9s","text":"<ol> <li> <p>\u00cdrjunk egy \u00faj f\u00fcggv\u00e9nyt, mely kit\u00f6r\u00f6l egy adott sz\u00e1ll\u00edt\u00f3t.</p> <pre><code>private static void DeleteShipper(int shipperID)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"DELETE FROM Shippers WHERE ShipperID = @ShipperID\", conn);\n    command.Parameters.AddWithValue(\"@ShipperID\", shipperID);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} row(s) affected\");\n}\n</code></pre> </li> <li> <p>H\u00edvjuk meg \u00faj f\u00fcggv\u00e9ny\u00fcnket a <code>Main</code> f\u00fcggv\u00e9nyb\u0151l, pl. 1-gyel param\u00e9terezve.</p> </li> <li>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st. Val\u00f3sz\u00edn\u0171leg kiv\u00e9telt kapunk, ugyanis van hivatkoz\u00e1s (idegen kulcs k\u00e9nyszerrel) az adott rekordra.</li> <li>SSOE-b\u0151l n\u00e9zz\u00fck ki az azonos\u00edt\u00f3j\u00e1t egy olyan sz\u00e1ll\u00edt\u00f3nak, melyet mi vett\u00fcnk fel. Adjuk \u00e1t ezt az azonos\u00edt\u00f3t a t\u00f6rl\u0151 f\u00fcggv\u00e9nynek \u2013 ezt m\u00e1r ki tudja t\u00f6r\u00f6lni, hiszen nincs r\u00e1 hivatkoz\u00e1s.</li> </ol> <p>T\u00f6rl\u00e9si strat\u00e9gi\u00e1k</p> <p>L\u00e1that\u00f3, hogy a t\u00f6rl\u00e9s igen kock\u00e1zatos \u00e9s kisz\u00e1m\u00edthatatlan m\u0171velet az idegen kulcs k\u00e9nyszerek miatt. N\u00e9h\u00e1ny m\u00f3dszer a t\u00f6rl\u00e9s kezel\u00e9s\u00e9re:</p> <ul> <li>nem enged\u00e9lyezz\u00fck a t\u00f6rl\u00e9st: Ha hivatkoznak a t\u00f6rlend\u0151 rekordra, az adatb\u00e1zis hib\u00e1val t\u00e9r vissza (ahogy fent is l\u00e1thattuk).</li> <li>kaszk\u00e1d t\u00f6rl\u00e9s \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord is t\u00f6rl\u0151dj\u00f6n. Gyakran ez oda vezet, hogy minden idegen kulcs k\u00e9nyszer\u00fcnk ilyen lesz, \u00e9s egy (v\u00e9letlen) t\u00f6rl\u00e9ssel v\u00e9gigt\u00f6r\u00f6lhetj\u00fck ak\u00e1r a teljes adatb\u00e1zist, azaz nehezen j\u00f3solhat\u00f3 a t\u00f6rl\u00e9s hat\u00e1sa.</li> <li>hivatkoz\u00e1s NULL-oz\u00e1sa \u2013 az idegen kulcs k\u00e9nyszeren be\u00e1ll\u00edthat\u00f3, hogy a hivatkozott rekord t\u00f6rl\u00e9sekor a hivatkoz\u00f3 rekord idegen kulcs mez\u0151je <code>NULL</code> \u00e9rt\u00e9k\u0171 legyen. Csak akkor alkalmazhat\u00f3, ha a modell\u00fcnkben az adott idegen kulcs mez\u0151 <code>NULL</code>-ozhat\u00f3.</li> <li>logikai t\u00f6rl\u00e9s (soft delete) \u2013 t\u00f6rl\u00e9s m\u0171velet helyett csak egy flag oszlopot (pl. <code>IsDeleted</code>) \u00e1ll\u00edtunk be. El\u0151nye, hogy nem kell az idegen kulcs k\u00e9nyszerekkel foglalkoznunk, a t\u00f6r\u00f6lt adat rendelkez\u00e9sre \u00e1ll, ha sz\u00fcks\u00e9g lenne r\u00e1 (pl. undelete m\u0171velet). \u00c1m a m\u0171k\u00f6d\u00e9s bonyol\u00f3dik, mert foglalkozni kell azzal, hogy hogyan \u00e9s mikor sz\u0171rj\u00fck a t\u00f6r\u00f6lt rekordokat (pl. hogy ne jelenjenek meg a fel\u00fcleten, statisztik\u00e1kban), vagy hogyan kezelj\u00fck, ha egy nem t\u00f6r\u00f6lt rekord t\u00f6r\u00f6lt rekordra hivatkozik.</li> </ul>"},{"location":"labor/7-adatkezeles/#kitekintes","title":"Kitekint\u00e9s","text":"<p>A fenti ADO.NET alapm\u0171veleteket ebben az itt l\u00e1tott alapform\u00e1ban ritk\u00e1n haszn\u00e1lj\u00e1k k\u00e9t okb\u00f3l kifoly\u00f3an (m\u00e9g akkor is, ha ez a megk\u00f6zel\u00edt\u00e9s adja a legjobb teljes\u00edtm\u00e9nyt):</p> <ul> <li>Gyenge t\u00edpusoss\u00e1g (egy rekord adatait beolvasni egy oszt\u00e1ly property-jeibe igen k\u00f6r\u00fclm\u00e9nyes, cast-olni kell stb.)</li> <li>String-be k\u00f3dolt SQL (az elg\u00e9pel\u00e9sb\u0151l ered\u0151 hib\u00e1k csak fut\u00e1si id\u0151ben der\u00fclnek ki)</li> </ul> <p>Az el\u0151bbire megold\u00e1st jelenthetnek a k\u00fcl\u00f6nb\u00f6z\u0151 ADO.NET-et kieg\u00e9sz\u00edt\u0151 komponensek, pl.:</p> <ul> <li>Dapper</li> <li>PetaPoco</li> </ul> <p>Ezek a megold\u00e1sok egy minim\u00e1lis teljes\u00edtm\u00e9nyvesztes\u00e9g\u00e9rt cser\u00e9be nagyobb k\u00e9nyelmet k\u00edn\u00e1lnak.</p> <p>Mindk\u00e9t probl\u00e9m\u00e1ra megold\u00e1st jelentenek az ORM (Object-Relational-Mapping) rendszerek, cser\u00e9be ezek nagyobb overheaddel j\u00e1rnak, mint az el\u0151bb eml\u00edtett megold\u00e1sok. Az ORM-ek lek\u00e9pez\u00e9st alak\u00edtanak ki az adatb\u00e1zis \u00e9s az OO oszt\u00e1lyaink k\u00f6z\u00f6tt, \u00e9s ennek a lek\u00e9pez\u00e9snek a seg\u00edts\u00e9g\u00e9vel egyszer\u0171s\u00edtik az adatb\u00e1zis m\u0171veleteket. Az oszt\u00e1lyainkon v\u00e9gzett, t\u00edpusos k\u00f3ddal le\u00edrt m\u0171veleteinket automatikusan \u00e1tford\u00edtj\u00e1k a megfelel\u0151 adatb\u00e1zis m\u0171veletekre, \u00edgy a mem\u00f3riabeli objektummodell\u00fcnket szinkronban tartj\u00e1k az adatb\u00e1zissal. Az ORM-ek ebb\u0151l k\u00f6vetkez\u0151en kapcsolat n\u00e9lk\u00fcli modellt haszn\u00e1lnak. Ismertebb .NET-es ORM-ek:</p> <ul> <li>ADO.NET DataSet \u2013 els\u0151 gener\u00e1ci\u00f3s ORM, ma m\u00e1r nagyon ritk\u00e1n haszn\u00e1ljuk</li> <li>Entity Framework 6.x \u2013 (r\u00e9gi) .NET Framework leggyakrabban haszn\u00e1lt ORM keretrendszere</li> <li>Entity Framework Core (EF Core) \u2013 a jelenleg els\u0151dlegesen haszn\u00e1lt .NET ORM (open source)</li> <li>NHibernate \u2013 a Java-s Hibernate .NET-es portja (open source)</li> </ul> <p>Az Entity Framework Core-ral r\u00e9szletesebben foglalkozunk az Adatvez\u00e9relt rendszerek specializ\u00e1ci\u00f3 t\u00e1rgyban illetve a Szoftverfejleszt\u00e9s .NET platformon v\u00e1laszthat\u00f3 t\u00e1rgyban.</p>"},{"location":"labor/7-adatkezeles/index_ger/","title":"7. Verwaltung der Daten","text":""},{"location":"labor/7-adatkezeles/index_ger/#das-ziel-der-ubung","title":"Das Ziel der \u00dcbung","text":"<p>Ziel der \u00dcbung ist es, das ADO.NET-Programmiermodell zu erlernen und die h\u00e4ufigsten Datenverwaltungsprobleme und Fallstricke durch das Schreiben grundlegender CRUD-Operationen zu veranschaulichen.</p> <p>Verwandte Pr\u00e4sentationen: Datenverwaltung, ADO.NET-Grundlagen.</p>"},{"location":"labor/7-adatkezeles/index_ger/#voraussetzungen","title":"Voraussetzungen","text":"<p>Die f\u00fcr die Durchf\u00fchrung der \u00dcbung ben\u00f6tigten Werkzeuge:</p> <ul> <li>Visual Studio 2022</li> <li>Betriebssystem Windows 10 oder Windows 11</li> <li>In dieser \u00dcbung werden wir den SQL Server Object Explorer in Visual Studio verwenden, um zwischen Datenbankobjekten zu navigieren und Abfragen auszuf\u00fchren. Dazu ist m\u00f6glicherweise die Komponente SQL Server Data Tools erforderlich, die am einfachsten auf der Seite Individuelle Komponenten im Visual Studio Installer installiert wird, aber auch im Workload Datenspeicherung und -verarbeitung enthalten ist.</li> </ul> <p>\u00dcbung unter Linux oder Mac</p> <p>Das \u00dcbungsmaterial ist grunds\u00e4tzlich f\u00fcr Windows und Visual Studio gedacht, kann aber - in leicht abgewandelter Form - auch auf anderen Betriebssystemen durchgef\u00fchrt werden, da das .NET SDK auch unter Linux und Mac sowie Linux unterst\u00fctzt wird:</p> <ul> <li>Verwenden Sie anstelle von Visual Studio einen Texteditor (z. B.: VSCode) und CLI-Tools.</li> <li>Es gibt eine Linux-Version von SQL Server, und auf dem Mac kann er in Docker ausgef\u00fchrt werden (aber Docker ist wahrscheinlich der bequemste Weg, um ihn unter Linux auszuf\u00fchren).</li> <li>Zur Visualisierung der Daten kann das ebenfalls plattform\u00fcbergreifende Tool Azure Data Studio verwendet werden.</li> </ul>"},{"location":"labor/7-adatkezeles/index_ger/#losung","title":"L\u00f6sung","text":"Laden Sie die fertige L\u00f6sung herunter <p> Es ist wichtig, dass Sie sich w\u00e4hrend des Praktikums an die Anleitung halten. Es ist verboten (und sinnlos), die fertige L\u00f6sung herunterzuladen. Allerdings kann es bei der anschlie\u00dfenden Selbstein\u00fcbung n\u00fctzlich sein, die fertige L\u00f6sung zu \u00fcberpr\u00fcfen, daher stellen wir sie zur Verf\u00fcgung.</p> <p>Die L\u00f6sung ist auf GitHub [hier] verf\u00fcgbar (https://github.com/bmeviauab00/lab-adatkezeles-megoldas). Der einfachste Weg, es herunterzuladen, ist, es von der Kommandozeile aus mit dem Befehl <code>git clone</code> auf Ihren Computer zu klonen:</p> <p><code>git clone https://github.com/bmeviauab00/lab-adatkezeles-megoldas</code></p> <p>Sie m\u00fcssen Git auf Ihrem Rechner installiert haben, weitere Informationen hier.</p>"},{"location":"labor/7-adatkezeles/index_ger/#einfuhrung","title":"Einf\u00fchrung","text":"Hinweis f\u00fcr Praktiker <p>Dieses Kapitel muss in einer Praxis nicht ausf\u00fchrlich genug erkl\u00e4rt werden, aber die wichtigsten Begriffe sollten kurz erl\u00e4utert werden.</p>"},{"location":"labor/7-adatkezeles/index_ger/#adonet","title":"ADO.NET","text":"<p>F\u00fcr die Low-Level-Datenbankverwaltung auf der .NET-Plattform ist ADO.NET f\u00fcr den Zugriff auf relationale Datenbanken verf\u00fcgbar.</p> <p>Bei der Verwendung von ADO.NET k\u00f6nnen Sie zwei verschiedene Datenzugriffsmodelle verwenden:</p> <ul> <li>Switch-basiertes Modell</li> <li>Unverbundenes Modell</li> </ul> <p>Wenn Sie auf die beiden Bl\u00f6cke unten klicken, k\u00f6nnen Sie sich einen \u00dcberblick \u00fcber die Grunds\u00e4tze der beiden Modelle verschaffen.</p> Principles of the Connection-based Model <p>Die Idee ist, die Datenbankverbindung die ganze Zeit \u00fcber offen zu halten, w\u00e4hrend die Daten abgefragt und ge\u00e4ndert werden und die \u00c4nderungen dann in die Datenbank zur\u00fcckgeschrieben werden. DataReader-Objekte k\u00f6nnen zur L\u00f6sung dieses Problems verwendet werden (siehe sp\u00e4ter). Der Vorteil dieser L\u00f6sung liegt in ihrer Einfachheit (einfacheres Programmiermodell und Wettbewerbsmanagement). Der Nachteil dieser L\u00f6sung ist, dass aufgrund der st\u00e4ndig aufrechtzuerhaltenden Netzverbindung Skalierbarkeitsprobleme auftreten k\u00f6nnen. Dies bedeutet, dass bei einer gro\u00dfen Anzahl von gleichzeitigen Benutzerzugriffen auf den Data Controller eine gro\u00dfe Anzahl von Datenbankverbindungen st\u00e4ndig aktiv ist, was eine kostspielige Ressource in Bezug auf die Leistung von Data Controller-Systemen darstellt. Daher ist es ratsam, w\u00e4hrend der Entwicklung zu versuchen, die Datenbankverbindungen so bald wie m\u00f6glich zu schlie\u00dfen.</p> <p>Vorteile des Modells:</p> <ul> <li>Leichtere Verwaltung des Wettbewerbs</li> <li>Die Daten sind \u00fcberall auf dem neuesten Stand</li> </ul> <p>Hinweis: Diese Vorteile gelten nur, wenn der Datenbankzugriff strengen Sperren unterliegt, die von dem f\u00fcr die Datenverarbeitung Verantwortlichen verwendet werden - wir k\u00f6nnen dies kontrollieren, indem wir den entsprechenden Transaktionsisolierungsgrad w\u00e4hrend des Zugriffs einstellen. (Die Techniken werden in sp\u00e4teren Studien beschrieben.)</p> <p>Benachteiligungen:</p> <ul> <li>Kontinuierliche Netzwerkverbindung</li> <li>Mangelnde Skalierbarkeit</li> </ul> Principles of the Connectionless Model <p>Im Gegensatz zum verbindungsbasierten Modell wird keine Datenbankverbindung aufrechterhalten, wenn Daten im Speicher angezeigt und ge\u00e4ndert werden. Die wichtigsten Schritte sind demnach folgende: Nach dem Verbindungsaufbau und dem Abruf der Daten wird die Verbindung sofort wieder beendet. Die Daten werden dann in der Regel angezeigt, und der Benutzer hat die M\u00f6glichkeit, die Daten zu \u00e4ndern (Datens\u00e4tze hinzuzuf\u00fcgen, zu \u00e4ndern oder zu l\u00f6schen, je nach Bedarf). Wenn wir \u00c4nderungen speichern, stellen wir die Datenverbindung wieder her, speichern die \u00c4nderungen in der Datenbank und schlie\u00dfen die Verbindung. Nat\u00fcrlich setzt das Modell voraus, dass Sie zwischen der Abfrage und dem Festschreiben von \u00c4nderungen - wenn Sie nicht mit der Datenbank verbunden sind - die Daten und \u00c4nderungen im Speicher halten. Eine sehr bequeme L\u00f6sung daf\u00fcr ist in der ADO.NET-Umgebung die Verwendung von <code>DataSet</code> -Objekten.</p> <p>Vorteile des Modells:</p> <ul> <li>Keine st\u00e4ndige Netzwerkverbindung erforderlich</li> <li>Skalierbarkeit</li> </ul> <p>Benachteiligungen</p> <ul> <li>Die Daten sind nicht immer auf dem neuesten Stand</li> <li>Zusammenst\u00f6\u00dfe sind m\u00f6glich</li> </ul> <p>Kommentar: Es gibt mehrere M\u00f6glichkeiten, Objekte und damit verbundene \u00c4nderungen im Ged\u00e4chtnis zu speichern. Das <code>DataSet</code> ist nur eine der m\u00f6glichen Techniken. Sie k\u00f6nnen aber auch gew\u00f6hnliche Objekte und .NET-Technologien (z. B. Entity Framework Core) verwenden, die die Verwaltung dieser Objekte erleichtern und fortschrittlicher sind als ADO.NET.</p>"},{"location":"labor/7-adatkezeles/index_ger/#das-beziehungsorientierte-modell","title":"Das beziehungsorientierte Modell","text":"<p>Im Labor werden wir das beziehungsbasierte Modell kennenlernen.</p> <p>Das grundlegende Verfahren ist wie folgt:</p> <ol> <li>Erstellen Sie eine Verbindung zwischen der Anwendung und dem Datenbankmanagementsystem (mit dem Objekt<code>Connection</code> ).</li> <li>Erstellen Sie die auszuf\u00fchrende SQL-Anweisung (unter Verwendung des Objekts<code>Command</code> ).</li> <li>F\u00fchren Sie einen Befehl aus (unter Verwendung des Objekts<code>Command</code> ).</li> <li>Verarbeitung des zur\u00fcckgegebenen Datensatzes f\u00fcr Abfragen (unter Verwendung des<code>DataReader</code> Objekts). F\u00fcr Modifikatorbefehle ist dies nat\u00fcrlich nicht notwendig.</li> <li>Schlie\u00dfen einer Verbindung.</li> </ol> <p>Wie oben zu sehen ist, hat die Kommunikation mit der Datenbank in diesem Modell drei Hauptkomponenten:</p> <ul> <li>Verbindung</li> <li>Befehl</li> <li>Datenleser</li> </ul> <p>Diese Komponenten werden als Klasse dargestellt, deren datenbankunabh\u00e4ngiger Teil im BCL-Namensraum System.Data.Common unter <code>DbConnection</code>, <code>DbCommand</code> bzw. <code>DbDataReader</code> zu finden ist. Es handelt sich um abstrakte Klassen, und es ist die Aufgabe der Anbieter von Datenbankmanagern, Versionen zu schreiben, die bestimmte von ihnen abgeleitete Datenbankmanager unterst\u00fctzen.</p> <p>Alle drei ADO.NET-Komponenten unterst\u00fctzen das Dispose-Muster, so dass sie im <code>using</code> -Block verwendet werden k\u00f6nnen - lassen Sie uns sie auf diese Weise verwenden, wann immer wir k\u00f6nnen. Der Datenbankmanager befindet sich in der Regel auf einem anderen Rechner als der, auf dem unser Code l\u00e4uft (nicht im Labor :)), also betrachten Sie sie als entfernte Netzwerkressourcen.</p> <p>Die Version, die Microsoft SQL Server unterst\u00fctzt, finden Sie im NuGet-Paket Microsoft.Data.SqlClient in Klassen mit dem Pr\u00e4fix \"Sql\" (<code>SqlConnection</code>, <code>SqlCommand</code> und <code>SqlDataReader</code>).</p> <p>Andere Anbieter packen ihre eigene Version in eine separate DLL(s), die daraus resultierende Komponente wird als Datenanbieter bezeichnet. Einige Beispiele ohne Anspruch auf Vollst\u00e4ndigkeit:</p> <ul> <li>PostgreSQL</li> <li>SQLite </li> <li>Oracle</li> </ul>"},{"location":"labor/7-adatkezeles/index_ger/#verbindung","title":"Verbindung","text":"<p>Dies ist die Verbindung zwischen unserem Programm und dem Datenbankmanagementsystem. Um sie zu initialisieren, ben\u00f6tigen wir einen Verbindungsstring, der dem Treiber die notwendigen Informationen zum Aufbau der Verbindung gibt. Das interne Format variiert von Datenbankanbieter zu Datenbankanbieter(weitere Informationen).</p> <p>Wenn eine neue <code>Connection</code> instanziiert wird, ist nicht garantiert, dass tats\u00e4chlich eine neue Verbindung zur Datenbank hergestellt wird. Die Treiber verwenden in der Regel Connection Pooling, \u00e4hnlich wie Thread Pooling, um fr\u00fchere (derzeit nicht verwendete) Verbindungen wieder zu verwenden.</p> <p><code>Connection</code> ist eine besonders teure, nicht verwaltete Ressource, daher muss sichergestellt werden, dass sie so schnell wie m\u00f6glich geschlossen wird, wenn sie nicht mehr ben\u00f6tigt wird (z. B. durch den Aufruf von <code>Dispose()</code>, was in den meisten F\u00e4llen am einfachsten mit dem <code>using</code> -Block geschieht).</p>"},{"location":"labor/7-adatkezeles/index_ger/#befehl","title":"Befehl","text":"<p>So k\u00f6nnen wir \"Anweisungen\" f\u00fcr den Datenbankmanager formulieren. Diese m\u00fcssen wir in SQL formulieren.  <code>Command</code>muss einen Link-Set haben - hier wird der Befehl ausgef\u00fchrt. Der Befehl kann verschiedene Ergebnisse haben, also f\u00fchren wir den Befehl mit verschiedenen Funktionen aus:</p> <ul> <li>ExecuteReader: Abfrage einer Ergebnismenge</li> <li>ExecuteScalar: Abfrage des Einzelwerts</li> <li>ExecuteNonQuery: Kein R\u00fcckgabewert (z.B: INSERT, UPDATE und DELETE), aber die Anzahl der von der Operation betroffenen Datens\u00e4tze wird zur\u00fcckgegeben</li> </ul>"},{"location":"labor/7-adatkezeles/index_ger/#datenleser","title":"Datenleser","text":"<p>Wenn das Ergebnis des Befehls eine Ergebnismenge ist, k\u00f6nnen wir diese Komponente verwenden, um die Daten zu lesen. Die Ergebnismenge kann als Tabelle angezeigt werden, <code>Data Reader</code> kann Zeile f\u00fcr Zeile (eine nach der anderen!) durch sie navigieren. Der Cursor befindet sich jeweils in einer Zeile. Sobald die gew\u00fcnschten Daten aus der Zeile gelesen wurden, kann der Cursor eine Zeile weiterbewegt werden. Wir k\u00f6nnen nur aus der aktuellen Zeile lesen. Zu Beginn steht der Cursor nicht in der ersten Zeile, Sie m\u00fcssen ihn einmal bewegen, um ihn in die erste Zeile zu setzen.</p> <p>Hinweis: Die clientseitige Navigation erfolgt im Speicher, sie hat nichts mit den serverseitigen Cursors zu tun, die von jedem Controller unterst\u00fctzt werden.</p>"},{"location":"labor/7-adatkezeles/index_ger/#1-aufgabe-vorbereitung-der-datenbank","title":"1. Aufgabe - Vorbereitung der Datenbank","text":"<p>Zun\u00e4chst brauchen wir einen Datenbankmanager. Dies wird durch voll funktionsf\u00e4hige Datenbankmanager erreicht, die in einer realen Umgebung auf speziellen Servern laufen und von Datenbankadministratoren \u00fcberwacht werden. W\u00e4hrend der Entwicklungszeit, f\u00fcr lokale Tests, ist es jedoch bequemer, einen Datenbankmanager f\u00fcr Entwickler zu verwenden. Als Teil der Visual Studio-Installation erhalten Sie eine solche Datenbank-Engine, LocalDB, die eine vereinfachte Version des voll funktionsf\u00e4higen SQL Servers ist. Seine Hauptmerkmale sind:</p> <ul> <li>kann nicht nur mit Visual Studio, sondern auch separat installiert werden,</li> <li>die Datenbank-Engine ist fast vollst\u00e4ndig kompatibel mit dem vollwertigen Microsoft SQL Server,</li> <li>ist grunds\u00e4tzlich auf dem Rechner verf\u00fcgbar, auf dem es installiert ist,</li> <li>mehrere Instanzen k\u00f6nnen bei Bedarf erstellt werden, die Instanzen stehen im Wesentlichen dem Benutzer des erstellenden Betriebssystems zur Verf\u00fcgung (eine Instanz kann bei Bedarf von mehreren Benutzern gemeinsam genutzt werden),</li> <li>f\u00fcr die Verwaltung Ihrer eigenen Kopien (Erstellen, L\u00f6schen usw.) sind keine Administratorrechte erforderlich.</li> </ul> ssqllocaldb command line tool <p>In der Praxis brauchen wir das nicht, aber wir k\u00f6nnen das <code>sqllocaldb</code> command line tool verwenden, um Instanzen zu verwalten.  Einige Befehle, die durch Eingabe nach <code>sqllocaldb</code> verwendet werden k\u00f6nnen:</p> Paracs Beschreibung info Liste der Instanzen, die f\u00fcr den aktuellen Benutzer sichtbar sind create \"locdb\" create a new instance named \"locdb\" l\u00f6schen \"locdb\" l\u00f6schen \"locdb\" \"locdb\" starten eine Instanz von \"locdb\" starten Stopp \"locdb\" Stopp \"locdb\" <p>Visual Studio installiert und startet auch LocalDB-Instanzen, so dass es sich lohnt, zu \u00fcberpr\u00fcfen, was Visual Studio standardm\u00e4\u00dfig sieht.</p> <ol> <li>Starten Sie Visual Studio und w\u00e4hlen Sie SQL Server Object Explorer (SSOE) aus dem Men\u00fc Ansicht.</li> <li>\u00d6ffnen Sie den SQL Server-Knoten. Wenn Sie andere Knoten darunter sehen, haben Sie einen erfolgreichen Fall, \u00f6ffnen Sie einen davon (dadurch wird die Instanz gestartet, falls sie noch nicht gestartet ist, Sie m\u00fcssen also m\u00f6glicherweise etwas warten).</li> <li>Wenn nichts erscheint, gibt der Befehl <code>mssqllocaldb info</code> in der Befehlszeile die vorhandenen Instanzen zur\u00fcck. Klicken Sie mit der rechten Maustaste auf den Knoten SQL Server und w\u00e4hlen Sie SQL Server hinzuf\u00fcgen, dann geben Sie eine vorhandene Instanz an, z. B. (localdb)MSSQLLocalDB</li> <li>W\u00e4hlen Sie im erscheinenden Knoten Datenbanken die Option Neue Datenbank und geben Sie einen Datenbanknamen ein. (Da in Praktika mehrere Sch\u00fcler denselben Betriebssystembenutzer verwenden k\u00f6nnen, empfiehlt es sich, den Neptun-Code als Namen zu verwenden).</li> <li>Klicken Sie mit der rechten Maustaste auf den neuen Datenbankknoten und w\u00e4hlen Sie Neue Abfrage, wodurch sich ein neues Abfragefenster \u00f6ffnet.</li> <li>\u00d6ffnen Sie das Skriptzur Initialisierung der Northwind-Datenbank oder laden Sie es herunter.</li> <li>Kopieren Sie das vollst\u00e4ndige Skript in das Abfragefenster.</li> <li>F\u00fchren Sie das Skript aus, indem Sie auf den kleinen gr\u00fcnen Pfeil*(Ausf\u00fchren*) klicken. Vergewissern Sie sich, dass eine gute Datenbank (die in Schritt 4 oben erstellt wurde) oben im Abfragefenster in der Dropdown-Liste ausgew\u00e4hlt ist!</li> <li>Pr\u00fcfen Sie, ob Tabellen und Ansichten in unserer Datenbank ver\u00f6ffentlicht worden sind.</li> <li>Sehen wir uns die wichtigsten Funktionen von SSOE an (Abruf von Daten aus Tabellen, Schemata usw.).</li> </ol> <p>MSSQL-Verwaltungstools</p> <p>In Visual Studio k\u00f6nnen Sie Datenbanken mit zwei Tools verwalten: dem Server Explorer und dem SQL Server Object Explorer. Ersteres ist ein allgemeineres Tool, das nicht nur Datenbanken, sondern auch andere Serverressourcen (z. B. Azure-Server) verwalten kann, w\u00e4hrend letzteres speziell auf die Datenbankverwaltung ausgerichtet ist. Auf beide kann \u00fcber das Men\u00fc Ansicht zugegriffen werden, und beide bieten \u00e4hnliche Datenbankverwaltungsfunktionen, weshalb wir in dieser Messung nur einen (SQL Server Object Explorer) verwenden werden.</p> <p>Wenn Sie nicht \u00fcber die Visual Studio-Entwicklungsumgebung verf\u00fcgen, k\u00f6nnen Sie das (kostenlose) SQL Server Management Studio oder das kostenlose und plattform\u00fcbergreifende Azure Data Studio verwenden, um Ihre Datenbank zu verwalten.</p>"},{"location":"labor/7-adatkezeles/index_ger/#2-aufgabe-abfrage-mit-adonet-sqldatareader","title":"2. Aufgabe - Abfrage mit ADO.NET SqlDataReader","text":"<p>Die Aufgabe besteht darin, eine C#-Konsolenanwendung zu erstellen, die die Datens\u00e4tze der Northwind-Datenbanktabelle <code>Shippers</code> verwendet.</p> <ol> <li> <p>Erstellen Sie eine Konsolenanwendung in C#. Der Projekttyp sollte Console App und NICHT Console App (.NET Framework) sein:</p> <ul> <li>Der Projektname sollte AdoExample lauten</li> <li>Das Ziel-Framework sollte .NET 8 sein</li> <li>Aktivieren Sie die Option Keine Top-Level-Anweisungen verwenden </li> </ul> </li> <li> <p>Suchen Sie die Verbindungszeichenfolge aus der SSOE: Klicken Sie mit der rechten Maustaste auf unsere Datenbankverbindung (in der Abbildung unten rot markiert) / Eigenschaften.</p> <p></p> </li> <li> <p>Kopieren Sie die Eigenschaft Connection String aus dem Fenster Properties in eine Variable der Klasse <code>Program</code>. </p> <pre><code>private const string ConnString = @\"Data Source=(localdb)MSSQLLocalDB;Initial Catalog=neptun;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\";\n</code></pre> <p>SQL Server-Verbindungsstringformat</p> <p>Bei MSSQL enth\u00e4lt der Schl\u00fcssel des Verbindungsstrings durch Semikolon getrennte Wertepaare. Unter dem Schl\u00fcssel <code>Data Source</code> steht der Name der SQL-Server-Instanz und unter dem Schl\u00fcssel<code>Initial Catalog</code> der Name der Datenbank. Die Option <code>Integrated Security=true</code> steht f\u00fcr die Windows-Authentifizierung.</p> <p>@- string (C# verbatim string)</p> <p><code>@</code> ist ein Sonderzeichen (verbatim identifier), das hier verwendet wird, um zu vermeiden, dass das Backslash-Zeichen (``) in der Verbindungszeichenfolge als Escape-Zeichen interpretiert wird.</p> </li> <li> <p>F\u00fcgen Sie das NuGet-Paket <code>Microsoft.Data.SqlClient</code> zum Projekt hinzu. Es gibt zwei M\u00f6glichkeiten, dies zu tun:</p> <ul> <li>A) Visual Studio in NuGet:<ol> <li>Projekte rechte Taste / NuGet-Pakete verwalten..., auf der erscheinenden Seite wechseln Sie zu Durchsuchen.</li> <li>Geben Sie in das Suchfeld Microsoft.Data.SqlClient.</li> <li>W\u00e4hlen Sie im Feld Version die Version 5.0.1 aus (im Labor w\u00e4hlen wir diese Version, weil sie sich im NuGet-Cache auf den Rechnern befindet; in der Praxis bevorzugen wir die Version Latest stable).</li> </ol> </li> <li> <p>B) Wir kopieren den folgenden Paketverweis in die Projektdatei:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Microsoft.Data.SqlClient\" Version=\"5.0.1\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> </li> </ul> <p>NuGet Package Manager</p> <p>NuGet ist ein Online-Paketverwaltungssystem, mit dem Sie externe Abh\u00e4ngigkeiten und Klassenbibliotheken in versionierter Form mit Ihren .NET-basierten Projekten verkn\u00fcpfen k\u00f6nnen. Lesen Sie mehr \u00fcber die erste Pr\u00e4sentation.</p> </li> <li> <p>Schreiben Sie eine Abfragefunktion, die alle Lieferanten abfragt:</p> <pre><code>private static void GetShippers()\n{\n    using (var conn = new SqlConnection(ConnString))\n    using (var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn))\n    {\n        conn.Open();\n        Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\", \"ShipperID\", \"CompanyName\", \"Phone\");\n        Console.WriteLine(new string('-', 60));\n        using (SqlDataReader reader = command.ExecuteReader())\n        {\n            while (reader.Read())\n            {\n                Console.WriteLine(\n                    $\"{reader[\"ShipperID\"],-10}\" +\n                    $\"{reader[\"CompanyName\"],-20}\" +\n                    $\"{reader[\"Phone\"],-20}\");\n            }\n        }\n    }\n}\n</code></pre> <p>Der beziehungsorientierte Modellprozess:</p> <ul> <li>Verbindung initialisieren, Befehl</li> <li>Einen Kontakt \u00f6ffnen</li> <li>Ausf\u00fchren eines Befehls</li> <li>Verarbeitung des Ergebnisses</li> <li>Abschaltung, Reinigung</li> </ul> <p>Einige Hinweise zum Code</p> <ul> <li><code>DataReader</code>erh\u00e4lt man als Ergebnis der Ausf\u00fchrung des Befehls, nicht durch direktes Kopieren</li> <li>Sie m\u00fcssen die Verbindung \u00f6ffnen, bevor Sie den Befehl ausf\u00fchren</li> <li>Wenn <code>DbConnection</code> kopiert wird, wird die Verbindung nicht ge\u00f6ffnet (keine Netzwerkkommunikation)</li> <li>Die Funktion <code>DataReader.Read()</code> zeigt an, ob noch Daten in der Ergebnismenge vorhanden sind</li> <li>Sie k\u00f6nnen <code>DataReader</code>mit den Namen der Spalten in der Ergebnismenge indizieren - das Ergebnis wird <code>object</code> sein, wenn Sie also einen spezifischeren Typ ben\u00f6tigen, m\u00fcssen Sie einen Cast durchf\u00fchren</li> <li>Der Compiler interpretiert den SQL-Befehlstext nicht (es ist nur ein String), nur die Datenbank tut dies, daher erhalten Sie im Falle eines SQL-Fehlers eine Laufzeitausnahme</li> <li>Beachten Sie, dass, wenn sich das Datenbankschema \u00e4ndert, z.B. wenn sich das Datenbankschema \u00e4ndert, z. B. nach der Umbenennung einer Spalte, m\u00fcssen Sie an vielen Stellen im Code Strings manuell umschreiben</li> <li>Mit <code>$</code>k\u00f6nnen Sie String-Interpolation verwenden, d. h. Ausdr\u00fccke einbetten, die direkt im String ausgewertet werden (C# 6-F\u00e4higkeit). <code>$@</code> erm\u00f6glicht es Ihnen, mehrzeilige String-Interpolationsausdr\u00fccke zu schreiben (Sie m\u00fcssen den Zeilenumbruch zwischen -k einf\u00fcgen, sonst wird er in der Ausgabe angezeigt). Interessante Tatsache: Ab C# 8 k\u00f6nnen Sie $- und @-Zeichen in beliebiger Reihenfolge schreiben, daher sind auch <code>$@</code> und <code>@$</code> korrekt.</li> <li> <p>Das using-Schl\u00fcsselwort kann als einzeiliger Ausdruck anstelle einer Blockanweisung verwendet werden. In diesem Fall reicht das Ende des using-Blocks bis zum enthaltenden Block (in unserem Fall das Ende der Funktion). Dies reduziert die Anzahl der Einr\u00fcckungen, sollte aber kein automatischer Reflex sein, da es sinnvoll sein kann, die Freigabe von Ressourcen fr\u00fcher als am Ende des enthaltenden Blocks zu erzwingen.</p> <pre><code>private static void GetShippers()\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"SELECT ShipperID, CompanyName, Phone FROM Shippers\", conn);\n\n    conn.Open();\n\n    Console.WriteLine(\"{0,-10}{1,-20}{2,-20}\",\"ShipperID\", \"CompanyName\", \"Phone\");\n    Console.WriteLine(new string('-', 60));\n\n    using var reader = command.ExecuteReader();\n    while (reader.Read())\n    {\n        Console.WriteLine(\n            $\"{reader[\"ShipperID\"],-10}\" +\n            $\"{reader[\"CompanyName\"],-20}\" +\n            $\"{reader[\"Phone\"],-20}\");\n    }\n}\n</code></pre> <p>Diese Methode wird im Folgenden verwendet, um Einz\u00fcge und Klammern zu speichern.</p> </li> </ul> </li> <li> <p>Rufen Sie unsere neue Funktion von <code>Main</code> aus auf.</p> <pre><code>private static void Main(string[] args)\n{\n    GetShippers();\n}\n</code></pre> </li> <li> <p>Probieren wir die App aus. Wir sollten SQL zerst\u00f6ren und es auf diese Weise versuchen.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/index_ger/#3-aufgabe-einfugen-mit-sql-anweisung","title":"3. Aufgabe - Einf\u00fcgen mit SQL-Anweisung","text":"<ol> <li> <p>Schreiben Sie eine Funktion zum Einf\u00fcgen eines neuen Lieferanten in die Datenbank:</p> <pre><code>private static void InsertShipper(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        \"INSERT INTO Shippers(CompanyName, Phone) VALUES(@name,@phone)\", conn);\n    command.Parameters.AddWithValue(\"@name\", companyName);\n    command.Parameters.AddWithValue(\"@phone\", phone);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>Hier m\u00fcssen wir SQL schreiben, das unter Verwendung von Variablenwerten kompiliert wurde, die wir von au\u00dfen erhalten haben. Um die Zeichenkette zusammenzusetzen, h\u00e4tten wir einfach den Operator f\u00fcr die Zeichenkettenverkettung, die Zeichenketteninterpolation oder <code>string.Format</code>verwenden k\u00f6nnen, aber das birgt ein Sicherheitsrisiko (SQL Injection - siehe unten f\u00fcr weitere Einzelheiten) - NIEMALS!!! SQL mit einer Zeichenkettenoperation zusammensetzen. Stattdessen sollten wir SQL so schreiben, dass wir an die Stelle der Werte von Variablen Parameterreferenzen setzen. Bei SQL Server lautet die Syntax des Verweises @parametername.</p> <p>Um den Befehl auszuf\u00fchren, m\u00fcssen wir auch die Werte der Parameter an die Datenbank \u00fcbergeben, da diese die Ersetzung der Werte f\u00fcr die Parameter vornimmt.</p> <p>Die Ausgabe des Einf\u00fcgebefehls ist keine Ergebnismenge, daher muss er mit <code>ExecuteNonQuery</code> ausgef\u00fchrt werden, das die Anzahl der eingef\u00fcgten Zeilen zur\u00fcckgibt.</p> </li> <li> <p>Rufen Sie unsere neue Funktion von <code>Main</code> aus auf.</p> <pre><code>GetShippers();\nInsertShipper(\"Super Shipper\",\"49-98562\");\nGetShippers();\n</code></pre> </li> <li> <p>Probieren wir die Anwendung aus und pr\u00fcfen wir in der Konsole und in der SSOE, ob die neue Zeile eingef\u00fcgt wurde. F\u00fcr eine schnelle und bequeme \u00dcberpr\u00fcfung in SSOE w\u00e4hlen Sie Daten anzeigen aus dem Kontextmen\u00fc der Tabelle <code>Shippers</code>. </p> </li> </ol>"},{"location":"labor/7-adatkezeles/index_ger/#4-aufgabe-modifikation-durch-gespeicherte-prozedur","title":"4. Aufgabe - Modifikation durch gespeicherte Prozedur","text":"<ol> <li> <p>Studieren Sie den in SSOE <code>Product_Update</code> gespeicherten Verfahrenscode. \u00d6ffnen Sie dazu den Knoten \"Gespeicherte Prozeduren\" unter \"Programmierbarkeit\" und w\u00e4hlen Sie dann \" Code anzeigen \" aus dem Kontextmen\u00fc der gespeicherten Prozedur unter <code>Product_Update</code>. </p> <p>Programmcode in der Datenbank</p> <p>Die gro\u00dfen Datenverwaltungssysteme bieten die M\u00f6glichkeit, Programmcode in der Datenbank des Datenverwalters selbst zu definieren. Diese werden als gespeicherte Verfahren bezeichnet. Die Sprache ist abh\u00e4ngig von der Datensteuerung, aber f\u00fcr MSSQL ist es T-SQL.</p> <p>Heutzutage wird die Praxis, ernsthafte Gesch\u00e4ftslogik in die Datenbank zu packen, immer mehr aus der Industrie verdr\u00e4ngt, da der Werkzeugsatz dieser SQL-Dialekte nun viel begrenzter ist als der einer h\u00f6heren Programmiersprache (C#, Java). Dar\u00fcber hinaus wird die Testbarkeit des Systems durch die Verwendung von gespeicherten Prozeduren stark beeintr\u00e4chtigt. Dennoch kann es manchmal sinnvoll sein, einen Teil der Logik in der Datenbank zu belassen, wenn wir den Vorteil nutzen wollen, dass unser Code in der N\u00e4he der Daten l\u00e4uft, z. B. wenn wir f\u00fcr eine einfache Massenpflege von Daten nicht \u00fcber das Netz gehen wollen.</p> </li> <li> <p>Schreiben Sie eine Funktion, die diese gespeicherte Prozedur aufruft</p> <pre><code>private static void UpdateProduct(int productID, string productName, decimal price)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"Product_Update\", conn);\n\n    command.CommandType = CommandType.StoredProcedure;\n\n    command.Parameters.AddWithValue(\"@ProductID\", productID);\n    command.Parameters.AddWithValue(\"@ProductName\", productName);\n    command.Parameters.AddWithValue(\"@UnitPrice\", price);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} rows affected\");\n}\n</code></pre> <p>Der <code>Command</code>musste der Name der gespeicherten Prozedur gegeben werden und der Typ des Befehls musste ge\u00e4ndert werden, ansonsten ist er strukturell \u00e4hnlich wie der vorherige Einf\u00fcgecode.</p> </li> <li> <p>Rufen Sie unsere neue Funktion von <code>Main</code> aus auf, z. B. mit den folgenden Parametern:</p> <pre><code>UpdateProduct(1, \"MyProduct\", 50);\n</code></pre> </li> <li> <p>Probieren wir die Anwendung aus und pr\u00fcfen in der Konsole und in SSOE, ob das Produkt mit der ID 1 ge\u00e4ndert wurde.</p> </li> </ol>"},{"location":"labor/7-adatkezeles/index_ger/#5-aufgabe-sql-injektion","title":"5. Aufgabe - SQL-Injektion","text":"<ol> <li> <p>Schreiben wir die Einf\u00fcgefunktion, um SQL mit Hilfe der String-Interpolation zu kompilieren.</p> <pre><code>private static void InsertShipper2(string companyName, string phone)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\n        $\"INSERT INTO Shippers(CompanyName, Phone) VALUES('{companyName}','{phone}')\",\n        conn);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n    Console.WriteLine($\"{affectedRows} row(s) inserted\");\n}\n</code></pre> </li> <li> <p>Rufen Sie unsere neue Funktion von <code>Main</code> mit \"speziellen\" Parametern auf.</p> <pre><code>InsertShipper2(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\n</code></pre> <p>Der zweite Parameter wird so gesetzt, dass die urspr\u00fcngliche Anweisung geschlossen wird, dann werden alle (!!!) Wir k\u00f6nnen SQL schreiben und schlie\u00dflich den Rest der urspr\u00fcnglichen Anweisung auskommentieren (<code>--</code>).</p> </li> <li> <p>Versuchen Sie die Anwendung, sollten Sie einen Fehler erhalten, der angibt, dass ein Lieferant aufgrund eines Fremdschl\u00fcsselverweises nicht gel\u00f6scht werden kann.</p> <p>Also <code>DELETE FROM</code> ist auch gelaufen! Pr\u00fcfen wir mit dem Debugger (z. B. durch Anhalten bei der Anweisung <code>conn.Open</code> ), wie das endg\u00fcltige SQL (<code>command.CommandText</code>) lautet.</p> <p>Lektionen gelernt:</p> <ul> <li>Splei\u00dfen Sie SQL NICHT programmatisch (egal mit welcher Methode), da dies Ihren Code f\u00fcr SQL-Injection-basierte Angriffe anf\u00e4llig macht.</li> <li>Die Datenbank sollte das endg\u00fcltige SQL auf der Grundlage der SQL-Parameter kompilieren, denn dann ist gew\u00e4hrleistet, dass die Parameterwerte nicht als SQL interpretiert werden (selbst wenn SQL eingegeben wird). Verwenden Sie parametrisiertes SQL oder gespeicherte Prozeduren.</li> <li>Verwenden Sie Datenbankbeschr\u00e4nkungen, z. B. zum Schutz vor versehentlichem L\u00f6schen.</li> <li>Konfigurieren Sie Benutzer in der Datenbank mit unterschiedlichen Rechten. Der in der Verbindungszeichenfolge Ihres Programms angegebene Benutzer sollte nur die f\u00fcr den Betrieb erforderlichen Mindestrechte haben. In unserem Fall haben wir keinen Benutzer angegeben, wir werden uns als Windows-Benutzer verbinden.</li> </ul> </li> <li> <p>Rufen wir nun die urspr\u00fcngliche (d.h. die sichere, mit SQL-Parametern versehene) Einf\u00fcgefunktion mit der \"speziellen\" Parametrisierung auf, um zu sehen, ob der Schutz funktioniert:</p> <pre><code>InsertShipper(\"Super Shipper\", \"49-98562'); DELETE FROM Shippers;--\");\nInsertShipper(\"XXX');DELETE FROM Shippers;--\", \"49-98562\");\n</code></pre> <p>Der erste passt nicht in die Gr\u00f6\u00dfenbeschr\u00e4nkung, der zweite l\u00e4uft, aber nur ein \"seltsam\" benannter Anbieter ist enthalten. Der Parameterwert wurde tats\u00e4chlich als Wert und nicht als SQL interpretiert. Nicht so wie hier:</p> <p></p> </li> </ol>"},{"location":"labor/7-adatkezeles/index_ger/#6-aufgabe-loschen","title":"6. Aufgabe - L\u00f6schen","text":"<ol> <li> <p>Schreiben Sie eine neue Funktion zum L\u00f6schen eines bestimmten Lieferanten.</p> <pre><code>private static void DeleteShipper(int shipperID)\n{\n    using var conn = new SqlConnection(ConnString);\n    using var command = new SqlCommand(\"DELETE FROM Shippers WHERE ShipperID = @ShipperID\", conn);\n    command.Parameters.AddWithValue(\"@ShipperID\", shipperID);\n\n    conn.Open();\n\n    int affectedRows = command.ExecuteNonQuery();\n\n    Console.WriteLine($\"{affectedRows} row(s) affected\");\n}\n</code></pre> </li> <li> <p>Rufen wir unsere neue Funktion von <code>Main</code> auf, parametrisiert mit, sagen wir, 1.</p> </li> <li>Probieren wir die App aus. Sie werden wahrscheinlich eine Ausnahme erhalten, da ein Verweis (mit Fremdschl\u00fcssel-Beschr\u00e4nkung) auf den Datensatz besteht.</li> <li>In SSOE suchen wir nach der ID eines Lieferanten, den wir beauftragt haben. \u00dcbergeben wir diesen Bezeichner an die L\u00f6schfunktion - sie kann ihn l\u00f6schen, da es keinen Verweis auf ihn gibt.</li> </ol> <p>L\u00f6schstrategien</p> <p>Es zeigt sich, dass das L\u00f6schen aufgrund der Fremdschl\u00fcssel-Beschr\u00e4nkungen eine sehr riskante und unvorhersehbare Operation ist. Einige M\u00f6glichkeiten, die L\u00f6schung zu verwalten:</p> <ul> <li>Wir erlauben keine L\u00f6schung: Wenn der zu l\u00f6schende Datensatz referenziert ist, gibt die Datenbank einen Fehler zur\u00fcck (wie oben gezeigt).</li> <li>L\u00f6schkaskade - die Fremdschl\u00fcssel-Beschr\u00e4nkung kann so eingestellt werden, dass der referenzierte Datensatz gel\u00f6scht wird, wenn der referenzierte Datensatz gel\u00f6scht wird. Dies f\u00fchrt oft dazu, dass alle unsere Fremdschl\u00fcssel-Beschr\u00e4nkungen so aussehen, und eine (versehentliche) L\u00f6schung kann die gesamte Datenbank ausl\u00f6schen, d.h. die Auswirkungen der L\u00f6schung sind schwer vorherzusagen.</li> <li>NULL der Referenz - die Fremdschl\u00fcssel-Beschr\u00e4nkung kann so eingestellt werden, dass das Fremdschl\u00fcsselfeld des referenzierten Datensatzes auf <code>NULL</code> gesetzt wird, wenn der referenzierte Datensatz gel\u00f6scht wird. Nur anwendbar, wenn das Fremdschl\u00fcsselfeld in Ihrem Modell auf <code>NULL</code> gesetzt werden kann.</li> <li>logisches L\u00f6schen (soft delete) - anstelle eines L\u00f6schvorgangs wird nur eine Flaggenspalte (z.B. <code>IsDeleted</code>) gesetzt. Der Vorteil ist, dass Sie sich nicht mit Fremdschl\u00fcssel-Beschr\u00e4nkungen befassen m\u00fcssen und die gel\u00f6schten Daten bei Bedarf verf\u00fcgbar sind (z. B. beim R\u00fcckg\u00e4ngigmachen des L\u00f6schvorgangs). Der Vorgang ist jedoch kompliziert, da man sich damit befassen muss, wie und wann gel\u00f6schte Datens\u00e4tze gefiltert werden sollen (z. B. damit sie nicht in der Schnittstelle oder in der Statistik erscheinen) oder wie man damit umgeht, wenn ein nicht gel\u00f6schter Datensatz auf einen gel\u00f6schten Datensatz verweist.</li> </ul>"},{"location":"labor/7-adatkezeles/index_ger/#screenshots","title":"Screenshots","text":"<p>Die oben genannten grundlegenden ADO.NET-Operationen in der hier gezeigten Form werden aus zwei Gr\u00fcnden selten verwendet (auch wenn dieser Ansatz die beste Leistung bietet):</p> <ul> <li>Schlechte Typisierung (das Einlesen der Daten eines Datensatzes in die Eigenschaften einer Klasse ist sehr umst\u00e4ndlich, Cast usw.)</li> <li>SQL kodiert in Strings (Fehler aufgrund von Tippfehlern werden erst zur Laufzeit erkannt)</li> </ul> <p>Ersteres kann durch verschiedene Komponenten gel\u00f6st werden, die ADO.NET erg\u00e4nzen, wie z.B.:</p> <ul> <li>Dapper</li> <li>PetaPoco</li> </ul> <p>Diese L\u00f6sungen bieten mehr Komfort bei minimalen Leistungseinbu\u00dfen.</p> <p>Beide Probleme werden durch ORM-Systeme (Object-Relational-Mapping) gel\u00f6st, die jedoch einen h\u00f6heren Overhead haben als die oben genannten L\u00f6sungen. ORMs erstellen ein Mapping zwischen der Datenbank und unseren OO-Klassen und verwenden dieses Mapping, um Datenbankoperationen zu vereinfachen. Unsere in Typcode geschriebenen Operationen mit unseren Klassen werden automatisch in die entsprechenden Datenbankoperationen \u00fcbersetzt, so dass unser In-Memory-Objektmodell mit der Datenbank synchronisiert wird. ORMs verwenden daher ein verbindungsloses Modell. Besser bekannte .NET ORMs:</p> <ul> <li>ADO.NET DataSet - ORM der ersten Generation, jetzt sehr selten verwendet</li> <li>Entity Framework 6.x - das am h\u00e4ufigsten verwendete ORM-Framework im (alten) .NET Framework</li> <li>Entity Framework Core (EF Core) - derzeit das wichtigste .NET ORM (Open Source)</li> <li>NHibernate - die .NET-Portierung von Hibernate f\u00fcr Java (Open Source)</li> </ul> <p>Das Entity Framework Core wird in der Spezialisierung Data Driven Systems und im Wahlfach Software Development on .NET platform ausf\u00fchrlicher behandelt.</p>"},{"location":"labor/old-6-doc-view/","title":"6. Document-View architekt\u00fara","text":""},{"location":"labor/old-6-doc-view/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai:</p> <ul> <li>UML alap\u00fa tervez\u00e9s \u00e9s n\u00e9h\u00e1ny tervez\u00e9si minta alkalmaz\u00e1sa</li> <li>A Document-View architekt\u00fara alkalmaz\u00e1sa a gyakorlatban</li> <li>UserControl szerep\u00e9nek bemutat\u00e1sa Window Forms alkalmaz\u00e1sokban, Document-View architekt\u00fara eset\u00e9n</li> <li>A grafikus megjelen\u00edt\u00e9s elveinek gyakorl\u00e1sa Window Forms alkalmaz\u00e1sokban (<code>Paint</code> esem\u00e9ny, <code>Invalidate</code>, <code>Graphics</code> haszn\u00e1lata)</li> </ul> <p>A kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok \u00e9s kor\u00e1bbi gyakorlatok anyaga:</p> <ul> <li>UML alap\u00fa modellez\u00e9s (1. gyakorlat)</li> <li>Windows Forms alkalmaz\u00e1sfejleszt\u00e9s</li> <li>Szoftverarchitekt\u00far\u00e1k (Document-View architekt\u00fara)</li> </ul>"},{"location":"labor/old-6-doc-view/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/old-6-doc-view/#a-gyakorlat-menete","title":"A gyakorlat menete","text":"<p>Az al\u00e1bbiak szerint fogunk dolgozni:</p> <ul> <li>A feladat/c\u00e9lok r\u00f6vid ismertet\u00e9se: egy interakt\u00edv fonteditor (bet\u0171t\u00edpus-szerkeszt\u0151) megtervez\u00e9se</li> <li>A k\u00e9sz alkalmaz\u00e1st futtatva a feladat (a k\u00e9sz alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9nek) ismertet\u00e9se</li> <li>Az alkalmaz\u00e1s architekt\u00far\u00e1j\u00e1nak megtervez\u00e9se (oszt\u00e1lydiagram elk\u00e9sz\u00edt\u00e9se)</li> <li>A k\u00e9sz alkalmaz\u00e1s forr\u00e1sk\u00f3dj\u00e1nak alapj\u00e1n n\u00e9h\u00e1ny fontosabb forgat\u00f3k\u00f6nyv megval\u00f3s\u00edt\u00e1s\u00e1nak \u00e1ttekint\u00e9se</li> </ul> Megjegyz\u00e9s gyakorlatvezet\u0151k sz\u00e1m\u00e1ra <p>A gyakorlat elej\u00e9n t\u00f6lts\u00fck le a k\u00e9sz alkalmaz\u00e1st (innen kl\u00f3nozzuk ki: https://github.com/bmeviauab00/lab-docview-megoldas). A hallgat\u00f3k ekkor m\u00e9g ne t\u00f6lts\u00e9k le, ne ezt kattintgass\u00e1k, majd csak a gyakorlat m\u00e1sodik r\u00e9sz\u00e9ben. A gyakorlatvezet\u0151knek viszont sz\u00fcks\u00e9ge lesz r\u00e1, mert ennek seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik a feladat bemutat\u00e1sa.</p>"},{"location":"labor/old-6-doc-view/#1-feladat-a-feladat-ismertetese","title":"1. Feladat - A feladat ismertet\u00e9se","text":"<p>Interakt\u00edv FontEditor (bet\u0171t\u00edpus szerkeszt\u0151) k\u00e9sz\u00edt\u00e9se, amelyben lehet szerkeszteni a karaktereket, \u00e9s az aktu\u00e1lis bet\u0171k\u00e9szlet alapj\u00e1n tetsz\u0151leges p\u00e9ldasz\u00f6veg megjelen\u00edthet\u0151. Az alkalmaz\u00e1s felhaszn\u00e1l\u00f3i fel\u00fclete fut\u00e1s k\u00f6zben:</p> <p></p> <p>A k\u00f6vetkez\u0151 funkci\u00f3kat kell t\u00e1mogatnia:</p> <ul> <li>T\u00f6bb bet\u0171t\u00edpus egyidej\u0171 szerkeszt\u00e9se. Ez egyes bet\u0171t\u00edpusok k\u00fcl\u00f6n tab oldalakon szerkeszthet\u0151k (MDI \u2013 Multiple Document Interface).</li> <li>\u00daj bet\u0171t\u00edpus a File/New men\u00fcelem kiv\u00e1laszt\u00e1s\u00e1val hozhat\u00f3 l\u00e9tre (meg kell adni a nev\u00e9t).</li> <li>Ez egyes bet\u0171t\u00edpusok elmenthet\u0151k (File/Save), bet\u00f6lthet\u0151k (File/Open), \u00e9s az aktu\u00e1lis dokumentum bez\u00e1rhat\u00f3 (File/Close). Ezek helye megvan az alkalmaz\u00e1sban, de nincsenek r\u00e9szleteiben implement\u00e1lva (a f\u00fcggv\u00e9nyek t\u00f6rzse nincs kit\u00f6ltve \u2013 opcion\u00e1lis HF).</li> <li>A felhaszn\u00e1l\u00f3i fel\u00fclet fel\u00e9p\u00edt\u00e9se<ul> <li>Az oldal tetej\u00e9n (Sample text) egy mintasz\u00f6veg adhat\u00f3 meg, melyet az aktu\u00e1lis bet\u0171t\u00edpussal az alkalmaz\u00e1s megjelen\u00edt.</li> <li>Az oldalak k\u00f6zep\u00e9n egy karakters\u00e1v tal\u00e1lhat\u00f3. Egy adott karakteren dupl\u00e1n kattintva alatta megjelenik egy, az adott karakterhez tartoz\u00f3 szerkeszt\u0151n\u00e9zet.</li> <li>Az oldal alj\u00e1n egym\u00e1s mellett az eddig szerkeszt\u00e9sre megnyitott karakterek szerkeszt\u0151n\u00e9zetei l\u00e1that\u00f3k. Egy karakter t\u00f6bbsz\u00f6r is megnyithat\u00f3 szerkeszt\u00e9sre, ez esetben t\u00f6bb szerkeszt\u0151n\u00e9zet j\u00f6n l\u00e9tre hozz\u00e1. Ennek az az \u00e9rtelme, hogy ugyanazt a karaktert k\u00fcl\u00f6nb\u00f6z\u0151 nagy\u00edt\u00e1ssal is l\u00e1thatjuk/szerkeszthetj\u00fck.</li> </ul> </li> <li>A szerkeszt\u0151n\u00e9zetek fel\u00e9p\u00edt\u00e9se<ul> <li>Nagy r\u00e9sze (eltekintve a fels\u0151 s\u00e1v) a szerkeszt\u0151fel\u00fclet, ahol fekete h\u00e1tt\u00e9ren s\u00e1rg\u00e1val jelennek meg az akt\u00edv pixelek. Egy adott pixelen az eg\u00e9rrel kattintva a pixel invert\u00e1l\u00f3dik.</li> <li>Bal fels\u0151 sarokban a megjelen\u00edtett karakter l\u00e1that\u00f3</li> <li>\u2019c\u2019 gomb: Clear, minden akt\u00edv pixelt t\u00f6r\u00f6l</li> <li>\u2019+\u2019 gomb: nagy\u00edt\u00e1s</li> <li>\u2019-\u2019 gomb: kicsiny\u00edt\u00e9s</li> </ul> </li> </ul> <p>Futtassuk az alkalmaz\u00e1st, \u00e9s vizsg\u00e1ljuk meg a m\u0171k\u00f6d\u00e9s\u00e9t a fentieknek megfelel\u0151en. Azt mindenk\u00e9ppen n\u00e9zz\u00fck meg, hogy ha egy karakter szerepel a mintasz\u00f6vegben, valamint t\u00f6bbsz\u00f6r megnyitjuk szerkeszt\u00e9sre, akkor az egyik n\u00e9zetben v\u00e1ltoztatva (egy pixelt invert\u00e1lva) valamennyi n\u00e9zete friss\u00fcl.</p> <p>Az alkalmaz\u00e1s a k\u00f3dmennyis\u00e9g minim\u00e1lis \u00e9rt\u00e9ken tart\u00e1sa \u00e9rdek\u00e9ben minimalisztikus, pl. a hibakezel\u00e9s nincs \u00e1ltal\u00e1noss\u00e1g\u00e1ban kidolgozva, hi\u00e1nyoznak ellen\u0151rz\u00e9sek. Ugyanakkor k\u00f3dmegjegyz\u00e9sekkel el van l\u00e1tva, mely seg\u00edti a k\u00f3d ut\u00f3lagos meg\u00e9rt\u00e9s\u00e9t.</p>"},{"location":"labor/old-6-doc-view/#2-feladat-az-alkalmazas-megtervezese","title":"2. Feladat - Az alkalmaz\u00e1s megtervez\u00e9se","text":"<p>A c\u00e9l az, hogy l\u00e1ssuk, milyen folyamatot k\u00f6vetve, milyen l\u00e9p\u00e9sekben dolgozunk, mikor milyen tervez\u0151i l\u00e9p\u00e9seket kell meghoznunk. T\u00f6rekedj\u00fcnk oktat\u00f3i \u00e9s hallgat\u00f3i r\u00e9szr\u0151l is az interaktivit\u00e1sra, k\u00f6z\u00f6sen hozzuk meg a d\u00f6nt\u00e9seket.</p> <p>Hozzunk l\u00e9tre egy \u00faj C# nyelv\u0171 \u201eWindow Form App\u201d projektet (.NET 6-osat), legyen a neve FontEditor. Vegy\u00fcnk fel egy oszt\u00e1lydiagramot: projekten jobb katt, Add / New Item, majd a megjelen\u0151 ablakban Class Diagram kiv\u00e1laszt\u00e1sa, a neve maradhat az alap\u00e9rtelmezett. \u00c1ll\u00edtsuk be, hogy a diagram mutassa majd a m\u0171veletek szignat\u00far\u00e1it is (pl. jobb katt a h\u00e1tt\u00e9ren, Change Members Format / Display Full Signature). A gyakorlat nagy r\u00e9sz\u00e9ben ezt a diagramot fogjuk szerkeszteni.</p> <p>A k\u00e9sz oszt\u00e1lydiagram a k\u00f6vetkez\u0151, eddig fogunk fokozatosan eljutni:</p> <p></p>"},{"location":"labor/old-6-doc-view/#document-view-architektura","title":"Document-View architekt\u00fara","text":"<p>Az els\u0151 tervez\u0151i d\u00f6nt\u00e9s: architekt\u00far\u00e1t kell v\u00e1lasztani. A Document-View eset\u00fcnkben egy\u00e9rtelm\u0171 v\u00e1laszt\u00e1s: dokumentumokkal dolgozunk, \u00e9s t\u00f6bb n\u00e9zettel, melyeket szinkronban kell tartani. Az al\u00e1bbi \u00e1bra ismerteti a m\u0171k\u00f6d\u00e9st. A n\u00e9zetek az observerek, a document pedig a subject, melynek v\u00e1ltoz\u00e1saira az egyes n\u00e9zetek fel vannak iratkozva.</p> <p></p> <p>A D-V architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g\u00fcnk lesz dokumentum oszt\u00e1lyra, amely a dokumentum adatait t\u00e1rolja (tagv\u00e1ltoz\u00f3kban), mint pl. a n\u00e9v, el\u00e9r\u00e9si \u00fat, pixelm\u00e1trix. Tegy\u00fck fel, hogy a k\u00e9s\u0151bbiekben t\u00f6bb dokumentum t\u00edpust is t\u00e1mogatni kell majd: pl. megnyithatunk egy olyan tabf\u00fclet, melyen a BKK j\u00e1rm\u0171vekhez tudjuk rendelni a bet\u0171t\u00edpusokat (elektronikus kijelz\u0151). Vannak olyan dokumentum adatok, melyek minden dokumentum t\u00edpusban megjelennek (pl. n\u00e9v, el\u00e9r\u00e9si \u00fat). Az egyes dokumentum t\u00edpusoknak a k\u00f6z\u00f6s tulajdons\u00e1gait/m\u0171veleteit c\u00e9lszer\u0171 egy <code>Document</code> \u0151soszt\u00e1lyba kiszervezni, hogy ne legyenek duplik\u00e1lva az egyes dokumentum t\u00edpusokat reprezent\u00e1l\u00f3 dokumentum oszt\u00e1lyokban.</p> <ul> <li>Vegy\u00fck fel a <code>Document</code> oszt\u00e1lyt (ez az absztrakt \u0151s).</li> <li>Vegy\u00fcnk fel bele egy <code>string Name</code> property-t (ez jelenik meg a tabf\u00fcleken).</li> </ul> <p>A Document-View architekt\u00far\u00e1b\u00f3l ad\u00f3d\u00f3an sz\u00fcks\u00e9g van egy n\u00e9zet interf\u00e9szre (egy <code>Update</code> m\u0171velettel a n\u00e9zet \u00e9rtes\u00edt\u00e9s\u00e9hez), valamint a dokumentumoknak nyilv\u00e1n kell tartaniuk egy list\u00e1ban a n\u00e9zeteiket:</p> <ul> <li>Vegy\u00fck fel az <code>IView</code> interf\u00e9szt.</li> <li>Vegy\u00fcnk fel bele egy <code>Update</code> m\u0171veletet.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel egy <code>List&lt;IView&gt; views</code> mez\u0151t (a Fields-n\u00e9l). Jobb gombbal kattintsunk a mez\u0151 nev\u00e9n a diagramon, \u00e9s a men\u00fcb\u0151l Show as collection association kiv\u00e1laszt\u00e1sa.</li> <li>A <code>Document</code> oszt\u00e1lyba vegy\u00fcnk fel a <code>void AttachView(IView view)</code> m\u0171veletet, mellyel \u00faj n\u00e9zetet lehet beregisztr\u00e1lni.</li> <li>V\u00e9g\u00fcl vegy\u00fcnk fel egy <code>void DetachView(IView view)</code>-t, mert n\u00e9zetet bez\u00e1rni is lehet.</li> </ul> <p>T\u00e1mogatnunk kell az egyes dokumentumok tartalm\u00e1nak perziszt\u00e1l\u00e1s\u00e1t (ment\u00e9s/bet\u00f6lt\u00e9s). Ezekhez vegy\u00fcnk fel a <code>Document</code> \u0151sbe a megfelel\u0151 m\u0171veleteket:</p> <ul> <li><code>Document</code>-be <code>LoadDocument(string path)</code> felv\u00e9tele.</li> <li><code>Document</code>-be <code>SaveDocument(string path)</code> felv\u00e9tele.</li> <li>Mindkett\u0151 legyen absztrakt, hiszen csak az egyes dokumentum lesz\u00e1rmazottakban tudunk implement\u00e1ci\u00f3t megadni: szelekt\u00e1ljuk ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban az Inheritence modifier legyen Abstract.</li> </ul> <p>Az egyes dokumentumoknak t\u00e1mogatniuk kell a n\u00e9zeteik friss\u00edt\u00e9s\u00e9t, ez minden dokumentum t\u00edpusra k\u00f6z\u00f6s:</p> <ul> <li>A <code>Document</code>-be vegy\u00fck fel az <code>UpdateAllViews()</code>-t (ez felel meg az Observer minta Notify m\u0171velet\u00e9nek).</li> </ul>"},{"location":"labor/old-6-doc-view/#konkret-dokumentum-es-adatai","title":"Konkr\u00e9t dokumentum \u00e9s adatai","text":"<p>Sz\u00fcks\u00e9g van egy olyan dokumentum t\u00edpusra, ami a bet\u0171t\u00edpusok szerkeszt\u00e9s\u00e9hez tartozik, amely a tagv\u00e1ltoz\u00f3iban nyilv\u00e1ntartja a sz\u00fcks\u00e9ges adatokat: legyen a neve <code>FontEditorDocument</code>.</p> <ul> <li>Vegy\u00fck fel a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Sz\u00e1rmaztassuk a <code>Document</code>-b\u0151l (Toolbox \u2013 Inheritence kapcsolat).</li> <li>Ekkor a <code>LoadDocument</code> \u00e9s <code>SaveDocument</code> m\u0171veletekre automatikusan megsz\u00fcletik az override-ol\u00f3 m\u0171velet. Ha m\u00e9gsem lenne \u00edgy<ul> <li>Jel\u00f6lj\u00fck ki az \u0151sben a k\u00e9t m\u0171veletet.</li> <li>Copy</li> <li>Jel\u00f6lj\u00fck ki a <code>FontEditorDocument</code> oszt\u00e1lyt.</li> <li>Paste</li> <li>Jel\u00f6lj\u00fck itt ki a k\u00e9t m\u0171veletet, \u00e9s a Properties ablakban a Instance Modifier legyen <code>override</code>.</li> </ul> </li> </ul> <p>A dokumentumunk tagv\u00e1ltoz\u00f3kban t\u00e1rolja az adatokat. Gondoljuk \u00e1t, hogy ezt hogyan c\u00e9lszer\u0171 megval\u00f3s\u00edtani. Lehetne egy h\u00e1romdimenzi\u00f3s t\u00f6mb (karakter \u2013 x \u2013 y), de ink\u00e1bb emelj\u00fck ki egy k\u00fcl\u00f6n oszt\u00e1lyba az egy adott karakter pixeleinek t\u00e1rol\u00e1s\u00e1t/menedzsel\u00e9s\u00e9t: vezess\u00fck be a <code>CharDef</code> oszt\u00e1lyt.</p> <p>Pixel t\u00f6mb helyett</p> <p>Az\u00e9rt nem a pixelt\u00f6mb\u00f6t haszn\u00e1ljuk k\u00f6zvetlen\u00fcl, mert csak egy \u00faj oszt\u00e1ly bevezet\u00e9s\u00e9vel van lehet\u0151s\u00e9g\u00fcnk kifejezetten ide tartoz\u00f3 m\u0171veletek bevezet\u00e9s\u00e9re, vagyis az egys\u00e9gbez\u00e1r\u00e1s korrekt megval\u00f3s\u00edt\u00e1s\u00e1ra.</p> <ul> <li>Vegy\u00fck fel a <code>CharDef</code> oszt\u00e1lyt.</li> <li> <p><code>CharDef</code>-be <code>bool[,] Pixels</code> tulajdons\u00e1g felv\u00e9tele.</p> <p>t\u00f6bbdimenzo\u00f3s t\u00f6mb\u00f6k C#-ban</p> <p>A fenti p\u00e9ld\u00e1ban egy t\u00f6bbdimenzi\u00f3s t\u00f6mb\u00f6t haszn\u00e1ltunk <code>bool[,]</code> \u00e9s nem t\u00f6mb\u00f6k t\u00f6mbj\u00e9t <code>bool[][]</code>, mivel ezt nyelvi szinten is t\u00e1mogatja a C# \u00e9s jobb teljes\u00edtm\u00e9nyt ny\u00fajt, mint a t\u00f6mb\u00f6k t\u00f6mbje, mert egy objektumk\u00e9nt t\u00f6rol\u00f3dik a heapen.</p> </li> <li> <p><code>CharDef</code>-be <code>char Character</code> felv\u00e9tele: az egyes <code>CharDef</code> oszt\u00e1lyok t\u00e1rolj\u00e1k magukr\u00f3l, hogy mely karakter pixeleit reprezent\u00e1lj\u00e1k.</p> </li> </ul> <p>A dokumentumnak lesz egy gy\u0171jtem\u00e9nye <code>CharDef</code> objektumokb\u00f3l: minden karakterhez pontosan egy darab. Gondoljuk \u00e1t, hogy a legc\u00e9lszer\u0171bb ezt megval\u00f3s\u00edtani. Az egyes karakterdefin\u00edci\u00f3kat a karakterk\u00f3djukkal akarjuk c\u00edmezni, \u00edgy a <code>Dictionary&lt;char, CharDef&gt;</code> ide\u00e1lis v\u00e1laszt\u00e1s: a karakterk\u00f3d a kulcs, az hozz\u00e1 tartoz\u00f3 <code>CharDef</code> pedig az \u00e9rt\u00e9k.</p> <ul> <li><code>FontEditorDocument</code>-be: <code>Dictionary&lt;char, CharDef&gt; charDefs</code> mez\u0151 felv\u00e9tele. Jobb katt, Show as collection association.</li> </ul>"},{"location":"labor/old-6-doc-view/#dokumentumok-menedzselese-app-singleton-osztaly","title":"Dokumentumok menedzsel\u00e9se - App Singleton oszt\u00e1ly","text":"<p>Az alkalmaz\u00e1sban nyilv\u00e1n kell tartani a megnyitott dokumentumok list\u00e1j\u00e1t. Mely oszt\u00e1ly felel\u0151ss\u00e9ge legyen? Vezess\u00fcnk be r\u00e1 egy alkalmaz\u00e1sszint\u0171 oszt\u00e1lyt: legyen a neve <code>App</code> (Windows Forms alatt m\u00e1r van <code>Application</code>, nem c\u00e9lszer\u0171 ezt a nevet v\u00e1lasztani). Ez lesz az alkalmaz\u00e1sunk \u201egy\u00f6k\u00e9roszt\u00e1lya\u201d.</p> <ul> <li>Vegy\u00fck fel az <code>App</code> oszt\u00e1lyt.</li> <li><code>App</code>-ba <code>List&lt;FontEditorDocument&gt; documents</code> mez\u0151 felv\u00e9tele, majd Show as collection association.</li> </ul> <p>Gondoljuk v\u00e9gig, hogyan t\u00f6rt\u00e9nik majd egy \u00faj dokumentum l\u00e9trehoz\u00e1sa (mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor): be kell k\u00e9rni a felhaszn\u00e1l\u00f3t\u00f3l a dokumentum nev\u00e9t, l\u00e9tre kell hozni egy <code>FontEditorDocument</code> objektumot, fel kell venni a megnyitott dokumentumok list\u00e1j\u00e1ba stb. Ezt a logik\u00e1t ne tegy\u00fck a GUI-ba (men\u00fcelem click esem\u00e9nykezel\u0151): tegy\u00fck abba az oszt\u00e1lyba, melynek a felel\u0151ss\u00e9ge a megnyitott dokumentumok menedzsel\u00e9se, amely t\u00e1rolja a sz\u00fcks\u00e9ges adatokat hozz\u00e1 (dokumentum lista). \u00cdgy legyen ez az <code>App</code> oszt\u00e1lyunk feladata, benne vegy\u00fck fel a sz\u00fcks\u00e9ges m\u0171veleteket:</p> <ul> <li><code>App</code>-ba <code>NewDocument</code> \u00e9s <code>OpenDocument</code> m\u0171veletek felv\u00e9tele.</li> </ul> <p>Most a dokumentum ment\u00e9st gondoljuk v\u00e9gig: a File/Save mindig az akt\u00edv dokumentumra vonatkozik. Valakinek nyilv\u00e1n kell tartani, melyik az akt\u00edv dokumentum: legyen ez az <code>App</code>, hiszen \u0151 t\u00e1rolja a dokumentumok list\u00e1j\u00e1t is.</p> <ul> <li>A Toolbox-on v\u00e1lasszuk ki az Association kapcsolatot. Az <code>App</code>-b\u00f3l h\u00fazzunk egy nyilat a <code>FontEditorDocument</code>-be. V\u00e1lasszuk ki az \u00fajonnan l\u00e9trehozott kapcsolatot, \u00e9s nevezz\u00fck \u00e1t <code>ActiveDocument</code>-re.</li> <li><code>App</code>-ba <code>void SaveActiveDocument()</code> felv\u00e9tele.</li> <li><code>App</code>-ba <code>void CloseActiveDocument\u00e1()</code> felv\u00e9tele.</li> </ul> <p>Konkr\u00e9t dokumentumra vagy absztrakt \u0151sre hivatkozzunk?</p> <p>Mivel az <code>App</code> oszt\u00e1lyunk alkalmaz\u00e1s specifikus funkci\u00f3kat l\u00e1t el, nyugodtan hivatkozhat a konkr\u00e9t dokumentum t\u00edpusra, \u00e9s felesleges az absztrakt \u0151st\u0151l f\u00fcggen\u00fcnk, mert az csak nem k\u00edv\u00e1nt castol\u00e1sokhoz vezetne.</p> <p>Az <code>App</code> objektumb\u00f3l \u00e9rtelemszer\u0171en csak egyet kell/szabad l\u00e9trehozni, amely a fut\u00f3 alkalmaz\u00e1st reprezent\u00e1lja. Van m\u00e9g egy probl\u00e9m\u00e1nk: a File/Save stb. men\u00fcelem click esem\u00e9nykezel\u0151ben el kell \u00e9rj\u00fck ezt az egy objektumot. Illetve, majd t\u00f6bb m\u00e1s helyen is. J\u00f3 lenne, ha nem kellene minden oszt\u00e1lyban k\u00fcl\u00f6n el\u00e9rhet\u0151v\u00e9 tenni (tagv\u00e1ltoz\u00f3 vagy f\u00fcggv\u00e9nyparam\u00e9ter form\u00e1j\u00e1ban), hanem b\u00e1rhonnan egyszer\u0171en el\u00e9rhet\u0151 lenne. Erre ny\u00fajt megold\u00e1st a Singleton tervez\u00e9si minta. Egy oszt\u00e1lyb\u00f3l csak egy objektumot enged l\u00e9trehozni, \u00e9s ahhoz glob\u00e1lis hozz\u00e1f\u00e9r\u00e9st biztos\u00edt, m\u00e9gpedig az oszt\u00e1ly nev\u00e9n \u00e9s egy statikus <code>Instance</code> property-n kereszt\u00fcl, pl. \u00edgy: <code>App.Instance.SaveDocument</code> stb. Nem val\u00f3s\u00edtjuk meg teljes \u00e9rt\u00e9k\u0171en, de tegy\u00fck meg az al\u00e1bbiakat:</p> <ul> <li><code>App</code>-ba <code>App Instance</code> property felv\u00e9tele. Properties ablakban static: true.</li> <li><code>App</code>-ba priv\u00e1t konstruktor felv\u00e9tele.</li> </ul> <p>Az <code>App</code>-oszt\u00e1llyal v\u00e9gezt\u00fcnk.</p>"},{"location":"labor/old-6-doc-view/#nezetek","title":"N\u00e9zetek","text":"<p>A n\u00e9zetekkel eddig nem foglalkoztunk, ez a k\u00f6vetkez\u0151 l\u00e9p\u00e9s. Futtassuk a k\u00e9sz alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, hogy h\u00e1ny t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g, melyikb\u0151l h\u00e1ny p\u00e9ld\u00e1ny lesz:</p> <ul> <li>K\u00e9t t\u00edpus\u00fa n\u00e9zetre van sz\u00fcks\u00e9g: az egyik a mintasz\u00f6veget jelen\u00edti meg, a m\u00e1sik egy adott karakter szerkeszt\u00e9s\u00e9t teszi lehet\u0151v\u00e9.</li> <li>Legyen az el\u0151z\u0151 neve <code>SampleTextView</code>, az ut\u00f3bbi\u00e9 <code>FontEditorView</code>.</li> <li><code>SampleTextView</code>-b\u00f3l mindig egy van (egy adott dokumentumra vonatkoz\u00f3an), a <code>FontEditorView</code> objektumok ig\u00e9ny szerint j\u00f6nnek l\u00e9tre, 0..n p\u00e9ld\u00e1ny l\u00e9tezhet.</li> <li>Vegy\u00fck fel a k\u00e9t oszt\u00e1lyt.</li> <li>Implement\u00e1ltassuk vel\u00fck az <code>IView</code> interf\u00e9szt (Toolbox / Inheritence kapcsolat). Az <code>Update</code> m\u0171velet automatikusan implement\u00e1lva lesz.</li> </ul> <p>Az egyes n\u00e9zetek a dokumentumukb\u00f3l \u201et\u00e1pl\u00e1lkoznak\u201d, a a dokumentumukban t\u00e1rolt adatokat jelen\u00edtik meg, azokat m\u00f3dos\u00edtj\u00e1k. Ehhez, a D-V architekt\u00far\u00e1nak megfelel\u0151en el kell \u00e9rj\u00e9k a dokumentumukat.</p> <ul> <li>A <code>SampleTextView</code> \u00e9s <code>FontEditorView</code>-ban vegy\u00fcnk fel egy <code>FontEditorDocument</code> t\u00edpus\u00fa <code>document</code> nev\u0171 mez\u0151t (ha felvett\u00fck az egyikben, lehet copy-paste-tel m\u00e1solni a m\u00e1sikba), majd \"Show as Association\". Megjegyz\u00e9s: az\u00e9rt nem c\u00e9lszer\u0171 \u00e1ltal\u00e1nos <code>Document</code> t\u00edpus\u00fat felvenni (\u00e9s az interf\u00e9szbe felvinni), mert a view-knak a konkr\u00e9t dokumentum adatait (l\u00e1sd al\u00e1bb) el kell \u00e9rni\u00fck.</li> </ul> <p>Gondoljuk v\u00e9gig, milyen adattagokkal rendelkeznek az egyes n\u00e9zetek. Ehhez futtassuk az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg ism\u00e9t a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t.</p> <ul> <li>A <code>SampleTextView</code> t\u00e1rolja a mintasz\u00f6veget, melyet meg kell jelen\u00edteni. Vegy\u00fcnk fel egy <code>sampleText:string</code> mez\u0151t. Ha el kellene menteni a mintasz\u00f6veget is, akkor a <code>FontEditorDocument</code>-ben kellene t\u00e1rolni (\u00e9s onnan mindig lek\u00e9rdezni), mert az adatok ment\u00e9s\u00e9\u00e9rt a dokumentum oszt\u00e1lyunk a felel\u0151s.</li> <li>A <code>FontEditorView</code> k\u00e9t dolgot t\u00e1rol:<ul> <li>A karakter k\u00f3dja, melynek pixeleit megjelen\u00edti. Vegy\u00fcnk fel egy <code>editedChar: char</code> mez\u0151t.</li> <li>A nagy\u00edt\u00e1si t\u00e9nyez\u0151t (<code>zoom: double</code> felv\u00e9tele)</li> </ul> </li> </ul> <p>A n\u00e9zetek maguk felel\u0151sek a kirajzol\u00e1suk\u00e9rt:</p> <ul> <li><code>Draw (g:Graphics)</code> felv\u00e9tele mindk\u00e9t n\u00e9zetbe.</li> </ul>"},{"location":"labor/old-6-doc-view/#fonteditordocument-muveletek","title":"FontEditorDocument m\u0171veletek","text":"<p>A <code>FontEditorDocument</code>-ben egy priv\u00e1t list\u00e1ban van egyel\u0151re jelen a <code>CharDef</code>-ek list\u00e1ja. A n\u00e9zetek \u00edgy nem tudj\u00e1k el\u00e9rni, pedig a megjelen\u00edt\u00e9shez sz\u00fcks\u00e9g\u00fck lenne r\u00e1. A dokumentumunkban be kell vezess\u00fcnk olyan m\u0171veleteket, melyek a dokumentum \u00e1ltal t\u00e1rolt adatokat a n\u00e9zetek sz\u00e1m\u00e1ra el\u00e9rhet\u0151v\u00e9 teszik, \u00e9s lehet\u0151s\u00e9get biztos\u00edtanak a m\u00f3dos\u00edt\u00e1sra is.</p> <ul> <li>Mindk\u00e9t n\u00e9zet el kell \u00e9rje a megjelen\u00edtett karakterek pixeleit t\u00e1rol\u00f3 <code>CharDef</code> objektumokat. Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben a <code>GetCharDef(c:char):CharDef</code> m\u0171veletet. Ezt hossz\u00fa t\u00e1von majd \u00fagy lesz c\u00e9lszer\u0171 megval\u00f3s\u00edtani, hogy a <code>GetCharDef</code> nem az eredeti objektumot adja vissza, hanem annak egy m\u00e1solat\u00e1t (clone). Ha az eredetit adn\u00e1 vissza, akkor a n\u00e9zetek K\u00d6ZVETLEN\u00dcL tudn\u00e1k m\u00f3dos\u00edtani a pixelek \u00e9rt\u00e9k\u00e9t, ezt mi nem akarjuk (b\u00e1r a funkci\u00f3k b\u0151v\u00edt\u00e9s\u00e9vel r\u00e1k\u00e9nyszer\u00fclhet\u00fcnk).</li> <li>A <code>FontEditorView</code>-nak k\u00e9pesnek kell lennie egy adott <code>CharDef</code> adott koordin\u00e1t\u00e1ban lev\u0151 pixel \u00e9rt\u00e9k\u00e9t invert\u00e1lni (eg\u00e9r kattint\u00e1skor). Ehhez vezess\u00fck be a <code>FontEditorDocument</code>-ben az <code>InvertCharDefPixel(c:char, x: int, y: int)</code> m\u0171veletet.</li> </ul>"},{"location":"labor/old-6-doc-view/#a-tervezes-zarasa","title":"A tervez\u00e9s z\u00e1r\u00e1sa","text":"<p>Eljutottunk oda, hogy megtervezt\u00fck az architekt\u00far\u00e1t, minden igaz\u00e1n l\u00e9nyeges d\u00f6nt\u00e9st meghoztunk. Az UML diagram alapj\u00e1n megsz\u00fcletett az oszt\u00e1lyok v\u00e1za. Ezt term\u00e9szetesen jelent\u0151sen b\u0151v\u00edteni kell, m\u00e9g sz\u00fcletnek \u00faj oszt\u00e1lyok is (pl. Form-ok, vez\u00e9rl\u0151k).</p>"},{"location":"labor/old-6-doc-view/#3-feladat-a-kesz-alkalmazas-attekintese","title":"3. Feladat - A k\u00e9sz alkalmaz\u00e1s \u00e1ttekint\u00e9se","text":"<p>Id\u0151 hi\u00e1ny\u00e1ban nem val\u00f3s\u00edtjuk meg az alkalmaz\u00e1st, hanem a k\u00e9sz megold\u00e1st n\u00e9zz\u00fck \u00e1t (laboron kb. 15 percben), annak is csak n\u00e9h\u00e1ny l\u00e9nyeges haszn\u00e1lati eset\u00e9t.</p> <p>T\u00f6lts\u00fck le  a k\u00e9sz megold\u00e1st. Ehhez parancssorban navig\u00e1ljunk a c:\\work\\ mapp\u00e1ba (ha a laborban dolgozunk), \u00e9s adjuk ki a k\u00f6vetkez\u0151 parancsot: <p><code>git clone https://github.com/bmeviauab00/lab-docview-megoldas</code></p> <p>Nyissuk meg a k\u00e9sz solution-t, futtassuk \u00e9s pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1s alapfunkci\u00f3it.</p>"},{"location":"labor/old-6-doc-view/#nezetek-megvalositasa","title":"N\u00e9zetek megval\u00f3s\u00edt\u00e1sa","text":"<p>Nyissuk meg a <code>FontEditorView</code>-t, el\u0151sz\u00f6r a k\u00f3dot n\u00e9zz\u00fck. A <code>FontEditorView</code> egyr\u00e9szt implement\u00e1lja az <code>IView</code> interf\u00e9szt, m\u00e1sr\u00e9szt a <code>UserControl</code>-b\u00f3l sz\u00e1rmazik. M\u00e9gpedig az\u00e9rt, mert \u00edgy a tervez\u0151ben (designer) tudjuk kialak\u00edtani a felhaszn\u00e1l\u00f3i fel\u00fclet\u00e9t, pont \u00fagy, mint egy \u0171rlapnak. A Visual Studio designer fel\u00fclet\u00e9n ak\u00e1r bele is m\u00f3dos\u00edthatn\u00e1nk a layoutba \u00e9s a vez\u00e9rl\u0151k tulajdons\u00e1gaiba. Ha k\u00edv\u00e1ncsiak vagyunk, ki is pr\u00f3b\u00e1lhatjuk ezt (pl. a nagy\u00edt\u00e1s \u00e9s a kicsiny\u00edt\u00e9s gombok hely\u00e9nek megv\u00e1ltoztat\u00e1s\u00e1val).</p> <p>A <code>SampleTextView</code> is <code>UserControl</code> lesz\u00e1rmazott, b\u00e1r annak egyszer\u0171 a fel\u00fclete (nincsenek rajta m\u00e1s vez\u00e9rl\u0151k), \u00edgy lehetett volna k\u00f6z\u00f6ns\u00e9ges <code>Control</code> lesz\u00e1rmazott is.</p> <p> Vonjuk le a tanuls\u00e1got: Windows Forms k\u00f6rnyezetben a n\u00e9zeteket tipikusan <code>UserControl</code>-k\u00e9nt (esetleg <code>Control</code>-k\u00e9nt) c\u00e9lszer\u0171 megval\u00f3s\u00edtani.</p>"},{"location":"labor/old-6-doc-view/#egy-oldal-tab-elrendezese","title":"Egy oldal (tab) elrendez\u00e9se","text":"<p>Futtassuk az alkalmaz\u00e1st. Valahogy ki kell alak\u00edtsuk egy adott oldal (tabpage) elrendez\u00e9s\u00e9t. Lehet\u0151leg tervez\u0151i n\u00e9zetben, \u00e9s nem fut\u00e1s k\u00f6zben, k\u00f3db\u00f3l poz\u00edcion\u00e1lva az elemeket (legal\u00e1bbis ahol nem musz\u00e1j). A <code>UserControl</code>-ok alkalmaz\u00e1sa jelenti sz\u00e1munkra a megold\u00e1st. Nyissuk meg a <code>FontDocumentControl</code>-t tervez\u0151i n\u00e9zetben. Ez egy olyan vez\u00e9rl\u0151, amely egy taboldalra ker\u00fcl fel, azt t\u00f6lti ki teljesen. Az oldalt a m\u00e1r ismert layout technik\u00e1kkal alak\u00edtottuk ki (<code>Label</code>, <code>TextBox</code>, <code>Panel</code>-ek Dock-kolva). Ha van id\u0151nk, akkor n\u00e9zz\u00fck meg a Document Outline ablakban. Az igazi \u00e9rdekess\u00e9g pedig az, hogy a <code>SampleTextView</code>-t is a Toolbox-r\u00f3l drag&amp;drop-pal ker\u00fclt felhelyez\u00e9sre (pont \u00fagy, mintha egy be\u00e9p\u00edtett vez\u00e9rl\u0151 lenne). Annyit n\u00e9zz\u00fcnk meg, hogy a <code>SampleTextView</code> val\u00f3ban ott van a Toolbox tetej\u00e9n.</p>"},{"location":"labor/old-6-doc-view/#forgatokonyv-1-egy-pixel-invertalasa-nezetek-szinkronizalasa","title":"Forgat\u00f3k\u00f6nyv 1 \u2013 Egy pixel invert\u00e1l\u00e1sa, n\u00e9zetek szinkroniz\u00e1l\u00e1sa","text":"<p> Ez egy kiemelt jelent\u0151s\u00e9g\u0171 forgat\u00f3k\u00f6nyv, mert ezt illusztr\u00e1lja a D-V architekt\u00fara alapmechanizmus\u00e1t, a n\u00e9zetek friss\u00edt\u00e9s\u00e9t \u00e9s konzisztensen tart\u00e1s\u00e1t. Keress\u00fck meg azt a f\u00fcggv\u00e9nyt, ahol az eg\u00e9sz pixel invert\u00e1l\u00e1s folyamat elindul. A <code>FontEditorView.FontEditorView_MouseClick</code> a kiindul\u00f3pont. Itt az al\u00e1bb kiemelt sor a l\u00e9nyeg:</p> <pre><code>private void FontEditorView_MouseClick(object sender, MouseEventArgs e)\n{\n    int x = e.X / zoom;\n    int y = (e.Y - offsetY) / zoom;\n    if (x &gt;= CharDef.FontSize.Width)\n        return;\n\n    document.InvertCharDefPixel(editedChar, x, y);\n}\n</code></pre> <p>N\u00e9zz\u00fck meg a <code>FontEditorDocument.InvertCharDefPixel</code>-t. Az invert\u00e1lja a megfelel\u0151 <code>CharDef</code> pixel\u00e9t, de a l\u00e9nyeg az utols\u00f3 sor:</p> <pre><code>public void InvertCharDefPixel(char c, int x, int y)\n{\n    var charDef = GetCharDefCore(c);\n    if (charDef == null)\n        return;\n\n    charDef.Pixels[x, y] = !charDef.Pixels[x, y];\n\n    UpdateAllViews();\n}\n</code></pre> <p>Az <code>UpdateAllViews</code> a <code>Document</code> \u0151sben van, <code>Update</code>-et h\u00edv minden n\u00e9zetre. Ami \u00e9rdekes, hogy az <code>Update</code> hogyan van meg\u00edrva az egyes n\u00e9zetekben. N\u00e9zz\u00fck meg pl. a <code>FontEditView</code>-t:</p> <pre><code>public void Update()\n{\n    Invalidate();\n}\n</code></pre> <p>Az <code>Update</code> hat\u00e1s\u00e1ra a n\u00e9zetek \u00fajra kell rajzolj\u00e1k magukat az aktu\u00e1lis dokumentum \u00e1llapot alapj\u00e1n. De az <code>Update</code>-ben nem tudunk rajzolni, csak az <code>OnPaint</code>-ben. \u00cdgy itt az <code>Invalidate</code> h\u00edv\u00e1ssal kiv\u00e1ltjuk a <code>Paint</code> esem\u00e9nyt. Ez megint egy tanuls\u00e1g: Windows Forms alkalmaz\u00e1sokban a n\u00e9zetek <code>Update</code> f\u00fcggv\u00e9ny\u00e9ben tipikusan egy <code>Invalidate</code> h\u00edv\u00e1s szokott lenni.</p> <p>Z\u00e1r\u00e1sk\u00e9ppen n\u00e9zz\u00fck meg a <code>FontEditView.OnPaint</code> megval\u00f3s\u00edt\u00e1s\u00e1t. Egyetlen l\u00e9nyeges dolog van itt: a megjelen\u00edt\u00e9shez le kell k\u00e9rni a dokumentumt\u00f3l az aktu\u00e1lis <code>CharDef</code>-et (mert a n\u00e9zet a D-V architekt\u00fara alapelveinek megfelel\u0151en nem t\u00e1rolja), majd ki kell azt rajzolni.</p> <pre><code>protected override void OnPaint(PaintEventArgs e)\n{\n    base.OnPaint(e);\n\n    var editedCharDef = document.GetCharDef(editedChar);\n\n    CharDefViewModel.DrawFont(e.Graphics, editedCharDef, 0, offsetY, zoom);\n}\n</code></pre> <p>Kirajzol\u00e1s logik\u00e1ja</p> <p>Mivel a kirajzol\u00e1s logik\u00e1ja a <code>FontEditorView</code>-ban \u00e9s a <code>SampleTextView</code>-ban is azonosan m\u0171k\u00f6dik a <code>Graphics</code> oszt\u00e1ly haszn\u00e1lat\u00e1val, kiszervezt\u00fck ezt egy <code>CharDefViewModel</code> seg\u00e9doszt\u00e1lyba az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g kedv\u00e9\u00e9rt.</p> <p>A <code>CharDef</code>-be nem c\u00e9lszer\u0171 rakni ezt a logik\u00e1t, mivel az egy n\u00e9zet f\u00fcggetlen adatreprezent\u00e1ci\u00f3, \u00e9s sokkal ink\u00e1bb a dokumentumhoz tartozik, mint a n\u00e9zethez.</p>"},{"location":"labor/old-6-doc-view/#forgatokonyv-2-uj-dokumentum-letrehozasa-opcionalis","title":"Forgat\u00f3k\u00f6nyv 2 \u2013 \u00daj dokumentum l\u00e9trehoz\u00e1sa (opcion\u00e1lis)","text":"<p>Azt n\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik egy \u00faj dokumentum l\u00e9trehoz\u00e1sa, vagyis mi t\u00f6rt\u00e9nik a File/New men\u00fcelem kiv\u00e1laszt\u00e1sakor.</p> <p>Nyissuk meg a <code>MainForm</code>-ot tervez\u0151i n\u00e9zetben, v\u00e1laszuk a File/New men\u00fcelemet, majd ugorjunk el a <code>Click</code> esem\u00e9nykezel\u0151h\u00f6z. Arra l\u00e1tunk p\u00e9ld\u00e1t, hogy az <code>App</code> oszt\u00e1ly, mint Singleton, hogy \u00e9rhet\u0151 el:</p> <pre><code>App.Instance.NewDocument();\n</code></pre> <p>Az \u00f6sszes t\u00f6bbi men\u00fcelem esem\u00e9nykezel\u0151je hasonl\u00f3, nincs semmi logika a GUI-ban, csak egyszer\u0171 tov\u00e1bbh\u00edv\u00e1s az <code>App</code>-ba.</p> <p>Tekints\u00fck \u00e1t az <code>App.NewDocument</code> t\u00f6rzs\u00e9t, \u00e9s egy-egy mondatban fussuk \u00e1t a fontosabb l\u00e9p\u00e9seket.</p> <ol> <li><code>NewDocForm</code> n\u00e9zet megnyit\u00e1sa \u00e9s v\u00e1rakoz\u00e1s a v\u00e1laszra.</li> <li>Sikeres v\u00e1lasz eset\u00e9n \u00faj <code>FontEditorDocument</code> l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentumok k\u00f6z\u00e9, valamint akt\u00edvv\u00e1 t\u00e9tele.</li> <li>\u00daj tab l\u00e9trehoz\u00e1sa a n\u00e9zetekkel.</li> </ol> <pre><code>public void NewDocument()\n{\n    // Bek\u00e9rj\u00fckk az \u00faj font t\u00edpus (dokumentum) nev\u00e9t a\n    // felhaszn\u00e1l\u00f3t\u00f3l egy mod\u00e1lis dial\u00f3gs ablakban.\n    var form = new NewDocForm(GetDocumentNames());\n    if (form.ShowDialog() != DialogResult.OK)\n        return;\n\n    // \u00daj dokumentum objektum l\u00e9trehoz\u00e1sa \u00e9s felv\u00e9tele a dokumentum list\u00e1ba.\n    var doc = new FontEditorDocument(form.FontName);\n    documents.Add(doc);\n\n    // Az \u00faj tab lesz az akt\u00edv, az activeDocument tagv\u00e1ltoz\u00f3t erre kell \u00e1ll\u00edtani.\n    UpdateActiveDocument(doc.Name);\n\n    CreateTabForNewDocument(doc);\n}\n</code></pre> <p>App oszt\u00e1ly felel\u0151ss\u00e9gi k\u00f6re</p> <p>Az egyszer\u0171s\u00e9g \u00e9rdek\u00e9ben az <code>App</code> oszt\u00e1ly most t\u00f6bb felel\u0151ss\u00e9ggel is rendelkezik, de ide\u00e1lis esetben sz\u00e9t lenne szedve pl. a k\u00f6vetkez\u0151 oszt\u00e1lyokra a felel\u0151ss\u00e9gi k\u00f6r\u00f6knek megfelel\u0151en:</p> <ul> <li><code>DocumentManager</code>: a megjelen\u00edt\u00e9st\u0151l f\u00fcggetlen\u00fcl a dokumentumokat t\u00e1roln\u00e1.</li> <li><code>ViewManager</code>: feladata a n\u00e9zetek menedzsel\u00e9se, tabcontrolokhoz hozz\u00e1ad\u00e1sa stb. lenne.</li> </ul> <p>Az <code>App.OpenDocument</code> m\u0171velet t\u00f6rzse nincs implement\u00e1lva, de a l\u00e9p\u00e9sek k\u00f3dmegjegyz\u00e9sek form\u00e1j\u00e1ban adottak, remek otthoni gyakorl\u00e1si lehet\u0151s\u00e9g a m\u0171velet t\u00e9nyleges megval\u00f3s\u00edt\u00e1sa.</p>"},{"location":"labor/old-7-tervezesi-mintak/","title":"7. Tervez\u00e9si mint\u00e1k","text":""},{"location":"labor/old-7-tervezesi-mintak/#a-gyakorlat-celja","title":"A gyakorlat c\u00e9lja","text":"<p>A gyakorlat c\u00e9ljai:</p> <ul> <li>Egy \u00f6sszetettebb p\u00e9lda alapj\u00e1n n\u00e9h\u00e1ny tervez\u00e9si minta gyakorlati alkalmaz\u00e1sa (els\u0151dlegesen Singleton, Command Processor \u00e9s Memento).</li> <li>A Document-View minta tov\u00e1bbi gyakorl\u00e1sa, illetve annak demonstr\u00e1l\u00e1sa, hogy a mint\u00e1nak t\u00f6bb vari\u00e1nsa l\u00e9tezik.</li> <li>Alapszint\u0171 betekint\u00e9st nyerni az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1got t\u00e1mogat\u00f3 oszt\u00e1lyk\u00f6nyvt\u00e1rak/keretrendszerek fejleszt\u00e9s\u00e9nek vil\u00e1g\u00e1ba.</li> <li>Jelent\u0151s\u00e9g\u00fcknek megfelel\u0151en tov\u00e1bb gyakoroljuk az objektumorient\u00e1lt paradigma legfontosabb koncepci\u00f3it (pl. felel\u0151ss\u00e9gek k\u00fcl\u00f6nv\u00e1laszt\u00e1sa).</li> </ul> <p>Kapcsol\u00f3d\u00f3 el\u0151ad\u00e1sok:</p> <ul> <li>Tervez\u00e9si mint\u00e1k</li> <li>Szoftver architekt\u00far\u00e1k t\u00e9mak\u00f6rb\u0151l a Document-View architekt\u00fara</li> <li>Windows Forms alkalmaz\u00e1sok fejleszt\u00e9se</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A gyakorlat elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Visual Studio 2022</li> <li>Windows 10 vagy Windows 11 oper\u00e1ci\u00f3s rendszer (Linux \u00e9s macOS nem alkalmas)</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#megoldas","title":"Megold\u00e1s","text":"A k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se <p> L\u00e9nyeges, hogy a labor sor\u00e1n a laborvezet\u0151t k\u00f6vetve kell dolgozni, tilos (\u00e9s \u00e9rtelmetlen) a k\u00e9sz megold\u00e1s let\u00f6lt\u00e9se. Ugyanakkor az ut\u00f3lagos \u00f6n\u00e1ll\u00f3 gyakorl\u00e1s sor\u00e1n hasznos lehet a k\u00e9sz megold\u00e1s \u00e1ttekint\u00e9se, \u00edgy ezt el\u00e9rhet\u0151v\u00e9 tessz\u00fck.</p> <p>A megold\u00e1s GitHubon \u00e9rhet\u0151 el itt. A legegyszer\u0171bb m\u00f3d a let\u00f6lt\u00e9s\u00e9re, ha parancssorb\u00f3l a <code>git clone</code> utas\u00edt\u00e1ssal lekl\u00f3nozzuk a g\u00e9p\u00fcnkre:</p> <p><code>git clone https://github.com/bmeviauab00/lab-designpattern-kiindulo -b megoldas-refactor-elott</code></p> <p>Ehhez telep\u00edtve kell legyen a g\u00e9pre a parancssori git, b\u0151vebb inform\u00e1ci\u00f3 itt.</p>"},{"location":"labor/old-7-tervezesi-mintak/#bevezeto","title":"Bevezet\u0151","text":""},{"location":"labor/old-7-tervezesi-mintak/#elmeleti-hatter","title":"Elm\u00e9leti h\u00e1tt\u00e9r","text":"<p>A komplexebb alkalmaz\u00e1sok fejleszt\u00e9se sor\u00e1n sz\u00e1mos tervez\u0151i d\u00f6nt\u00e9st kell meghoznunk, melyek sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk. Amennyiben ezen pontokban olyan d\u00f6nt\u00e9seket hozunk, melyek nem k\u00f6vetik az objektumorient\u00e1lt szeml\u00e9letm\u00f3d alapelveit, nem tartjuk szem el\u0151tt az alkalmaz\u00e1sunk k\u00f6nny\u0171 karbantarthat\u00f3s\u00e1g\u00e1t, illetve egyszer\u0171en megval\u00f3s\u00edthat\u00f3 tov\u00e1bbfejleszt\u00e9si lehet\u0151s\u00e9g\u00e9t, k\u00f6nnyen hamar r\u00e9m\u00e1lomm\u00e1 v\u00e1lhat a fejleszt\u00e9s. Az egyes hib\u00e1k jav\u00edt\u00e1sa folyamatosan \u00faj hib\u00e1kat sz\u00fcl. Ezen fel\u00fcl a megrendel\u0151i v\u00e1ltoztat\u00e1si \u00e9s b\u0151v\u00edt\u00e9si ig\u00e9nyek a k\u00f3d nagym\u00e9rt\u00e9k\u0171 folyamatos \u00e1t\u00edr\u00e1s\u00e1t ig\u00e9nylik ahelyett, hogy a k\u00f3d p\u00e1r j\u00f3l meghat\u00e1rozott pontj\u00e1ban t\u00f6rt\u00e9n\u0151 b\u0151v\u00edt\u00e9s\u00e9vel - a megl\u00e9v\u0151 k\u00f3d jelent\u0151s m\u00f3dos\u00edt\u00e1sa n\u00e9lk\u00fcl - el tudn\u00e1nk ezt \u00e9rni. A tervez\u00e9si mint\u00e1k j\u00f3l bev\u00e1lt megold\u00e1sokat mutatnak bizonyos gyakran el\u0151fordul\u00f3 tervez\u00e9si probl\u00e9m\u00e1kra: ezen megold\u00e1sok abban seg\u00edtenek, hogy k\u00f3dunk k\u00f6nnyebben b\u0151v\u00edthet\u0151, karbantarthat\u00f3 \u00e9s min\u00e9l nagyobb m\u00e9rt\u00e9kben \u00fajrafelhaszn\u00e1lhat\u00f3 legyen. Ugyanakkor ne ess\u00fcnk \u00e1t a l\u00f3 t\u00faloldal\u00e1ra: csak akkor \u00e9rdemes egy adott tervez\u00e9si mint\u00e1t bevetni, ha adott esetben val\u00f3s el\u0151nyt jelent az alkalmaz\u00e1sa. Ellenkez\u0151 esetben csak a megval\u00f3s\u00edt\u00e1s komplexit\u00e1s\u00e1t n\u00f6veli feleslegesen.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-feladat-ismertetese","title":"A feladat ismertet\u00e9se","text":"<p>A feladatunk egy vektorgrafikus rajzol\u00f3program kifejleszt\u00e9se:</p> <ul> <li>Az alkalmaz\u00e1sban vektorgrafikus alakzatokat lehet l\u00e9trehozni, \u00fagymint t\u00e9glalap, ellipszis stb.</li> <li>A m\u00e1r l\u00e9trehozott alakzatokat egy grafikus fel\u00fcleten meg kell jelen\u00edteni (ki kell rajzolni).</li> <li>A m\u00e1r l\u00e9trehozott alakzatok fontosabb param\u00e9tereit, \u00fagymint koordin\u00e1t\u00e1k, befoglal\u00f3 t\u00e9glalap meg kell jelen\u00edteni egy list\u00e1ban egy inform\u00e1ci\u00f3s panelen.</li> <li>Windows Forms technol\u00f3gi\u00e1ra \u00e9p\u00edtve dolgozunk.</li> <li>Document-View architekt\u00far\u00e1t k\u00f6vetj\u00fck, de egyszerre csak egy dokumentum lehet megnyitva (nincsenek dokumentumonk\u00e9nt tabf\u00fclek vagy ablakok).</li> <li>Egy adott pontig el\u0151k\u00e9sz\u00edtett k\u00f6rnyezetet visz\u00fcnk tov\u00e1bb. A munka mennyis\u00e9g\u00e9nek kezelhet\u0151 szinten tart\u00e1sa v\u00e9gett csak bizonyos pontig vissz\u00fck tov\u00e1bb a fejleszt\u00e9st, nem val\u00f3s\u00edtjuk meg a teljes \u00e9rt\u00e9k\u0171 megold\u00e1st. Az \u00fajonnan besz\u00farand\u00f3 sorokat az \u00fatmutat\u00f3ban kiemelt h\u00e1tt\u00e9r jelzi.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#1-feladat-a-kiindulasi-kornyezet-megismerese","title":"1. Feladat - A kiindul\u00e1si k\u00f6rnyezet megismer\u00e9se","text":"<p>Kl\u00f3nozzuk le a gyakorlathoz tartoz\u00f3 kiindul\u00f3 alkalmaz\u00e1s repositoryj\u00e1t:</p> <ul> <li>Nyissunk egy command prompt-ot,</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN</li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone https://github.com/bmeviauab00/lab-designpattern-kiindulo</code></li> <li>Nyissuk meg a DesignPatternApp.sln solutiont Visual Studio-ban.</li> </ul> <p>Futtassuk az alkalmaz\u00e1st, az al\u00e1bbihoz hasonl\u00f3 fel\u00fcletet l\u00e1tunk (amennyiben a File/New men\u00fcelemet kiv\u00e1lasztjuk):</p> <p></p> <p>Ismerkedj\u00fcnk meg m\u0171k\u00f6d\u00e9s\u00e9nek n\u00e9h\u00e1ny aspektus\u00e1val:</p> <ul> <li>A legt\u00f6bb funkci\u00f3 nincs m\u00e9g megval\u00f3s\u00edtva.</li> <li>A File/New men\u00fcelem valamint a toolbar els\u0151 gombja egy \u00faj dokumentumot hoz l\u00e9tre. Ez m\u00e1r m\u0171k\u00f6dik, pr\u00f3b\u00e1ljuk ki.</li> <li>Mivel \u00faj alakzatot jelen pillanatban m\u00e9g nem tudunk l\u00e9trehozni, a dokumentum a l\u00e9trej\u00f6tt\u00e9t k\u00f6vet\u0151en nem \u00fcres, tartalmaz n\u00e9mi tesztel\u00e9st szolg\u00e1l\u00f3 adatot (k\u00e9t t\u00e9glalapot \u00e9s egy ellipszist).</li> <li>Az alakzatok kirajzol\u00e1sa is meg van val\u00f3s\u00edtva. Ezen fel\u00fcl a jobb oldali inform\u00e1ci\u00f3s panelen l\u00e1thatjuk a m\u00e1r l\u00e9tez\u0151 alakzatok param\u00e9tereit.</li> <li>Az alakzatok k\u00f6z\u00fcl egy ki lehet v\u00e1lasztva: ez piros sz\u00ednnel \u00e9s szaggatott k\u00e9k kerettel ker\u00fcl kirajzol\u00e1sra, illetve az inform\u00e1ci\u00f3s panelen ki is van v\u00e1lasztva az alakzathoz tartoz\u00f3 sor. \u00daj alakzat kijel\u00f6l\u00e9s\u00e9re az inform\u00e1ci\u00f3s panelen a megfelel\u0151 sor kiv\u00e1laszt\u00e1s\u00e1val van m\u00f3d. Ezt pr\u00f3b\u00e1ljuk is ki. Azt tapasztaljuk, hogy v\u00e1ltoztat\u00e1skor a bal oldali grafikus fel\u00fclet is friss\u00fcl, a kiv\u00e1lasztott alakzat sz\u00edne piros lesz. Hangs\u00falyozzuk, hogy ez bizony a klasszikus dokumentum-n\u00e9zet architekt\u00fara alap\u00fa megk\u00f6zel\u00edt\u00e9s ig\u00e9ny\u00e9t veti fel: a dokumentumunkhoz k\u00e9t n\u00e9zet kapcsol\u00f3dik, melyeket konzisztensen kell tartani. Megjegyz\u00e9s: a teljes \u00e9rt\u00e9k\u0171 megold\u00e1sban a bal oldali grafikus n\u00e9zetben is megval\u00f3s\u00edthatn\u00e1nk az eg\u00e9rkattint\u00e1sra t\u00f6rt\u00e9n\u0151 kijel\u00f6l\u00e9st. Ez jelent\u0151sen komplexebb\u00e9 tenn\u00e9 a k\u00e9s\u0151bbi feladataink megval\u00f3s\u00edt\u00e1s\u00e1t, \u00edgy ezt sz\u00e1nd\u00e9kosan kihagyjuk.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#megvalositando-funkciok","title":"Megval\u00f3s\u00edtand\u00f3 funkci\u00f3k","text":"<p>A k\u00f6vetkez\u0151 funkci\u00f3kat fogjuk a gyakorlat sor\u00e1n megval\u00f3s\u00edtani:</p> <ul> <li>\u00daj t\u00e9glalap \u00e9s \u00faj ellipszis l\u00e9trehoz\u00e1sa v\u00e9letlen poz\u00edci\u00f3ban. A funkci\u00f3k az eszk\u00f6zs\u00e1von (toolbar)  \u00e9s a Tools men\u00fc alatt is el\u00e9rhet\u0151k.</li> <li>Dokumentum tartalm\u00e1nak t\u00f6rl\u00e9se. Minden alakzatot elt\u00e1vol\u00edt a dokumentumb\u00f3l. File/Clear men\u00fcvel el\u00e9rhet\u0151.</li> <li>Visszavon\u00e1s (Undo). Az utols\u00f3 parancs visszavon\u00e1sa, ak\u00e1rh\u00e1ny l\u00e9p\u00e9sig visszamen\u0151en. Visszavonja az utols\u00f3 parancsot, legyen az valamilyen \u00faj alakzat l\u00e9trehoz\u00e1sa, vagy a dokumentum tartalm\u00e1nak t\u00f6rl\u00e9se. Az eszk\u00f6zs\u00e1von \u00e9s \u00e9s az Edit/Undo men\u00fcvel is el\u00e9rhet\u0151.</li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#a-solution-felepitese","title":"A solution fel\u00e9p\u00edt\u00e9se","text":"<p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben a kiindul\u00f3 k\u00f3db\u00e1zissal fogunk megismerkedni. Gyakorlatilag az architekt\u00far\u00e1nk komponens n\u00e9zet\u00e9t tekintj\u00fck \u00e1t ebben a l\u00e9p\u00e9sben. A Visual Studio Solution Explorer ablak\u00e1ban megfigyelhet\u0151, hogy solution\u00fcnk k\u00e9t projektet is tartalmaz.</p> <ul> <li><code>AppFx</code>: Egy oszt\u00e1lyk\u00f6nyvt\u00e1r (egy DLL a kimenete). Az ebben tal\u00e1lhat\u00f3 oszt\u00e1lyok \u00e1ltal\u00e1nos dokumentumkezel\u00e9si \u00e9s parancskezel\u00e9si szolg\u00e1ltat\u00e1sokat val\u00f3s\u00edtanak meg, melyek ak\u00e1r t\u00f6bb alkalmaz\u00e1sban is felhaszn\u00e1lhat\u00f3k. Az oszt\u00e1lyk\u00f6nyvt\u00e1r bevezet\u00e9s\u00e9vel az els\u0151dleges c\u00e9lunk teh\u00e1t az \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g el\u00e9r\u00e9se.</li> <li><code>DesignPatternApp</code>: A futtathat\u00f3 (.exe) alkalmaz\u00e1sunk projektje, mely \u00e9p\u00edt az <code>AppFx</code> oszt\u00e1lyk\u00f6nyvt\u00e1rra.</li> </ul> <p>F\u00fcgg\u0151s\u00e9g a projektek k\u00f6z\u00f6tt</p> <p>Visual Studio projektek k\u00f6z\u00f6tt mindig csak egyir\u00e1ny\u00fa f\u00fcgg\u0151s\u00e9g lehet. Jelen esetben a DesignPatternApp \u00e9p\u00edt az <code>AppFx</code> projektre. Ezt a gyakorlatban \u00fagy val\u00f3s\u00edtottuk meg, hogy a DesignPatternApp projektben felvett\u00fcnk egy referenci\u00e1t az <code>AppFx</code> projektre. Ett\u0151l kezdve az DesignPatternApp-ban el\u00e9rhet\u0151k az <code>AppFx</code> (publikus) oszt\u00e1lyai. Ford\u00edtva viszont nem igaz az \u00e1ll\u00edt\u00e1s, \u00e9s ennek el\u00e9r\u00e9s\u00e9re nincs is m\u00f3d.</p>"},{"location":"labor/old-7-tervezesi-mintak/#document-view-architektura","title":"Document-View architekt\u00fara","text":"<p>Az alkalmaz\u00e1sunk a Document-View architekt\u00far\u00e1ra \u00e9p\u00fcl, annak n\u00e9mik\u00e9ppen tov\u00e1bbfejlesztett koncepci\u00f3j\u00e1t val\u00f3s\u00edtja meg: ahelyett, hogy a n\u00e9zeteknek egy <code>Update</code> m\u0171velete lenne, amelyen kereszt\u00fcl \u00e1ltal\u00e1nos v\u00e1ltoz\u00e1s \u00e9rtes\u00edt\u00e9st kapnak a dokumentumukt\u00f3l, a dokumentumok k\u00fcl\u00f6nb\u00f6z\u0151 v\u00e1ltoz\u00e1si esem\u00e9nyeket publik\u00e1lhatnak: minden n\u00e9zet arra az esem\u00e9nyre fizet el\u0151, \u00e9s arr\u00f3l kap \u00e9rtes\u00edt\u00e9st, mely sz\u00e1m\u00e1ra \u00e9rdekes.</p> <ul> <li>Az <code>AppFx</code> projekt DocView mapp\u00e1j\u00e1ban tal\u00e1lhat\u00f3 egy <code>Document</code> oszt\u00e1ly \u00e9s egy <code>IView</code> interf\u00e9sz. N\u00e9zz\u00fck meg \u0151ket sorban (nyissuk is meg a forr\u00e1sf\u00e1jlt):<ul> <li><code>Document</code>: K\u00fcl\u00f6nb\u00f6z\u0151 dokumentum t\u00edpusok \u0151soszt\u00e1lyak\u00e9nt szolg\u00e1lhat. T\u00f6bbek k\u00f6z\u00f6tt van egy n\u00e9zet list\u00e1ja. (Megjegyz\u00e9s: mivel alkalmaz\u00e1sunk a Document-View architekt\u00fara egy speci\u00e1lis vari\u00e1ns\u00e1t haszn\u00e1lja, a n\u00e9zet list\u00e1t az \u0151sb\u0151l el is hagyhattuk volna).</li> <li><code>IView</code>: K\u00fcl\u00f6nb\u00f6z\u0151 n\u00e9zet implement\u00e1ci\u00f3k k\u00f6z\u00f6s interf\u00e9sze. Nincs <code>Update</code> m\u0171velet, helyette egy <code>SetDocumentAndRegisterToDocEvents</code> m\u0171veletet tal\u00e1lunk (ebben kell a n\u00e9zetnek a dokumentum megfelel\u0151 esem\u00e9nyeire beregisztr\u00e1lnia).</li> </ul> </li> </ul> <p>A k\u00f6vetkez\u0151kben a <code>DesignPatternApp</code> projekt kapcsol\u00f3d\u00f3 oszt\u00e1lyait tekintj\u00fck \u00e1t:</p> <ul> <li> <p><code>DrawingDocument</code> oszt\u00e1ly</p> <ul> <li>Egy <code>shapes</code> nev\u0171 list\u00e1ban t\u00e1rolja az alakzatokat.</li> <li>A <code>selectedShape</code> az aktu\u00e1lisan kiv\u00e1lasztott alakzatra mutat.</li> <li>A dokumentum adatai a <code>Shapes</code>, <code>SelectedShape</code> \u00e9s <code>SelectedShapeIndex</code> tulajdons\u00e1gokon kereszt\u00fcl \u00e9rhet\u0151k el a k\u00fclvil\u00e1g (pl. n\u00e9zetek) sz\u00e1m\u00e1ra.</li> <li>A kor\u00e1bban ismertetett koncepci\u00f3nknak megfelel\u0151en a dokumentumunk k\u00e9t esem\u00e9nyt is publik\u00e1l, melyek C# esem\u00e9nyk\u00e9nt vannak megval\u00f3s\u00edtva:<ul> <li><code>ShapesChanged</code>: azt jelzi, hogy az alakzatok list\u00e1ja megv\u00e1ltozott, pl. \u00faj alakzattal b\u0151v\u00fclt, vagy kiker\u00fclt egy alakzat a list\u00e1b\u00f3l, vagy ak\u00e1r egy alakzat adatai v\u00e1ltoztak meg a list\u00e1ban.</li> <li><code>SelectionChanged</code>: azt jelzi, hogy egy kor\u00e1bbit\u00f3l elt\u00e9r\u0151 alakzat ker\u00fclt kiv\u00e1laszt\u00e1sra (mely piros sz\u00ednnel jelenik meg rajzol\u00e1skor).</li> </ul> </li> <li>A <code>CreateRect</code> \u00e9s <code>CreateEllipse</code> m\u0171veletek l\u00e9trehoznak egy megfelel\u0151 alakzatot, amit a dokumentum el is t\u00e1rol (\u00e9s term\u00e9szetesen el is s\u00fcti a <code>ShapesChanged</code> esem\u00e9nyt).</li> </ul> </li> <li> <p><code>ViewBase</code> oszt\u00e1ly</p> <ul> <li>A n\u00e9zeteink k\u00f6z\u00f6s \u0151soszt\u00e1lya, a k\u00f3dduplik\u00e1ci\u00f3 elker\u00fcl\u00e9s\u00e9re vezett\u00fck be. Implement\u00e1lja az <code>IView</code> interf\u00e9szt.</li> <li><code>UserControl</code>-b\u00f3l sz\u00e1rmazik (hasonl\u00f3 koncepci\u00f3t m\u00e1r l\u00e1ttunk a megel\u0151z\u0151 gyakorlat <code>FontEditor</code> p\u00e9ld\u00e1j\u00e1ban).</li> <li>A <code>document</code> tagv\u00e1ltoz\u00f3ban t\u00e1rolja a n\u00e9zetet.</li> <li>A dokumentum megfelel\u0151 esem\u00e9nyeire val\u00f3 fel/leiratkoz\u00e1shoz bevezeti a <code>RegisterToDocEvents</code> \u00e9s <code>UnRegisterToDocEvents</code> virtu\u00e1lis m\u0171veleteket, a lesz\u00e1rmazottakban ig\u00e9ny szerint kell implement\u00e1lni.</li> </ul> </li> <li><code>GraphicsView</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk bal oldali, grafikus n\u00e9zet\u00e9nek implement\u00e1ci\u00f3ja.</li> <li>A <code>ViewBase</code>-b\u0151l sz\u00e1rmazik, \u00edgy k\u00f6zvetve ezen oszt\u00e1lyunk is egy <code>UserControl</code>.</li> <li>A <code>RegisterToDocEvents</code> m\u0171velet\u00e9ben a dokumentum mindk\u00e9t esem\u00e9ny\u00e9re (<code>ShapesChanged</code> \u00e9s <code>SelectionChanged</code>) el\u0151fizet, ugyanazt a <code>DocumentOnShapesChanged</code> esem\u00e9nykezel\u0151 f\u00fcggv\u00e9nyt regisztr\u00e1lja be. Az esem\u00e9nykezel\u0151ben egy egyszer\u0171 <code>Invalidate</code> h\u00edv\u00e1st tal\u00e1lunk, mely kik\u00e9nyszer\u00edti a n\u00e9zet\u00fcnk \u00fajrarajzol\u00e1s\u00e1t.</li> <li>Az <code>OnPaint</code> megval\u00f3s\u00edt\u00e1s\u00e1nak alapelve: minden alakzatra megh\u00edvjuk a <code>Draw</code> m\u0171veletet, mely gondoskodik a t\u00e9nyleges megjelen\u00edt\u00e9sr\u0151l.</li> </ul> </li> <li><code>InfoPanel</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk jobb oldali inform\u00e1ci\u00f3s panel n\u00e9zet\u00e9nek implement\u00e1ci\u00f3ja.</li> <li>Szint\u00e9n a <code>ViewBase</code>-b\u0151l sz\u00e1rmazik, \u00edgy k\u00f6zvetve ezen oszt\u00e1lyunk is egy UserControl.</li> <li>Az inform\u00e1ci\u00f3k megjelen\u00edt\u00e9s\u00e9re egy <code>ListBox</code> vez\u00e9rl\u0151t haszn\u00e1l.</li> <li>A <code>RegisterToDocEvents</code> m\u0171velet\u00e9ben \u0151 is feliratkozik a dokumentum mindk\u00e9t esem\u00e9ny\u00e9re:<ul> <li>Amikor a dokumentum ShapesChanged esem\u00e9nye s\u00fcl el, az InfoPanel <code>Document_ShapesChanged</code> m\u0171velete h\u00edv\u00f3dik meg: ebben friss\u00edti a listbox tartalm\u00e1t a dokumentum aktu\u00e1lis \u00e1llapot\u00e1nak megfelel\u0151en.</li> <li>Amikor a dokumentum SelectionChanged esem\u00e9nye s\u00fcl el, a <code>Document_SelectionChanged</code> h\u00edv\u00f3dik: ebben a listbox megfelel\u0151 elem\u00e9t \u00e1ll\u00edtjuk be kiv\u00e1lasztottnak.</li> </ul> </li> <li>Amikor a felhaszn\u00e1l\u00f3 egy \u00faj elemet v\u00e1laszt ki a listboxban, a <code>listBox_SelectedIndexChanged</code> esem\u00e9nykezel\u0151 h\u00edv\u00f3dik: ebben az <code>App.Instance.SetSelectedShape()</code> h\u00edv\u00e1ssal az aktu\u00e1lis dokumentumunkban \u00e1ll\u00edtjuk \u00e1t a kiv\u00e1lasztott alakzatot a listbox felhaszn\u00e1l\u00f3 \u00e1ltal kiv\u00e1lasztott sor\u00e1nak megfelel\u0151en.</li> </ul> </li> <li><code>Shape</code>, <code>Rect</code>, <code>Ellipse</code> oszt\u00e1lyok<ul> <li>A <code>Shape</code> a k\u00f6z\u00f6s \u0151s, az egyes alakzatok ennek lesz\u00e1rmazottai.</li> <li>A gyakorlat sor\u00e1n ezek k\u00f3dj\u00e1ra \u00e9ppen csak n\u00e9zz\u00fcnk r\u00e1, ezek implement\u00e1ci\u00f3s r\u00e9szletei sz\u00e1munkra most kev\u00e9sb\u00e9 izgalmasak. Megjegyz\u00e9s: Az egyik feladat megval\u00f3s\u00edt\u00e1sa sor\u00e1n m\u00e1solatot k\u00e9sz\u00edt\u00fcnk majd az alakzatokr\u00f3l. Annak \u00e9rdek\u00e9ben, hogy az alakzatot \u00e9s a m\u00e1solatait \u00f6ssze tudjuk \u201etal\u00e1ltatni\u201d, az egyes alakzatokhoz egy sz\u00e1mazonos\u00edt\u00f3t rendel\u00fcnk (<code>Id</code> tag), mely az alakzat \u00e9s m\u00e1solatai eset\u00e9ben ugyanazt az \u00e9rt\u00e9ket veszi fel.</li> </ul> </li> <li><code>App</code> oszt\u00e1ly<ul> <li>Az alkalmaz\u00e1sunk \u201eroot\u201d oszt\u00e1lya, mag\u00e1t az alkalmaz\u00e1st reprezent\u00e1lja. Szerepe hasonl\u00f3, mint az el\u0151z\u0151 gyakorlat <code>FontEditor</code> p\u00e9ld\u00e1j\u00e1ban.</li> <li>Megval\u00f3s\u00edt\u00e1sa a <code>Singleton</code> tervez\u00e9si minta fontosabb elveit k\u00f6veti: egy p\u00e9ld\u00e1ny l\u00e9tezhet bel\u0151le, mely egy statikus <code>Instance</code> nev\u0171 tulajdons\u00e1gon kereszt\u00fcl \u00e9rhet\u0151 el, a konstruktora pedig v\u00e9dett.</li> <li>Mivel alkalmaz\u00e1sunkban egyszerre egy dokumentum lehet megnyitva (\u00fan. SDI, Single Document Interface application), egy jelent\u0151s egyszer\u0171s\u00edt\u00e9ssel \u00e9lhett\u00fcnk: a dokumentumunkb\u00f3l \u00e9s mindk\u00e9t n\u00e9zet t\u00edpusunkb\u00f3l egy-egy objektumra van csak sz\u00fcks\u00e9g. Ezekre az <code>App</code> oszt\u00e1lyunkban el is t\u00e1rolunk egy-egy hivatkoz\u00e1st az al\u00e1bbi tagv\u00e1ltoz\u00f3kban: <pre><code>    private DrawingDocument document;\n    private GraphicsView graphicsView;\n    private InfoPanel infoPanel;\n</code></pre></li> <li>Az <code>Initialize</code> m\u0171veletben lev\u0151 <code>CommandBindingManager</code> h\u00edv\u00e1sokra k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza.</li> </ul> </li> </ul>"},{"location":"labor/old-7-tervezesi-mintak/#command-binding","title":"Command Binding","text":"<p>A komplex felhaszn\u00e1l\u00f3 fel\u00fclettel rendelkez\u0151 alkalmaz\u00e1sok eset\u00e9n gyakran el\u0151fordul, hogy ugyanazt a parancsot k\u00fcl\u00f6nb\u00f6z\u0151 felhaszn\u00e1l\u00f3i fel\u00fcletelemekhez is hozz\u00e1 szeretn\u00e9nk k\u00f6tni. P\u00e9ld\u00e1ul New/Open/Close/Cut/Copy/stb. parancsok a legt\u00f6bb alkalmaz\u00e1sban egyar\u00e1nt el\u00e9rhet\u0151k men\u00fcb\u0151l \u00e9s eszk\u00f6zs\u00e1vr\u00f3l is. Vagyis a parancs \u00e9s a kiv\u00e1lt\u00f3 fel\u00fcletelemek k\u00f6z\u00f6tt egy-t\u00f6bb kapcsolat van.  Ilyen esetben egy adott parancs vonatkoz\u00e1s\u00e1ban a k\u00f6vetkez\u0151ket kell megval\u00f3s\u00edtani:</p> <ul> <li>Parancs futtat\u00e1sa. Ak\u00e1rmelyik fel\u00fcletelemet is aktiv\u00e1lja a felhaszn\u00e1l\u00f3, a parancshoz tartoz\u00f3 ugyanazon \u201eesem\u00e9nykezel\u0151\u201d k\u00f3dot kell futtatni. Ez a gyakorlatban egy adott f\u00fcggv\u00e9ny megh\u00edv\u00e1s\u00e1t jelenti.</li> <li>Fel\u00fcletelemek \u00e1llapotkezel\u00e9se. Adott parancs vonatkoz\u00e1s\u00e1ban valamennyi fel\u00fcletelem \u00e1llapot\u00e1t konzisztensen kell tartani. Vagyis ha pl. letiltjuk az Undo men\u00fct, mert nincs visszavonhat\u00f3 m\u0171velet, akkor a visszavon\u00e1sra szolg\u00e1l\u00f3 Undo toolbar gombot is le kell tiltani. Hasonl\u00f3k\u00e9ppen, ha egy men\u00fcelemet el akarunk rejteni, akkor a kapcsol\u00f3d\u00f3 toolbar gombot is rejteni kell. De m\u00e9g fel\u00fcletelemek kijel\u00f6lts\u00e9gi \u00e1llapot\u00e1t is akarhatjuk szab\u00e1lyozni, erre is \u00e9l a szab\u00e1lyunk.</li> </ul> <p>N\u00e9zz\u00fcnk erre p\u00e9ld\u00e1kat az alkalmaz\u00e1sunkban:</p> <ol> <li>Ind\u00edtsuk el az alkalmaz\u00e1st. Figyelj\u00fck meg, hogy a File men\u00fc alatt a Save/Save As/Close men\u00fcelemek \u00e9s az ezeknek megfelel\u0151 toolbar gombok (a Close a harmadik gomb a toolbaron) is le vannak tiltva: am\u00edg nem hoztunk l\u00e9tre vagy t\u00f6lt\u00f6tt\u00fcnk be dokumentumot, ezen parancsok futtat\u00e1s\u00e1nak nincs \u00e9rtelme.</li> <li>Hozzunk l\u00e9tre egy \u00faj dokumentumot (File/New men\u00fc). Ekkor valamennyi, az el\u0151z\u0151 pontban eml\u00edtett fel\u00fcletelem konzisztens m\u00f3don enged\u00e9lyezett lesz.</li> <li>Ha bez\u00e1rjuk a dokumentumot (File/Close men\u00fc), ism\u00e9t valamennyi fel\u00fcletelem tiltott lesz.</li> </ol> <p>Egy komplex alkalmaz\u00e1sban a fenti probl\u00e9mak\u00f6r egyszer\u0171 kezel\u00e9s\u00e9re c\u00e9lszer\u0171 egy k\u00f6zponti megold\u00e1st bevezetni. Ezt sz\u00e1mos m\u00f3don lehet implement\u00e1lni, a legt\u00f6bb k\u00f6rnyezet Command Binding n\u00e9ven hivatkozik a koncepci\u00f3ra. Sajnos az elnevez\u00e9s tekintet\u00e9ben nincs egys\u00e9gess\u00e9g: van olyan technol\u00f3gia, mely Command n\u00e9ven neves\u00edti ezt a technik\u00e1t. Mi Command minta alatt \u2013 a tervez\u00e9si mint\u00e1k klasszikus nevez\u00e9ktan\u00e1t k\u00f6vetve \u2013 m\u00e1st fogunk \u00e9rteni, egy k\u00e9s\u0151bbi feladatban t\u00e9r\u00fcnk majd r\u00e1.</p> <p>A Command Binding minta alapelvei:</p> <ul> <li>Minden felhaszn\u00e1l\u00f3i parancshoz egy k\u00f6zponti (<code>CommandBinding</code>) objektumot hozunk l\u00e9tre.</li> <li>Ehhez hozz\u00e1k\u00f6tj\u00fck a parancs aktiv\u00e1l\u00e1sakor futtatand\u00f3 esem\u00e9nykezel\u0151t.</li> <li>Hozz\u00e1k\u00f6tj\u00fck valamennyi aktiv\u00e1l\u00f3 fel\u00fcletelemet (men\u00fc, toolbar gomb stb.)</li> <li>Seg\u00e9dm\u0171veleteket vezet\u00fcnk be a parancsok tilt\u00e1s\u00e1ra/enged\u00e9lyez\u00e9s\u00e9re/elrejt\u00e9s\u00e9re/megjelen\u00edt\u00e9s\u00e9re.</li> <li>A parancsokat a k\u00f6nny\u0171 azonos\u00edt\u00e1s \u00e9rdek\u00e9ben valamilyen egyszer\u0171 m\u00f3don, tipikusan stringgel azonos\u00edtjuk.</li> </ul> <p>A solution\u00fcnk <code>AppFx</code> projektj\u00e9ben tal\u00e1lunk t\u00e1mogat\u00e1st a Command Binding megval\u00f3s\u00edt\u00e1s\u00e1ra (<code>CommandBinding</code> mappa). A megval\u00f3s\u00edt\u00e1s r\u00e9szletei sz\u00e1munkra teljesen \u00e9rdektelenek, gyakorlaton ne is n\u00e9zz\u00fck a k\u00f3dj\u00e1t, ink\u00e1bb a felhaszn\u00e1l\u00e1s\u00e1nak m\u00f3dj\u00e1t tekints\u00fck \u00e1t r\u00f6viden DesignPatternApp projekt\u00fcnkben:</p> <ul> <li>N\u00e9zz\u00fck meg a <code>CommandName</code> oszt\u00e1lyt: minden parancshoz egy string nevet vezett\u00fcnk be, mely a parancsot azonos\u00edtja (pl. \"Open\", \"Undo\" stb.).</li> <li>Inicializ\u00e1l\u00e1s: a <code>CommandBinding</code> objektumokat a <code>MainForm</code> oszt\u00e1ly <code>initCommandBindings</code> m\u0171veletben hozzuk l\u00e9tre \u00e9s k\u00f6tj\u00fck hozz\u00e1 az egyes men\u00fcelemekhez/toolbar gombokhoz. El\u00e9g, ha itt egy p\u00e9ld\u00e1t megn\u00e9z\u00fcnk a sok el\u0151fordul\u00e1s k\u00f6z\u00fcl.</li> <li>Ezt k\u00f6vet\u0151en adott parancshoz tartoz\u00f3 fel\u00fcletelemek \u00e1llapotai a <code>CommandBindingManager</code> oszt\u00e1ly \u00e1llapot\u00e1ll\u00edt\u00f3 seg\u00e9df\u00fcggv\u00e9nyeivel b\u00e1rmikor k\u00e9nyelmesen \u00e1ll\u00edthat\u00f3k (pl. <code>EnableCommandBinding</code> tilt\u00e1shoz/enged\u00e9lyez\u00e9shez). N\u00e9zz\u00fck meg, hogyan t\u00f6rt\u00e9nik ez a Save/Save As/Close parancsok vonatkoz\u00e1s\u00e1ban:<ul> <li>Amikor az alkalmaz\u00e1s elindul, a parancsokat az <code>App</code> oszt\u00e1ly Initialize m\u0171velet\u00e9ben tiltjuk (a false m\u00e1sodik param\u00e9ter jelzi, hogy tiltani akarjuk a vez\u00e9rl\u0151t): <pre><code>CommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.CloseDocument, false);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveDocument, false);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveAsDocument, false);\n</code></pre></li> <li>A parancsok enged\u00e9lyez\u00e9s\u00e9re az <code>App.NewDocument</code>-ben l\u00e1tunk p\u00e9ld\u00e1t. Ez a m\u0171velet egy parancs esem\u00e9nykezel\u0151je, a t\u00f6bbi esem\u00e9nykezel\u0151vel egy\u00fctt az <code>App.CommandHandlers.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 (az App oszt\u00e1ly \u201epartial\u201d, t\u00f6bb f\u00e1jlban van meg\u00edrva). <pre><code>CommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.CloseDocument, true);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveDocument, true);\nCommandBindingManager.Instance.EnableCommandBinding(\n    CommandName.SaveAsDocument, true);\n</code></pre></li> </ul> </li> </ul> <p>A tov\u00e1bbi feladatok megval\u00f3s\u00edt\u00e1sa sor\u00e1n is a <code>CommandBindingManager</code> oszt\u00e1lyunkat fogjuk haszn\u00e1lni a parancsok tilt\u00e1s\u00e1hoz \u00e9s enged\u00e9lyez\u00e9s\u00e9hez.</p>"},{"location":"labor/old-7-tervezesi-mintak/#2-feladat-command-processor-minta","title":"2. Feladat - Command Processor minta","text":"<p>A feladat sor\u00e1n a Command, pontosabban annak tov\u00e1bbfejlesztett v\u00e1ltozata, a Command Processor tervez\u00e9si minta megval\u00f3s\u00edt\u00e1s\u00e1t fogjuk gyakorolni. Mindk\u00e9t minta elm\u00e9leti h\u00e1tter\u00e9t a kapcsol\u00f3d\u00f3 el\u0151ad\u00e1s ismerteti r\u00e9szletesen, UML diagramokkal illusztr\u00e1lva. A gyakorlat sor\u00e1n, \u00e9s \u00edgy jelen \u00fatmutat\u00f3ban is csak az elm\u00e9leti h\u00e1tt\u00e9r legfontosabb elemeire t\u00e9r\u00fcnk ki. L\u00e9nyeges, hogy a mint\u00e1t ne keverj\u00fck a m\u00e1r kor\u00e1bban ismertetett Command Binding mint\u00e1val, mert att\u00f3l elt\u00e9r\u0151 probl\u00e9m\u00e1ra mutat megold\u00e1st.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-command-processor-minta-koncepcioja","title":"A Command Processor minta koncepci\u00f3ja","text":"<p>A minta alapelve az, hogy minden felhaszn\u00e1l\u00f3i k\u00e9r\u00e9st egy k\u00fcl\u00f6n parancs (Command) objektumk\u00e9nt z\u00e1r egys\u00e9gbe. Ezen t\u00falmen\u0151en a v\u00e9grehajtott parancs objektumok elt\u00e1rol\u00e1sra ker\u00fclnek, ami lehet\u0151v\u00e9 teszi a kor\u00e1bban v\u00e9grehajtott parancsok visszavon\u00e1s\u00e1t. A k\u00f6vetkez\u0151kben \u00e1ttekintj\u00fck a minta m\u0171k\u00f6d\u00e9s\u00e9t. Els\u0151 l\u00e9p\u00e9sben m\u00e9g nem val\u00f3s\u00edtjuk meg, csak az alapelveire koncentr\u00e1lunk (b\u00e1r hogy k\u00f6nnyebben meg\u00e9rthet\u0151 legyen, a mint\u00e1t az alkalmaz\u00e1sunkra vet\u00edtve mutatjuk be). K\u00f6vetkezzen egy \u00e1bra, majd a hozz\u00e1 kapcsol\u00f3d\u00f3 gondolatok. </p> <p></p> <ul> <li>Bevezet\u00fcnk egy <code>Command</code> \u0151soszt\u00e1lyt vagy interf\u00e9szt, melynek van egy <code>Execute</code> \u00e9s egy <code>UnExecute</code> absztrakt m\u0171velete (vagy nevezhetj\u00fck <code>Do</code> \u00e9s <code>Undo</code>-nak is \u0151ket, ha \u00fagy tartja kedv\u00fcnk).</li> <li>Az egyes felhaszn\u00e1l\u00f3i parancsokhoz bevezet\u00fcnk egy Command lesz\u00e1rmazott oszt\u00e1lyt.<ul> <li>Els\u0151 k\u00f6rben a New Rect \u00e9s New Ellipse parancsokra vonatkoz\u00f3an k\u00edv\u00e1nunk Undo t\u00e1mogat\u00e1st bevezetni, \u00edgy ezekhez vezet\u00fcnk majd r\u00f6videsen be egy-egy \u00faj oszt\u00e1lyt, pl. <code>NewRectCommand</code> \u00e9s <code>NewEllipseCommand</code> n\u00e9ven.</li> <li>Ezen oszt\u00e1lyokban a parancsspecifikusan meg\u00edrjuk az <code>Execute</code> m\u0171veletet (pl. a <code>NewRectCommand.Execute</code>-ban felvesz\u00fcnk a dokumentumunkban egy \u00faj t\u00e9glalapot), az <code>UnExecute</code>-ban pedig visszacsin\u00e1ljuk a m\u0171velet hat\u00e1s\u00e1t. </li> <li>A <code>Command</code> lesz\u00e1rmazott oszt\u00e1lyok sokszor nem maguk val\u00f3s\u00edtj\u00e1k meg funkci\u00f3jukat, hanem deleg\u00e1lj\u00e1k azt egy vagy t\u00f6bb m\u00e1sik oszt\u00e1lynak. Ezt az oszt\u00e1lyt az UML diagramon Receiver n\u00e9ven t\u00fcntett\u00fck fel. A gyakorlatban nem \u00edgy szoktuk h\u00edvni. Alkalmaz\u00e1sunkban a Command-ok tipikusan az <code>App</code> oszt\u00e1lyba h\u00edvnak tov\u00e1bb, vagyis eset\u00fcnkben az <code>App</code> felel meg legt\u00f6bb esetben az \u00e1br\u00e1n szerepl\u0151 Receiver oszt\u00e1lynak.</li> </ul> </li> <li>Bevezet\u00fcnk egy k\u00f6zponti <code>CommandProcessor</code> oszt\u00e1lyt k\u00e9t m\u0171velettel:<ul> <li><code>ExecuteCommand</code>: v\u00e9grehajtja a param\u00e9ter\u00fcl kapott parancsot (megh\u00edvja az <code>Execute</code> m\u0171velet\u00e9t), majd elt\u00e1rolja egy bels\u0151 stack gy\u0171jtem\u00e9nyben.</li> <li><code>UnExecuteLastCommand</code>: kiveszi az utolj\u00e1ra v\u00e9grehajtott parancsot a command stack-b\u0151l, \u00e9s megh\u00edvja annak <code>UnExecute</code> m\u0171velet\u00e9t. Ezzel gyakorlatilag a parancs visszavon\u00e1s funkci\u00f3j\u00e1t (Undo) val\u00f3s\u00edtja meg.</li> </ul> </li> </ul> <p>L\u00e9nyeges, hogy a Command Binding mint\u00e1val ellent\u00e9tben itt a parancsok minden egyes futtat\u00e1s\u00e1hoz \u00faj Command objektumot hozunk l\u00e9tre, vagyis ha pl. h\u00e1romszor \u201efuttatjuk\" a <code>NewRectCommand</code> parancsot, akkor h\u00e1rom <code>NewRectCommand</code> objektumot hozunk ehhez l\u00e9tre. Ennek oka az, hogy a <code>CommandProcessor</code> command stack-j\u00e9ben h\u00e1rom parancsobjektumot kell elt\u00e1rolni (hiszen ezeket egym\u00e1st\u00f3l f\u00fcggetlen\u00fcl akarjuk visszavonni Undo eset\u00e9n).</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-command-processor-minta-megvalositasa-alkalmazasunkban","title":"A Command Processor minta megval\u00f3s\u00edt\u00e1sa alkalmaz\u00e1sunkban","text":"<p>K\u00f6vess\u00fck az al\u00e1bbi l\u00e9p\u00e9seket:</p> <ol> <li>Az <code>AppFx</code> projekt Command mapp\u00e1j\u00e1ban m\u00e1r l\u00e9tezik egy absztrakt <code>Command</code> oszt\u00e1ly, \u00edgy ezzel nincs teend\u0151nk.</li> <li>A <code>Command</code> mapp\u00e1ban vegy\u00fck fel a parancsok menedzsel\u00e9s\u00e9\u00e9rt felel\u0151s az \u00e1ltal\u00e1nos <code>CommandProcessor</code> oszt\u00e1lyt: <pre><code>public class CommandProcessor\n{\n    Stack&lt;Command&gt; commands = new Stack&lt;Command&gt;();\n\n    public void ExecuteCommand(Command cmd)\n    {\n        cmd.Execute();\n        commands.Push(cmd);\n    }\n\n    public void UnExecuteLastCommand()\n    {\n        // Ha \u00fcres, nem csin\u00e1lunk semmit\n        if (!commands.Any())\n            return;\n\n        Command lastCommand = commands.Pop();\n        lastCommand.UnExecute();\n    }\n\n    public void Clear()\n    {\n      commands.Clear();\n    }\n\n    public bool HasAny { get { return commands.Any(); } }\n}\n</code></pre> A megval\u00f3s\u00edt\u00e1s sor\u00e1n a .NET be\u00e9p\u00edtett <code>Stack&lt;T&gt;</code> oszt\u00e1ly\u00e1t haszn\u00e1ljuk a command stack megval\u00f3s\u00edt\u00e1s\u00e1ra. A met\u00f3dusok implement\u00e1ci\u00f3ja egyszer\u0171, a kor\u00e1bban ismertetett logik\u00e1t k\u00f6veti.</li> <li>Integr\u00e1ljuk be a <code>CommandProcessor</code> oszt\u00e1lyt az alkalmaz\u00e1sunkba. Vegy\u00fcnk fel egy tagv\u00e1ltoz\u00f3t az <code>App</code> oszt\u00e1lyba: <pre><code>readonly CommandProcessor commandProcessor = new CommandProcessor();\n</code></pre> Annak \u00e9rdek\u00e9ben, hogy ez forduljon, a forr\u00e1sf\u00e1jlban az <code>AppFx.Command</code> n\u00e9vteret \u201eusing-olni\u201d kell.</li> <li>Az <code>App.CommandHandlers.cs</code>-be a <code>CloseDocument</code> v\u00e9g\u00e9re vegy\u00fck fel ezt a sort: <pre><code>commandProcessor.Clear();\n</code></pre> Ennek az a szerepe, hogy amikor bez\u00e1rjuk a dokumentumot, kipucoljuk az undo sort, hiszen a benne lev\u0151 elemek egy m\u00e1r bez\u00e1rt, nem l\u00e9tez\u0151 dokumentumra vonatkoznak.</li> <li>Amikor egy parancsot futtatunk vagy visszavonunk, az Undo men\u00fct \u00e9s toolbar gombot is megfelel\u0151en tiltani vagy enged\u00e9lyezni kell: ha van legal\u00e1bb egy command a command stack-en, akkor enged\u00e9lyezz\u00fck, egy\u00e9bk\u00e9nt tiltjuk. Vezess\u00fcnk be egy-egy seg\u00e9df\u00fcggv\u00e9nyt az App oszt\u00e1lyba a parancsok futtat\u00e1s\u00e1hoz \u00e9s visszavon\u00e1s\u00e1hoz, melyek a kor\u00e1bban ismertetett CommandBindingManager oszt\u00e1lyunk seg\u00edts\u00e9g\u00e9vel gondoskodnak az Undo tilt\u00e1s\u00e1r\u00f3l/enged\u00e9lyez\u00e9s\u00e9r\u0151l is: <pre><code>void executeCommand(Command cmd)\n{\n    commandProcessor.ExecuteCommand(cmd);\n    CommandBindingManager.Instance.EnableCommandBinding(\n                    CommandName.Undo, commandProcessor.HasAny);\n}\n</code></pre> <pre><code>void unexecuteLastCommand()\n{\n    commandProcessor.UnExecuteLastCommand();\n    CommandBindingManager.Instance.EnableCommandBinding(\n                    CommandName.Undo, commandProcessor.HasAny);\n}\n</code></pre> Az <code>unexecuteLastCommand</code> m\u0171veletet akkor kell megh\u00edvni, amikor a felhaszn\u00e1l\u00f3 az Undo funkci\u00f3t aktiv\u00e1lja. Az <code>App.CommandHandlers.cs</code> f\u00e1jlban lev\u0151 UndoLast met\u00f3dus egy <code>CommandBinding</code> seg\u00edts\u00e9g\u00e9vel m\u00e1r hozz\u00e1 van k\u00f6tve a fel\u00fcletelemekhez (Undo men\u00fc \u00e9s toolbar gomb), \u00edgy aktiv\u00e1l\u00e1sukkor meg is h\u00edv\u00f3dik. M\u00e1r csak az a dolgunk, hogy \u00e1t\u00edrjuk az <code>UndoLast</code> t\u00f6rzs\u00e9t: <pre><code>public void UndoLast()\n{\n    unexecuteLastCommand();\n}\n</code></pre></li> <li>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekben Command lesz\u00e1rmazott oszt\u00e1lyokat hozunk l\u00e9tre az egyes alkalmaz\u00e1sspecifikus parancsokhoz. A <code>DesignPatternApp</code> projektben vegy\u00fcnk fel egy <code>Commands</code> nev\u0171 mapp\u00e1t (jobb katt a projekten, Add/New Folder men\u00fc), ebbe fogjuk az ide tartoz\u00f3 oszt\u00e1lyokat \u00f6sszegy\u0171jteni.</li> <li>Ebbe a <code>Commands</code> mapp\u00e1ba vegy\u00fcnk fel egy <code>NewRectCommand</code> oszt\u00e1lyt a \u201eNew Rect\u201d funkci\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1hoz, a k\u00f6vetkez\u0151 k\u00f3ddal: <pre><code>using AppFx.Command;\n\u2026\n\nclass NewRectCommand : Command\n{\n    private int shapeId;\n\n    public override void Execute()\n    {\n        shapeId = App.Instance.CreateRandomRect().Id;\n    }\n\n    public override void UnExecute()\n    {\n        App.Instance.RemoveShape(shapeId);\n    }\n}\n</code></pre> Az <code>Execute</code> m\u0171velet megh\u00edvja az <code>App</code> singleton <code>CreateRandomRect</code> m\u0171velet\u00e9t, amely felvesz egy \u00faj <code>Rectangle</code> objektumot a dokumentumban, v\u00e9letlenszer\u0171en gener\u00e1lt befoglal\u00f3 t\u00e9glalapban, \u00e9s visszat\u00e9r vele. Az \u00fajonnan l\u00e9trehozott <code>Rect</code> objektumra a <code>NewRectCommand</code> elt\u00e1rolja az alakzat azonos\u00edt\u00f3j\u00e1t a <code>shapeId</code> tagv\u00e1ltoz\u00f3ban. (Jelen pillanatban egy referencia t\u00e1rol\u00e1sa is el\u00e9g lenne, de mikor k\u00e9s\u0151bb a Memento megval\u00f3s\u00edt\u00e1sa sor\u00e1n m\u00e1solatot k\u00e9sz\u00edt\u00fcnk az alakzat objektumokr\u00f3l, a referencia haszn\u00e1lata m\u00e1r nem jelentene megold\u00e1st.) Az <code>UnExecute</code> m\u0171veletben az App singleton <code>RemoveShape</code> m\u0171velet\u00e9nek seg\u00edts\u00e9g\u00e9vel elt\u00e1vol\u00edtjuk a parancs \u00e1ltal l\u00e9trehozott alakzatot, \u00edgy visszavonjuk annak hat\u00e1s\u00e1t (n\u00e9zz\u00fck meg a k\u00f3dban, hogyan van megval\u00f3s\u00edtva).</li> <li>Vegy\u00fcnk fel a <code>Commands</code> mapp\u00e1ba egy <code>NewEllipseCommand</code> oszt\u00e1lyt, \u00e9s implement\u00e1ljuk a <code>NewRectCommand</code>-hoz hasonl\u00f3 elveknek megfelel\u0151en: <pre><code>using AppFx.Command;\n\nclass NewEllipseCommand : Command\n{\n    private int shapeId;\n\n    public override void Execute()\n    {\n        shapeId = App.Instance.CreateRandomEllipse().Id;\n    }\n\n    public override void UnExecute()\n    {\n        App.Instance.RemoveShape(shapeId);\n    }\n}\n</code></pre></li> <li>A <code>NewRectCommand</code> \u00e9s <code>NewEllipseCommand</code> oszt\u00e1lyainkat m\u00e9g nem haszn\u00e1ljuk sehol, most ezek bevet\u00e9se k\u00f6vetkezik. Amikor a felhaszn\u00e1l\u00f3 ak\u00e1r men\u00fcb\u0151l, ak\u00e1r toolbarr\u00f3l aktiv\u00e1lja a New Rect funkci\u00f3t, l\u00e9tre kell hozzunk egy NewRectCommand objektumot, \u00e9s futtatni kell seg\u00e9dm\u0171veleteink felhaszn\u00e1l\u00e1s\u00e1val. Keress\u00fck meg az <code>App.CommandHandlers.cs</code> f\u00e1jlban a <code>NewRect</code> met\u00f3dust. Ez egy <code>CommandBinding</code> seg\u00edts\u00e9g\u00e9vel m\u00e1r r\u00e1 van k\u00f6tve a megfelel\u0151 men\u00fcre/toolbar gombra, csak a t\u00f6rzs\u00e9ben lev\u0151 <code>showNotImplemented()</code> h\u00edv\u00e1st kell lecser\u00e9lni: <pre><code>using DesignPatternApp.Commands;\n\u2026\npublic void NewRect()\n{\n    executeCommand( new NewRectCommand() );\n}\n</code></pre> Ehhez hasonl\u00f3an alak\u00edtsuk \u00e1t a <code>NewRect</code> mellett tal\u00e1lhat\u00f3 <code>NewEllipse</code> m\u0171veletet is: <pre><code>public void NewEllipse()\n{\n    executeCommand( new NewEllipseCommand() );\n}\n</code></pre></li> <li>Mostant\u00f3l tudunk \u00faj alakzatokat l\u00e9trehozni, \u00edgy \u00faj dokumentum l\u00e9trehoz\u00e1sakor tesztadatok automatikus felv\u00e9tel\u00e9re nincs sz\u00fcks\u00e9g: az App.NewDocument m\u0171veletben kommentezz\u00fck ki az <code>addTestData</code> h\u00edv\u00e1s\u00e1t.</li> </ol> <p>Elk\u00e9sz\u00fclt\u00fcnk, tesztelj\u00fck a megold\u00e1sunkat:</p> <ol> <li>Futtassuk az alkalmaz\u00e1st, \u00e9s hozzunk l\u00e9tre egy dokumentumot.</li> <li>Figyelj\u00fck meg, hogy az Undo parancs (toolbar \u00e9s men\u00fc is) tiltva van.</li> <li>A New Rect paranccsal hozzunk l\u00e9tre egy \u00faj t\u00e9glalapot. A t\u00e9glalap megjelenik, \u00e9s az Undo parancs enged\u00e9lyezett lesz.</li> <li>Hozzunk l\u00e9tre n\u00e9h\u00e1ny tov\u00e1bbi alakzatot, t\u00e9glalapot \u00e9s ellipszist vegyesen.</li> <li>Az Undo funkci\u00f3 haszn\u00e1lat\u00e1val vonjuk vissza a m\u0171veleteket mindaddig, am\u00edg nem marad alakzat: ekkor az Undo parancs letilt\u00e1sra ker\u00fcl.</li> </ol> <p>Amennyiben a gyakorlat sor\u00e1n j\u00f3l \u00e1llunk id\u0151vel, a k\u00f3dot l\u00e9p\u00e9senk\u00e9nt futtatva is n\u00e9zz\u00fck vissza megold\u00e1sunk m\u0171k\u00f6d\u00e9s\u00e9t:</p> <ol> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot az <code>App.CommandHandlers.cs</code>-ben tal\u00e1lhat\u00f3 <code>NewRect</code> \u00e9s <code>UndoLast</code> m\u0171veletek t\u00f6rzs\u00e9be (mindk\u00e9t m\u0171velet egysoros).</li> <li>Ind\u00edtsuk el debug m\u00f3dban az alkalmaz\u00e1st (F5).</li> <li>Hozzunk l\u00e9tre egy dokumentumot, majd egy t\u00e9glalapot. A <code>NewRect</code> k\u00f3dj\u00e1b\u00f3l kiindulva az F11 billenty\u0171vel az <code>executeCommand</code> \u00e9s a <code>CommandProcessor</code> m\u0171veleteibe belel\u00e9pve \u201e\u00e9rtelmezz\u00fck\u201d megold\u00e1sunkat.</li> <li>Ezt k\u00f6vet\u0151en vonjuk vissza az utols\u00f3 m\u0171veletet. Ekkor az <code>UndoLast</code> m\u0171veletb\u0151l kiindulva l\u00e9pkedj\u00fcnk v\u00e9gig a k\u00f3dunkon.</li> </ol>"},{"location":"labor/old-7-tervezesi-mintak/#3-feladat-memento-minta","title":"3. Feladat \u2013 Memento minta","text":"<p>A feladatban a Memento minta megval\u00f3s\u00edt\u00e1s\u00e1t gyakoroljuk. A minta teljes elm\u00e9leti h\u00e1ttere \u2013 UML diagramokkal illusztr\u00e1lva - el\u0151ad\u00e1son ker\u00fcl ismertet\u00e9sre, itt a minta legfontosabb elemeire koncentr\u00e1lunk.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-memento-minta-koncepcioja","title":"A Memento minta koncepci\u00f3ja","text":"<p>El\u0151z\u0151 feladatunkban a New Rect \u00e9s New Ellipse parancsok visszavon\u00e1s\u00e1t k\u00f6nnyen meg tudtuk val\u00f3s\u00edtani: mind\u00f6ssze el kellett t\u00e1vol\u00edtani a parancs \u00e1ltal l\u00e9trehozott alakzatot a dokumentum alakzatlist\u00e1j\u00e1b\u00f3l. A command objektumainkban ehhez el\u00e9g volt egy azonos\u00edt\u00f3t elt\u00e1rolni az \u00fajonnan l\u00e9trehozott alakzatra.</p> <p>Az alkalmaz\u00e1sok t\u00f6bbs\u00e9g\u00e9n\u00e9l azonban sz\u00e1mos olyan parancs felbukkanhat, mely a dokumentum \u00e1llapot\u00e1t jelent\u0151s m\u00e9rt\u00e9kben befoly\u00e1solja. Ilyenkor a parancsnak a v\u00e9grehajt\u00e1s el\u0151tt a dokumentum \u00e1llapot\u00e1nak jelent\u0151s r\u00e9sz\u00e9hez, vagy ak\u00e1r a teljes \u00e1llapot\u00e1hoz is hozz\u00e1 kell f\u00e9rnie, hogy eltudja azt menteni az UnExecute megval\u00f3s\u00edt\u00e1s\u00e1hoz. Ez \u00fagy lehets\u00e9ges, ha a dokumentum teljes \u00e1llapot\u00e1t publikuss\u00e1 tessz\u00fck. Ez viszont nem szerencs\u00e9s, mert ellentmond az egys\u00e9gbez\u00e1r\u00e1s elv\u00e9nek. Nem szeretn\u00e9nk a teljes \u00e1llapotot \u2013 r\u00e1ad\u00e1sul m\u00f3dos\u00edt\u00e1sra vonatkoz\u00f3an is \u2013 hozz\u00e1f\u00e9rhet\u0151v\u00e9 tenni a k\u00fclvil\u00e1g sz\u00e1m\u00e1ra, csak a visszavon\u00e1s kedv\u00e9\u00e9rt.  Erre a probl\u00e9m\u00e1ra ny\u00fajt megold\u00e1st a Memento tervez\u00e9si minta.</p> <p>Alapelve egy mondatban: dokumentumunk \u00e1llapot\u00e1t egy \u00fan. Memento objektumba csomagoljuk be, hogy az k\u00e9s\u0151bb a visszavon\u00e1s sor\u00e1n vissza\u00e1ll\u00edthat\u00f3 legyen.</p> <p>K\u00f6vetkezzen egy \u00e1bra, majd a hozz\u00e1 kapcsol\u00f3d\u00f3 gondolatok.</p> <p></p> <p>Alapelve r\u00e9szletesebben: - Az <code>Originator</code> azon oszt\u00e1ly, melynek az \u00e1llapot\u00e1hoz hozz\u00e1 szeretn\u00e9nk f\u00e9rni. Eset\u00fcnkben ez a <code>DrawingDocument</code> oszt\u00e1ly t\u00f6lti be az <code>Originator</code> szerep\u00e9t. Az \u00e1llapotot \u00f6sszefog\u00f3an az \u00e1bra a <code>state:State</code> taggal jel\u00f6li. Eset\u00fcnkben ez a <code>shapes</code> lista, valamint a <code>selectedShape</code> tag lesz.  A k\u00f6vetkez\u0151 l\u00e9p\u00e9sekt\u0151l a mint\u00e1t az alkalmaz\u00e1sunkra vet\u00edtj\u00fck. - A dokumentumunk \u00e1llapot\u00e1t (eset\u00fcnkben ez a <code>shapes</code> lista, valamit a <code>selectedShape</code> tag) NEM tessz\u00fck publikuss\u00e1. - A dokumentumunkban bevezet\u00fcnk egy <code>CreateMemento</code> m\u0171veletet, mely egy \u00fan. <code>Memento</code> objektumot hoz l\u00e9tre. A <code>Memento</code> tagv\u00e1ltoz\u00f3iban a dokumentum \u00e1llapot\u00e1nak pillanatnyi k\u00e9p\u00e9t tartalmazza (vagyis tulajdonk\u00e9ppen egy csomagol\u00f3 objektum a dokumentum aktu\u00e1lis \u00e1llapot\u00e1hoz). - A dokumentum \u00e1llapot\u00e1nak vissza\u00e1ll\u00edt\u00e1s\u00e1ra bevezet\u00fcnk a dokumentumban egy <code>RestoreFromMemento</code> m\u0171veletet, mely param\u00e9terk\u00e9nt egy <code>Memento</code> objektumot kap. A dokumentum ebben a m\u0171veletben vissza\u00e1ll\u00edtja saj\u00e1t \u00e1llapot\u00e1t a param\u00e9terk\u00e9nt kapott <code>Memento</code> objektum alapj\u00e1n.</p>"},{"location":"labor/old-7-tervezesi-mintak/#a-memento-minta-megvalositasa-alkalmazasunkban","title":"A Memento minta megval\u00f3s\u00edt\u00e1sa alkalmaz\u00e1sunkban","text":"<p>Alkalmaz\u00e1sunkban a Clear funkci\u00f3t val\u00f3s\u00edtjuk meg a Memento mint\u00e1ra \u00e9p\u00edtve. A Clear parancs t\u00f6rli a dokumentumb\u00f3l az \u00f6sszes alakzatot. Annak \u00e9rdek\u00e9ken, hogy ez visszavonhat\u00f3 legyen, a dokumentumunk teljes \u00e1llapot\u00e1t el kell menteni a parancs v\u00e9grehajt\u00e1sa el\u0151tt. Ehhez a <code>DrawingDocument</code> oszt\u00e1lyunk \u00e1llapot\u00e1t jelent\u0151 shapes tagot NEM fogjuk publikuss\u00e1 tenni. M\u00e9g k\u00f6zvetve, property-n/m\u0171veleten kereszt\u00fcl sem tessz\u00fck m\u00f3dos\u00edthat\u00f3v\u00e1!</p> <p>Warning</p> <p>Amennyiben kev\u00e9s id\u0151 maradt gyakorlaton, nyissuk meg a k\u00e9sz megold\u00e1st, \u00e9s abban mutassuk be a megval\u00f3s\u00edt\u00e1s r\u00e9szleteit!</p> <ul> <li> <p>A dokumentum \u00e1llapot\u00e1t t\u00e1rol\u00f3 Memento oszt\u00e1lyt egy a <code>DrawingDocument</code>-be be\u00e1gyazott oszt\u00e1lyk\u00e9nt val\u00f3s\u00edtjuk meg, ezzel is hangs\u00falyozva, hogy <code>Memento</code> oszt\u00e1lyunk nagyon szorosan kapcsol\u00f3dik a dokumentumhoz. Forr\u00e1sk\u00f3d szintj\u00e9n viszont igyeksz\u00fcnk lev\u00e1lasztani, \u00edgy a DrawingDocument oszt\u00e1lyt partial class-ra alak\u00edtva k\u00fcl\u00f6n f\u00e1jlban dolgozunk.</p> <ul> <li>Alak\u00edtsuk a <code>DrawingDocument</code>-et partial class-\u00e1: <pre><code>public partial class DrawingDocument\n</code></pre></li> <li>Vegy\u00fcnk fel egy <code>DrawingDocument.Memento.cs</code> f\u00e1jlt a <code>DesignPatternApp</code> projektbe (jobb katt a projekten, Add/New Item, \u00e9s a megjelen\u0151 ablakban a Code File-t v\u00e1lasszuk ki).</li> <li> <p>Illessz\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet a f\u00e1jlba:</p> DrawingDocument.Memento.cs <pre><code>using System.Collections.Generic;\n\nnamespace DesignPatternApp\n{\n    public partial class DrawingDocument\n    {\n        public class Memento\n        {\n            private List&lt;Shape&gt; shapes = new List&lt;Shape&gt;();\n            private Shape selectedShape;\n\n            public Memento(List&lt;Shape&gt; shapes, Shape selectedShape)\n            {\n                // Deep copyra van sz\u00fcks\u00e9g\u00fcnk!\n                foreach (Shape shape in shapes)\n                    this.shapes.Add(shape.CreateCopy());\n\n                // Be kell \u00e1ll\u00edtsuk selectedShape-nek. Az \u00faj Shape list\u00e1ban kell a megfelel\u00f5\n                // elemre hivatkoznia, nem az eredetiben. Be kell \u00e1ll\u00edtsuk.\n                this.selectedShape = null;\n                for (int i = 0; i &lt; shapes.Count; ++i)\n                    if (shapes[i] == selectedShape)\n                    {\n                        this.selectedShape = this.shapes[i];\n                        break;\n                    }\n            }\n\n            public void GetState(out List&lt;Shape&gt; shapes, out Shape selectedShape)\n            {\n                shapes = this.shapes;\n                selectedShape = this.selectedShape;\n            }\n        }\n\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>A <code>Memento</code> oszt\u00e1lyunk legfontosabb aspektusai:</p> <ul> <li>Pontosan olyan tagv\u00e1ltoz\u00f3i vannak, mint a dokumentum oszt\u00e1lyunknak: \u00edgy tudja annak teljes \u00e1llapot\u00e1t elt\u00e1rolni.</li> <li>Konstruktor\u00e1ban a dokumentum \u00e1llapotv\u00e1ltoz\u00f3it v\u00e1rja (<code>shapes</code> \u00e9s <code>selectedShape</code>). L\u00e9nyeges, hogy a <code>shapes</code> list\u00e1r\u00f3l deep-copy m\u00e1solatot k\u00e9sz\u00edt: ha csak referenci\u00e1kat t\u00e1rolna a dokumentumban lev\u0151 objektumokra, akkor a dokumentum v\u00e1ltoz\u00e1s\u00e1val a memento objektumunk \u00e1llapota is v\u00e1ltozna. Nek\u00fcnk viszont az aktu\u00e1lis \u00e1llapot meg\u0151rz\u00e9se a c\u00e9lunk.</li> <li>A <code>GetState</code>-ben k\u00e9t out param\u00e9terben visszaadja az elmentett \u00e1llapotot. Az Undo m\u0171velet sor\u00e1n fogjuk ezt haszn\u00e1lni.</li> </ul> </li> <li> <p>Emelj\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet a <code>DrawingDocument.cs</code> f\u00e1jlba a <code>DrawingDocument</code> oszt\u00e1lyba:</p> DrawingDocument.cs f\u00e1jlba <pre><code>public Memento CreateMemento()\n{\n    return new Memento(shapes, selectedShape);\n}\n\npublic void RestoreFromMemento(Memento m)\n{\n    m.GetState(out shapes, out selectedShape);\n    fireShapesChanged();\n    fireSelectionChanged();\n}\n</code></pre> <p>A <code>CreateMemento</code> m\u0171velet a mint\u00e1nak megfelel\u0151en legy\u00e1rt egy <code>Memento</code> objektumot a dokumentum \u00e1llapot\u00e1r\u00f3l. A <code>RestoreFromMemento</code> pedig a param\u00e9ter\u00fcl kapott <code>Memento</code> objektum alapj\u00e1n vissza\u00e1ll\u00edtja a dokumentum \u00e1llapot\u00e1t.</p> </li> </ul> <p>Ezzel a Memento t\u00e1mogat\u00e1s be\u00e9p\u00edt\u00e9s\u00e9vel v\u00e9gezt\u00fcnk. Ugyanakkor jelen pillanatban egyetlen parancsunk sem haszn\u00e1lja ezt a szolg\u00e1ltat\u00e1st.  Mint kor\u00e1bban eml\u00edtett\u00fck, a Clear funkci\u00f3t val\u00f3s\u00edtjuk meg a Memento mint\u00e1ra \u00e9p\u00edtve.</p> <ul> <li>Vegy\u00fcnk fel egy <code>ClearCommand</code> oszt\u00e1lyt a <code>DesignPatternApp</code> projekt <code>Commands</code> mapp\u00e1j\u00e1ban.</li> <li> <p>Emelj\u00fck be az al\u00e1bbi k\u00f3dr\u00e9szletet az \u00faj <code>ClearCommand.cs</code> f\u00e1jlba:</p> ClearCommand.cs <pre><code>class ClearCommand: Command\n{\n    DrawingDocument.Memento memento = null;\n\n    public override void Execute()\n    {\n        if (App.Instance.Document == null)\n            return;\n\n        memento = App.Instance.Document.CreateMemento();\n        App.Instance.Document.Clear();\n    }\n\n    public override void UnExecute()\n    {\n        if (App.Instance.Document == null)\n            return;\n\n        App.Instance.Document.RestoreFromMemento(memento);\n    }\n}\n</code></pre> </li> <li> <p>Vegy\u00fck fel a f\u00e1jl elej\u00e9re ez al\u00e1bbi sort: <pre><code>using AppFx.Command;\n</code></pre></p> </li> <li>Az <code>App.CommandHandlers.cs</code> f\u00e1jlban a <code>ClearDocument</code> m\u0171veletet \u00edrjuk \u00e1t, hogy most m\u00e1r az \u00fajonnan l\u00e9trehozott <code>ClearCommand</code> parancsunkat \u201efuttassa\u201d: <pre><code>public void ClearDocument()\n{\n    executeCommand(new ClearCommand());\n}\n</code></pre></li> </ul> <p>Tesztelj\u00fck megold\u00e1sunkat:</p> <ul> <li>Futtassuk az alkalmaz\u00e1st,</li> <li>Hozzunk l\u00e9tre p\u00e1r alakzatot,</li> <li>A File/Clear men\u00fcb\u0151l futtassuk a Clear parancsot: az alakzataink elt\u0171nnek.</li> <li>Az Undo paranccsal vonjuk vissza a parancsot: az alakzatok \u00fajra megjelennek.</li> </ul> <p>L\u00e9p\u00e9senk\u00e9nt futtatva is tesztelj\u00fck a megold\u00e1st:</p> <ul> <li>Tegy\u00fcnk egy t\u00f6r\u00e9spontot a <code>ClearCommand.Execute</code> m\u0171velet els\u0151 sor\u00e1ra.</li> <li>Ind\u00edtsuk ez az alkalmaz\u00e1st, hozzunk l\u00e9tre p\u00e1r alakzatot, majd a File/Clear men\u00fcb\u0151l futtassuk a Clear parancsot.</li> <li>Mikor a k\u00f3dunk meg\u00e1ll a t\u00f6r\u00e9spontn\u00e1l, l\u00e9pkedj\u00fck el a <code>CreateMemento</code> h\u00edv\u00e1s\u00e1ig, \u00e9s l\u00e9pj\u00fcnk is \u00e1t rajta. A <code>CreateMemento</code> \u00e1ltal visszaadott memento objektum bels\u0151 \u00e1llapot\u00e1t n\u00e9zz\u00fck meg vagy a Watch ablakban, vagy tooltipben r\u00e1\u00e1llva. Azt l\u00e1tjuk, hogy val\u00f3ban \u201etartalmazza\u201d a dokumentum pillanatnyi \u00e1llapot\u00e1t a shapes \u00e9s <code>selectedShape</code> tagv\u00e1ltoz\u00f3j\u00e1ban. A <code>ClearCommand</code> ezt el is t\u00e1rolja a tagv\u00e1ltoz\u00f3j\u00e1ban, amit az <code>UnExecute</code> m\u0171veletben haszn\u00e1l fel a dokumentum \u00e1llapot\u00e1nak vissza\u00e1ll\u00edt\u00e1s\u00e1ra.</li> </ul> <p>P\u00e9ld\u00e1nkban a Memento minta arra \u00e9p\u00edt, hogy a dokumentum teljes \u00e1llapot\u00e1r\u00f3l m\u00e1solatot k\u00e9sz\u00edt\u00fcnk. Sok alkalmaz\u00e1s, illetve nagym\u00e9ret\u0171 dokumentum eset\u00e9ben ennek nagyon nagy lehet a mem\u00f3riaig\u00e9nye. Milyen megold\u00e1sokban gondolkozhatunk a probl\u00e9ma elker\u00fcl\u00e9s\u00e9re?</p> <ul> <li>A kisebb v\u00e1ltoz\u00e1sok hat\u00e1s\u00e1t ink\u00e1bb \u201einverz\u201d m\u0171velettel pr\u00f3b\u00e1ljuk visszacsin\u00e1lni. Ezt alkalmaztuk pl. a New Rect parancs eset\u00e9ben.</li> <li>A Memento-ba nem mentj\u00fck bele a teljes \u00e1llapotot, hanem csak m\u00f3dosult \u00e1llapotot. Sajnos ez nem mindig tehet\u0151 meg, valamint nehezebben karbantarthat\u00f3 megold\u00e1st eredm\u00e9nyez.</li> <li>Korl\u00e1tozzuk a visszavonhat\u00f3 l\u00e9p\u00e9sek sz\u00e1m\u00e1t.</li> </ul>"}]}